

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>algorithms &mdash; HPX 1.4.1 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../_static/css/theme_overrides.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="HPX 1.4.1 documentation" href="../../index.html"/>
        <link rel="up" title="API reference" href="../../api.html"/>
        <link rel="next" title="filesystem" href="../filesystem/api.html"/>
        <link rel="prev" title="plugin" href="../plugin/api.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> HPX
          

          
            
            <img src="../../_static/HPX_STELLAR.png" class="logo" />
          
          </a>

          
            
            
              <div class="version">
                1.4.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">User documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../why_hpx.html">Why <em>HPX</em>?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart.html">Quick start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../terminology.html">Terminology</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../manual.html">Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../additional_material.html">Additional material</a></li>
</ul>
<p class="caption"><span class="caption-text">Modules</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../all_modules.html">All modules</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../../api.html">API reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../api.html#main-hpx-library-reference">Main <em>HPX</em> library reference</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../../api.html#modules-reference">Modules reference</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../datastructures/api.html">datastructures</a></li>
<li class="toctree-l3"><a class="reference internal" href="../resiliency/api.html">resiliency</a></li>
<li class="toctree-l3"><a class="reference internal" href="../basic_execution/api.html">basic_execution</a></li>
<li class="toctree-l3"><a class="reference internal" href="../debugging/api.html">debugging</a></li>
<li class="toctree-l3"><a class="reference internal" href="../testing/api.html">testing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../functional/api.html">functional</a></li>
<li class="toctree-l3"><a class="reference internal" href="../hardware/api.html">hardware</a></li>
<li class="toctree-l3"><a class="reference internal" href="../collectives/api.html">collectives</a></li>
<li class="toctree-l3"><a class="reference internal" href="../coroutines/api.html">coroutines</a></li>
<li class="toctree-l3"><a class="reference internal" href="../concurrency/api.html">concurrency</a></li>
<li class="toctree-l3"><a class="reference internal" href="../serialization/api.html">serialization</a></li>
<li class="toctree-l3"><a class="reference internal" href="../execution/api.html">execution</a></li>
<li class="toctree-l3"><a class="reference internal" href="../statistics/api.html">statistics</a></li>
<li class="toctree-l3"><a class="reference internal" href="../errors/api.html">errors</a></li>
<li class="toctree-l3"><a class="reference internal" href="../type_support/api.html">type_support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../cache/api.html">cache</a></li>
<li class="toctree-l3"><a class="reference internal" href="../assertion/api.html">assertion</a></li>
<li class="toctree-l3"><a class="reference internal" href="../resource_partitioner/api.html">resource_partitioner</a></li>
<li class="toctree-l3"><a class="reference internal" href="../checkpoint/api.html">checkpoint</a></li>
<li class="toctree-l3"><a class="reference internal" href="../affinity/api.html">affinity</a></li>
<li class="toctree-l3"><a class="reference internal" href="../memory/api.html">memory</a></li>
<li class="toctree-l3"><a class="reference internal" href="../program_options/api.html">program_options</a></li>
<li class="toctree-l3"><a class="reference internal" href="../hashing/api.html">hashing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../config/api.html">config</a></li>
<li class="toctree-l3"><a class="reference internal" href="../iterator_support/api.html">iterator_support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../format/api.html">format</a></li>
<li class="toctree-l3"><a class="reference internal" href="../concepts/api.html">concepts</a></li>
<li class="toctree-l3"><a class="reference internal" href="../allocator_support/api.html">allocator_support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../segmented_algorithms/api.html">segmented_algorithms</a></li>
<li class="toctree-l3"><a class="reference internal" href="../util/api.html">util</a></li>
<li class="toctree-l3"><a class="reference internal" href="../synchronization/api.html">synchronization</a></li>
<li class="toctree-l3"><a class="reference internal" href="../preprocessor/api.html">preprocessor</a></li>
<li class="toctree-l3"><a class="reference internal" href="../timing/api.html">timing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../logging/api.html">logging</a></li>
<li class="toctree-l3"><a class="reference internal" href="../local_lcos/api.html">local_lcos</a></li>
<li class="toctree-l3"><a class="reference internal" href="../topology/api.html">topology</a></li>
<li class="toctree-l3"><a class="reference internal" href="../batch_environments/api.html">batch_environments</a></li>
<li class="toctree-l3"><a class="reference internal" href="../compute/api.html">compute</a></li>
<li class="toctree-l3"><a class="reference internal" href="../plugin/api.html">plugin</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">algorithms</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-traits-segmented-iterator-traits-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/traits/segmented_iterator_traits.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-traits-is-value-proxy-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/traits/is_value_proxy.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-datapar-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/datapar.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-tagspec-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/tagspec.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-numeric-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/numeric.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-memory-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/memory.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-container-algorithms-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/container_algorithms.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithm-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithm.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-container-algorithms-partition-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/container_algorithms/partition.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-container-algorithms-rotate-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/container_algorithms/rotate.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-container-algorithms-all-any-none-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/container_algorithms/all_any_none.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-container-algorithms-find-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/container_algorithms/find.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-container-algorithms-for-each-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/container_algorithms/for_each.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-container-algorithms-reverse-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/container_algorithms/reverse.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-container-algorithms-search-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/container_algorithms/search.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-container-algorithms-fill-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/container_algorithms/fill.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-container-algorithms-merge-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/container_algorithms/merge.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-container-algorithms-remove-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/container_algorithms/remove.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-container-algorithms-minmax-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/container_algorithms/minmax.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-container-algorithms-transform-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/container_algorithms/transform.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-container-algorithms-unique-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/container_algorithms/unique.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-container-algorithms-replace-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/container_algorithms/replace.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-container-algorithms-move-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/container_algorithms/move.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-container-algorithms-copy-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/container_algorithms/copy.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-container-algorithms-generate-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/container_algorithms/generate.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-container-algorithms-is-heap-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/container_algorithms/is_heap.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-container-algorithms-remove-copy-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/container_algorithms/remove_copy.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-container-algorithms-sort-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/container_algorithms/sort.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-container-algorithms-count-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/container_algorithms/count.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-util-partitioner-with-cleanup-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/util/partitioner_with_cleanup.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-util-transfer-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/util/transfer.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-util-scan-partitioner-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/util/scan_partitioner.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-util-projection-identity-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/util/projection_identity.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-util-invoke-projected-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/util/invoke_projected.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-util-cancellation-token-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/util/cancellation_token.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-util-foreach-partitioner-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/util/foreach_partitioner.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-util-loop-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/util/loop.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-util-prefetching-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/util/prefetching.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-util-partitioner-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/util/partitioner.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-util-zip-iterator-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/util/zip_iterator.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-util-compare-projected-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/util/compare_projected.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-util-transform-loop-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/util/transform_loop.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-reduce-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/reduce.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-partition-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/partition.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-rotate-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/rotate.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-all-any-none-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/all_any_none.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-find-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/find.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-for-each-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/for_each.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-reverse-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/reverse.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-is-partitioned-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/is_partitioned.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-transform-reduce-binary-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/transform_reduce_binary.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-uninitialized-value-construct-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/uninitialized_value_construct.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-uninitialized-move-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/uninitialized_move.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-search-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/search.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-is-sorted-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/is_sorted.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-reduce-by-key-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/reduce_by_key.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-fill-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/fill.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-transform-inclusive-scan-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/transform_inclusive_scan.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-adjacent-find-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/adjacent_find.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-set-intersection-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/set_intersection.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-sort-by-key-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/sort_by_key.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-swap-ranges-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/swap_ranges.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-uninitialized-default-construct-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/uninitialized_default_construct.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-merge-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/merge.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-remove-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/remove.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-set-union-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/set_union.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-minmax-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/minmax.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-set-difference-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/set_difference.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-for-loop-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/for_loop.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-transform-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/transform.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-unique-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/unique.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-for-loop-reduction-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/for_loop_reduction.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-replace-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/replace.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-lexicographical-compare-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/lexicographical_compare.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-uninitialized-fill-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/uninitialized_fill.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-includes-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/includes.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-exclusive-scan-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/exclusive_scan.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-move-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/move.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-copy-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/copy.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-for-loop-induction-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/for_loop_induction.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-uninitialized-copy-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/uninitialized_copy.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-generate-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/generate.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-inclusive-scan-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/inclusive_scan.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-mismatch-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/mismatch.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-set-symmetric-difference-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/set_symmetric_difference.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-is-heap-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/is_heap.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-equal-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/equal.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-remove-copy-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/remove_copy.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-destroy-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/destroy.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-adjacent-difference-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/adjacent_difference.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-transform-exclusive-scan-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/transform_exclusive_scan.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-transform-reduce-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/transform_reduce.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-sort-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/sort.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-algorithms-count-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/count.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-traits-projected-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/traits/projected.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-traits-projected-range-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/traits/projected_range.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-datapar-iterator-helpers-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/datapar/iterator_helpers.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-datapar-loop-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/datapar/loop.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-datapar-zip-iterator-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/datapar/zip_iterator.hpp&gt;</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#include-hpx-parallel-datapar-transform-loop-hpp"><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/datapar/transform_loop.hpp&gt;</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../filesystem/api.html">filesystem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../threadmanager/api.html">threadmanager</a></li>
<li class="toctree-l3"><a class="reference internal" href="../static_reinit/api.html">static_reinit</a></li>
<li class="toctree-l3"><a class="reference internal" href="../thread_support/api.html">thread_support</a></li>
<li class="toctree-l3"><a class="reference internal" href="../compute_cuda/api.html">compute_cuda</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption"><span class="caption-text">Developer documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../contributing.html">Contributing to <em>HPX</em></a></li>
</ul>
<p class="caption"><span class="caption-text">Other</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../releases.html">Releases</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../about_hpx.html">About <em>HPX</em></a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">HPX</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../api.html">API reference</a> &raquo;</li>
        
      <li>algorithms</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/STEllAR-GROUP/hpx/blob/master/docs/sphinx/libs/algorithms/api.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="algorithms">
<span id="libs-algorithms-api"></span><h1>algorithms<a class="headerlink" href="#algorithms" title="Permalink to this headline">¶</a></h1>
<div class="section" id="include-hpx-traits-segmented-iterator-traits-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/traits/segmented_iterator_traits.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-traits-segmented-iterator-traits-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="_CPPv33hpx">
<span id="_CPPv23hpx"></span><span id="hpx"></span><span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt id="_CPPv3N3hpx6traitsE">
<span id="_CPPv2N3hpx6traitsE"></span><span id="hpx::traits"></span><span class="target" id="namespacehpx_1_1traits"></span><em class="property">namespace </em><code class="descname">traits</code><br /></dt>
<dd><dl class="class">
<dt id="_CPPv3N3hpx6traits25segmented_iterator_traitsE">
<span id="_CPPv2N3hpx6traits25segmented_iterator_traitsE"></span><span id="hpx::traits::segmented_iterator_traits"></span><span class="target" id="structhpx_1_1traits_1_1segmented__iterator__traits"></span><em class="property">template </em>&lt;typename <em>Iterator</em>, typename <em>Enable</em> = void&gt;<br /><em class="property">struct </em><code class="descname">segmented_iterator_traits</code><a class="headerlink" href="#_CPPv3N3hpx6traits25segmented_iterator_traitsE" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="type">
<dt id="_CPPv3N3hpx6traits25segmented_iterator_traits21is_segmented_iteratorE">
<span id="_CPPv2N3hpx6traits25segmented_iterator_traits21is_segmented_iteratorE"></span><span id="hpx::traits::segmented_iterator_traits::is_segmented_iterator"></span><span class="target" id="structhpx_1_1traits_1_1segmented__iterator__traits_1afe6702096744b0fc81a2b27136fd9fe4"></span><em class="property">typedef </em><a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::false_type <code class="descname">is_segmented_iterator</code><a class="headerlink" href="#_CPPv3N3hpx6traits25segmented_iterator_traits21is_segmented_iteratorE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx6traits31segmented_local_iterator_traitsE">
<span id="_CPPv2N3hpx6traits31segmented_local_iterator_traitsE"></span><span id="hpx::traits::segmented_local_iterator_traits"></span><span class="target" id="structhpx_1_1traits_1_1segmented__local__iterator__traits"></span><em class="property">template </em>&lt;typename <em>Iterator</em>, typename <em>Enable</em> = void&gt;<br /><em class="property">struct </em><code class="descname">segmented_local_iterator_traits</code><a class="headerlink" href="#_CPPv3N3hpx6traits31segmented_local_iterator_traitsE" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="type">
<dt id="_CPPv3N3hpx6traits31segmented_local_iterator_traits27is_segmented_local_iteratorE">
<span id="_CPPv2N3hpx6traits31segmented_local_iterator_traits27is_segmented_local_iteratorE"></span><span id="hpx::traits::segmented_local_iterator_traits::is_segmented_local_iterator"></span><span class="target" id="structhpx_1_1traits_1_1segmented__local__iterator__traits_1a98a6c6ec06d9e6a75fd406b19a42c57c"></span><em class="property">typedef </em><a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::false_type <code class="descname">is_segmented_local_iterator</code><a class="headerlink" href="#_CPPv3N3hpx6traits31segmented_local_iterator_traits27is_segmented_local_iteratorE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx6traits31segmented_local_iterator_traits8iteratorE">
<span id="_CPPv2N3hpx6traits31segmented_local_iterator_traits8iteratorE"></span><span id="hpx::traits::segmented_local_iterator_traits::iterator"></span><span class="target" id="structhpx_1_1traits_1_1segmented__local__iterator__traits_1a83946176aa4d631c568b09a28e7a0052"></span><em class="property">typedef </em>Iterator <code class="descname">iterator</code><a class="headerlink" href="#_CPPv3N3hpx6traits31segmented_local_iterator_traits8iteratorE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx6traits31segmented_local_iterator_traits14local_iteratorE">
<span id="_CPPv2N3hpx6traits31segmented_local_iterator_traits14local_iteratorE"></span><span id="hpx::traits::segmented_local_iterator_traits::local_iterator"></span><span class="target" id="structhpx_1_1traits_1_1segmented__local__iterator__traits_1a8dcd416064b064cdd1f6a131462ab99c"></span><em class="property">typedef </em>Iterator <code class="descname">local_iterator</code><a class="headerlink" href="#_CPPv3N3hpx6traits31segmented_local_iterator_traits14local_iteratorE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx6traits31segmented_local_iterator_traits18local_raw_iteratorE">
<span id="_CPPv2N3hpx6traits31segmented_local_iterator_traits18local_raw_iteratorE"></span><span id="hpx::traits::segmented_local_iterator_traits::local_raw_iterator"></span><span class="target" id="structhpx_1_1traits_1_1segmented__local__iterator__traits_1ac06a4f873b7374217e2829eb2f6609eb"></span><em class="property">typedef </em>Iterator <code class="descname">local_raw_iterator</code><a class="headerlink" href="#_CPPv3N3hpx6traits31segmented_local_iterator_traits18local_raw_iteratorE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Static Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx6traits31segmented_local_iterator_traits5localER14local_iterator">
<span id="_CPPv2N3hpx6traits31segmented_local_iterator_traits5localER14local_iterator"></span><span id="hpx::traits::segmented_local_iterator_traits::local__local_iteratorCR"></span><span class="target" id="structhpx_1_1traits_1_1segmented__local__iterator__traits_1a958909ea6f85316cd6382f892cb4cb4c"></span><em class="property">static</em> <a class="reference internal" href="#_CPPv3N3hpx6traits31segmented_local_iterator_traits18local_raw_iteratorE" title="hpx::traits::segmented_local_iterator_traits::local_raw_iterator">local_raw_iterator</a> <em class="property">const</em> &amp;<code class="descname">local</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx6traits31segmented_local_iterator_traits14local_iteratorE" title="hpx::traits::segmented_local_iterator_traits::local_iterator">local_iterator</a> <em class="property">const</em> &amp;<em>it</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx6traits31segmented_local_iterator_traits5localER14local_iterator" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx6traits31segmented_local_iterator_traits6remoteER18local_raw_iterator">
<span id="_CPPv2N3hpx6traits31segmented_local_iterator_traits6remoteER18local_raw_iterator"></span><span id="hpx::traits::segmented_local_iterator_traits::remote__local_raw_iteratorCR"></span><span class="target" id="structhpx_1_1traits_1_1segmented__local__iterator__traits_1a903225a9c54bfec5374f1b023497e1b2"></span><em class="property">static</em> <a class="reference internal" href="#_CPPv3N3hpx6traits31segmented_local_iterator_traits14local_iteratorE" title="hpx::traits::segmented_local_iterator_traits::local_iterator">local_iterator</a> <em class="property">const</em> &amp;<code class="descname">remote</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx6traits31segmented_local_iterator_traits18local_raw_iteratorE" title="hpx::traits::segmented_local_iterator_traits::local_raw_iterator">local_raw_iterator</a> <em class="property">const</em> &amp;<em>it</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx6traits31segmented_local_iterator_traits6remoteER18local_raw_iterator" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx6traits31segmented_local_iterator_traits5localERR14local_iterator">
<span id="_CPPv2N3hpx6traits31segmented_local_iterator_traits5localERR14local_iterator"></span><span id="hpx::traits::segmented_local_iterator_traits::local__local_iteratorRR"></span><span class="target" id="structhpx_1_1traits_1_1segmented__local__iterator__traits_1a31596424cc1dfb1946878c0abd1ae917"></span><em class="property">static</em> <a class="reference internal" href="#_CPPv3N3hpx6traits31segmented_local_iterator_traits18local_raw_iteratorE" title="hpx::traits::segmented_local_iterator_traits::local_raw_iterator">local_raw_iterator</a> <code class="descname">local</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx6traits31segmented_local_iterator_traits14local_iteratorE" title="hpx::traits::segmented_local_iterator_traits::local_iterator">local_iterator</a> &amp;&amp;<em>it</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx6traits31segmented_local_iterator_traits5localERR14local_iterator" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx6traits31segmented_local_iterator_traits6remoteERR18local_raw_iterator">
<span id="_CPPv2N3hpx6traits31segmented_local_iterator_traits6remoteERR18local_raw_iterator"></span><span id="hpx::traits::segmented_local_iterator_traits::remote__local_raw_iteratorRR"></span><span class="target" id="structhpx_1_1traits_1_1segmented__local__iterator__traits_1aff8300699bf4be294e7276412527e520"></span><em class="property">static</em> <a class="reference internal" href="#_CPPv3N3hpx6traits31segmented_local_iterator_traits14local_iteratorE" title="hpx::traits::segmented_local_iterator_traits::local_iterator">local_iterator</a> <code class="descname">remote</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx6traits31segmented_local_iterator_traits18local_raw_iteratorE" title="hpx::traits::segmented_local_iterator_traits::local_raw_iterator">local_raw_iterator</a> &amp;&amp;<em>it</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx6traits31segmented_local_iterator_traits6remoteERR18local_raw_iterator" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-traits-is-value-proxy-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/traits/is_value_proxy.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-traits-is-value-proxy-hpp" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="include-hpx-parallel-datapar-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/datapar.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-datapar-hpp" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="include-hpx-parallel-tagspec-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/tagspec.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-tagspec-hpp" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="include-hpx-parallel-numeric-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/numeric.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-numeric-hpp" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="include-hpx-parallel-memory-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/memory.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-memory-hpp" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="include-hpx-parallel-container-algorithms-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/container_algorithms.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-container-algorithms-hpp" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="include-hpx-parallel-algorithm-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithm.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithm-hpp" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="include-hpx-parallel-container-algorithms-partition-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/container_algorithms/partition.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-container-algorithms-partition-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="_CPPv33hpx">
<span id="_CPPv23hpx"></span><span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt id="_CPPv3N3hpx8parallelE">
<span id="_CPPv2N3hpx8parallelE"></span><span id="hpx::parallel"></span><span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt id="_CPPv3N3hpx8parallel2v1E">
<span id="_CPPv2N3hpx8parallel2v1E"></span><span id="hpx::parallel::v1"></span><span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><a class="headerlink" href="#_CPPv3N3hpx8parallel2v1E" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v19partitionERR8ExPolicyRR3RngRR4PredRR4Proj">
<span id="_CPPv2N3hpx8parallel2v19partitionERR8ExPolicyRR3RngRR4PredRR4Proj"></span><span id="hpx::parallel::v1::partition__ExPolicyRR.RngRR.PredRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> Pred, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="container__algorithms_2partition_8hpp_1a21ca6a1a05930ecf7173cfd42cebc80c"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng&gt;::type&gt;::type <code class="descname">partition</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, Pred &amp;&amp;<em>pred</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v19partitionERR8ExPolicyRR3RngRR4PredRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Reorders the elements in the range <em>rng</em> in such a way that all elements for which the predicate <em>pred</em> returns true precede the elements for which the predicate <em>pred</em> returns false. Relative order of the elements is not preserved.</p>
<p><p>The assignments in the parallel </p>
<em>partition</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs at most 2 * N swaps, exactly N applications of the predicate and projection, where N = std::distance(begin(rng), end(rng)).</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>partition</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">pred</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by the range <em>rng</em>. This is an unary predicate for partitioning the source iterators. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter</em> can be dereferenced and then implicitly converted to <em>Type</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>partition</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>partition</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>parallel_task_policy</em> and returns <em>FwdIter</em> otherwise. The <em>partition</em> algorithm returns the iterator to the first element of the second group. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v114partition_copyERR8ExPolicyRR3Rng8FwdIter28FwdIter3RR4PredRR4Proj">
<span id="_CPPv2N3hpx8parallel2v114partition_copyERR8ExPolicyRR3Rng8FwdIter28FwdIter3RR4PredRR4Proj"></span><span id="hpx::parallel::v1::partition_copy__ExPolicyRR.RngRR.FwdIter2.FwdIter3.PredRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> FwdIter3, <em class="property">typename</em> Pred, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="container__algorithms_2partition_8hpp_1a20fcac98a43471e18e06b7deb3584516"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_tuple&lt;tag::in<span class="sig-paren">(</span><em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng&gt;::type<span class="sig-paren">)</span>, tag::out1<span class="sig-paren">(</span>FwdIter2<span class="sig-paren">)</span>, tag::out2<span class="sig-paren">(</span>FwdIter3<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">partition_copy</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, FwdIter2 <em>dest_true</em>, FwdIter3 <em>dest_false</em>, Pred &amp;&amp;<em>pred</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v114partition_copyERR8ExPolicyRR3Rng8FwdIter28FwdIter3RR4PredRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the elements in the range <em>rng</em>, to two different ranges depending on the value returned by the predicate <em>pred</em>. The elements, that satisfy the predicate <em>pred</em>, are copied to the range beginning at <em>dest_true</em>. The rest of the elements are copied to the range beginning at <em>dest_false</em>. The order of the elements is preserved.</p>
<p><p>The assignments in the parallel </p>
<em>partition_copy</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs not more than N assignments, exactly N applications of the predicate <em>pred</em>, where N = std::distance(begin(rng), end(rng)).</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range for the elements that satisfy the predicate <em>pred</em> (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter3</span></code>: The type of the iterator representing the destination range for the elements that don’t satisfy the predicate <em>pred</em> (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>partition_copy</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest_true</span></code>: Refers to the beginning of the destination range for the elements that satisfy the predicate <em>pred</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest_false</span></code>: Refers to the beginning of the destination range for the elements that don’t satisfy the predicate <em>pred</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">pred</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by the range <em>rng</em>. This is an unary predicate for partitioning the source iterators. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter1</em> can be dereferenced and then implicitly converted to <em>Type</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>partition_copy</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>partition_copy</em> algorithm returns a <em>hpx::future&lt;tagged_tuple&lt;tag::in(InIter), tag::out1(OutIter1), tag::out2(OutIter2)&gt;</em> &gt; if the execution policy is of type <em>parallel_task_policy</em> and returns <em>tagged_tuple&lt;tag::in(InIter), tag::out1(OutIter1), tag::out2(OutIter2)&gt;</em> otherwise. The <em>partition_copy</em> algorithm returns the tuple of the source iterator <em>last</em>, the destination iterator to the end of the <em>dest_true</em> range, and the destination iterator to the end of the <em>dest_false</em> range. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-container-algorithms-rotate-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/container_algorithms/rotate.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-container-algorithms-rotate-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="_CPPv33hpx">
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt id="_CPPv3N3hpx8parallelE">
<span id="_CPPv2N3hpx8parallelE"></span><span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt id="_CPPv3N3hpx8parallel2v1E">
<span id="_CPPv2N3hpx8parallel2v1E"></span><span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v16rotateERR8ExPolicyRR3RngN3hpx6traits14range_iteratorI3RngE4typeE">
<span id="_CPPv2N3hpx8parallel2v16rotateERR8ExPolicyRR3RngN3hpx6traits14range_iteratorI3RngE4typeE"></span><span id="hpx::parallel::v1::rotate__ExPolicyRR.RngRR.hpx::traits::range_iterator:Rng:::type"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng&gt;<br /><span class="target" id="container__algorithms_2rotate_8hpp_1aee2b5ab2738ef342f9b299d3d8ecb1b2"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::begin<span class="sig-paren">(</span><em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng&gt;::type<span class="sig-paren">)</span>, tag::end<span class="sig-paren">(</span><em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng&gt;::type<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">rotate</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, <em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng&gt;::type <em>middle</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v16rotateERR8ExPolicyRR3RngN3hpx6traits14range_iteratorI3RngE4typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Performs a left rotation on a range of elements. Specifically, <em>rotate</em> swaps the elements in the range [first, last) in such a way that the element new_first becomes the first element of the new range and new_first - 1 becomes the last element.</p>
<p><p>The assignments in the parallel </p>
<em>rotate</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Linear in the distance between <em>first</em> and <em>last</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of a forward iterator.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">middle</span></code>: Refers to the element that should appear at the beginning of the rotated range.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>rotate</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The type of dereferenced <em>FwdIter</em> must meet the requirements of <em>MoveAssignable</em> and <em>MoveConstructible</em>.</dd>
<dt><strong>Return</strong></dt>
<dd>The <em>rotate</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::begin(FwdIter), tag::end(FwdIter)&gt;</em> &gt; if the execution policy is of type <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::begin(FwdIter), tag::end(FwdIter)&gt;</em> otherwise. The <em>rotate</em> algorithm returns the iterator equal to pair(first + (last - new_first), last). </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v111rotate_copyERR8ExPolicyRR3RngN3hpx6traits14range_iteratorI3RngE4typeE7OutIter">
<span id="_CPPv2N3hpx8parallel2v111rotate_copyERR8ExPolicyRR3RngN3hpx6traits14range_iteratorI3RngE4typeE7OutIter"></span><span id="hpx::parallel::v1::rotate_copy__ExPolicyRR.RngRR.hpx::traits::range_iterator:Rng:::type.OutIter"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> OutIter&gt;<br /><span class="target" id="container__algorithms_2rotate_8hpp_1a6ebe0378af9a67a1be800a0c2b58f3ad"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::in<span class="sig-paren">(</span><em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng&gt;::type<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>OutIter<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">rotate_copy</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, <em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng&gt;::type <em>middle</em>, OutIter <em>dest_first</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v111rotate_copyERR8ExPolicyRR3RngN3hpx6traits14range_iteratorI3RngE4typeE7OutIter" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the elements from the range [first, last), to another range beginning at <em>dest_first</em> in such a way, that the element <em>new_first</em> becomes the first element of the new range and <em>new_first</em> - 1 becomes the last element.</p>
<p><p>The assignments in the parallel </p>
<em>rotate_copy</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>last</em> - <em>first</em> assignments.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of a forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">OutIter</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an output iterator.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">middle</span></code>: Refers to the element that should appear at the beginning of the rotated range. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest_first</span></code>: Refers to the begin of the destination range.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>rotate_copy</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>rotate_copy</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::in(FwdIter), tag::out(OutIter)&gt;</em> &gt; if the execution policy is of type <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::in(FwdIter), tag::out(OutIter)&gt;</em> otherwise. The <em>rotate_copy</em> algorithm returns the output iterator to the element past the last element copied. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-container-algorithms-all-any-none-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/container_algorithms/all_any_none.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-container-algorithms-all-any-none-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt id="_CPPv3N3hpx8parallelE">
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt id="_CPPv3N3hpx8parallel2v1E">
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v17none_ofERR8ExPolicyRR3RngRR1FRR4Proj">
<span id="_CPPv2N3hpx8parallel2v17none_ofERR8ExPolicyRR3RngRR1FRR4Proj"></span><span id="hpx::parallel::v1::none_of__ExPolicyRR.RngRR.FRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> F, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="container__algorithms_2all__any__none_8hpp_1ab8adfd5bd843e5e3be75695e94ea8a7e"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, bool&gt;::type <code class="descname">none_of</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, F &amp;&amp;<em>f</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v17none_ofERR8ExPolicyRR3RngRR1FRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Checks if unary predicate <em>f</em> returns true for no elements in the range <em>rng</em>.</p>
<p><p>The application of function objects in parallel algorithm invoked with an execution policy object of type </p>
<em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: At most std::distance(begin(rng), end(rng)) applications of the predicate <em>f</em> </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>none_of</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter</em> can be dereferenced and then implicitly converted to Type. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>none_of</em> algorithm returns a <em>hpx::future&lt;bool&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>bool</em> otherwise. The <em>none_of</em> algorithm returns true if the unary predicate <em>f</em> returns true for no elements in the range, false otherwise. It returns true if the range is empty. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v16any_ofERR8ExPolicyRR3RngRR1FRR4Proj">
<span id="_CPPv2N3hpx8parallel2v16any_ofERR8ExPolicyRR3RngRR1FRR4Proj"></span><span id="hpx::parallel::v1::any_of__ExPolicyRR.RngRR.FRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> F, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="container__algorithms_2all__any__none_8hpp_1a645a8f385208732e17b7fd0edeff88b4"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, bool&gt;::type <code class="descname">any_of</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, F &amp;&amp;<em>f</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v16any_ofERR8ExPolicyRR3RngRR1FRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Checks if unary predicate <em>f</em> returns true for at least one element in the range <em>rng</em>.</p>
<p><p>The application of function objects in parallel algorithm invoked with an execution policy object of type </p>
<em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: At most std::distance(begin(rng), end(rng)) applications of the predicate <em>f</em> </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>none_of</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter</em> can be dereferenced and then implicitly converted to Type. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>any_of</em> algorithm returns a <em>hpx::future&lt;bool&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>bool</em> otherwise. The <em>any_of</em> algorithm returns true if the unary predicate <em>f</em> returns true for at least one element in the range, false otherwise. It returns false if the range is empty. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v16all_ofERR8ExPolicyRR3RngRR1FRR4Proj">
<span id="_CPPv2N3hpx8parallel2v16all_ofERR8ExPolicyRR3RngRR1FRR4Proj"></span><span id="hpx::parallel::v1::all_of__ExPolicyRR.RngRR.FRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> F, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="container__algorithms_2all__any__none_8hpp_1ab9145664976f55bb15fa51d275d3d3c5"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, bool&gt;::type <code class="descname">all_of</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, F &amp;&amp;<em>f</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v16all_ofERR8ExPolicyRR3RngRR1FRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Checks if unary predicate <em>f</em> returns true for all elements in the range <em>rng</em>.</p>
<p><p>The application of function objects in parallel algorithm invoked with an execution policy object of type </p>
<em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: At most std::distance(begin(rng), end(rng)) applications of the predicate <em>f</em> </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>none_of</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter</em> can be dereferenced and then implicitly converted to Type. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>all_of</em> algorithm returns a <em>hpx::future&lt;bool&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>bool</em> otherwise. The <em>all_of</em> algorithm returns true if the unary predicate <em>f</em> returns true for all elements in the range, false otherwise. It returns true if the range is empty. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-container-algorithms-find-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/container_algorithms/find.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-container-algorithms-find-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v18find_endERR8ExPolicyRR3RngRR4Rng2RR4PredRR4Proj">
<span id="_CPPv2N3hpx8parallel2v18find_endERR8ExPolicyRR3RngRR4Rng2RR4PredRR4Proj"></span><span id="hpx::parallel::v1::find_end__ExPolicyRR.RngRR.Rng2RR.PredRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> Rng2, <em class="property">typename</em> Pred = detail::equal_to, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="container__algorithms_2find_8hpp_1aa1d19194856e731e975f174f6412bb48"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng&gt;::type&gt;::type <code class="descname">find_end</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, Rng2 &amp;&amp;<em>rng2</em>, Pred &amp;&amp;<em>op</em> = Pred(), Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v18find_endERR8ExPolicyRR3RngRR4Rng2RR4PredRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the last subsequence of elements <em>rng2</em> found in the range <em>rng</em> using the given predicate <em>f</em> to compare elements.</p>
<p><p>The comparison operations in the parallel </p>
<em>find_end</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: at most S*(N-S+1) comparisons where <em>S</em> = distance(begin(rng2), end(rng2)) and <em>N</em> = distance(begin(rng), end(rng)).</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the first source range (deduced). The iterators extracted from this range type must meet the requirements of a forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng2</span></code>: The type of the second source range (deduced). The iterators extracted from this range type must meet the requirements of a forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <em>replace</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::equal_to&lt;&gt; </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the first sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng2</span></code>: Refers to the second sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">op</span></code>: The binary predicate which returns <em>true</em> if the elements should be treated as equal. The signature should be equivalent to the following: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type2</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> and <em>Type2</em> must be such that objects of types <em>iterator_t&lt;Rng&gt;</em> and <em>iterator_t&lt;Rng2&gt;</em> can be dereferenced and then implicitly converted to <em>Type1</em> and <em>Type2</em> respectively. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of type dereferenced <em>iterator_t&lt;Rng&gt;</em> and dereferenced <em>iterator_t&lt;Rng2&gt;</em> as a projection operation before the function <em>op</em> is invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The comparison operations in the parallel <em>find_end</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><p>This overload of </p>
<em>find_end</em> is available if the user decides to provide the algorithm their own predicate <em>op</em>. <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>find_end</em> algorithm returns a <em>hpx::future&lt;iterator_t&lt;Rng&gt;</em> &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>iterator_t&lt;Rng&gt;</em> otherwise. The <em>find_end</em> algorithm returns an iterator to the beginning of the last subsequence <em>rng2</em> in range <em>rng</em>. If the length of the subsequence <em>rng2</em> is greater than the length of the range <em>rng</em>, <em>end(rng)</em> is returned. Additionally if the size of the subsequence is empty or no subsequence is found, <em>end(rng)</em> is also returned.</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v113find_first_ofERR8ExPolicyRR4Rng1RR4Rng2RR4PredRR5Proj1RR5Proj2">
<span id="_CPPv2N3hpx8parallel2v113find_first_ofERR8ExPolicyRR4Rng1RR4Rng2RR4PredRR5Proj1RR5Proj2"></span><span id="hpx::parallel::v1::find_first_of__ExPolicyRR.Rng1RR.Rng2RR.PredRR.Proj1RR.Proj2RR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng1, <em class="property">typename</em> Rng2, <em class="property">typename</em> Pred = detail::equal_to, <em class="property">typename</em> Proj1 = util::projection_identity, <em class="property">typename</em> Proj2 = util::projection_identity&gt;<br /><span class="target" id="container__algorithms_2find_8hpp_1a0c521b09804f682d8354042aa13b200d"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng1&gt;::type&gt;::type <code class="descname">find_first_of</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng1 &amp;&amp;<em>rng1</em>, Rng2 &amp;&amp;<em>rng2</em>, Pred &amp;&amp;<em>op</em> = Pred(), Proj1 &amp;&amp;<em>proj1</em> = Proj1(), Proj2 &amp;&amp;<em>proj2</em> = Proj2()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v113find_first_ofERR8ExPolicyRR4Rng1RR4Rng2RR4PredRR5Proj1RR5Proj2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Searches the range <em>rng1</em> for any elements in the range <em>rng2</em>. Uses binary predicate <em>p</em> to compare elements</p>
<p><p>The comparison operations in the parallel </p>
<em>find_first_of</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: at most (S*N) comparisons where <em>S</em> = distance(begin(rng2), end(rng2)) and <em>N</em> = distance(begin(rng1), end(rng1)).</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng1</span></code>: The type of the first source range (deduced). The iterators extracted from this range type must meet the requirements of a forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng2</span></code>: The type of the second source range (deduced). The iterators extracted from this range type must meet the requirements of a forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <em>replace</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::equal_to&lt;&gt; </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj1</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> and is applied to the elements in <em>rng1</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj2</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> and is applied to the elements in <em>rng2</em>.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng1</span></code>: Refers to the first sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng2</span></code>: Refers to the second sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">op</span></code>: The binary predicate which returns <em>true</em> if the elements should be treated as equal. The signature should be equivalent to the following: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type2</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> and <em>Type2</em> must be such that objects of types <em>iterator_t&lt;Rng1&gt;</em> and <em>iterator_t&lt;Rng2&gt;</em> can be dereferenced and then implicitly converted to <em>Type1</em> and <em>Type2</em> respectively. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj1</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of type dereferenced <em>iterator_t&lt;Rng1&gt;</em> before the function <em>op</em> is invoked. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj2</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of type dereferenced <em>iterator_t&lt;Rng2&gt;</em> before the function <em>op</em> is invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The comparison operations in the parallel <em>find_first_of</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><p>This overload of </p>
<em>find_first_of</em> is available if the user decides to provide the algorithm their own predicate <em>op</em>. <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>find_end</em> algorithm returns a <em>hpx::future&lt;iterator_t&lt;Rng1&gt;</em> &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>iterator_t&lt;Rng1&gt;</em> otherwise. The <em>find_first_of</em> algorithm returns an iterator to the first element in the range <em>rng1</em> that is equal to an element from the range <em>rng2</em>. If the length of the subsequence <em>rng2</em> is greater than the length of the range <em>rng1</em>, <em>end(rng1)</em> is returned. Additionally if the size of the subsequence is empty or no subsequence is found, <em>end(rng1)</em> is also returned.</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-container-algorithms-for-each-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/container_algorithms/for_each.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-container-algorithms-for-each-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v18for_eachERR8ExPolicyRR3RngRR1FRR4Proj">
<span id="_CPPv2N3hpx8parallel2v18for_eachERR8ExPolicyRR3RngRR1FRR4Proj"></span><span id="hpx::parallel::v1::for_each__ExPolicyRR.RngRR.FRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> F, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="container__algorithms_2for__each_8hpp_1a905b9f58b27808a42e0cff8c093e5453"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng&gt;::type&gt;::type <code class="descname">for_each</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, F &amp;&amp;<em>f</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v18for_eachERR8ExPolicyRR3RngRR1FRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Applies <em>f</em> to the result of dereferencing every iterator in the given range <em>rng</em>.</p>
<p><p>If </p>
<em>f</em> returns a result, the result is ignored.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Applies <em>f</em> exactly <em>size(rng)</em> times.</dd>
</dl>
</p>
<p>If the type of <em>first</em> satisfies the requirements of a mutable iterator, <em>f</em> may apply non-constant functions through the dereferenced iterator.</p>
<p>Unlike its sequential form, the parallel overload of <em>for_each</em> does not return a copy of its <em>Function</em> parameter, since parallelization may not permit efficient state accumulation.</p>
<p><p>The application of function objects in parallel algorithm invoked with an execution policy object of type </p>
<em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>for_each</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">ignored</span><span class="o">&gt;</span> <span class="n">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;. The type </p>
<em>Type</em> must be such that an object of type <em>InIter</em> can be dereferenced and then implicitly converted to Type. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>for_each</em> algorithm returns a <em>hpx::future&lt;InIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>InIter</em> otherwise. It returns <em>last</em>. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-container-algorithms-reverse-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/container_algorithms/reverse.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-container-algorithms-reverse-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v17reverseERR8ExPolicyRR3Rng">
<span id="_CPPv2N3hpx8parallel2v17reverseERR8ExPolicyRR3Rng"></span><span id="hpx::parallel::v1::reverse__ExPolicyRR.RngRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng&gt;<br /><span class="target" id="container__algorithms_2reverse_8hpp_1a4b57ce817756e1475993dcb3ce86fb74"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng&gt;::type&gt;::type <code class="descname">reverse</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v17reverseERR8ExPolicyRR3Rng" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Reverses the order of the elements in the range [first, last). Behaves as if applying std::iter_swap to every pair of iterators first+i, (last-i) - 1 for each non-negative i &lt; (last-first)/2.</p>
<p><p>The assignments in the parallel </p>
<em>reverse</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Linear in the distance between <em>first</em> and <em>last</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of a bidirectional iterator.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>reverse</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>reverse</em> algorithm returns a <em>hpx::future&lt;BidirIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>BidirIter</em> otherwise. It returns <em>last</em>. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v112reverse_copyERR8ExPolicyRR3Rng7OutIter">
<span id="_CPPv2N3hpx8parallel2v112reverse_copyERR8ExPolicyRR3Rng7OutIter"></span><span id="hpx::parallel::v1::reverse_copy__ExPolicyRR.RngRR.OutIter"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> OutIter&gt;<br /><span class="target" id="container__algorithms_2reverse_8hpp_1a379f146357139db0bb6ecc90ed7a1da9"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::in<span class="sig-paren">(</span><em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng&gt;::type<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>OutIter<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">reverse_copy</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, OutIter <em>dest_first</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v112reverse_copyERR8ExPolicyRR3Rng7OutIter" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the elements from the range [first, last) to another range beginning at dest_first in such a way that the elements in the new range are in reverse order. Behaves as if by executing the assignment *(dest_first + (last - first) - 1 - i) = *(first + i) once for each non-negative i &lt; (last - first) If the source and destination ranges (that is, [first, last) and [dest_first, dest_first+(last-first)) respectively) overlap, the behavior is undefined.</p>
<p><p>The assignments in the parallel </p>
<em>reverse_copy</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>last</em> - <em>first</em> assignments.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of a bidirectional iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">OutputIter</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an output iterator.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest_first</span></code>: Refers to the begin of the destination range.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>reverse_copy</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>reverse_copy</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::in(BidirIter), tag::out(OutIter)&gt;</em> &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::in(BidirIter), tag::out(OutIter)&gt;</em> otherwise. The <em>copy</em> algorithm returns the pair of the input iterator forwarded to the first element after the last in the input sequence and the output iterator to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-container-algorithms-search-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/container_algorithms/search.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-container-algorithms-search-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v16searchERR8ExPolicyRR4Rng1RR4Rng2RR4PredRR5Proj1RR5Proj2">
<span id="_CPPv2N3hpx8parallel2v16searchERR8ExPolicyRR4Rng1RR4Rng2RR4PredRR5Proj1RR5Proj2"></span><span id="hpx::parallel::v1::search__ExPolicyRR.Rng1RR.Rng2RR.PredRR.Proj1RR.Proj2RR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng1, <em class="property">typename</em> Rng2, <em class="property">typename</em> Pred = detail::equal_to, <em class="property">typename</em> Proj1 = util::projection_identity, <em class="property">typename</em> Proj2 = util::projection_identity&gt;<br /><span class="target" id="container__algorithms_2search_8hpp_1ab1ffca42afa3d4e26dc66e7909956a41"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng1&gt;::type&gt;::type <code class="descname">search</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng1 &amp;&amp;<em>rng1</em>, Rng2 &amp;&amp;<em>rng2</em>, Pred &amp;&amp;<em>op</em> = Pred(), Proj1 &amp;&amp;<em>proj1</em> = Proj1(), Proj2 &amp;&amp;<em>proj2</em> = Proj2()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v16searchERR8ExPolicyRR4Rng1RR4Rng2RR4PredRR5Proj1RR5Proj2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Searches the range [first, last) for any elements in the range [s_first, s_last). Uses a provided predicate to compare elements.</p>
<p><p>The comparison operations in the parallel </p>
<em>search</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: at most (S*N) comparisons where <em>S</em> = distance(s_first, s_last) and <em>N</em> = distance(first, last).</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng1</span></code>: The type of the examine range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng2</span></code>: The type of the search range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <em>adjacent_find</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::equal_to&lt;&gt; </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj1</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> and is applied to the elements of <em>Rng1</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj2</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> and is applied to the elements of <em>Rng2</em>.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng1</span></code>: Refers to the sequence of elements the algorithm will be examining. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng2</span></code>: Refers to the sequence of elements the algorithm will be searching for. </li>
<li><code class="docutils literal notranslate"><span class="pre">op</span></code>: Refers to the binary predicate which returns true if the elements should be treated as equal. the signature of the function should be equivalent to <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type2</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> and <em>Type2</em> must be such that objects of types <em>FwdIter1</em> and <em>FwdIter2</em> can be dereferenced and then implicitly converted to <em>Type1</em> and <em>Type2</em> respectively </li>
<li><code class="docutils literal notranslate"><span class="pre">proj1</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of <em>rng1</em> as a projection operation before the actual predicate <em>is</em> invoked. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj2</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of <em>rng2</em> as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The comparison operations in the parallel <em>search</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>search</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>task_execution_policy</em> and returns <em>FwdIter</em> otherwise. The <em>search</em> algorithm returns an iterator to the beginning of the first subsequence [s_first, s_last) in range [first, last). If the length of the subsequence [s_first, s_last) is greater than the length of the range [first, last), <em>last</em> is returned. Additionally if the size of the subsequence is empty <em>first</em> is returned. If no subsequence is found, <em>last</em> is returned. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v18search_nERR8ExPolicyRR4Rng1NSt6size_tERR4Rng2RR4PredRR5Proj1RR5Proj2">
<span id="_CPPv2N3hpx8parallel2v18search_nERR8ExPolicyRR4Rng1NSt6size_tERR4Rng2RR4PredRR5Proj1RR5Proj2"></span><span id="hpx::parallel::v1::search_n__ExPolicyRR.Rng1RR.std::s.Rng2RR.PredRR.Proj1RR.Proj2RR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng1, <em class="property">typename</em> Rng2, <em class="property">typename</em> Pred = detail::equal_to, <em class="property">typename</em> Proj1 = util::projection_identity, <em class="property">typename</em> Proj2 = util::projection_identity&gt;<br /><span class="target" id="container__algorithms_2search_8hpp_1a604fae53f2d42afc02155499a378c1ad"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng1&gt;::type&gt;::type <code class="descname">search_n</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng1 &amp;&amp;<em>rng1</em>, <a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::size_t <em>count</em>, Rng2 &amp;&amp;<em>rng2</em>, Pred &amp;&amp;<em>op</em> = Pred(), Proj1 &amp;&amp;<em>proj1</em> = Proj1(), Proj2 &amp;&amp;<em>proj2</em> = Proj2()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v18search_nERR8ExPolicyRR4Rng1NSt6size_tERR4Rng2RR4PredRR5Proj1RR5Proj2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Searches the range [first, last) for any elements in the range [s_first, s_last). Uses a provided predicate to compare elements.</p>
<p><p>The comparison operations in the parallel </p>
<em>search</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: at most (S*N) comparisons where <em>S</em> = distance(s_first, s_last) and <em>N</em> = distance(first, last).</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng1</span></code>: The type of the examine range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng2</span></code>: The type of the search range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <em>adjacent_find</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::equal_to&lt;&gt; </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj1</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> and is applied to the elements of <em>Rng1</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj2</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> and is applied to the elements of <em>Rng2</em>.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng1</span></code>: Refers to the sequence of elements the algorithm will be examining. </li>
<li><code class="docutils literal notranslate"><span class="pre">count</span></code>: The number of elements to apply the algorithm on. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng2</span></code>: Refers to the sequence of elements the algorithm will be searching for. </li>
<li><code class="docutils literal notranslate"><span class="pre">op</span></code>: Refers to the binary predicate which returns true if the elements should be treated as equal. the signature of the function should be equivalent to <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type2</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> and <em>Type2</em> must be such that objects of types <em>FwdIter1</em> and <em>FwdIter2</em> can be dereferenced and then implicitly converted to <em>Type1</em> and <em>Type2</em> respectively </li>
<li><code class="docutils literal notranslate"><span class="pre">proj1</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of <em>rng1</em> as a projection operation before the actual predicate <em>is</em> invoked. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj2</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of <em>rng2</em> as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The comparison operations in the parallel <em>search</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>search</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>task_execution_policy</em> and returns <em>FwdIter</em> otherwise. The <em>search</em> algorithm returns an iterator to the beginning of the first subsequence [s_first, s_last) in range [first, last). If the length of the subsequence [s_first, s_last) is greater than the length of the range [first, last), <em>last</em> is returned. Additionally if the size of the subsequence is empty <em>first</em> is returned. If no subsequence is found, <em>last</em> is returned. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-container-algorithms-fill-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/container_algorithms/fill.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-container-algorithms-fill-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v14fillERR8ExPolicyRR3Rng1T">
<span id="_CPPv2N3hpx8parallel2v14fillERR8ExPolicyRR3Rng1T"></span><span id="hpx::parallel::v1::fill__ExPolicyRR.RngRR.T"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> T&gt;<br /><span class="target" id="container__algorithms_2fill_8hpp_1a84a9d0b04c5eaffaf3debbf7b5a2391f"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy&gt;::type <code class="descname">fill</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, T <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v14fillERR8ExPolicyRR3Rng1T" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assigns the given value to the elements in the range [first, last).</p>
<p><p>The comparisons in the parallel </p>
<em>fill</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>last</em> - <em>first</em> assignments.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the value to be assigned (deduced).</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">value</span></code>: The value to be assigned.</li>
</ul>
</dd>
</dl>
</p>
<p>The comparisons in the parallel <em>fill</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>fill</em> algorithm returns a <em>hpx::future&lt;void&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>difference_type</em> otherwise (where <em>difference_type</em> is defined by <em>void</em>. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v16fill_nERR8ExPolicyR3Rng4Size1T">
<span id="_CPPv2N3hpx8parallel2v16fill_nERR8ExPolicyR3Rng4Size1T"></span><span id="hpx::parallel::v1::fill_n__ExPolicyRR.RngR.Size.T"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> Size, <em class="property">typename</em> T&gt;<br /><span class="target" id="container__algorithms_2fill_8hpp_1a5a2d3082ecac9572cf4dc26935e07b60"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_traits&lt;Rng&gt;::iterator_type&gt;::type <code class="descname">fill_n</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;<em>rng</em>, Size <em>count</em>, T <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v16fill_nERR8ExPolicyR3Rng4Size1T" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assigns the given value value to the first count elements in the range beginning at first if count &gt; 0. Does nothing otherwise.</p>
<p><p>The comparisons in the parallel </p>
<em>fill_n</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>count</em> assignments, for count &gt; 0.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Size</span></code>: The type of the argument specifying the number of elements to apply <em>f</em> to. </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the value to be assigned (deduced).</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">count</span></code>: Refers to the number of elements starting at <em>first</em> the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">value</span></code>: The value to be assigned.</li>
</ul>
</dd>
</dl>
</p>
<p>The comparisons in the parallel <em>fill_n</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>fill_n</em> algorithm returns a <em>hpx::future&lt;void&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>difference_type</em> otherwise (where <em>difference_type</em> is defined by <em>void</em>. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-container-algorithms-merge-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/container_algorithms/merge.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-container-algorithms-merge-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v15mergeERR8ExPolicyRR4Rng1RR4Rng29RandIter3RR4CompRR5Proj1RR5Proj2">
<span id="_CPPv2N3hpx8parallel2v15mergeERR8ExPolicyRR4Rng1RR4Rng29RandIter3RR4CompRR5Proj1RR5Proj2"></span><span id="hpx::parallel::v1::merge__ExPolicyRR.Rng1RR.Rng2RR.RandIter3.CompRR.Proj1RR.Proj2RR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng1, <em class="property">typename</em> Rng2, <em class="property">typename</em> RandIter3, <em class="property">typename</em> Comp = detail::less, <em class="property">typename</em> Proj1 = util::projection_identity, <em class="property">typename</em> Proj2 = util::projection_identity&gt;<br /><span class="target" id="container__algorithms_2merge_8hpp_1a6c82672cf5c318cfaa02bf771934dcdd"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_tuple&lt;tag::in1<span class="sig-paren">(</span><em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng1&gt;::type<span class="sig-paren">)</span>, tag::in2<span class="sig-paren">(</span><em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng2&gt;::type<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>RandIter3<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">merge</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng1 &amp;&amp;<em>rng1</em>, Rng2 &amp;&amp;<em>rng2</em>, RandIter3 <em>dest</em>, Comp &amp;&amp;<em>comp</em> = Comp(), Proj1 &amp;&amp;<em>proj1</em> = Proj1(), Proj2 &amp;&amp;<em>proj2</em> = Proj2()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v15mergeERR8ExPolicyRR4Rng1RR4Rng29RandIter3RR4CompRR5Proj1RR5Proj2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Merges two sorted ranges [first1, last1) and [first2, last2) into one sorted range beginning at <em>dest</em>. The order of equivalent elements in the each of original two ranges is preserved. For equivalent elements in the original two ranges, the elements from the first range precede the elements from the second range. The destination range cannot overlap with either of the input ranges.</p>
<p><p>The assignments in the parallel </p>
<em>merge</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs O(std::distance(first1, last1) + std::distance(first2, last2)) applications of the comparison <em>comp</em> and the each projection.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng1</span></code>: The type of the first source range used (deduced). The iterators extracted from this range type must meet the requirements of an random access iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng2</span></code>: The type of the second source range used (deduced). The iterators extracted from this range type must meet the requirements of an random access iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">RandIter3</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an random access iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Comp</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>merge</em> requires <em>Comp</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::less&lt;&gt; </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj1</span></code>: The type of an optional projection function to be used for elements of the first range. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj2</span></code>: The type of an optional projection function to be used for elements of the second range. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng1</span></code>: Refers to the first range of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng2</span></code>: Refers to the second range of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">comp</span></code>: <em>comp</em> is a callable object which returns true if the first argument is less than the second, and false otherwise. The signature of this comparison should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">comp</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type2</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> and <em>Type2</em> must be such that objects of types <em>RandIter1</em> and <em>RandIter2</em> can be dereferenced and then implicitly converted to both <em>Type1</em> and <em>Type2</em> </li>
<li><code class="docutils literal notranslate"><span class="pre">proj1</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of the first range as a projection operation before the actual comparison <em>comp</em> is invoked. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj2</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of the second range as a projection operation before the actual comparison <em>comp</em> is invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>merge</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>merge</em> algorithm returns a <em>hpx::future&lt;tagged_tuple&lt;tag::in1(RandIter1), tag::in2(RandIter2), tag::out(RandIter3)&gt;</em> &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>tagged_tuple&lt;tag::in1(RandIter1), tag::in2(RandIter2), tag::out(RandIter3)&gt;</em> otherwise. The <em>merge</em> algorithm returns the tuple of the source iterator <em>last1</em>, the source iterator <em>last2</em>, the destination iterator to the end of the <em>dest</em> range. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v113inplace_mergeERR8ExPolicyRR3Rng8RandIterRR4CompRR4Proj">
<span id="_CPPv2N3hpx8parallel2v113inplace_mergeERR8ExPolicyRR3Rng8RandIterRR4CompRR4Proj"></span><span id="hpx::parallel::v1::inplace_merge__ExPolicyRR.RngRR.RandIter.CompRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> RandIter, <em class="property">typename</em> Comp = detail::less, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="container__algorithms_2merge_8hpp_1a1cd900a1f789e1218bcd65b1cc9c5588"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, RandIter&gt;::type <code class="descname">inplace_merge</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, RandIter <em>middle</em>, Comp &amp;&amp;<em>comp</em> = Comp(), Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v113inplace_mergeERR8ExPolicyRR3Rng8RandIterRR4CompRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Merges two consecutive sorted ranges [first, middle) and [middle, last) into one sorted range [first, last). The order of equivalent elements in the each of original two ranges is preserved. For equivalent elements in the original two ranges, the elements from the first range precede the elements from the second range.</p>
<p><p>The assignments in the parallel </p>
<em>inplace_merge</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs O(std::distance(first, last)) applications of the comparison <em>comp</em> and the each projection.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an random access iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">RandIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an random access iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Comp</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>inplace_merge</em> requires <em>Comp</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::less&lt;&gt; </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the range of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">middle</span></code>: Refers to the end of the first sorted range and the beginning of the second sorted range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">comp</span></code>: <em>comp</em> is a callable object which returns true if the first argument is less than the second, and false otherwise. The signature of this comparison should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">comp</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type2</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> and <em>Type2</em> must be such that objects of types <em>RandIter</em> can be dereferenced and then implicitly converted to both <em>Type1</em> and <em>Type2</em> </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>inplace_merge</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>inplace_merge</em> algorithm returns a <em>hpx::future&lt;RandIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>RandIter</em> otherwise. The <em>inplace_merge</em> algorithm returns the source iterator <em>last</em> </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-container-algorithms-remove-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/container_algorithms/remove.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-container-algorithms-remove-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v16removeERR8ExPolicyRR3RngR1TRR4Proj">
<span id="_CPPv2N3hpx8parallel2v16removeERR8ExPolicyRR3RngR1TRR4Proj"></span><span id="hpx::parallel::v1::remove__ExPolicyRR.RngRR.TCR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> T, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="container__algorithms_2remove_8hpp_1aedb2c2cd49d8e084e5d131eb8fd3b9b8"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng&gt;::type&gt;::type <code class="descname">remove</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, T <em class="property">const</em> &amp;<em>value</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v16removeERR8ExPolicyRR3RngR1TRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Removes all elements satisfying specific criteria from the range [first, last) and returns a past-the-end iterator for the new end of the range. This version removes all elements that are equal to <em>value</em>.</p>
<p><p>The assignments in the parallel </p>
<em>remove</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs not more than <em>last</em> - <em>first</em> assignments, exactly <em>last</em> - <em>first</em> applications of the operator==() and the projection <em>proj</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the value to remove (deduced). This value type must meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">value</span></code>: Specifies the value of elements to remove. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>remove</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>remove</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter</em> otherwise. The <em>remove</em> algorithm returns the iterator to the new end of the range. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v19remove_ifERR8ExPolicyRR3RngRR4PredRR4Proj">
<span id="_CPPv2N3hpx8parallel2v19remove_ifERR8ExPolicyRR3RngRR4PredRR4Proj"></span><span id="hpx::parallel::v1::remove_if__ExPolicyRR.RngRR.PredRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> Pred, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="container__algorithms_2remove_8hpp_1a757e4e09d210a018eb408f8f91be26db"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng&gt;::type&gt;::type <code class="descname">remove_if</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, Pred &amp;&amp;<em>pred</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v19remove_ifERR8ExPolicyRR3RngRR4PredRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Removes all elements satisfying specific criteria from the range [first, last) and returns a past-the-end iterator for the new end of the range. This version removes all elements for which predicate <em>pred</em> returns true.</p>
<p><p>The assignments in the parallel </p>
<em>remove_if</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs not more than <em>last</em> - <em>first</em> assignments, exactly <em>last</em> - <em>first</em> applications of the predicate <em>pred</em> and the projection <em>proj</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>remove_if</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">pred</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is an unary predicate which returns <em>true</em> for the required elements. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter</em> can be dereferenced and then implicitly converted to Type. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>remove_if</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>remove_if</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter</em> otherwise. The <em>remove_if</em> algorithm returns the iterator to the new end of the range. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-container-algorithms-minmax-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/container_algorithms/minmax.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-container-algorithms-minmax-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v111min_elementERR8ExPolicyRR3RngRR1FRR4Proj">
<span id="_CPPv2N3hpx8parallel2v111min_elementERR8ExPolicyRR3RngRR1FRR4Proj"></span><span id="hpx::parallel::v1::min_element__ExPolicyRR.RngRR.FRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> Proj = util::projection_identity, <em class="property">typename</em> F = detail::less&gt;<br /><span class="target" id="container__algorithms_2minmax_8hpp_1a6a33655d349a0aed7ca06d8fc5ab19f0"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_traits&lt;Rng&gt;::iterator_type&gt;::type <code class="descname">min_element</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, F &amp;&amp;<em>f</em> = F(), Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v111min_elementERR8ExPolicyRR3RngRR1FRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Finds the smallest element in the range [first, last) using the given comparison function <em>f</em>.</p>
<p><p>The comparisons in the parallel </p>
<em>min_element</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Exactly <em>max</em>(N-1, 0) comparisons, where N = std::distance(first, last).</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>min_element</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: The binary predicate which returns true if the the left argument is less than the right element. The signature of the predicate function should be equivalent to the following: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type1</em> must be such that objects of type <em>FwdIter</em> can be dereferenced and then implicitly converted to <em>Type1</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The comparisons in the parallel <em>min_element</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>min_element</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter</em> otherwise. The <em>min_element</em> algorithm returns the iterator to the smallest element in the range [first, last). If several elements in the range are equivalent to the smallest element, returns the iterator to the first such element. Returns last if the range is empty. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v111max_elementERR8ExPolicyRR3RngRR1FRR4Proj">
<span id="_CPPv2N3hpx8parallel2v111max_elementERR8ExPolicyRR3RngRR1FRR4Proj"></span><span id="hpx::parallel::v1::max_element__ExPolicyRR.RngRR.FRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> Proj = util::projection_identity, <em class="property">typename</em> F = detail::less&gt;<br /><span class="target" id="container__algorithms_2minmax_8hpp_1a7b0371ff082b9961da0bcc44277b03e0"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_traits&lt;Rng&gt;::iterator_type&gt;::type <code class="descname">max_element</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, F &amp;&amp;<em>f</em> = F(), Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v111max_elementERR8ExPolicyRR3RngRR1FRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Finds the greatest element in the range [first, last) using the given comparison function <em>f</em>.</p>
<p><p>The comparisons in the parallel </p>
<em>max_element</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Exactly <em>max</em>(N-1, 0) comparisons, where N = std::distance(first, last).</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>max_element</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: The binary predicate which returns true if the This argument is optional and defaults to std::less. the left argument is less than the right element. The signature of the predicate function should be equivalent to the following: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type1</em> must be such that objects of type <em>FwdIter</em> can be dereferenced and then implicitly converted to <em>Type1</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The comparisons in the parallel <em>max_element</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>max_element</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter</em> otherwise. The <em>max_element</em> algorithm returns the iterator to the smallest element in the range [first, last). If several elements in the range are equivalent to the smallest element, returns the iterator to the first such element. Returns last if the range is empty. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v114minmax_elementERR8ExPolicyRR3RngRR1FRR4Proj">
<span id="_CPPv2N3hpx8parallel2v114minmax_elementERR8ExPolicyRR3RngRR1FRR4Proj"></span><span id="hpx::parallel::v1::minmax_element__ExPolicyRR.RngRR.FRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> Proj = util::projection_identity, <em class="property">typename</em> F = detail::less&gt;<br /><span class="target" id="container__algorithms_2minmax_8hpp_1a4e2b095b137a17e50fc6cf54d261e5a9"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::min<span class="sig-paren">(</span><em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_traits&lt;Rng&gt;::iterator_type<span class="sig-paren">)</span>, tag::max<span class="sig-paren">(</span><em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_traits&lt;Rng&gt;::iterator_type<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">minmax_element</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, F &amp;&amp;<em>f</em> = F(), Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v114minmax_elementERR8ExPolicyRR3RngRR1FRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Finds the greatest element in the range [first, last) using the given comparison function <em>f</em>.</p>
<p><p>The comparisons in the parallel </p>
<em>minmax_element</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: At most <em>max</em>(floor(3/2*(N-1)), 0) applications of the predicate, where N = std::distance(first, last).</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>minmax_element</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: The binary predicate which returns true if the the left argument is less than the right element. This argument is optional and defaults to std::less. The signature of the predicate function should be equivalent to the following: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type1</em> must be such that objects of type <em>FwdIter</em> can be dereferenced and then implicitly converted to <em>Type1</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The comparisons in the parallel <em>minmax_element</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>minmax_element</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::min(FwdIter), tag::max(FwdIter)&gt;</em> &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::min(FwdIter), tag::max(FwdIter)&gt;</em> otherwise. The <em>minmax_element</em> algorithm returns a pair consisting of an iterator to the smallest element as the first element and an iterator to the greatest element as the second. Returns std::make_pair(first, first) if the range is empty. If several elements are equivalent to the smallest element, the iterator to the first such element is returned. If several elements are equivalent to the largest element, the iterator to the last such element is returned. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-container-algorithms-transform-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/container_algorithms/transform.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-container-algorithms-transform-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v19transformERR8ExPolicyRR3Rng7OutIterRR1FRR4Proj">
<span id="_CPPv2N3hpx8parallel2v19transformERR8ExPolicyRR3Rng7OutIterRR1FRR4Proj"></span><span id="hpx::parallel::v1::transform__ExPolicyRR.RngRR.OutIter.FRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> OutIter, <em class="property">typename</em> F, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="container__algorithms_2transform_8hpp_1a1acabde30faa80f7dbcdffc4cf0956f5"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::in<span class="sig-paren">(</span><em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng&gt;::type<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>OutIter<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">transform</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, OutIter <em>dest</em>, F &amp;&amp;<em>f</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v19transformERR8ExPolicyRR3Rng7OutIterRR1FRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Applies the given function <em>f</em> to the given range <em>rng</em> and stores the result in another range, beginning at dest.</p>
<p><p>The invocations of </p>
<em>f</em> in the parallel <em>transform</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Exactly size(rng) applications of <em>f</em> </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the invocations of <em>f</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">OutIter</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an output iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>transform</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is an unary predicate. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ret</span> <span class="nf">fun</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;. The type </p>
<em>Type</em> must be such that an object of type <em>InIter</em> can be dereferenced and then implicitly converted to <em>Type</em>. The type <em>Ret</em> must be such that an object of type <em>OutIter</em> can be dereferenced and assigned a value of type <em>Ret</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>f</em> is invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The invocations of <em>f</em> in the parallel <em>transform</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>transform</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::in(InIter), tag::out(OutIter)&gt;</em> &gt; if the execution policy is of type <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::in(InIter), tag::out(OutIter)&gt;</em> otherwise. The <em>transform</em> algorithm returns a tuple holding an iterator referring to the first element after the input sequence and the output iterator to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v19transformERR8ExPolicyRR3Rng7InIter27OutIterRR1FRR5Proj1RR5Proj2">
<span id="_CPPv2N3hpx8parallel2v19transformERR8ExPolicyRR3Rng7InIter27OutIterRR1FRR5Proj1RR5Proj2"></span><span id="hpx::parallel::v1::transform__ExPolicyRR.RngRR.InIter2.OutIter.FRR.Proj1RR.Proj2RR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> InIter2, <em class="property">typename</em> OutIter, <em class="property">typename</em> F, <em class="property">typename</em> Proj1 = util::projection_identity, <em class="property">typename</em> Proj2 = util::projection_identity&gt;<br /><span class="target" id="container__algorithms_2transform_8hpp_1a3e9fe0320544aa7733a4fb8973e7f2f9"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_tuple&lt;tag::in1<span class="sig-paren">(</span><em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng&gt;::type<span class="sig-paren">)</span>, tag::in2<span class="sig-paren">(</span>InIter2<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>OutIter<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">transform</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, InIter2 <em>first2</em>, OutIter <em>dest</em>, F &amp;&amp;<em>f</em>, Proj1 &amp;&amp;<em>proj1</em> = Proj1(), Proj2 &amp;&amp;<em>proj2</em> = Proj2()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v19transformERR8ExPolicyRR3Rng7InIter27OutIterRR1FRR5Proj1RR5Proj2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Applies the given function <em>f</em> to pairs of elements from two ranges: one defined by <em>rng</em> and the other beginning at first2, and stores the result in another range, beginning at dest.</p>
<p><p>The invocations of </p>
<em>f</em> in the parallel <em>transform</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Exactly size(rng) applications of <em>f</em> </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the invocations of <em>f</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">InIter2</span></code>: The type of the source iterators for the second range used (deduced). This iterator type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">OutIter</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an output iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>transform</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj1</span></code>: The type of an optional projection function to be used for elements of the first sequence. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj2</span></code>: The type of an optional projection function to be used for elements of the second sequence. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">first2</span></code>: Refers to the beginning of the second sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is a binary predicate. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ret</span> <span class="nf">fun</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type2</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;. The types </p>
<em>Type1</em> and <em>Type2</em> must be such that objects of types InIter1 and InIter2 can be dereferenced and then implicitly converted to <em>Type1</em> and <em>Type2</em> respectively. The type <em>Ret</em> must be such that an object of type <em>OutIter</em> can be dereferenced and assigned a value of type <em>Ret</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj1</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of the first sequence as a projection operation before the actual predicate <em>f</em> is invoked. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj2</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of the second sequence as a projection operation before the actual predicate <em>f</em> is invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The invocations of <em>f</em> in the parallel <em>transform</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>transform</em> algorithm returns a <em>hpx::future&lt;tagged_tuple&lt;tag::in1(InIter1), tag::in2(InIter2), tag::out(OutIter)&gt;</em> &gt; if the execution policy is of type <em>parallel_task_policy</em> and returns <em>tagged_tuple&lt;tag::in1(InIter1), tag::in2(InIter2), tag::out(OutIter)&gt;</em> otherwise. The <em>transform</em> algorithm returns a tuple holding an iterator referring to the first element after the first input sequence, an iterator referring to the first element after the second input sequence, and the output iterator referring to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v19transformERR8ExPolicyRR4Rng1RR4Rng27OutIterRR1FRR5Proj1RR5Proj2">
<span id="_CPPv2N3hpx8parallel2v19transformERR8ExPolicyRR4Rng1RR4Rng27OutIterRR1FRR5Proj1RR5Proj2"></span><span id="hpx::parallel::v1::transform__ExPolicyRR.Rng1RR.Rng2RR.OutIter.FRR.Proj1RR.Proj2RR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng1, <em class="property">typename</em> Rng2, <em class="property">typename</em> OutIter, <em class="property">typename</em> F, <em class="property">typename</em> Proj1 = util::projection_identity, <em class="property">typename</em> Proj2 = util::projection_identity&gt;<br /><span class="target" id="container__algorithms_2transform_8hpp_1adcd24f100f8ab51b1fc5a71c7c330401"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_tuple&lt;tag::in1<span class="sig-paren">(</span><em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng1&gt;::type<span class="sig-paren">)</span>, tag::in2<span class="sig-paren">(</span><em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng2&gt;::type<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>OutIter<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">transform</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng1 &amp;&amp;<em>rng1</em>, Rng2 &amp;&amp;<em>rng2</em>, OutIter <em>dest</em>, F &amp;&amp;<em>f</em>, Proj1 &amp;&amp;<em>proj1</em> = Proj1(), Proj2 &amp;&amp;<em>proj2</em> = Proj2()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v19transformERR8ExPolicyRR4Rng1RR4Rng27OutIterRR1FRR5Proj1RR5Proj2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Applies the given function <em>f</em> to pairs of elements from two ranges: one defined by [first1, last1) and the other beginning at first2, and stores the result in another range, beginning at dest.</p>
<p><p>The invocations of </p>
<em>f</em> in the parallel <em>transform</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Exactly min(last2-first2, last1-first1) applications of <em>f</em> </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the invocations of <em>f</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng1</span></code>: The type of the first source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng2</span></code>: The type of the second source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">OutIter</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an output iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>transform</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj1</span></code>: The type of an optional projection function to be used for elements of the first sequence. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj2</span></code>: The type of an optional projection function to be used for elements of the second sequence. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng1</span></code>: Refers to the first sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng2</span></code>: Refers to the second sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is a binary predicate. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ret</span> <span class="nf">fun</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type2</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;. The types </p>
<em>Type1</em> and <em>Type2</em> must be such that objects of types InIter1 and InIter2 can be dereferenced and then implicitly converted to <em>Type1</em> and <em>Type2</em> respectively. The type <em>Ret</em> must be such that an object of type <em>OutIter</em> can be dereferenced and assigned a value of type <em>Ret</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj1</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of the first sequence as a projection operation before the actual predicate <em>f</em> is invoked. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj2</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of the second sequence as a projection operation before the actual predicate <em>f</em> is invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The invocations of <em>f</em> in the parallel <em>transform</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The algorithm will invoke the binary predicate until it reaches the end of the shorter of the two given input sequences</dd>
<dt><strong>Return</strong></dt>
<dd>The <em>transform</em> algorithm returns a <em>hpx::future&lt;tagged_tuple&lt;tag::in1(InIter1), tag::in2(InIter2), tag::out(OutIter)&gt;</em> &gt; if the execution policy is of type <em>parallel_task_policy</em> and returns <em>tagged_tuple&lt;tag::in1(InIter1), tag::in2(InIter2), tag::out(OutIter)&gt;</em> otherwise. The <em>transform</em> algorithm returns a tuple holding an iterator referring to the first element r the first input sequence, an iterator referring to the first element after the second input sequence, and the output iterator referring to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-container-algorithms-unique-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/container_algorithms/unique.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-container-algorithms-unique-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v16uniqueERR8ExPolicyRR3RngRR4PredRR4Proj">
<span id="_CPPv2N3hpx8parallel2v16uniqueERR8ExPolicyRR3RngRR4PredRR4Proj"></span><span id="hpx::parallel::v1::unique__ExPolicyRR.RngRR.PredRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> Pred = detail::equal_to, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="container__algorithms_2unique_8hpp_1ae82e383f0d87fb46944e02c0c02cb84f"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng&gt;::type&gt;::type <code class="descname">unique</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, Pred &amp;&amp;<em>pred</em> = Pred(), Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v16uniqueERR8ExPolicyRR3RngRR4PredRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Eliminates all but the first element from every consecutive group of equivalent elements from the range <em>rng</em> and returns a past-the-end iterator for the new logical end of the range.</p>
<p><p>The assignments in the parallel </p>
<em>unique</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs not more than N assignments, exactly N - 1 applications of the predicate <em>pred</em> and no more than twice as many applications of the projection <em>proj</em>, where N = std::distance(begin(rng), end(rng)).</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>unique</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::equal_to&lt;&gt; </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">pred</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). This is an binary predicate which returns <em>true</em> for the required elements. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter1</em> can be dereferenced and then implicitly converted to <em>Type</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>unique</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>unique</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter</em> otherwise. The <em>unique</em> algorithm returns the iterator to the new end of the range. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v111unique_copyERR8ExPolicyRR3Rng8FwdIter2RR4PredRR4Proj">
<span id="_CPPv2N3hpx8parallel2v111unique_copyERR8ExPolicyRR3Rng8FwdIter2RR4PredRR4Proj"></span><span id="hpx::parallel::v1::unique_copy__ExPolicyRR.RngRR.FwdIter2.PredRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> Pred = detail::equal_to, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="container__algorithms_2unique_8hpp_1a953aa24693169289a5bef88607bcb622"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::in<span class="sig-paren">(</span><em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng&gt;::type<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>FwdIter2<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">unique_copy</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, FwdIter2 <em>dest</em>, Pred &amp;&amp;<em>pred</em> = Pred(), Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v111unique_copyERR8ExPolicyRR3Rng8FwdIter2RR4PredRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the elements from the range <em>rng</em>, to another range beginning at <em>dest</em> in such a way that there are no consecutive equal elements. Only the first element of each group of equal elements is copied.</p>
<p><p>The assignments in the parallel </p>
<em>unique_copy</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs not more than N assignments, exactly N - 1 applications of the predicate <em>pred</em>, where N = std::distance(begin(rng), end(rng)).</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>unique_copy</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::equal_to&lt;&gt; </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">pred</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by the range <em>rng</em>. This is an binary predicate which returns <em>true</em> for the required elements. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter1</em> can be dereferenced and then implicitly converted to <em>Type</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>unique_copy</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>unique_copy</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</em> &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</em> otherwise. The <em>unique_copy</em> algorithm returns the pair of the source iterator to <em>last</em>, and the destination iterator to the end of the <em>dest</em> range. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-container-algorithms-replace-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/container_algorithms/replace.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-container-algorithms-replace-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v17replaceERR8ExPolicyRR3RngR2T1R2T2RR4Proj">
<span id="_CPPv2N3hpx8parallel2v17replaceERR8ExPolicyRR3RngR2T1R2T2RR4Proj"></span><span id="hpx::parallel::v1::replace__ExPolicyRR.RngRR.T1CR.T2CR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> T1, <em class="property">typename</em> T2, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="container__algorithms_2replace_8hpp_1a840d0a0e6021762ec63acbe308f40912"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_traits&lt;Rng&gt;::iterator_type&gt;::type <code class="descname">replace</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, T1 <em class="property">const</em> &amp;<em>old_value</em>, T2 <em class="property">const</em> &amp;<em>new_value</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v17replaceERR8ExPolicyRR3RngR2T1R2T2RR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Replaces all elements satisfying specific criteria with <em>new_value</em> in the range [first, last).</p>
<p><p>Effects: Substitutes elements referred by the iterator it in the range [first,last) with new_value, when the following corresponding conditions hold: INVOKE(proj, *i) == old_value</p>
<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>last</em> - <em>first</em> assignments.</dd>
</dl>
</p>
<p><p>The assignments in the parallel </p>
<em>replace</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of a forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">T1</span></code>: The type of the old value to replace (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">T2</span></code>: The type of the new values to replace (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">old_value</span></code>: Refers to the old value of the elements to replace. </li>
<li><code class="docutils literal notranslate"><span class="pre">new_value</span></code>: Refers to the new value to use as the replacement. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>replace</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>replace</em> algorithm returns a <em>hpx::future&lt;void&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>void</em> otherwise. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v110replace_ifERR8ExPolicyRR3RngRR1FR1TRR4Proj">
<span id="_CPPv2N3hpx8parallel2v110replace_ifERR8ExPolicyRR3RngRR1FR1TRR4Proj"></span><span id="hpx::parallel::v1::replace_if__ExPolicyRR.RngRR.FRR.TCR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> F, <em class="property">typename</em> T, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="container__algorithms_2replace_8hpp_1a6ead563761a22536b3d51a713af804e1"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_traits&lt;Rng&gt;::iterator_type&gt;::type <code class="descname">replace_if</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, F &amp;&amp;<em>f</em>, T <em class="property">const</em> &amp;<em>new_value</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v110replace_ifERR8ExPolicyRR3RngRR1FR1TRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Replaces all elements satisfying specific criteria (for which predicate <em>f</em> returns true) with <em>new_value</em> in the range [first, last).</p>
<p><p>Effects: Substitutes elements referred by the iterator it in the range [first, last) with new_value, when the following corresponding conditions hold: INVOKE(f, INVOKE(proj, *it)) != false</p>
<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>last</em> - <em>first</em> applications of the predicate.</dd>
</dl>
</p>
<p><p>The assignments in the parallel </p>
<em>replace_if</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of a forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>equal</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the new values to replace (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is an unary predicate which returns <em>true</em> for the elements which need to replaced. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter</em> can be dereferenced and then implicitly converted to <em>Type</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">new_value</span></code>: Refers to the new value to use as the replacement. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>replace_if</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>replace_if</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>void</em> otherwise. It returns <em>last</em>. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v112replace_copyERR8ExPolicyRR3Rng7OutIterR2T1R2T2RR4Proj">
<span id="_CPPv2N3hpx8parallel2v112replace_copyERR8ExPolicyRR3Rng7OutIterR2T1R2T2RR4Proj"></span><span id="hpx::parallel::v1::replace_copy__ExPolicyRR.RngRR.OutIter.T1CR.T2CR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> OutIter, <em class="property">typename</em> T1, <em class="property">typename</em> T2, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="container__algorithms_2replace_8hpp_1af864f34d4734bdc949b863be40b7c856"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::in<span class="sig-paren">(</span><em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_traits&lt;Rng&gt;::iterator_type<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>OutIter<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">replace_copy</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, OutIter <em>dest</em>, T1 <em class="property">const</em> &amp;<em>old_value</em>, T2 <em class="property">const</em> &amp;<em>new_value</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v112replace_copyERR8ExPolicyRR3Rng7OutIterR2T1R2T2RR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the all elements from the range [first, last) to another range beginning at <em>dest</em> replacing all elements satisfying a specific criteria with <em>new_value</em>.</p>
<p>Effects: Assigns to every iterator it in the range [result, result + (last - first)) either new_value or *(first + (it - result)) depending on whether the following corresponding condition holds: INVOKE(proj, *(first + (i - result))) == old_value</p>
<p><p>The assignments in the parallel </p>
<em>replace_copy</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>last</em> - <em>first</em> applications of the predicate.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">OutIter</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an output iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">T1</span></code>: The type of the old value to replace (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">T2</span></code>: The type of the new values to replace (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">old_value</span></code>: Refers to the old value of the elements to replace. </li>
<li><code class="docutils literal notranslate"><span class="pre">new_value</span></code>: Refers to the new value to use as the replacement. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>replace_copy</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>replace_copy</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::in(InIter), tag::out(OutIter)&gt;</em> &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::in(InIter), tag::out(OutIter)&gt;</em> otherwise. The <em>copy</em> algorithm returns the pair of the input iterator <em>last</em> and the output iterator to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v115replace_copy_ifERR8ExPolicyRR3Rng7OutIterRR1FR1TRR4Proj">
<span id="_CPPv2N3hpx8parallel2v115replace_copy_ifERR8ExPolicyRR3Rng7OutIterRR1FR1TRR4Proj"></span><span id="hpx::parallel::v1::replace_copy_if__ExPolicyRR.RngRR.OutIter.FRR.TCR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> OutIter, <em class="property">typename</em> F, <em class="property">typename</em> T, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="container__algorithms_2replace_8hpp_1a69a630200daa952f412b2ba896e31196"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::in<span class="sig-paren">(</span><em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_traits&lt;Rng&gt;::iterator_type<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>OutIter<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">replace_copy_if</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, OutIter <em>dest</em>, F &amp;&amp;<em>f</em>, T <em class="property">const</em> &amp;<em>new_value</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v115replace_copy_ifERR8ExPolicyRR3Rng7OutIterRR1FR1TRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the all elements from the range [first, last) to another range beginning at <em>dest</em> replacing all elements satisfying a specific criteria with <em>new_value</em>.</p>
<p>Effects: Assigns to every iterator it in the range [result, result + (last - first)) either new_value or *(first + (it - result)) depending on whether the following corresponding condition holds: INVOKE(f, INVOKE(proj, *(first + (i - result)))) != false</p>
<p><p>The assignments in the parallel </p>
<em>replace_copy_if</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>last</em> - <em>first</em> applications of the predicate.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">OutIter</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an output iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>equal</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the new values to replace (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is an unary predicate which returns <em>true</em> for the elements which need to replaced. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter</em> can be dereferenced and then implicitly converted to <em>Type</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">new_value</span></code>: Refers to the new value to use as the replacement. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>replace_copy_if</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>replace_copy_if</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::in(InIter), tag::out(OutIter)&gt;</em> &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::in(InIter), tag::out(OutIter)&gt;</em> otherwise. The <em>replace_copy_if</em> algorithm returns the input iterator <em>last</em> and the output iterator to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-container-algorithms-move-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/container_algorithms/move.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-container-algorithms-move-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v14moveERR8ExPolicyRR3Rng7OutIter">
<span id="_CPPv2N3hpx8parallel2v14moveERR8ExPolicyRR3Rng7OutIter"></span><span id="hpx::parallel::v1::move__ExPolicyRR.RngRR.OutIter"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> OutIter&gt;<br /><span class="target" id="container__algorithms_2move_8hpp_1a2a503c70e419ac8e2e6b7bd9f05d2d82"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::in<span class="sig-paren">(</span><em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_traits&lt;Rng&gt;::iterator_type<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>OutIter<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">move</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, OutIter <em>dest</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v14moveERR8ExPolicyRR3Rng7OutIter" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Moves the elements in the range <em>rng</em> to another range beginning at <em>dest</em>. After this operation the elements in the moved-from range will still contain valid values of the appropriate type, but not necessarily the same values as before the move.</p>
<p><p>The assignments in the parallel </p>
<em>copy</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly std::distance(begin(rng), end(rng)) assignments.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">OutIter</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an output iterator.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>copy</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>move</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::in(iterator_t&lt;Rng&gt;)</em>, tag::out(FwdIter2)&gt; &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::in(iterator_t&lt;Rng&gt;)</em>, tag::out(FwdIter2)&gt; otherwise. The <em>move</em> algorithm returns the pair of the input iterator <em>last</em> and the output iterator to the element in the destination range, one past the last element moved. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-container-algorithms-copy-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/container_algorithms/copy.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-container-algorithms-copy-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v14copyERR8ExPolicyRR3Rng7OutIter">
<span id="_CPPv2N3hpx8parallel2v14copyERR8ExPolicyRR3Rng7OutIter"></span><span id="hpx::parallel::v1::copy__ExPolicyRR.RngRR.OutIter"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> OutIter&gt;<br /><span class="target" id="container__algorithms_2copy_8hpp_1ad06d25e626d92aa1ac5b1d1b7c698fb0"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::in<span class="sig-paren">(</span><em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_traits&lt;Rng&gt;::iterator_type<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>OutIter<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">copy</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, OutIter <em>dest</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v14copyERR8ExPolicyRR3Rng7OutIter" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the elements in the range <em>rng</em> to another range beginning at <em>dest</em>.</p>
<p><p>The assignments in the parallel </p>
<em>copy</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly std::distance(begin(rng), end(rng)) assignments.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">OutIter</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an output iterator.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>copy</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>copy</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::in(iterator_t&lt;Rng&gt;)</em>, tag::out(FwdIter2)&gt; &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::in(iterator_t&lt;Rng&gt;)</em>, tag::out(FwdIter2)&gt; otherwise. The <em>copy</em> algorithm returns the pair of the input iterator <em>last</em> and the output iterator to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v17copy_ifERR8ExPolicyRR3Rng7OutIterRR1FRR4Proj">
<span id="_CPPv2N3hpx8parallel2v17copy_ifERR8ExPolicyRR3Rng7OutIterRR1FRR4Proj"></span><span id="hpx::parallel::v1::copy_if__ExPolicyRR.RngRR.OutIter.FRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> OutIter, <em class="property">typename</em> F, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="container__algorithms_2copy_8hpp_1ad9486190129a9536caf95b28e22331e7"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::in<span class="sig-paren">(</span><em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_traits&lt;Rng&gt;::iterator_type<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>OutIter<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">copy_if</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, OutIter <em>dest</em>, F &amp;&amp;<em>f</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v17copy_ifERR8ExPolicyRR3Rng7OutIterRR1FRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the elements in the range <em>rng</em> to another range beginning at <em>dest</em>. Copies only the elements for which the predicate <em>f</em> returns true. The order of the elements that are not removed is preserved.</p>
<p><p>The assignments in the parallel </p>
<em>copy_if</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs not more than std::distance(begin(rng), end(rng)) assignments, exactly std::distance(begin(rng), end(rng)) applications of the predicate <em>f</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">OutIter</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an output iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>copy_if</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is an unary predicate which returns <em>true</em> for the required elements. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>InIter</em> can be dereferenced and then implicitly converted to Type. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>copy_if</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>copy_if</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::in(iterator_t&lt;Rng&gt;)</em>, tag::out(FwdIter2)&gt; &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::in(iterator_t&lt;Rng&gt;)</em>, tag::out(FwdIter2)&gt; otherwise. The <em>copy_if</em> algorithm returns the pair of the input iterator <em>last</em> and the output iterator to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-container-algorithms-generate-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/container_algorithms/generate.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-container-algorithms-generate-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v18generateERR8ExPolicyRR3RngRR1F">
<span id="_CPPv2N3hpx8parallel2v18generateERR8ExPolicyRR3RngRR1F"></span><span id="hpx::parallel::v1::generate__ExPolicyRR.RngRR.FRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> F&gt;<br /><span class="target" id="container__algorithms_2generate_8hpp_1a1eaf1b5b05ae144624622da6d653a07d"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng&gt;::type&gt;::type <code class="descname">generate</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, F &amp;&amp;<em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v18generateERR8ExPolicyRR3RngRR1F" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assign each element in range [first, last) a value generated by the given function object f</p>
<p><p>The assignments in the parallel </p>
<em>generate</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Exactly <em>distance(first, last)</em> invocations of <em>f</em> and assignments.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>equal</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: generator function that will be called. signature of function should be equivalent to the following: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ret</span> <span class="nf">fun</span><span class="p">();</span>
</pre></div>
</div>
 <p> The type </p>
<em>Ret</em> must be such that an object of type <em>FwdIter</em> can be dereferenced and assigned a value of type <em>Ret</em>.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>generate</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>replace_if</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter</em> otherwise. It returns <em>last</em>. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-container-algorithms-is-heap-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/container_algorithms/is_heap.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-container-algorithms-is-heap-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v17is_heapERR8ExPolicyRR3RngRR4CompRR4Proj">
<span id="_CPPv2N3hpx8parallel2v17is_heapERR8ExPolicyRR3RngRR4CompRR4Proj"></span><span id="hpx::parallel::v1::is_heap__ExPolicyRR.RngRR.CompRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> Comp = detail::less, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="container__algorithms_2is__heap_8hpp_1aba109aa6f95bc25e3613e87749385d1a"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, bool&gt;::type <code class="descname">is_heap</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, Comp &amp;&amp;<em>comp</em> = Comp(), Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v17is_heapERR8ExPolicyRR3RngRR4CompRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns whether the range is max heap. That is, true if the range is max heap, false otherwise. The function uses the given comparison function object <em>comp</em> (defaults to using operator&lt;()).</p>
<p><em>comp</em> has to induce a strict weak ordering on the values.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs at most N applications of the comparison <em>comp</em>, at most 2 * N applications of the projection <em>proj</em>, where N = last - first.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an random access iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Comp</span></code>: The type of the function/function object to use (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">comp</span></code>: <em>comp</em> is a callable object. The return value of the INVOKE operation applied to an object of type <em>Comp</em>, when contextually converted to bool, yields true if the first argument of the call is less than the second, and false otherwise. It is assumed that comp will not apply any non-constant function through the dereferenced iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>is_heap</em> algorithm returns a <em>hpx::future&lt;bool&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>bool</em> otherwise. The <em>is_heap</em> algorithm returns whether the range is max heap. That is, true if the range is max heap, false otherwise. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v113is_heap_untilERR8ExPolicyRR3RngRR4CompRR4Proj">
<span id="_CPPv2N3hpx8parallel2v113is_heap_untilERR8ExPolicyRR3RngRR4CompRR4Proj"></span><span id="hpx::parallel::v1::is_heap_until__ExPolicyRR.RngRR.CompRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> Comp = detail::less, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="container__algorithms_2is__heap_8hpp_1a2d4300e23912baf99c439fc62ba34180"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng&gt;::type&gt;::type <code class="descname">is_heap_until</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, Comp &amp;&amp;<em>comp</em> = Comp(), Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v113is_heap_untilERR8ExPolicyRR3RngRR4CompRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the upper bound of the largest range beginning at <em>first</em> which is a max heap. That is, the last iterator <em>it</em> for which range [first, it) is a max heap. The function uses the given comparison function object <em>comp</em> (defaults to using operator&lt;()).</p>
<p><em>comp</em> has to induce a strict weak ordering on the values.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs at most N applications of the comparison <em>comp</em>, at most 2 * N applications of the projection <em>proj</em>, where N = last - first.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an random access iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Comp</span></code>: The type of the function/function object to use (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">comp</span></code>: <em>comp</em> is a callable object. The return value of the INVOKE operation applied to an object of type <em>Comp</em>, when contextually converted to bool, yields true if the first argument of the call is less than the second, and false otherwise. It is assumed that comp will not apply any non-constant function through the dereferenced iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>is_heap_until</em> algorithm returns a <em>hpx::future&lt;RandIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>RandIter</em> otherwise. The <em>is_heap_until</em> algorithm returns the upper bound of the largest range beginning at first which is a max heap. That is, the last iterator <em>it</em> for which range [first, it) is a max heap. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-container-algorithms-remove-copy-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/container_algorithms/remove_copy.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-container-algorithms-remove-copy-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v111remove_copyERR8ExPolicyRR3Rng7OutIterR1TRR4Proj">
<span id="_CPPv2N3hpx8parallel2v111remove_copyERR8ExPolicyRR3Rng7OutIterR1TRR4Proj"></span><span id="hpx::parallel::v1::remove_copy__ExPolicyRR.RngRR.OutIter.TCR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> OutIter, <em class="property">typename</em> T, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="container__algorithms_2remove__copy_8hpp_1aba02d75c46b9db4bdc3771f27141c6d5"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::in<span class="sig-paren">(</span><em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_traits&lt;Rng&gt;::iterator_type<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>OutIter<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">remove_copy</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, OutIter <em>dest</em>, T <em class="property">const</em> &amp;<em>val</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v111remove_copyERR8ExPolicyRR3Rng7OutIterR1TRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the elements in the range, defined by [first, last), to another range beginning at <em>dest</em>. Copies only the elements for which the comparison operator returns false when compare to val. The order of the elements that are not removed is preserved.</p>
<p>Effects: Copies all the elements referred to by the iterator it in the range [first,last) for which the following corresponding conditions do not hold: INVOKE(proj, *it) == value</p>
<p><p>The assignments in the parallel </p>
<em>remove_copy</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs not more than <em>last</em> - <em>first</em> assignments, exactly <em>last</em> - <em>first</em> applications of the predicate <em>f</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">OutIter</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an output iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type that the result of dereferencing InIter is compared to. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">val</span></code>: Value to be removed. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>remove_copy</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>remove_copy</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::in(InIter), tag::out(OutIter)&gt;</em> &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::in(InIter), tag::out(OutIter)&gt;</em> otherwise. The <em>copy</em> algorithm returns the pair of the input iterator forwarded to the first element after the last in the input sequence and the output iterator to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v114remove_copy_ifERR8ExPolicyRR3Rng7OutIterRR1FRR4Proj">
<span id="_CPPv2N3hpx8parallel2v114remove_copy_ifERR8ExPolicyRR3Rng7OutIterRR1FRR4Proj"></span><span id="hpx::parallel::v1::remove_copy_if__ExPolicyRR.RngRR.OutIter.FRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> OutIter, <em class="property">typename</em> F, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="container__algorithms_2remove__copy_8hpp_1aa94867794fe239d874861ec8c425fef3"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::in<span class="sig-paren">(</span><em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_traits&lt;Rng&gt;::iterator_type<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>OutIter<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">remove_copy_if</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, OutIter <em>dest</em>, F &amp;&amp;<em>f</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v114remove_copy_ifERR8ExPolicyRR3Rng7OutIterRR1FRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the elements in the range, defined by [first, last), to another range beginning at <em>dest</em>. Copies only the elements for which the predicate <em>f</em> returns false. The order of the elements that are not removed is preserved.</p>
<p>Effects: Copies all the elements referred to by the iterator it in the range [first,last) for which the following corresponding conditions do not hold: INVOKE(pred, INVOKE(proj, *it)) != false.</p>
<p><p>The assignments in the parallel </p>
<em>remove_copy_if</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs not more than <em>last</em> - <em>first</em> assignments, exactly <em>last</em> - <em>first</em> applications of the predicate <em>f</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">OutIter</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an output iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>copy_if</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is an unary predicate which returns <em>true</em> for the elements to be removed. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>InIter</em> can be dereferenced and then implicitly converted to Type. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>remove_copy_if</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>remove_copy_if</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::in(InIter), tag::out(OutIter)&gt;</em> &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::in(InIter), tag::out(OutIter)&gt;</em> otherwise. The <em>copy</em> algorithm returns the pair of the input iterator forwarded to the first element after the last in the input sequence and the output iterator to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-container-algorithms-sort-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/container_algorithms/sort.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-container-algorithms-sort-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v14sortERR8ExPolicyRR3RngRR7CompareRR4Proj">
<span id="_CPPv2N3hpx8parallel2v14sortERR8ExPolicyRR3RngRR7CompareRR4Proj"></span><span id="hpx::parallel::v1::sort__ExPolicyRR.RngRR.CompareRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> Proj = util::projection_identity, <em class="property">typename</em> Compare = detail::less&gt;<br /><span class="target" id="container__algorithms_2sort_8hpp_1a94a3d91655d6d4ca150cab78e4be44b5"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng&gt;::type&gt;::type <code class="descname">sort</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, Compare &amp;&amp;<em>comp</em> = Compare(), Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v14sortERR8ExPolicyRR3RngRR7CompareRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Sorts the elements in the range <em>rng</em> in ascending order. The order of equal elements is not guaranteed to be preserved. The function uses the given comparison function object comp (defaults to using operator&lt;()).</p>
<p><p>A sequence is sorted with respect to a comparator </p>
<em>comp</em> and a projection <em>proj</em> if for every iterator i pointing to the sequence and every non-negative integer n such that i + n is a valid iterator pointing to an element of the sequence, and INVOKE(comp, INVOKE(proj, *(i + n)), INVOKE(proj, *i)) == false.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: O(Nlog(N)), where N = std::distance(begin(rng), end(rng)) comparisons.</dd>
</dl>
</p>
<p><em>comp</em> has to induce a strict weak ordering on the values.<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Comp</span></code>: The type of the function/function object to use (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">comp</span></code>: comp is a callable object. The return value of the INVOKE operation applied to an object of type Comp, when contextually converted to bool, yields true if the first argument of the call is less than the second, and false otherwise. It is assumed that comp will not apply any non-constant function through the dereferenced iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each pair of elements as a projection operation before the actual predicate <em>comp</em> is invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>sort</em> algorithm returns a <em>hpx::future&lt;Iter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>Iter</em> otherwise. It returns <em>last</em>. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-container-algorithms-count-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/container_algorithms/count.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-container-algorithms-count-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v15countERR8ExPolicyRR3RngR1TRR4Proj">
<span id="_CPPv2N3hpx8parallel2v15countERR8ExPolicyRR3RngR1TRR4Proj"></span><span id="hpx::parallel::v1::count__ExPolicyRR.RngRR.TCR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> T, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="container__algorithms_2count_8hpp_1a323f64997b0d4f44589e0d0d00b857d2"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::iterator_traits&lt;<em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_traits&lt;Rng&gt;::iterator_type&gt;::difference_type&gt;::type <code class="descname">count</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, T <em class="property">const</em> &amp;<em>value</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v15countERR8ExPolicyRR3RngR1TRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the number of elements in the range [first, last) satisfying a specific criteria. This version counts the elements that are equal to the given <em>value</em>.</p>
<p><p>The comparisons in the parallel </p>
<em>count</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>last</em> - <em>first</em> comparisons.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the comparisons. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the value to search for (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">value</span></code>: The value to search for. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The comparisons in the parallel <em>count</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</dd>
<dt><strong>Return</strong></dt>
<dd>The <em>count</em> algorithm returns a <em>hpx::future&lt;difference_type&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>difference_type</em> otherwise (where <em>difference_type</em> is defined by <em>std::iterator_traits&lt;FwdIter&gt;::difference_type</em>. The <em>count</em> algorithm returns the number of elements satisfying the given criteria. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v18count_ifERR8ExPolicyRR3RngRR1FRR4Proj">
<span id="_CPPv2N3hpx8parallel2v18count_ifERR8ExPolicyRR3RngRR1FRR4Proj"></span><span id="hpx::parallel::v1::count_if__ExPolicyRR.RngRR.FRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> F, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="container__algorithms_2count_8hpp_1a6c3485f88f612a98ec1fb10f4adfc1f5"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::iterator_traits&lt;<em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_traits&lt;Rng&gt;::iterator_type&gt;::difference_type&gt;::type <code class="descname">count_if</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, F &amp;&amp;<em>f</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v18count_ifERR8ExPolicyRR3RngRR1FRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the number of elements in the range [first, last) satisfying a specific criteria. This version counts elements for which predicate <em>f</em> returns true.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>last</em> - <em>first</em> applications of the predicate.</dd>
<dt><strong>Note</strong></dt>
<dd>The assignments in the parallel <em>count_if</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread. </dd>
<dt><strong>Note</strong></dt>
<dd>The assignments in the parallel <em>count_if</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</dd>
<dt><strong>Return</strong></dt>
<dd>The <em>count_if</em> algorithm returns <em>hpx::future&lt;difference_type&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>difference_type</em> otherwise (where <em>difference_type</em> is defined by <em>std::iterator_traits&lt;FwdIter&gt;::difference_type</em>. The <em>count</em> algorithm returns the number of elements satisfying the given criteria. </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the comparisons. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>count_if</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is an unary predicate which returns <em>true</em> for the required elements. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter</em> can be dereferenced and then implicitly converted to Type. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-util-partitioner-with-cleanup-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/util/partitioner_with_cleanup.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-util-partitioner-with-cleanup-hpp" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="include-hpx-parallel-util-transfer-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/util/transfer.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-util-transfer-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt id="_CPPv3N3hpx8parallel4utilE">
<span id="_CPPv2N3hpx8parallel4utilE"></span><span id="hpx::parallel::util"></span><span class="target" id="namespacehpx_1_1parallel_1_1util"></span><em class="property">namespace </em><code class="descname">util</code><a class="headerlink" href="#_CPPv3N3hpx8parallel4utilE" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel4util4copyE6InIter6InIter7OutIter">
<span id="_CPPv2N3hpx8parallel4util4copyE6InIter6InIter7OutIter"></span><span id="hpx::parallel::util::copy__InIter.InIter.OutIter"></span><em class="property">template </em>&lt;<em class="property">typename</em> InIter, <em class="property">typename</em> OutIter&gt;<br /><span class="target" id="transfer_8hpp_1ad69f6bb9f156a8fb6cc16d3b5bfb9e78"></span><a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::pair&lt;InIter, OutIter&gt; <code class="descname">copy</code><span class="sig-paren">(</span>InIter <em>first</em>, InIter <em>last</em>, OutIter <em>dest</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel4util4copyE6InIter6InIter7OutIter" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> InIter, <em class="property">typename</em> OutIter&gt;</dt>
<dt>
<span class="target" id="transfer_8hpp_1a06da13d80744f31fd4ab003231988262"></span><code class="descname">HPX_HOST_DEVICE std::pair&lt;InIter, OutIter&gt; hpx::parallel::util::copy_n(InIter first, std::size_t count, OutIter dest)</code></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel4util16copy_synchronizeER6InIterR7OutIter">
<span id="_CPPv2N3hpx8parallel4util16copy_synchronizeER6InIterR7OutIter"></span><span id="hpx::parallel::util::copy_synchronize__InIterCR.OutIterCR"></span><em class="property">template </em>&lt;<em class="property">typename</em> InIter, <em class="property">typename</em> OutIter&gt;<br /><span class="target" id="transfer_8hpp_1ab52998b9593cc0db1e41e0ce0298fa40"></span>void <code class="descname">copy_synchronize</code><span class="sig-paren">(</span>InIter <em class="property">const</em> &amp;<em>first</em>, OutIter <em class="property">const</em> &amp;<em>dest</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel4util16copy_synchronizeER6InIterR7OutIter" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel4util4moveE6InIter6InIter7OutIter">
<span id="_CPPv2N3hpx8parallel4util4moveE6InIter6InIter7OutIter"></span><span id="hpx::parallel::util::move__InIter.InIter.OutIter"></span><em class="property">template </em>&lt;<em class="property">typename</em> InIter, <em class="property">typename</em> OutIter&gt;<br /><span class="target" id="transfer_8hpp_1a7eda87a35256ecea75cd7f57c0f33159"></span><a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::pair&lt;InIter, OutIter&gt; <code class="descname">move</code><span class="sig-paren">(</span>InIter <em>first</em>, InIter <em>last</em>, OutIter <em>dest</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel4util4moveE6InIter6InIter7OutIter" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel4util6move_nE6InIterNSt6size_tE7OutIter">
<span id="_CPPv2N3hpx8parallel4util6move_nE6InIterNSt6size_tE7OutIter"></span><span id="hpx::parallel::util::move_n__InIter.std::s.OutIter"></span><em class="property">template </em>&lt;<em class="property">typename</em> InIter, <em class="property">typename</em> OutIter&gt;<br /><span class="target" id="transfer_8hpp_1ab00328e830d1e1ae888956cfdc39bd8a"></span><a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::pair&lt;InIter, OutIter&gt; <code class="descname">move_n</code><span class="sig-paren">(</span>InIter <em>first</em>, <a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::size_t <em>count</em>, OutIter <em>dest</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel4util6move_nE6InIterNSt6size_tE7OutIter" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-util-scan-partitioner-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/util/scan_partitioner.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-util-scan-partitioner-hpp" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="include-hpx-parallel-util-projection-identity-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/util/projection_identity.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-util-projection-identity-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt id="_CPPv3N3hpx8parallel4utilE">
<span id="_CPPv2N3hpx8parallel4utilE"></span><span class="target" id="namespacehpx_1_1parallel_1_1util"></span><em class="property">namespace </em><code class="descname">util</code><br /></dt>
<dd><dl class="class">
<dt id="_CPPv3N3hpx8parallel4util19projection_identityE">
<span id="_CPPv2N3hpx8parallel4util19projection_identityE"></span><span id="hpx::parallel::util::projection_identity"></span><span class="target" id="structhpx_1_1parallel_1_1util_1_1projection__identity"></span><em class="property">struct </em><code class="descname">projection_identity</code><a class="headerlink" href="#_CPPv3N3hpx8parallel4util19projection_identityE" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> T&gt;</dt>
<dt>
<span class="target" id="structhpx_1_1parallel_1_1util_1_1projection__identity_1af65efd8a5629886dd5086f6b33c1f1de"></span><code class="descname">HPX_HOST_DEVICE T&amp;&amp; hpx::parallel::util::projection_identity::operator()(T &amp;&amp; val) const</code></dt>
<dd></dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-util-invoke-projected-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/util/invoke_projected.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-util-invoke-projected-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt id="_CPPv3N3hpx8parallel4utilE">
<span class="target" id="namespacehpx_1_1parallel_1_1util"></span><em class="property">namespace </em><code class="descname">util</code><br /></dt>
<dd><dl class="class">
<dt id="_CPPv3N3hpx8parallel4util16invoke_projectedE">
<span id="_CPPv2N3hpx8parallel4util16invoke_projectedE"></span><span id="hpx::parallel::util::invoke_projected"></span><span class="target" id="structhpx_1_1parallel_1_1util_1_1invoke__projected"></span><em class="property">template </em>&lt;<em class="property">typename</em> Pred, <em class="property">typename</em> Proj&gt;<br /><em class="property">struct </em><code class="descname">invoke_projected</code><a class="headerlink" href="#_CPPv3N3hpx8parallel4util16invoke_projectedE" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="type">
<dt id="_CPPv3N3hpx8parallel4util16invoke_projected9pred_typeE">
<span id="_CPPv2N3hpx8parallel4util16invoke_projected9pred_typeE"></span><span id="hpx::parallel::util::invoke_projected::pred_type"></span><span class="target" id="structhpx_1_1parallel_1_1util_1_1invoke__projected_1a3afff39636a2ab1c39ba7d4e5e8fd5f2"></span><em class="property">typedef </em><a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::decay&lt;Pred&gt;::type <code class="descname">pred_type</code><a class="headerlink" href="#_CPPv3N3hpx8parallel4util16invoke_projected9pred_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx8parallel4util16invoke_projected9proj_typeE">
<span id="_CPPv2N3hpx8parallel4util16invoke_projected9proj_typeE"></span><span id="hpx::parallel::util::invoke_projected::proj_type"></span><span class="target" id="structhpx_1_1parallel_1_1util_1_1invoke__projected_1a9193b6ba3a874d0645c9849142cec63f"></span><em class="property">typedef </em><a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::decay&lt;Proj&gt;::type <code class="descname">proj_type</code><a class="headerlink" href="#_CPPv3N3hpx8parallel4util16invoke_projected9proj_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel4util16invoke_projected16invoke_projectedERR5Pred_RR5Proj_">
<span id="_CPPv2N3hpx8parallel4util16invoke_projected16invoke_projectedERR5Pred_RR5Proj_"></span><span id="hpx::parallel::util::invoke_projected::invoke_projected__Pred_RR.Proj_RR"></span><em class="property">template </em>&lt;<em class="property">typename</em> Pred_, <em class="property">typename</em> Proj_&gt;<br /><span class="target" id="structhpx_1_1parallel_1_1util_1_1invoke__projected_1af0466bc0f9577b75fe891041adf1963d"></span><code class="descname">invoke_projected</code><span class="sig-paren">(</span>Pred_ &amp;&amp;<em>pred</em>, Proj_ &amp;&amp;<em>proj</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel4util16invoke_projected16invoke_projectedERR5Pred_RR5Proj_" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel4util16invoke_projectedclERR1T">
<span id="_CPPv2N3hpx8parallel4util16invoke_projectedclERR1T"></span><span id="hpx::parallel::util::invoke_projected::call-operator__TRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> T&gt;<br /><span class="target" id="structhpx_1_1parallel_1_1util_1_1invoke__projected_1a7ddda4093b802f4fd01eeaa0c9ff2038"></span>auto <code class="descname">operator()</code><span class="sig-paren">(</span>T &amp;&amp;<em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel4util16invoke_projectedclERR1T" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Members</p>
<dl class="member">
<dt id="_CPPv3N3hpx8parallel4util16invoke_projected5pred_E">
<span id="_CPPv2N3hpx8parallel4util16invoke_projected5pred_E"></span><span id="hpx::parallel::util::invoke_projected::pred___pred_type"></span><span class="target" id="structhpx_1_1parallel_1_1util_1_1invoke__projected_1a8ec57e7601806576fe0636f4fc5e5613"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4util16invoke_projected9pred_typeE" title="hpx::parallel::util::invoke_projected::pred_type">pred_type</a> <code class="descname">pred_</code><a class="headerlink" href="#_CPPv3N3hpx8parallel4util16invoke_projected5pred_E" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv3N3hpx8parallel4util16invoke_projected5proj_E">
<span id="_CPPv2N3hpx8parallel4util16invoke_projected5proj_E"></span><span id="hpx::parallel::util::invoke_projected::proj___proj_type"></span><span class="target" id="structhpx_1_1parallel_1_1util_1_1invoke__projected_1ade312e8e1f4ae9b3db2a74bd34f2646c"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4util16invoke_projected9proj_typeE" title="hpx::parallel::util::invoke_projected::proj_type">proj_type</a> <code class="descname">proj_</code><a class="headerlink" href="#_CPPv3N3hpx8parallel4util16invoke_projected5proj_E" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-util-cancellation-token-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/util/cancellation_token.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-util-cancellation-token-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1util"></span><em class="property">namespace </em><code class="descname">util</code><br /></dt>
<dd><dl class="class">
<dt id="_CPPv3N3hpx8parallel4util18cancellation_tokenE">
<span id="_CPPv2N3hpx8parallel4util18cancellation_tokenE"></span><span id="hpx::parallel::util::cancellation_token"></span><span class="target" id="classhpx_1_1parallel_1_1util_1_1cancellation__token"></span><em class="property">template </em>&lt;typename <em>T</em> = detail::no_data, typename <em>Pred</em> = std::less_equal&lt;T&gt;&gt;<br /><em class="property">class </em><code class="descname">cancellation_token</code><a class="headerlink" href="#_CPPv3N3hpx8parallel4util18cancellation_tokenE" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel4util18cancellation_token18cancellation_tokenE1T">
<span id="_CPPv2N3hpx8parallel4util18cancellation_token18cancellation_tokenE1T"></span><span id="hpx::parallel::util::cancellation_token::cancellation_token__T"></span><span class="target" id="classhpx_1_1parallel_1_1util_1_1cancellation__token_1a5be3aa31eda38adad07dc94621266a94"></span><code class="descname">cancellation_token</code><span class="sig-paren">(</span>T <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel4util18cancellation_token18cancellation_tokenE1T" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx8parallel4util18cancellation_token13was_cancelledE1T">
<span id="_CPPv2NK3hpx8parallel4util18cancellation_token13was_cancelledE1T"></span><span id="hpx::parallel::util::cancellation_token::was_cancelled__TC"></span><span class="target" id="classhpx_1_1parallel_1_1util_1_1cancellation__token_1af8f983a164f838f10d5a6f9b795fd266"></span>bool <code class="descname">was_cancelled</code><span class="sig-paren">(</span>T <em>data</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8parallel4util18cancellation_token13was_cancelledE1T" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel4util18cancellation_token6cancelE1T">
<span id="_CPPv2N3hpx8parallel4util18cancellation_token6cancelE1T"></span><span id="hpx::parallel::util::cancellation_token::cancel__T"></span><span class="target" id="classhpx_1_1parallel_1_1util_1_1cancellation__token_1a7c04c9ed73eaa872cfd6b72b52922796"></span>void <code class="descname">cancel</code><span class="sig-paren">(</span>T <em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel4util18cancellation_token6cancelE1T" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx8parallel4util18cancellation_token8get_dataEv">
<span id="_CPPv2NK3hpx8parallel4util18cancellation_token8get_dataEv"></span><span id="hpx::parallel::util::cancellation_token::get_dataC"></span><span class="target" id="classhpx_1_1parallel_1_1util_1_1cancellation__token_1a63ec3c9e5287d23c9e9d4ce1777e49d2"></span>T <code class="descname">get_data</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8parallel4util18cancellation_token8get_dataEv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Types</p>
<dl class="type">
<dt id="_CPPv3N3hpx8parallel4util18cancellation_token9flag_typeE">
<span id="_CPPv2N3hpx8parallel4util18cancellation_token9flag_typeE"></span><span id="hpx::parallel::util::cancellation_token::flag_type"></span><span class="target" id="classhpx_1_1parallel_1_1util_1_1cancellation__token_1a7b2d76d85f59f06834b84899593d973d"></span><em class="property">typedef </em><a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::atomic&lt;T&gt; <code class="descname">flag_type</code><a class="headerlink" href="#_CPPv3N3hpx8parallel4util18cancellation_token9flag_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Members</p>
<dl class="member">
<dt id="_CPPv3N3hpx8parallel4util18cancellation_token14was_cancelled_E">
<span id="_CPPv2N3hpx8parallel4util18cancellation_token14was_cancelled_E"></span><span id="hpx::parallel::util::cancellation_token::was_cancelled___std::shared_ptr:flag_type:"></span><span class="target" id="classhpx_1_1parallel_1_1util_1_1cancellation__token_1a04d80c8ce540692e636217a6aad78228"></span><a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::shared_ptr&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel4util18cancellation_token9flag_typeE" title="hpx::parallel::util::cancellation_token::flag_type">flag_type</a>&gt; <code class="descname">was_cancelled_</code><a class="headerlink" href="#_CPPv3N3hpx8parallel4util18cancellation_token14was_cancelled_E" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-util-foreach-partitioner-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/util/foreach_partitioner.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-util-foreach-partitioner-hpp" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="include-hpx-parallel-util-loop-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/util/loop.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-util-loop-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1util"></span><em class="property">namespace </em><code class="descname">util</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> VecOnly, <em class="property">typename</em> F, typename… <em>Iters</em>&gt;</dt>
<dt>
<span class="target" id="util_2loop_8hpp_1a5335d0f3bd5bf2a3747de3d1eb7a76f4"></span><code class="descname">HPX_HOST_DEVICE std::enable_if&lt; !execution::is_vectorpack_execution_policy&lt;ExPolicy&gt;::value, typename hpx::util::invoke_result&lt;F, Iters...&gt;::type&gt;::type hpx::parallel::util::loop_step(VecOnly, F &amp;&amp; f, Iters &amp;... its)</code></dt>
<dd></dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Iter&gt;</dt>
<dt>
<span class="target" id="util_2loop_8hpp_1acb4cd2ebcfc5a54eb1b7971ce5e6709a"></span><code class="descname">HPX_HOST_DEVICE std::enable_if&lt; !execution::is_vectorpack_execution_policy&lt;ExPolicy&gt;::value, bool&gt;::type hpx::parallel::util::loop_optimization(Iter, Iter)</code></dt>
<dd></dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Begin, <em class="property">typename</em> End, <em class="property">typename</em> F&gt;</dt>
<dt>
<span class="target" id="util_2loop_8hpp_1a1be66512c62f73660d17fcc47011e959"></span><code class="descname">HPX_HOST_DEVICE Begin hpx::parallel::util::loop(ExPolicy &amp;&amp;, Begin begin, End end, F &amp;&amp; f)</code></dt>
<dd></dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Begin, <em class="property">typename</em> End, <em class="property">typename</em> CancelToken, <em class="property">typename</em> F&gt;</dt>
<dt>
<span class="target" id="util_2loop_8hpp_1a9b54875076230e886ec44c6032855171"></span><code class="descname">HPX_HOST_DEVICE Begin hpx::parallel::util::loop(ExPolicy &amp;&amp;, Begin begin, End end, CancelToken &amp; tok, F &amp;&amp; f)</code></dt>
<dd></dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> VecOnly, <em class="property">typename</em> Begin1, <em class="property">typename</em> End1, <em class="property">typename</em> Begin2, <em class="property">typename</em> F&gt;</dt>
<dt>
<span class="target" id="util_2loop_8hpp_1ac151d16af4bb11364399680414630859"></span><code class="descname">HPX_HOST_DEVICE std::enable_if&lt; !execution::is_vectorpack_execution_policy&lt;ExPolicy&gt;::value, std::pair&lt;Begin1, Begin2&gt; &gt;::type hpx::parallel::util::loop2(VecOnly, Begin1 begin1, End1 end1, Begin2 begin2, F &amp;&amp; f)</code></dt>
<dd></dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Iter, <em class="property">typename</em> F&gt;</dt>
<dt>
<span class="target" id="util_2loop_8hpp_1a50a255d98bb22382bfd558de79c6fb44"></span><code class="descname">HPX_HOST_DEVICE std::enable_if&lt; !execution::is_vectorpack_execution_policy&lt;ExPolicy&gt;::value, Iter&gt;::type hpx::parallel::util::loop_n(Iter it, std::size_t count, F &amp;&amp; f)</code></dt>
<dd></dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Iter, <em class="property">typename</em> CancelToken, <em class="property">typename</em> F&gt;</dt>
<dt>
<span class="target" id="util_2loop_8hpp_1a7acdc83d91a486b8fdbcd99c10ab1bbd"></span><code class="descname">HPX_HOST_DEVICE std::enable_if&lt; !execution::is_vectorpack_execution_policy&lt;ExPolicy&gt;::value, Iter&gt;::type hpx::parallel::util::loop_n(Iter it, std::size_t count, CancelToken &amp; tok, F &amp;&amp; f)</code></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel4util17loop_with_cleanupE4Iter4IterRR1FRR7Cleanup">
<span id="_CPPv2N3hpx8parallel4util17loop_with_cleanupE4Iter4IterRR1FRR7Cleanup"></span><span id="hpx::parallel::util::loop_with_cleanup__Iter.Iter.FRR.CleanupRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> Iter, <em class="property">typename</em> F, <em class="property">typename</em> Cleanup&gt;<br /><span class="target" id="util_2loop_8hpp_1a8f281ce2e47a7fbaec26cd2b18149bce"></span>Iter <code class="descname">loop_with_cleanup</code><span class="sig-paren">(</span>Iter <em>it</em>, Iter <em>last</em>, F &amp;&amp;<em>f</em>, Cleanup &amp;&amp;<em>cleanup</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel4util17loop_with_cleanupE4Iter4IterRR1FRR7Cleanup" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel4util17loop_with_cleanupE4Iter4Iter7FwdIterRR1FRR7Cleanup">
<span id="_CPPv2N3hpx8parallel4util17loop_with_cleanupE4Iter4Iter7FwdIterRR1FRR7Cleanup"></span><span id="hpx::parallel::util::loop_with_cleanup__Iter.Iter.FwdIter.FRR.CleanupRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> Iter, <em class="property">typename</em> FwdIter, <em class="property">typename</em> F, <em class="property">typename</em> Cleanup&gt;<br /><span class="target" id="util_2loop_8hpp_1ad194c54b79cb6d055466f55565345849"></span>FwdIter <code class="descname">loop_with_cleanup</code><span class="sig-paren">(</span>Iter <em>it</em>, Iter <em>last</em>, FwdIter <em>dest</em>, F &amp;&amp;<em>f</em>, Cleanup &amp;&amp;<em>cleanup</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel4util17loop_with_cleanupE4Iter4Iter7FwdIterRR1FRR7Cleanup" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel4util19loop_with_cleanup_nE4IterNSt6size_tERR1FRR7Cleanup">
<span id="_CPPv2N3hpx8parallel4util19loop_with_cleanup_nE4IterNSt6size_tERR1FRR7Cleanup"></span><span id="hpx::parallel::util::loop_with_cleanup_n__Iter.std::s.FRR.CleanupRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> Iter, <em class="property">typename</em> F, <em class="property">typename</em> Cleanup&gt;<br /><span class="target" id="util_2loop_8hpp_1a459459833959a6f2c4a7b69f36c1521b"></span>Iter <code class="descname">loop_with_cleanup_n</code><span class="sig-paren">(</span>Iter <em>it</em>, <a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::size_t <em>count</em>, F &amp;&amp;<em>f</em>, Cleanup &amp;&amp;<em>cleanup</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel4util19loop_with_cleanup_nE4IterNSt6size_tERR1FRR7Cleanup" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel4util19loop_with_cleanup_nE4IterNSt6size_tE7FwdIterRR1FRR7Cleanup">
<span id="_CPPv2N3hpx8parallel4util19loop_with_cleanup_nE4IterNSt6size_tE7FwdIterRR1FRR7Cleanup"></span><span id="hpx::parallel::util::loop_with_cleanup_n__Iter.std::s.FwdIter.FRR.CleanupRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> Iter, <em class="property">typename</em> FwdIter, <em class="property">typename</em> F, <em class="property">typename</em> Cleanup&gt;<br /><span class="target" id="util_2loop_8hpp_1ac7b66c80b34f681e133696d57042fe70"></span>FwdIter <code class="descname">loop_with_cleanup_n</code><span class="sig-paren">(</span>Iter <em>it</em>, <a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::size_t <em>count</em>, FwdIter <em>dest</em>, F &amp;&amp;<em>f</em>, Cleanup &amp;&amp;<em>cleanup</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel4util19loop_with_cleanup_nE4IterNSt6size_tE7FwdIterRR1FRR7Cleanup" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel4util30loop_with_cleanup_n_with_tokenE4IterNSt6size_tER11CancelTokenRR1FRR7Cleanup">
<span id="_CPPv2N3hpx8parallel4util30loop_with_cleanup_n_with_tokenE4IterNSt6size_tER11CancelTokenRR1FRR7Cleanup"></span><span id="hpx::parallel::util::loop_with_cleanup_n_with_token__Iter.std::s.CancelTokenR.FRR.CleanupRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> Iter, <em class="property">typename</em> CancelToken, <em class="property">typename</em> F, <em class="property">typename</em> Cleanup&gt;<br /><span class="target" id="util_2loop_8hpp_1adb9c098f0406ad056e7622a7f362506d"></span>Iter <code class="descname">loop_with_cleanup_n_with_token</code><span class="sig-paren">(</span>Iter <em>it</em>, <a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::size_t <em>count</em>, CancelToken &amp;<em>tok</em>, F &amp;&amp;<em>f</em>, Cleanup &amp;&amp;<em>cleanup</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel4util30loop_with_cleanup_n_with_tokenE4IterNSt6size_tER11CancelTokenRR1FRR7Cleanup" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel4util30loop_with_cleanup_n_with_tokenE4IterNSt6size_tE7FwdIterR11CancelTokenRR1FRR7Cleanup">
<span id="_CPPv2N3hpx8parallel4util30loop_with_cleanup_n_with_tokenE4IterNSt6size_tE7FwdIterR11CancelTokenRR1FRR7Cleanup"></span><span id="hpx::parallel::util::loop_with_cleanup_n_with_token__Iter.std::s.FwdIter.CancelTokenR.FRR.CleanupRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> Iter, <em class="property">typename</em> FwdIter, <em class="property">typename</em> CancelToken, <em class="property">typename</em> F, <em class="property">typename</em> Cleanup&gt;<br /><span class="target" id="util_2loop_8hpp_1a62f100fbec38199c82eb65ad7a04749b"></span>FwdIter <code class="descname">loop_with_cleanup_n_with_token</code><span class="sig-paren">(</span>Iter <em>it</em>, <a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::size_t <em>count</em>, FwdIter <em>dest</em>, CancelToken &amp;<em>tok</em>, F &amp;&amp;<em>f</em>, Cleanup &amp;&amp;<em>cleanup</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel4util30loop_with_cleanup_n_with_tokenE4IterNSt6size_tE7FwdIterR11CancelTokenRR1FRR7Cleanup" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel4util10loop_idx_nENSt6size_tE4IterNSt6size_tERR1F">
<span id="_CPPv2N3hpx8parallel4util10loop_idx_nENSt6size_tE4IterNSt6size_tERR1F"></span><span id="hpx::parallel::util::loop_idx_n__std::s.Iter.std::s.FRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> Iter, <em class="property">typename</em> F&gt;<br /><span class="target" id="util_2loop_8hpp_1a1a2bf0faa87b1fc8b6ba004d5f508036"></span>Iter <code class="descname">loop_idx_n</code><span class="sig-paren">(</span><a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::size_t <em>base_idx</em>, Iter <em>it</em>, <a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::size_t <em>count</em>, F &amp;&amp;<em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel4util10loop_idx_nENSt6size_tE4IterNSt6size_tERR1F" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel4util10loop_idx_nENSt6size_tE4IterNSt6size_tER11CancelTokenRR1F">
<span id="_CPPv2N3hpx8parallel4util10loop_idx_nENSt6size_tE4IterNSt6size_tER11CancelTokenRR1F"></span><span id="hpx::parallel::util::loop_idx_n__std::s.Iter.std::s.CancelTokenR.FRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> Iter, <em class="property">typename</em> CancelToken, <em class="property">typename</em> F&gt;<br /><span class="target" id="util_2loop_8hpp_1a53ec6b1dd767329dda8b5c8a2c8c9cdf"></span>Iter <code class="descname">loop_idx_n</code><span class="sig-paren">(</span><a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::size_t <em>base_idx</em>, Iter <em>it</em>, <a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::size_t <em>count</em>, CancelToken &amp;<em>tok</em>, F &amp;&amp;<em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel4util10loop_idx_nENSt6size_tE4IterNSt6size_tER11CancelTokenRR1F" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel4util12accumulate_nE4IterNSt6size_tE1TRR4Pred">
<span id="_CPPv2N3hpx8parallel4util12accumulate_nE4IterNSt6size_tE1TRR4Pred"></span><span id="hpx::parallel::util::accumulate_n__Iter.std::s.T.PredRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> Iter, <em class="property">typename</em> T, <em class="property">typename</em> Pred&gt;<br /><span class="target" id="util_2loop_8hpp_1a97a6e181bdf0367165a7dc3162ee423e"></span>T <code class="descname">accumulate_n</code><span class="sig-paren">(</span>Iter <em>it</em>, <a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::size_t <em>count</em>, T <em>init</em>, Pred &amp;&amp;<em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel4util12accumulate_nE4IterNSt6size_tE1TRR4Pred" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel4util10accumulateE4Iter4IterRR6ReduceRR4Conv">
<span id="_CPPv2N3hpx8parallel4util10accumulateE4Iter4IterRR6ReduceRR4Conv"></span><span id="hpx::parallel::util::accumulate__Iter.Iter.ReduceRR.ConvRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> T, <em class="property">typename</em> Iter, <em class="property">typename</em> Reduce, <em class="property">typename</em> Conv = util::projection_identity&gt;<br /><span class="target" id="util_2loop_8hpp_1ac7a4bcba305b04e79c5c1b5403dac7d4"></span>T <code class="descname">accumulate</code><span class="sig-paren">(</span>Iter <em>first</em>, Iter <em>last</em>, Reduce &amp;&amp;<em>r</em>, Conv &amp;&amp;<em>conv</em> = Conv()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel4util10accumulateE4Iter4IterRR6ReduceRR4Conv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel4util10accumulateE5Iter15Iter15Iter2RR6ReduceRR4Conv">
<span id="_CPPv2N3hpx8parallel4util10accumulateE5Iter15Iter15Iter2RR6ReduceRR4Conv"></span><span id="hpx::parallel::util::accumulate__Iter1.Iter1.Iter2.ReduceRR.ConvRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> T, <em class="property">typename</em> Iter1, <em class="property">typename</em> Iter2, <em class="property">typename</em> Reduce, <em class="property">typename</em> Conv&gt;<br /><span class="target" id="util_2loop_8hpp_1ac290e8d1cf94291a61586366ee7cf509"></span>T <code class="descname">accumulate</code><span class="sig-paren">(</span>Iter1 <em>first1</em>, Iter1 <em>last1</em>, Iter2 <em>first2</em>, Reduce &amp;&amp;<em>r</em>, Conv &amp;&amp;<em>conv</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel4util10accumulateE5Iter15Iter15Iter2RR6ReduceRR4Conv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-util-prefetching-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/util/prefetching.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-util-prefetching-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1util"></span><em class="property">namespace </em><code class="descname">util</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel4util23make_prefetcher_contextE3Itr3ItrNSt6size_tEDpR2Ts">
<span id="_CPPv2N3hpx8parallel4util23make_prefetcher_contextE3Itr3ItrNSt6size_tEDpR2Ts"></span><span id="hpx::parallel::util::make_prefetcher_context__Itr.Itr.std::s.TsCRDp"></span><em class="property">template </em>&lt;<em class="property">typename</em> Itr, typename... <em>Ts</em>&gt;<br /><span class="target" id="prefetching_8hpp_1accb603d012cdc79d0a128f7e48688c1e"></span>detail::prefetcher_context&lt;Itr, Ts <em class="property">const</em>...&gt; <code class="descname">make_prefetcher_context</code><span class="sig-paren">(</span>Itr <em>base_begin</em>, Itr <em>base_end</em>, <a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::size_t <em>p_factor</em>, Ts <em class="property">const</em>&amp;... <em>rngs</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel4util23make_prefetcher_contextE3Itr3ItrNSt6size_tEDpR2Ts" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-util-partitioner-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/util/partitioner.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-util-partitioner-hpp" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="include-hpx-parallel-util-zip-iterator-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/util/zip_iterator.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-util-zip-iterator-hpp" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="include-hpx-parallel-util-compare-projected-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/util/compare_projected.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-util-compare-projected-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1util"></span><em class="property">namespace </em><code class="descname">util</code><br /></dt>
<dd><dl class="class">
<dt id="_CPPv3IEN3hpx8parallel4util17compare_projectedI7Compare4ProjEE">
<span id="_CPPv2IEN3hpx8parallel4util17compare_projectedI7Compare4ProjEE"></span><span class="target" id="structhpx_1_1parallel_1_1util_1_1compare__projected_3_01_compare_00_01_proj_01_4"></span><em class="property">template </em>&lt;<em class="property">typename</em> Compare, <em class="property">typename</em> Proj&gt;<br />template&lt;&gt;<br /><em class="property">struct </em><code class="descname">compare_projected</code>&lt;Compare, Proj&gt;<a class="headerlink" href="#_CPPv3IEN3hpx8parallel4util17compare_projectedI7Compare4ProjEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel4util17compare_projected17compare_projectedERR8Compare_RR5Proj_">
<span id="_CPPv2N3hpx8parallel4util17compare_projected17compare_projectedERR8Compare_RR5Proj_"></span><span id="hpx::parallel::util::compare_projected::compare_projected__Compare_RR.Proj_RR"></span><em class="property">template </em>&lt;<em class="property">typename</em> Compare_, <em class="property">typename</em> Proj_&gt;<br /><span class="target" id="structhpx_1_1parallel_1_1util_1_1compare__projected_3_01_compare_00_01_proj_01_4_1a2a55bcc2ae1a354ea0791e1ecbd58fdf"></span><code class="descname">compare_projected</code><span class="sig-paren">(</span>Compare_ &amp;&amp;<em>comp</em>, Proj_ &amp;&amp;<em>proj</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel4util17compare_projected17compare_projectedERR8Compare_RR5Proj_" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx8parallel4util17compare_projectedclERR2T1RR2T2">
<span id="_CPPv2NK3hpx8parallel4util17compare_projectedclERR2T1RR2T2"></span><span id="hpx::parallel::util::compare_projected::call-operator__T1RR.T2RRC"></span><em class="property">template </em>&lt;<em class="property">typename</em> T1, <em class="property">typename</em> T2&gt;<br /><span class="target" id="structhpx_1_1parallel_1_1util_1_1compare__projected_3_01_compare_00_01_proj_01_4_1adbea051f54c847c9bdc7c0953064ea0b"></span>bool <code class="descname">operator()</code><span class="sig-paren">(</span>T1 &amp;&amp;<em>t1</em>, T2 &amp;&amp;<em>t2</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8parallel4util17compare_projectedclERR2T1RR2T2" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Members</p>
<dl class="member">
<dt id="_CPPv3N3hpx8parallel4util17compare_projected5comp_E">
<span id="_CPPv2N3hpx8parallel4util17compare_projected5comp_E"></span><span id="hpx::parallel::util::compare_projected::comp___Compare"></span><span class="target" id="structhpx_1_1parallel_1_1util_1_1compare__projected_3_01_compare_00_01_proj_01_4_1ae7bbd9b6944231b9904646d8ac72b38f"></span>Compare <code class="descname">comp_</code><a class="headerlink" href="#_CPPv3N3hpx8parallel4util17compare_projected5comp_E" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv3N3hpx8parallel4util17compare_projected5proj_E">
<span id="_CPPv2N3hpx8parallel4util17compare_projected5proj_E"></span><span id="hpx::parallel::util::compare_projected::proj___Proj"></span><span class="target" id="structhpx_1_1parallel_1_1util_1_1compare__projected_3_01_compare_00_01_proj_01_4_1a512a98f8925beefb8665e6e04a136186"></span>Proj <code class="descname">proj_</code><a class="headerlink" href="#_CPPv3N3hpx8parallel4util17compare_projected5proj_E" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv3IEN3hpx8parallel4util17compare_projectedI7Compare5Proj15Proj2EE">
<span id="_CPPv2IEN3hpx8parallel4util17compare_projectedI7Compare5Proj15Proj2EE"></span><span class="target" id="structhpx_1_1parallel_1_1util_1_1compare__projected_3_01_compare_00_01_proj1_00_01_proj2_01_4"></span><em class="property">template </em>&lt;<em class="property">typename</em> Compare, <em class="property">typename</em> Proj1, <em class="property">typename</em> Proj2&gt;<br />template&lt;&gt;<br /><em class="property">struct </em><code class="descname">compare_projected</code>&lt;Compare, Proj1, Proj2&gt;<a class="headerlink" href="#_CPPv3IEN3hpx8parallel4util17compare_projectedI7Compare5Proj15Proj2EE" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel4util17compare_projected17compare_projectedERR8Compare_RR6Proj1_RR6Proj2_">
<span id="_CPPv2N3hpx8parallel4util17compare_projected17compare_projectedERR8Compare_RR6Proj1_RR6Proj2_"></span><span id="hpx::parallel::util::compare_projected::compare_projected__Compare_RR.Proj1_RR.Proj2_RR"></span><em class="property">template </em>&lt;<em class="property">typename</em> Compare_, <em class="property">typename</em> Proj1_, <em class="property">typename</em> Proj2_&gt;<br /><span class="target" id="structhpx_1_1parallel_1_1util_1_1compare__projected_3_01_compare_00_01_proj1_00_01_proj2_01_4_1aebe9b09e27ef732226989876760d0efb"></span><code class="descname">compare_projected</code><span class="sig-paren">(</span>Compare_ &amp;&amp;<em>comp</em>, Proj1_ &amp;&amp;<em>proj1</em>, Proj2_ &amp;&amp;<em>proj2</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel4util17compare_projected17compare_projectedERR8Compare_RR6Proj1_RR6Proj2_" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx8parallel4util17compare_projectedclERR2T1RR2T2">
<span id="_CPPv2NK3hpx8parallel4util17compare_projectedclERR2T1RR2T2"></span><em class="property">template </em>&lt;<em class="property">typename</em> T1, <em class="property">typename</em> T2&gt;<br /><span class="target" id="structhpx_1_1parallel_1_1util_1_1compare__projected_3_01_compare_00_01_proj1_00_01_proj2_01_4_1a03894b975248f0fa26b923a55fe3970b"></span>bool <code class="descname">operator()</code><span class="sig-paren">(</span>T1 &amp;&amp;<em>t1</em>, T2 &amp;&amp;<em>t2</em><span class="sig-paren">)</span> <em class="property">const</em><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Members</p>
<dl class="member">
<dt id="_CPPv3N3hpx8parallel4util17compare_projected5comp_E">
<span id="_CPPv2N3hpx8parallel4util17compare_projected5comp_E"></span><span class="target" id="structhpx_1_1parallel_1_1util_1_1compare__projected_3_01_compare_00_01_proj1_00_01_proj2_01_4_1adadd02bcc8c500d302fa4dd1c1dc1595"></span>Compare <code class="descname">comp_</code><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv3N3hpx8parallel4util17compare_projected6proj1_E">
<span id="_CPPv2N3hpx8parallel4util17compare_projected6proj1_E"></span><span id="hpx::parallel::util::compare_projected::proj1___Proj1"></span><span class="target" id="structhpx_1_1parallel_1_1util_1_1compare__projected_3_01_compare_00_01_proj1_00_01_proj2_01_4_1a715754f636f94fce3865b6af2203eb10"></span>Proj1 <code class="descname">proj1_</code><a class="headerlink" href="#_CPPv3N3hpx8parallel4util17compare_projected6proj1_E" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv3N3hpx8parallel4util17compare_projected6proj2_E">
<span id="_CPPv2N3hpx8parallel4util17compare_projected6proj2_E"></span><span id="hpx::parallel::util::compare_projected::proj2___Proj2"></span><span class="target" id="structhpx_1_1parallel_1_1util_1_1compare__projected_3_01_compare_00_01_proj1_00_01_proj2_01_4_1ae42badcb9da0ea89ce4a87a64e40f551"></span>Proj2 <code class="descname">proj2_</code><a class="headerlink" href="#_CPPv3N3hpx8parallel4util17compare_projected6proj2_E" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-util-transform-loop-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/util/transform_loop.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-util-transform-loop-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1util"></span><em class="property">namespace </em><code class="descname">util</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Iter, <em class="property">typename</em> OutIter, <em class="property">typename</em> F&gt;</dt>
<dt>
<span class="target" id="util_2transform__loop_8hpp_1a46af9f9a8e9d8c4bd05c969f38e1a693"></span><code class="descname">HPX_HOST_DEVICE std::pair&lt;Iter, OutIter&gt; hpx::parallel::util::transform_loop(ExPolicy &amp;&amp;, Iter it, Iter end, OutIter dest, F &amp;&amp; f)</code></dt>
<dd></dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> InIter1, <em class="property">typename</em> InIter2, <em class="property">typename</em> OutIter, <em class="property">typename</em> F&gt;</dt>
<dt>
<span class="target" id="util_2transform__loop_8hpp_1a69096d1eb55630ba5045d82429a25d13"></span><code class="descname">HPX_HOST_DEVICE std::enable_if&lt; !execution::is_vectorpack_execution_policy&lt;ExPolicy&gt;::value, hpx::util::tuple&lt;InIter1, InIter2, OutIter&gt; &gt;::type hpx::parallel::util::transform_binary_loop(InIter1 first1, InIter1 last1, InIter2 first2, OutIter dest, F &amp;&amp; f)</code></dt>
<dd></dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> InIter1, <em class="property">typename</em> InIter2, <em class="property">typename</em> OutIter, <em class="property">typename</em> F&gt;</dt>
<dt>
<span class="target" id="util_2transform__loop_8hpp_1a90b4b612f181184671ca6fff15f89264"></span><code class="descname">HPX_HOST_DEVICE std::enable_if&lt; !execution::is_vectorpack_execution_policy&lt;ExPolicy&gt;::value, hpx::util::tuple&lt;InIter1, InIter2, OutIter&gt; &gt;::type hpx::parallel::util::transform_binary_loop(InIter1 first1, InIter1 last1, InIter2 first2, InIter2 last2, OutIter dest, F &amp;&amp; f)</code></dt>
<dd></dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Iter, <em class="property">typename</em> OutIter, <em class="property">typename</em> F&gt;</dt>
<dt>
<span class="target" id="util_2transform__loop_8hpp_1a63735f20564a958bacebdf3cf48c35a5"></span><code class="descname">HPX_HOST_DEVICE std::enable_if&lt; !execution::is_vectorpack_execution_policy&lt;ExPolicy&gt;::value, std::pair&lt;Iter, OutIter&gt; &gt;::type hpx::parallel::util::transform_loop_n(Iter it, std::size_t count, OutIter dest, F &amp;&amp; f)</code></dt>
<dd></dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> InIter1, <em class="property">typename</em> InIter2, <em class="property">typename</em> OutIter, <em class="property">typename</em> F&gt;</dt>
<dt>
<span class="target" id="util_2transform__loop_8hpp_1a640edede89f322cc9479b4079c40a3e4"></span><code class="descname">HPX_HOST_DEVICE std::enable_if&lt; !execution::is_vectorpack_execution_policy&lt;ExPolicy&gt;::value, hpx::util::tuple&lt;InIter1, InIter2, OutIter&gt; &gt;::type hpx::parallel::util::transform_binary_loop_n(InIter1 first1, std::size_t count, InIter2 first2, OutIter dest, F &amp;&amp; f)</code></dt>
<dd></dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-reduce-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/reduce.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-reduce-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v16reduceERR8ExPolicy8FwdIterB8FwdIterE1TRR1F">
<span id="_CPPv2N3hpx8parallel2v16reduceERR8ExPolicy8FwdIterB8FwdIterE1TRR1F"></span><span id="hpx::parallel::v1::reduce__ExPolicyRR.FwdIterB.FwdIterE.T.FRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIterB, <em class="property">typename</em> FwdIterE, <em class="property">typename</em> T, <em class="property">typename</em> F&gt;<br /><span class="target" id="reduce_8hpp_1a44baf3cfcc68ff8988c06230550bfe4a"></span><a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::enable_if&lt;<a class="reference internal" href="../compute/api.html#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="../execution/api.html#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, T&gt;::type&gt;::type <code class="descname">reduce</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIterB <em>first</em>, FwdIterE <em>last</em>, T <em>init</em>, F &amp;&amp;<em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v16reduceERR8ExPolicy8FwdIterB8FwdIterE1TRR1F" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns GENERALIZED_SUM(f, init, *first, …, *(first + (last - first) - 1)).</p>
<p><p>The reduce operations in the parallel </p>
<em>reduce</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: O(<em>last</em> - <em>first</em>) applications of the predicate <em>f</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIterB</span></code>: The type of the source begin iterator used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIterE</span></code>: The type of the source end iterator used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>copy_if</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the value to be used as initial (and intermediate) values (deduced).</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). This is a binary predicate. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ret</span> <span class="nf">fun</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;. The types </p>
<em>Type1</em> <em>Ret</em> must be such that an object of type <em>FwdIterB</em> can be dereferenced and then implicitly converted to any of those types. </li>
<li><code class="docutils literal notranslate"><span class="pre">init</span></code>: The initial value for the generalized sum.</li>
</ul>
</dd>
</dl>
</p>
<p>The reduce operations in the parallel <em>copy_if</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><p>The difference between </p>
<em>reduce</em> and <em>accumulate</em> is that the behavior of reduce may be non-deterministic for non-associative or non-commutative binary predicate. <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>reduce</em> algorithm returns a <em>hpx::future&lt;T&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>T</em> otherwise. The <em>reduce</em> algorithm returns the result of the generalized sum over the elements given by the input range [first, last).</dd>
<dt><strong>Note</strong></dt>
<dd>GENERALIZED_SUM(op, a1, …, aN) is defined as follows:<ul class="simple">
<li>a1 when N is 1</li>
<li>op(GENERALIZED_SUM(op, b1, …, bK), GENERALIZED_SUM(op, bM, …, bN)), where:<ul>
<li>b1, …, bN may be any permutation of a1, …, aN and</li>
<li>1 &lt; K+1 = M &lt;= N.</li>
</ul>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v16reduceERR8ExPolicy8FwdIterB8FwdIterE1T">
<span id="_CPPv2N3hpx8parallel2v16reduceERR8ExPolicy8FwdIterB8FwdIterE1T"></span><span id="hpx::parallel::v1::reduce__ExPolicyRR.FwdIterB.FwdIterE.T"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIterB, <em class="property">typename</em> FwdIterE, <em class="property">typename</em> T&gt;<br /><span class="target" id="reduce_8hpp_1a5e2b7bad8bd62b42665046bd970277d6"></span><a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::enable_if&lt;<a class="reference internal" href="../compute/api.html#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="../execution/api.html#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, T&gt;::type&gt;::type <code class="descname">reduce</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIterB <em>first</em>, FwdIterE <em>last</em>, T <em>init</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v16reduceERR8ExPolicy8FwdIterB8FwdIterE1T" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns GENERALIZED_SUM(+, init, *first, …, *(first + (last - first) - 1)).</p>
<p><p>The reduce operations in the parallel </p>
<em>reduce</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: O(<em>last</em> - <em>first</em>) applications of the operator+().</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIterB</span></code>: The type of the source begin iterator used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIterE</span></code>: The type of the source end iterator used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the value to be used as initial (and intermediate) values (deduced).</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">init</span></code>: The initial value for the generalized sum.</li>
</ul>
</dd>
</dl>
</p>
<p>The reduce operations in the parallel <em>copy_if</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><p>The difference between </p>
<em>reduce</em> and <em>accumulate</em> is that the behavior of reduce may be non-deterministic for non-associative or non-commutative binary predicate. <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>reduce</em> algorithm returns a <em>hpx::future&lt;T&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>T</em> otherwise. The <em>reduce</em> algorithm returns the result of the generalized sum (applying operator+()) over the elements given by the input range [first, last).</dd>
<dt><strong>Note</strong></dt>
<dd>GENERALIZED_SUM(+, a1, …, aN) is defined as follows:<ul class="simple">
<li>a1 when N is 1</li>
<li>op(GENERALIZED_SUM(+, b1, …, bK), GENERALIZED_SUM(+, bM, …, bN)), where:<ul>
<li>b1, …, bN may be any permutation of a1, …, aN and</li>
<li>1 &lt; K+1 = M &lt;= N.</li>
</ul>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v16reduceERR8ExPolicy8FwdIterB8FwdIterE">
<span id="_CPPv2N3hpx8parallel2v16reduceERR8ExPolicy8FwdIterB8FwdIterE"></span><span id="hpx::parallel::v1::reduce__ExPolicyRR.FwdIterB.FwdIterE"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIterB, <em class="property">typename</em> FwdIterE&gt;<br /><span class="target" id="reduce_8hpp_1a9f6ecec64a85230340e88a0b7ce7529e"></span><a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::enable_if&lt;<a class="reference internal" href="../compute/api.html#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="../execution/api.html#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::iterator_traits&lt;FwdIterB&gt;::value_type&gt;::type&gt;::type <code class="descname">reduce</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIterB <em>first</em>, FwdIterE <em>last</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v16reduceERR8ExPolicy8FwdIterB8FwdIterE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns GENERALIZED_SUM(+, T(), *first, …, *(first + (last - first) - 1)).</p>
<p><p>The reduce operations in the parallel </p>
<em>reduce</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: O(<em>last</em> - <em>first</em>) applications of the operator+().</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIterB</span></code>: The type of the source begin iterator used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIterE</span></code>: The type of the source end iterator used (deduced). This iterator type must meet the requirements of an forward iterator.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to.</li>
</ul>
</dd>
</dl>
</p>
<p>The reduce operations in the parallel <em>copy_if</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><p>The difference between </p>
<em>reduce</em> and <em>accumulate</em> is that the behavior of reduce may be non-deterministic for non-associative or non-commutative binary predicate. <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>reduce</em> algorithm returns a <em>hpx::future&lt;T&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns T otherwise (where T is the value_type of <em>FwdIterB</em>). The <em>reduce</em> algorithm returns the result of the generalized sum (applying operator+()) over the elements given by the input range [first, last).</dd>
<dt><strong>Note</strong></dt>
<dd>The type of the initial value (and the result type) <em>T</em> is determined from the value_type of the used <em>FwdIterB</em>.</dd>
<dt><strong>Note</strong></dt>
<dd>GENERALIZED_SUM(+, a1, …, aN) is defined as follows:<ul class="simple">
<li>a1 when N is 1</li>
<li>op(GENERALIZED_SUM(+, b1, …, bK), GENERALIZED_SUM(+, bM, …, bN)), where:<ul>
<li>b1, …, bN may be any permutation of a1, …, aN and</li>
<li>1 &lt; K+1 = M &lt;= N.</li>
</ul>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-partition-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/partition.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-partition-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v116stable_partitionERR8ExPolicy9BidirIter9BidirIterRR1FRR4Proj">
<span id="_CPPv2N3hpx8parallel2v116stable_partitionERR8ExPolicy9BidirIter9BidirIterRR1FRR4Proj"></span><span id="hpx::parallel::v1::stable_partition__ExPolicyRR.BidirIter.BidirIter.FRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> BidirIter, <em class="property">typename</em> F, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="algorithms_2partition_8hpp_1a51d223e340c4841518fee0e95a68e426"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, BidirIter&gt;::type <code class="descname">stable_partition</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, BidirIter <em>first</em>, BidirIter <em>last</em>, F &amp;&amp;<em>f</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v116stable_partitionERR8ExPolicy9BidirIter9BidirIterRR1FRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Permutes the elements in the range [first, last) such that there exists an iterator i such that for every iterator j in the range [first, i) INVOKE(f, INVOKE (proj, *j)) != false, and for every iterator k in the range [i, last), INVOKE(f, INVOKE (proj, *k)) == false</p>
<p><p>The invocations of </p>
<em>f</em> in the parallel <em>stable_partition</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> executes in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: At most (last - first) * log(last - first) swaps, but only linear number of swaps if there is enough extra memory. Exactly <em>last</em> - <em>first</em> applications of the predicate and projection.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the invocations of <em>f</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">BidirIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>transform</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Unary predicate which returns true if the element should be ordered before other elements. Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">fun</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;. The type </p>
<em>Type</em> must be such that an object of type <em>BidirIter</em> can be dereferenced and then implicitly converted to <em>Type</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>f</em> is invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The invocations of <em>f</em> in the parallel <em>stable_partition</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>stable_partition</em> algorithm returns an iterator i such that for every iterator j in the range [first, i), f(*j) != false INVOKE(f, INVOKE(proj, *j)) != false, and for every iterator k in the range [i, last), f(*k) == false INVOKE(f, INVOKE (proj, *k)) == false. The relative order of the elements in both groups is preserved. If the execution policy is of type <em>parallel_task_policy</em> the algorithm returns a future&lt;&gt; referring to this iterator. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v19partitionERR8ExPolicy7FwdIter7FwdIterRR4PredRR4Proj">
<span id="_CPPv2N3hpx8parallel2v19partitionERR8ExPolicy7FwdIter7FwdIterRR4PredRR4Proj"></span><span id="hpx::parallel::v1::partition__ExPolicyRR.FwdIter.FwdIter.PredRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> Pred, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="algorithms_2partition_8hpp_1ace3554f7f7b701ed88970f31d82293d7"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type <code class="descname">partition</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, Pred &amp;&amp;<em>pred</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v19partitionERR8ExPolicy7FwdIter7FwdIterRR4PredRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Reorders the elements in the range [first, last) in such a way that all elements for which the predicate <em>pred</em> returns true precede the elements for which the predicate <em>pred</em> returns false. Relative order of the elements is not preserved.</p>
<p><p>The assignments in the parallel </p>
<em>partition</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: At most 2 * (last - first) swaps. Exactly <em>last</em> - <em>first</em> applications of the predicate and projection.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>partition</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">pred</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). This is an unary predicate for partitioning the source iterators. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>InIter</em> can be dereferenced and then implicitly converted to Type. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>partition</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>partition</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>parallel_task_policy</em> and returns <em>FwdIter</em> otherwise. The <em>partition</em> algorithm returns the iterator to the first element of the second group. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v114partition_copyERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter3RR4PredRR4Proj">
<span id="_CPPv2N3hpx8parallel2v114partition_copyERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter3RR4PredRR4Proj"></span><span id="hpx::parallel::v1::partition_copy__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.FwdIter3.PredRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> FwdIter3, <em class="property">typename</em> Pred, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="algorithms_2partition_8hpp_1a729a463da62bc43d095f16918de9eb81"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_tuple&lt;tag::in<span class="sig-paren">(</span>FwdIter1<span class="sig-paren">)</span>, tag::out1<span class="sig-paren">(</span>FwdIter2<span class="sig-paren">)</span>, tag::out2<span class="sig-paren">(</span>FwdIter3<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">partition_copy</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, FwdIter1 <em>last</em>, FwdIter2 <em>dest_true</em>, FwdIter3 <em>dest_false</em>, Pred &amp;&amp;<em>pred</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v114partition_copyERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter3RR4PredRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the elements in the range, defined by [first, last), to two different ranges depending on the value returned by the predicate <em>pred</em>. The elements, that satisfy the predicate <em>pred</em>, are copied to the range beginning at <em>dest_true</em>. The rest of the elements are copied to the range beginning at <em>dest_false</em>. The order of the elements is preserved.</p>
<p><p>The assignments in the parallel </p>
<em>partition_copy</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs not more than <em>last</em> - <em>first</em> assignments, exactly <em>last</em> - <em>first</em> applications of the predicate <em>f</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range for the elements that satisfy the predicate <em>pred</em> (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter3</span></code>: The type of the iterator representing the destination range for the elements that don’t satisfy the predicate <em>pred</em> (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>partition_copy</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest_true</span></code>: Refers to the beginning of the destination range for the elements that satisfy the predicate <em>pred</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest_false</span></code>: Refers to the beginning of the destination range for the elements that don’t satisfy the predicate <em>pred</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">pred</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). This is an unary predicate for partitioning the source iterators. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter1</em> can be dereferenced and then implicitly converted to Type. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>partition_copy</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>partition_copy</em> algorithm returns a <em>hpx::future&lt;tagged_tuple&lt;tag::in(InIter), tag::out1(OutIter1), tag::out2(OutIter2)&gt;</em> &gt; if the execution policy is of type <em>parallel_task_policy</em> and returns <em>tagged_tuple&lt;tag::in(InIter), tag::out1(OutIter1), tag::out2(OutIter2)&gt;</em> otherwise. The <em>partition_copy</em> algorithm returns the tuple of the source iterator <em>last</em>, the destination iterator to the end of the <em>dest_true</em> range, and the destination iterator to the end of the <em>dest_false</em> range. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-rotate-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/rotate.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-rotate-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v16rotateERR8ExPolicy7FwdIter7FwdIter7FwdIter">
<span id="_CPPv2N3hpx8parallel2v16rotateERR8ExPolicy7FwdIter7FwdIter7FwdIter"></span><span id="hpx::parallel::v1::rotate__ExPolicyRR.FwdIter.FwdIter.FwdIter"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter&gt;<br /><span class="target" id="algorithms_2rotate_8hpp_1a37fbfea98a8b85cf708658ab4074687c"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::begin<span class="sig-paren">(</span>FwdIter<span class="sig-paren">)</span>, tag::end<span class="sig-paren">(</span>FwdIter<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">rotate</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>new_first</em>, FwdIter <em>last</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v16rotateERR8ExPolicy7FwdIter7FwdIter7FwdIter" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Performs a left rotation on a range of elements. Specifically, <em>rotate</em> swaps the elements in the range [first, last) in such a way that the element new_first becomes the first element of the new range and new_first - 1 becomes the last element.</p>
<p><p>The assignments in the parallel </p>
<em>rotate</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Linear in the distance between <em>first</em> and <em>last</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">new_first</span></code>: Refers to the element that should appear at the beginning of the rotated range. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>rotate</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The type of dereferenced <em>FwdIter</em> must meet the requirements of <em>MoveAssignable</em> and <em>MoveConstructible</em>.</dd>
<dt><strong>Return</strong></dt>
<dd>The <em>rotate</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::begin(FwdIter), tag::end(FwdIter)&gt;</em> &gt; if the execution policy is of type <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::begin(FwdIter), tag::end(FwdIter)&gt;</em> otherwise. The <em>rotate</em> algorithm returns the iterator equal to pair(first + (last - new_first), last). </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v111rotate_copyERR8ExPolicy8FwdIter18FwdIter18FwdIter18FwdIter2">
<span id="_CPPv2N3hpx8parallel2v111rotate_copyERR8ExPolicy8FwdIter18FwdIter18FwdIter18FwdIter2"></span><span id="hpx::parallel::v1::rotate_copy__ExPolicyRR.FwdIter1.FwdIter1.FwdIter1.FwdIter2"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2&gt;<br /><span class="target" id="algorithms_2rotate_8hpp_1a394e722223291a249f049def93b4249b"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::in<span class="sig-paren">(</span>FwdIter1<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>FwdIter2<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">rotate_copy</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, FwdIter1 <em>new_first</em>, FwdIter1 <em>last</em>, FwdIter2 <em>dest_first</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v111rotate_copyERR8ExPolicy8FwdIter18FwdIter18FwdIter18FwdIter2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the elements from the range [first, last), to another range beginning at <em>dest_first</em> in such a way, that the element <em>new_first</em> becomes the first element of the new range and <em>new_first</em> - 1 becomes the last element.</p>
<p><p>The assignments in the parallel </p>
<em>rotate_copy</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>last</em> - <em>first</em> assignments.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an bidirectional iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">new_first</span></code>: Refers to the element that should appear at the beginning of the rotated range. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest_first</span></code>: Refers to the begin of the destination range.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>rotate_copy</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>rotate_copy</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</em> &gt; if the execution policy is of type <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</em> otherwise. The <em>rotate_copy</em> algorithm returns the output iterator to the element past the last element copied. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-all-any-none-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/all_any_none.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-all-any-none-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v17none_ofERR8ExPolicy7FwdIter7FwdIterRR1FRR4Proj">
<span id="_CPPv2N3hpx8parallel2v17none_ofERR8ExPolicy7FwdIter7FwdIterRR1FRR4Proj"></span><span id="hpx::parallel::v1::none_of__ExPolicyRR.FwdIter.FwdIter.FRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> F, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="algorithms_2all__any__none_8hpp_1a5f34b49fe744e1ea82df76e1c514aa49"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, bool&gt;::type <code class="descname">none_of</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, F &amp;&amp;<em>f</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v17none_ofERR8ExPolicy7FwdIter7FwdIterRR1FRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Checks if unary predicate <em>f</em> returns true for no elements in the range [first, last).</p>
<p><p>The application of function objects in parallel algorithm invoked with an execution policy object of type </p>
<em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: At most <em>last</em> - <em>first</em> applications of the predicate <em>f</em> </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>none_of</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter</em> can be dereferenced and then implicitly converted to Type. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>none_of</em> algorithm returns a <em>hpx::future&lt;bool&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>bool</em> otherwise. The <em>none_of</em> algorithm returns true if the unary predicate <em>f</em> returns true for no elements in the range, false otherwise. It returns true if the range is empty. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v16any_ofERR8ExPolicy7FwdIter7FwdIterRR1FRR4Proj">
<span id="_CPPv2N3hpx8parallel2v16any_ofERR8ExPolicy7FwdIter7FwdIterRR1FRR4Proj"></span><span id="hpx::parallel::v1::any_of__ExPolicyRR.FwdIter.FwdIter.FRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> F, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="algorithms_2all__any__none_8hpp_1afab0800132ab9eedfc6cf4fd89ee1913"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, bool&gt;::type <code class="descname">any_of</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, F &amp;&amp;<em>f</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v16any_ofERR8ExPolicy7FwdIter7FwdIterRR1FRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Checks if unary predicate <em>f</em> returns true for at least one element in the range [first, last).</p>
<p><p>The application of function objects in parallel algorithm invoked with an execution policy object of type </p>
<em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: At most <em>last</em> - <em>first</em> applications of the predicate <em>f</em> </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>any_of</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter</em> can be dereferenced and then implicitly converted to Type. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>any_of</em> algorithm returns a <em>hpx::future&lt;bool&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>bool</em> otherwise. The <em>any_of</em> algorithm returns true if the unary predicate <em>f</em> returns true for at least one element in the range, false otherwise. It returns false if the range is empty. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v16all_ofERR8ExPolicy7FwdIter7FwdIterRR1FRR4Proj">
<span id="_CPPv2N3hpx8parallel2v16all_ofERR8ExPolicy7FwdIter7FwdIterRR1FRR4Proj"></span><span id="hpx::parallel::v1::all_of__ExPolicyRR.FwdIter.FwdIter.FRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> F, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="algorithms_2all__any__none_8hpp_1a879e3cf8d3b4a2d70efa0dce73acb5ec"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, bool&gt;::type <code class="descname">all_of</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, F &amp;&amp;<em>f</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v16all_ofERR8ExPolicy7FwdIter7FwdIterRR1FRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Checks if unary predicate <em>f</em> returns true for all elements in the range [first, last).</p>
<p><p>The application of function objects in parallel algorithm invoked with an execution policy object of type </p>
<em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: At most <em>last</em> - <em>first</em> applications of the predicate <em>f</em> </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>all_of</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter</em> can be dereferenced and then implicitly converted to Type. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>all_of</em> algorithm returns a <em>hpx::future&lt;bool&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>bool</em> otherwise. The <em>all_of</em> algorithm returns true if the unary predicate <em>f</em> returns true for all elements in the range, false otherwise. It returns true if the range is empty. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-find-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/find.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-find-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v14findERR8ExPolicy7FwdIter7FwdIterR1T">
<span id="_CPPv2N3hpx8parallel2v14findERR8ExPolicy7FwdIter7FwdIterR1T"></span><span id="hpx::parallel::v1::find__ExPolicyRR.FwdIter.FwdIter.TCR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> T&gt;<br /><span class="target" id="algorithms_2find_8hpp_1a893a52786f37d74e50ac7beca62ff409"></span><a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::enable_if&lt;<a class="reference internal" href="../compute/api.html#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="../execution/api.html#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type&gt;::type <code class="descname">find</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, T <em class="property">const</em> &amp;<em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v14findERR8ExPolicy7FwdIter7FwdIterR1T" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the first element in the range [first, last) that is equal to value</p>
<p><p>The comparison operations in the parallel </p>
<em>find</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: At most last - first applications of the operator==().</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used for the first range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the value to find (deduced).</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">val</span></code>: the value to compare the elements to</li>
</ul>
</dd>
</dl>
</p>
<p>The comparison operations in the parallel <em>find</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>find</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter</em> otherwise. The <em>find</em> algorithm returns the first element in the range [first,last) that is equal to <em>val</em>. If no such element in the range of [first,last) is equal to <em>val</em>, then the algorithm returns <em>last</em>. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v17find_ifERR8ExPolicy7FwdIter7FwdIterRR1F">
<span id="_CPPv2N3hpx8parallel2v17find_ifERR8ExPolicy7FwdIter7FwdIterRR1F"></span><span id="hpx::parallel::v1::find_if__ExPolicyRR.FwdIter.FwdIter.FRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> F&gt;<br /><span class="target" id="algorithms_2find_8hpp_1a0530592aa6387d0e2ab3902222e18499"></span><a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::enable_if&lt;<a class="reference internal" href="../compute/api.html#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="../execution/api.html#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type&gt;::type <code class="descname">find_if</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, F &amp;&amp;<em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v17find_ifERR8ExPolicy7FwdIter7FwdIterRR1F" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the first element in the range [first, last) for which predicate <em>f</em> returns true</p>
<p><p>The comparison operations in the parallel </p>
<em>find_if</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: At most last - first applications of the predicate.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used for the first range (deduced). This iterator type must meet the requirements of a forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>equal</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: The unary predicate which returns true for the required element. The signature of the predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that objects of type <em>FwdIter</em> can be dereferenced and then implicitly converted to <em>Type</em>.</li>
</ul>
</dd>
</dl>
</p>
<p>The comparison operations in the parallel <em>find_if</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>find_if</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter</em> otherwise. The <em>find_if</em> algorithm returns the first element in the range [first,last) that satisfies the predicate <em>f</em>. If no such element exists that satisfies the predicate f, the algorithm returns <em>last</em>. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v111find_if_notERR8ExPolicy7FwdIter7FwdIterRR1F">
<span id="_CPPv2N3hpx8parallel2v111find_if_notERR8ExPolicy7FwdIter7FwdIterRR1F"></span><span id="hpx::parallel::v1::find_if_not__ExPolicyRR.FwdIter.FwdIter.FRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> F&gt;<br /><span class="target" id="algorithms_2find_8hpp_1a93a681512c7ac1e504321e52b075d37f"></span><a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::enable_if&lt;<a class="reference internal" href="../compute/api.html#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="../execution/api.html#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type&gt;::type <code class="descname">find_if_not</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, F &amp;&amp;<em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v111find_if_notERR8ExPolicy7FwdIter7FwdIterRR1F" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the first element in the range [first, last) for which predicate <em>f</em> returns false</p>
<p><p>The comparison operations in the parallel </p>
<em>find_if_not</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: At most last - first applications of the predicate.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used for the first range (deduced). This iterator type must meet the requirements of a forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>equal</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: The unary predicate which returns false for the required element. The signature of the predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that objects of type <em>FwdIter</em> can be dereferenced and then implicitly converted to <em>Type</em>.</li>
</ul>
</dd>
</dl>
</p>
<p>The comparison operations in the parallel <em>find_if_not</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>find_if_not</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter</em> otherwise. The <em>find_if_not</em> algorithm returns the first element in the range [first, last) that does <strong>not</strong> satisfy the predicate <em>f</em>. If no such element exists that does not satisfy the predicate f, the algorithm returns <em>last</em>. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v18find_endERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter2RR4PredRR4Proj">
<span id="_CPPv2N3hpx8parallel2v18find_endERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter2RR4PredRR4Proj"></span><span id="hpx::parallel::v1::find_end__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.FwdIter2.PredRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> Pred = detail::equal_to, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="algorithms_2find_8hpp_1a2d0994b13004b9951547bb2c7b5b5198"></span><a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::enable_if&lt;<a class="reference internal" href="../compute/api.html#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="../execution/api.html#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter1&gt;::type&gt;::type <code class="descname">find_end</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first1</em>, FwdIter1 <em>last1</em>, FwdIter2 <em>first2</em>, FwdIter2 <em>last2</em>, Pred &amp;&amp;<em>op</em> = Pred(), Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v18find_endERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter2RR4PredRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the last subsequence of elements [first2, last2) found in the range [first, last) using the given predicate <em>f</em> to compare elements.</p>
<p><p>The comparison operations in the parallel </p>
<em>find_end</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: at most S*(N-S+1) comparisons where <em>S</em> = distance(first2, last2) and <em>N</em> = distance(first1, last1).</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used for the first range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the source iterators used for the second range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <em>replace</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::equal_to&lt;&gt; </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> and is applied to the elements of type dereferenced <em>FwdIter1</em> and dereferenced <em>FwdIter2</em>.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first1</span></code>: Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last1</span></code>: Refers to the end of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">first2</span></code>: Refers to the beginning of the sequence of elements the algorithm will be searching for. </li>
<li><code class="docutils literal notranslate"><span class="pre">last2</span></code>: Refers to the end of the sequence of elements of the algorithm will be searching for. </li>
<li><code class="docutils literal notranslate"><span class="pre">op</span></code>: The binary predicate which returns <em>true</em> if the elements should be treated as equal. The signature should be equivalent to the following: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type2</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> and <em>Type2</em> must be such that objects of types <em>FwdIter1</em> and <em>FwdIter2</em> can be dereferenced and then implicitly converted to <em>Type1</em> and <em>Type2</em> respectively. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of type dereferenced <em>FwdIter1</em> and dereferenced <em>FwdIter2</em> as a projection operation before the function <em>f</em> is invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The comparison operations in the parallel <em>find_end</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><p>This overload of </p>
<em>find_end</em> is available if the user decides to provide the algorithm their own predicate <em>f</em>. <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>find_end</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter</em> otherwise. The <em>find_end</em> algorithm returns an iterator to the beginning of the last subsequence [first2, last2) in range [first, last). If the length of the subsequence [first2, last2) is greater than the length of the range [first1, last1), <em>last1</em> is returned. Additionally if the size of the subsequence is empty or no subsequence is found, <em>last1</em> is also returned.</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v113find_first_ofERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter2RR4PredRR5Proj1RR5Proj2">
<span id="_CPPv2N3hpx8parallel2v113find_first_ofERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter2RR4PredRR5Proj1RR5Proj2"></span><span id="hpx::parallel::v1::find_first_of__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.FwdIter2.PredRR.Proj1RR.Proj2RR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> Pred = detail::equal_to, <em class="property">typename</em> Proj1 = util::projection_identity, <em class="property">typename</em> Proj2 = util::projection_identity&gt;<br /><span class="target" id="algorithms_2find_8hpp_1a4374b62db395b7ee74b97a6adc8c7e89"></span><a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::enable_if&lt;<a class="reference internal" href="../compute/api.html#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="../execution/api.html#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter1&gt;::type&gt;::type <code class="descname">find_first_of</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, FwdIter1 <em>last</em>, FwdIter2 <em>s_first</em>, FwdIter2 <em>s_last</em>, Pred &amp;&amp;<em>op</em> = Pred(), Proj1 &amp;&amp;<em>proj1</em> = Proj1(), Proj2 &amp;&amp;<em>proj2</em> = Proj2()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v113find_first_ofERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter2RR4PredRR5Proj1RR5Proj2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Searches the range [first, last) for any elements in the range [s_first, s_last). Uses binary predicate p to compare elements</p>
<p><p>The comparison operations in the parallel </p>
<em>find_first_of</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: at most (S*N) comparisons where <em>S</em> = distance(s_first, s_last) and <em>N</em> = distance(first, last).</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used for the first range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the source iterators used for the second range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <em>equal</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::equal_to&lt;&gt; </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj1</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> and is applied to the elements of type dereferenced <em>FwdIter1</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj2</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> and is applied to the elements of type dereferenced <em>FwdIter2</em>.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">s_first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be searching for. </li>
<li><code class="docutils literal notranslate"><span class="pre">s_last</span></code>: Refers to the end of the sequence of elements of the algorithm will be searching for. </li>
<li><code class="docutils literal notranslate"><span class="pre">op</span></code>: The binary predicate which returns <em>true</em> if the elements should be treated as equal. The signature should be equivalent to the following: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type2</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> and <em>Type2</em> must be such that objects of types <em>FwdIter1</em> and <em>FwdIter2</em> can be dereferenced and then implicitly converted to <em>Type1</em> and <em>Type2</em> respectively. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj1</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of type dereferenced <em>FwdIter1</em> as a projection operation before the function <em>op</em> is invoked. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj2</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of type dereferenced <em>FwdIter2</em> as a projection operation before the function <em>op</em> is invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The comparison operations in the parallel <em>find_first_of</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>find_first_of</em> algorithm returns a <em>hpx::future&lt;FwdIter1&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter1</em> otherwise. The <em>find_first_of</em> algorithm returns an iterator to the first element in the range [first, last) that is equal to an element from the range [s_first, s_last). If the length of the subsequence [s_first, s_last) is greater than the length of the range [first, last), <em>last</em> is returned. Additionally if the size of the subsequence is empty or no subsequence is found, <em>last</em> is also returned. This overload of <em>find_end</em> is available if the user decides to provide the algorithm their own predicate <em>f</em>. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-for-each-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/for_each.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-for-each-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v110for_each_nERR8ExPolicy7FwdIter4SizeRR1FRR4Proj">
<span id="_CPPv2N3hpx8parallel2v110for_each_nERR8ExPolicy7FwdIter4SizeRR1FRR4Proj"></span><span id="hpx::parallel::v1::for_each_n__ExPolicyRR.FwdIter.Size.FRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> Size, <em class="property">typename</em> F, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="algorithms_2for__each_8hpp_1ae99cf785be3f48daf11e9ff21e2c2ebb"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type <code class="descname">for_each_n</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, Size <em>count</em>, F &amp;&amp;<em>f</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v110for_each_nERR8ExPolicy7FwdIter4SizeRR1FRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Applies <em>f</em> to the result of dereferencing every iterator in the range [first, first + count), starting from first and proceeding to first + count - 1.</p>
<p><p>If </p>
<em>f</em> returns a result, the result is ignored.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Applies <em>f</em> exactly <em>count</em> times.</dd>
</dl>
</p>
<p>If the type of <em>first</em> satisfies the requirements of a mutable iterator, <em>f</em> may apply non-constant functions through the dereferenced iterator.</p>
<p>Unlike its sequential form, the parallel overload of <em>for_each</em> does not return a copy of its <em>Function</em> parameter, since parallelization may not permit efficient state accumulation.</p>
<p><p>The application of function objects in parallel algorithm invoked with an execution policy object of type </p>
<em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Size</span></code>: The type of the argument specifying the number of elements to apply <em>f</em> to. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>for_each</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">count</span></code>: Refers to the number of elements starting at <em>first</em> the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">ignored</span><span class="o">&gt;</span> <span class="n">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter</em> can be dereferenced and then implicitly converted to Type. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>f</em> is invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>for_each_n</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter</em> otherwise. It returns <em>first</em> + <em>count</em> for non-negative values of <em>count</em> and <em>first</em> for negative values. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v18for_eachERR8ExPolicy7FwdIter7FwdIterRR1FRR4Proj">
<span id="_CPPv2N3hpx8parallel2v18for_eachERR8ExPolicy7FwdIter7FwdIterRR1FRR4Proj"></span><span id="hpx::parallel::v1::for_each__ExPolicyRR.FwdIter.FwdIter.FRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> F, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="algorithms_2for__each_8hpp_1a4eeac314eec9001c03e68882d85e9123"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type <code class="descname">for_each</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, F &amp;&amp;<em>f</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v18for_eachERR8ExPolicy7FwdIter7FwdIterRR1FRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Applies <em>f</em> to the result of dereferencing every iterator in the range [first, last).</p>
<p><p>If </p>
<em>f</em> returns a result, the result is ignored.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Applies <em>f</em> exactly <em>last</em> - <em>first</em> times.</dd>
</dl>
</p>
<p>If the type of <em>first</em> satisfies the requirements of a mutable iterator, <em>f</em> may apply non-constant functions through the dereferenced iterator.</p>
<p>Unlike its sequential form, the parallel overload of <em>for_each</em> does not return a copy of its <em>Function</em> parameter, since parallelization may not permit efficient state accumulation.</p>
<p><p>The application of function objects in parallel algorithm invoked with an execution policy object of type </p>
<em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>for_each</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">ignored</span><span class="o">&gt;</span> <span class="n">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter</em> can be dereferenced and then implicitly converted to Type. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>f</em> is invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>for_each</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter</em> otherwise. It returns <em>last</em>. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-reverse-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/reverse.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-reverse-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v17reverseERR8ExPolicy9BidirIter9BidirIter">
<span id="_CPPv2N3hpx8parallel2v17reverseERR8ExPolicy9BidirIter9BidirIter"></span><span id="hpx::parallel::v1::reverse__ExPolicyRR.BidirIter.BidirIter"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> BidirIter&gt;<br /><span class="target" id="algorithms_2reverse_8hpp_1a967582e2015a58617a450103228c2830"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, BidirIter&gt;::type <code class="descname">reverse</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, BidirIter <em>first</em>, BidirIter <em>last</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v17reverseERR8ExPolicy9BidirIter9BidirIter" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Reverses the order of the elements in the range [first, last). Behaves as if applying std::iter_swap to every pair of iterators first+i, (last-i) - 1 for each non-negative i &lt; (last-first)/2.</p>
<p><p>The assignments in the parallel </p>
<em>reverse</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Linear in the distance between <em>first</em> and <em>last</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">BidirIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an bidirectional iterator.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>reverse</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>reverse</em> algorithm returns a <em>hpx::future&lt;BidirIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>BidirIter</em> otherwise. It returns <em>last</em>. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v112reverse_copyERR8ExPolicy9BidirIter9BidirIter7FwdIter">
<span id="_CPPv2N3hpx8parallel2v112reverse_copyERR8ExPolicy9BidirIter9BidirIter7FwdIter"></span><span id="hpx::parallel::v1::reverse_copy__ExPolicyRR.BidirIter.BidirIter.FwdIter"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> BidirIter, <em class="property">typename</em> FwdIter&gt;<br /><span class="target" id="algorithms_2reverse_8hpp_1a73befee3dd512b8c821300dfdb863815"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::in<span class="sig-paren">(</span>BidirIter<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>FwdIter<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">reverse_copy</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, BidirIter <em>first</em>, BidirIter <em>last</em>, FwdIter <em>dest_first</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v112reverse_copyERR8ExPolicy9BidirIter9BidirIter7FwdIter" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the elements from the range [first, last) to another range beginning at dest_first in such a way that the elements in the new range are in reverse order. Behaves as if by executing the assignment *(dest_first + (last - first) - 1 - i) = *(first + i) once for each non-negative i &lt; (last - first) If the source and destination ranges (that is, [first, last) and [dest_first, dest_first+(last-first)) respectively) overlap, the behavior is undefined.</p>
<p><p>The assignments in the parallel </p>
<em>reverse_copy</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>last</em> - <em>first</em> assignments.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">BidirIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an bidirectional iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest_first</span></code>: Refers to the begin of the destination range.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>reverse_copy</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>reverse_copy</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::in(BidirIter), tag::out(FwdIter)&gt;</em> &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::in(BidirIter), tag::out(FwdIter)&gt;</em> otherwise. The <em>copy</em> algorithm returns the pair of the input iterator forwarded to the first element after the last in the input sequence and the output iterator to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-is-partitioned-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/is_partitioned.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-is-partitioned-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v114is_partitionedERR8ExPolicy7FwdIter7FwdIterRR4Pred">
<span id="_CPPv2N3hpx8parallel2v114is_partitionedERR8ExPolicy7FwdIter7FwdIterRR4Pred"></span><span id="hpx::parallel::v1::is_partitioned__ExPolicyRR.FwdIter.FwdIter.PredRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> Pred&gt;<br /><span class="target" id="is__partitioned_8hpp_1a4ce52857e15aa23f863761ccb100d79d"></span><a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::enable_if&lt;<a class="reference internal" href="../compute/api.html#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="../execution/api.html#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, bool&gt;::type&gt;::type <code class="descname">is_partitioned</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, Pred &amp;&amp;<em>pred</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v114is_partitionedERR8ExPolicy7FwdIter7FwdIterRR4Pred" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Determines if the range [first, last) is partitioned.</p>
<p><p>The predicate operations in the parallel </p>
<em>is_partitioned</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> executes in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: at most (N) predicate evaluations where <em>N</em> = distance(first, last).</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used for the This iterator type must meet the requirements of a forward iterator. </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements of that the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements of that the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">pred</span></code>: Refers to the binary predicate which returns true if the first argument should be treated as less than the second argument. The signature of the function should be equivalent to <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that objects of types <em>FwdIter</em> can be dereferenced and then implicitly converted to Type.</li>
</ul>
</dd>
</dl>
</p>
<p>The comparison operations in the parallel <em>is_partitioned</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>is_partitioned</em> algorithm returns a <em>hpx::future&lt;bool&gt;</em> if the execution policy is of type <em>task_execution_policy</em> and returns <em>bool</em> otherwise. The <em>is_partitioned</em> algorithm returns true if each element in the sequence for which pred returns true precedes those for which pred returns false. Otherwise is_partitioned returns false. If the range [first, last) contains less than two elements, the function is always true. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-transform-reduce-binary-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/transform_reduce_binary.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-transform-reduce-binary-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v116transform_reduceERR8ExPolicy8FwdIter18FwdIter18FwdIter21T">
<span id="_CPPv2N3hpx8parallel2v116transform_reduceERR8ExPolicy8FwdIter18FwdIter18FwdIter21T"></span><span id="hpx::parallel::v1::transform_reduce__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.T"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> T&gt;<br /><span class="target" id="transform__reduce__binary_8hpp_1a693dae27f2f4fa48464229112b73ae56"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, T&gt;::type <code class="descname">transform_reduce</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first1</em>, FwdIter1 <em>last1</em>, FwdIter2 <em>first2</em>, T <em>init</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v116transform_reduceERR8ExPolicy8FwdIter18FwdIter18FwdIter21T" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the result of accumulating init with the inner products of the pairs formed by the elements of two ranges starting at first1 and first2.</p>
<p><p>The operations in the parallel </p>
<em>transform_reduce</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: O(<em>last</em> - <em>first</em>) applications of the predicate <em>op2</em>. </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the first source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the second source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the value to be used as return) values (deduced). </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first1</span></code>: Refers to the beginning of the first sequence of elements the result will be calculated with. </li>
<li><code class="docutils literal notranslate"><span class="pre">last1</span></code>: Refers to the end of the first sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">first2</span></code>: Refers to the beginning of the second sequence of elements the result will be calculated with. </li>
<li><code class="docutils literal notranslate"><span class="pre">init</span></code>: The initial value for the sum.</li>
</ul>
</dd>
</dl>
</p>
<p>The operations in the parallel <em>transform_reduce</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>transform_reduce</em> algorithm returns a <em>hpx::future&lt;T&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>T</em> otherwise. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v116transform_reduceERR8ExPolicy8FwdIter18FwdIter18FwdIter21TRR6ReduceRR7Convert">
<span id="_CPPv2N3hpx8parallel2v116transform_reduceERR8ExPolicy8FwdIter18FwdIter18FwdIter21TRR6ReduceRR7Convert"></span><span id="hpx::parallel::v1::transform_reduce__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.T.ReduceRR.ConvertRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> T, <em class="property">typename</em> Reduce, <em class="property">typename</em> Convert&gt;<br /><span class="target" id="transform__reduce__binary_8hpp_1ad0241a6affe0562bc8b0ccedc8a5af6b"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, T&gt;::type <code class="descname">transform_reduce</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first1</em>, FwdIter1 <em>last1</em>, FwdIter2 <em>first2</em>, T <em>init</em>, Reduce &amp;&amp;<em>red_op</em>, Convert &amp;&amp;<em>conv_op</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v116transform_reduceERR8ExPolicy8FwdIter18FwdIter18FwdIter21TRR6ReduceRR7Convert" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the result of accumulating init with the inner products of the pairs formed by the elements of two ranges starting at first1 and first2.</p>
<p><p>The operations in the parallel </p>
<em>transform_reduce</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: O(<em>last</em> - <em>first</em>) applications of the predicate <em>op2</em>. </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the first source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the second source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the value to be used as return) values (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">Reduce</span></code>: The type of the binary function object used for the multiplication operation. </li>
<li><code class="docutils literal notranslate"><span class="pre">Convert</span></code>: The type of the unary function object used to transform the elements of the input sequence before invoking the reduce function.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first1</span></code>: Refers to the beginning of the first sequence of elements the result will be calculated with. </li>
<li><code class="docutils literal notranslate"><span class="pre">last1</span></code>: Refers to the end of the first sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">first2</span></code>: Refers to the beginning of the second sequence of elements the result will be calculated with. </li>
<li><code class="docutils literal notranslate"><span class="pre">init</span></code>: The initial value for the sum. </li>
<li><code class="docutils literal notranslate"><span class="pre">red_op</span></code>: Specifies the function (or function object) which will be invoked for the initial value and each of the return values of <em>op2</em>. This is a binary predicate. The signature of this predicate should be equivalent to should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ret</span> <span class="nf">fun</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Ret</em> must be such that it can be implicitly converted to a type of <em>T</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">conv_op</span></code>: Specifies the function (or function object) which will be invoked for each of the input values of the sequence. This is a binary predicate. The signature of this predicate should be equivalent to <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ret</span> <span class="nf">fun</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type2</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Ret</em> must be such that it can be implicitly converted to an object for the second argument type of <em>op1</em>.</li>
</ul>
</dd>
</dl>
</p>
<p>The operations in the parallel <em>transform_reduce</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>transform_reduce</em> algorithm returns a <em>hpx::future&lt;T&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>T</em> otherwise. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-uninitialized-value-construct-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/uninitialized_value_construct.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-uninitialized-value-construct-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v129uninitialized_value_constructERR8ExPolicy7FwdIter7FwdIter">
<span id="_CPPv2N3hpx8parallel2v129uninitialized_value_constructERR8ExPolicy7FwdIter7FwdIter"></span><span id="hpx::parallel::v1::uninitialized_value_construct__ExPolicyRR.FwdIter.FwdIter"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter&gt;<br /><span class="target" id="uninitialized__value__construct_8hpp_1a30a4fcff72d61a5c69d24d1982d6b2b4"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy&gt;::type <code class="descname">uninitialized_value_construct</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v129uninitialized_value_constructERR8ExPolicy7FwdIter7FwdIter" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructs objects of type typename iterator_traits&lt;ForwardIt&gt;::value_type in the uninitialized storage designated by the range [first, last) by default-initialization. If an exception is thrown during the initialization, the function has no effects.</p>
<p><p>The assignments in the parallel </p>
<em>uninitialized_value_construct</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>last</em> - <em>first</em> assignments.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>uninitialized_value_construct</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>uninitialized_value_construct</em> algorithm returns a <em>hpx::future&lt;void&gt;</em>, if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>void</em> otherwise. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v131uninitialized_value_construct_nERR8ExPolicy7FwdIter4Size">
<span id="_CPPv2N3hpx8parallel2v131uninitialized_value_construct_nERR8ExPolicy7FwdIter4Size"></span><span id="hpx::parallel::v1::uninitialized_value_construct_n__ExPolicyRR.FwdIter.Size"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> Size&gt;<br /><span class="target" id="uninitialized__value__construct_8hpp_1a26fb2b43578429cf5bcf837fe4be24cc"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type <code class="descname">uninitialized_value_construct_n</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, Size <em>count</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v131uninitialized_value_construct_nERR8ExPolicy7FwdIter4Size" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructs objects of type typename iterator_traits&lt;ForwardIt&gt;::value_type in the uninitialized storage designated by the range [first, first + count) by default-initialization. If an exception is thrown during the initialization, the function has no effects.</p>
<p><p>The assignments in the parallel </p>
<em>uninitialized_value_construct_n</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>count</em> assignments, if count &gt; 0, no assignments otherwise.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Size</span></code>: The type of the argument specifying the number of elements to apply <em>f</em> to.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">count</span></code>: Refers to the number of elements starting at <em>first</em> the algorithm will be applied to.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>uninitialized_value_construct_n</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>uninitialized_value_construct_n</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter</em> otherwise. The <em>uninitialized_value_construct_n</em> algorithm returns the iterator to the element in the source range, one past the last element constructed. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-uninitialized-move-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/uninitialized_move.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-uninitialized-move-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v118uninitialized_moveERR8ExPolicy8FwdIter18FwdIter18FwdIter2">
<span id="_CPPv2N3hpx8parallel2v118uninitialized_moveERR8ExPolicy8FwdIter18FwdIter18FwdIter2"></span><span id="hpx::parallel::v1::uninitialized_move__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2&gt;<br /><span class="target" id="uninitialized__move_8hpp_1a58724c8d012c1ffe714681f0ed0661cd"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter2&gt;::type <code class="descname">uninitialized_move</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, FwdIter1 <em>last</em>, FwdIter2 <em>dest</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v118uninitialized_moveERR8ExPolicy8FwdIter18FwdIter18FwdIter2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Moves the elements in the range, defined by [first, last), to an uninitialized memory area beginning at <em>dest</em>. If an exception is thrown during the initialization, some objects in [first, last) are left in a valid but unspecified state.</p>
<p><p>The assignments in the parallel </p>
<em>uninitialized_move</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>last</em> - <em>first</em> move operations.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of a forward iterator.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>uninitialized_move</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>uninitialized_move</em> algorithm returns a <em>hpx::future&lt;FwdIter2&gt;</em>, if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter2</em> otherwise. The <em>uninitialized_move</em> algorithm returns the output iterator to the element in the destination range, one past the last element moved. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v120uninitialized_move_nERR8ExPolicy8FwdIter14Size8FwdIter2">
<span id="_CPPv2N3hpx8parallel2v120uninitialized_move_nERR8ExPolicy8FwdIter14Size8FwdIter2"></span><span id="hpx::parallel::v1::uninitialized_move_n__ExPolicyRR.FwdIter1.Size.FwdIter2"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> Size, <em class="property">typename</em> FwdIter2&gt;<br /><span class="target" id="uninitialized__move_8hpp_1a50c33f88075e3a9f399857302d0e475d"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::in<span class="sig-paren">(</span>FwdIter1<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>FwdIter2<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">uninitialized_move_n</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, Size <em>count</em>, FwdIter2 <em>dest</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v120uninitialized_move_nERR8ExPolicy8FwdIter14Size8FwdIter2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Moves the elements in the range [first, first + count), starting from first and proceeding to first + count - 1., to another range beginning at dest. If an exception is thrown during the initialization, some objects in [first, first + count) are left in a valid but unspecified state.</p>
<p><p>The assignments in the parallel </p>
<em>uninitialized_move_n</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>count</em> movements, if count &gt; 0, no move operations otherwise.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Size</span></code>: The type of the argument specifying the number of elements to apply <em>f</em> to. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of a forward iterator.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">count</span></code>: Refers to the number of elements starting at <em>first</em> the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>uninitialized_move_n</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>uninitialized_move_n</em> algorithm returns a <em>hpx::future&lt;std::pair&lt;FwdIter1, FwdIter2&gt;&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>std::pair&lt;FwdIter1, FwdIter2&gt;</em> otherwise. The <em>uninitialized_move_n</em> algorithm returns the pair of the input iterator to the element past in the source range and an output iterator to the element in the destination range, one past the last element moved. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-search-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/search.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-search-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v16searchERR8ExPolicy7FwdIter7FwdIter8FwdIter28FwdIter2RR4PredRR5Proj1RR5Proj2">
<span id="_CPPv2N3hpx8parallel2v16searchERR8ExPolicy7FwdIter7FwdIter8FwdIter28FwdIter2RR4PredRR5Proj1RR5Proj2"></span><span id="hpx::parallel::v1::search__ExPolicyRR.FwdIter.FwdIter.FwdIter2.FwdIter2.PredRR.Proj1RR.Proj2RR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> Pred = detail::equal_to, <em class="property">typename</em> Proj1 = util::projection_identity, <em class="property">typename</em> Proj2 = util::projection_identity&gt;<br /><span class="target" id="algorithms_2search_8hpp_1a0422631fee0a3f2510ebb2cfbd4698e7"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type <code class="descname">search</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, FwdIter2 <em>s_first</em>, FwdIter2 <em>s_last</em>, Pred &amp;&amp;<em>op</em> = Pred(), Proj1 &amp;&amp;<em>proj1</em> = Proj1(), Proj2 &amp;&amp;<em>proj2</em> = Proj2()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v16searchERR8ExPolicy7FwdIter7FwdIter8FwdIter28FwdIter2RR4PredRR5Proj1RR5Proj2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Searches the range [first, last) for any elements in the range [s_first, s_last). Uses a provided predicate to compare elements.</p>
<p><p>The comparison operations in the parallel </p>
<em>search</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: at most (S*N) comparisons where <em>S</em> = distance(s_first, s_last) and <em>N</em> = distance(first, last).</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used for the first range (deduced). This iterator type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the source iterators used for the second range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <em>adjacent_find</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::equal_to&lt;&gt; </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj1</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> and is applied to the elements of type dereferenced <em>FwdIter</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj2</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> and is applied to the elements of type dereferenced <em>FwdIter2</em>.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">s_first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be searching for. </li>
<li><code class="docutils literal notranslate"><span class="pre">s_last</span></code>: Refers to the end of the sequence of elements of the algorithm will be searching for. </li>
<li><code class="docutils literal notranslate"><span class="pre">op</span></code>: Refers to the binary predicate which returns true if the elements should be treated as equal. the signature of the function should be equivalent to <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type2</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> and <em>Type2</em> must be such that objects of types <em>FwdIter1</em> and <em>FwdIter2</em> can be dereferenced and then implicitly converted to <em>Type1</em> and <em>Type2</em> respectively </li>
<li><code class="docutils literal notranslate"><span class="pre">proj1</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of type dereferenced <em>FwdIter1</em> as a projection operation before the actual predicate <em>is</em> invoked. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj2</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of type dereferenced <em>FwdIter2</em> as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The comparison operations in the parallel <em>search</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>search</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>task_execution_policy</em> and returns <em>FwdIter</em> otherwise. The <em>search</em> algorithm returns an iterator to the beginning of the first subsequence [s_first, s_last) in range [first, last). If the length of the subsequence [s_first, s_last) is greater than the length of the range [first, last), <em>last</em> is returned. Additionally if the size of the subsequence is empty <em>first</em> is returned. If no subsequence is found, <em>last</em> is returned. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v18search_nERR8ExPolicy7FwdIterNSt6size_tE8FwdIter28FwdIter2RR4PredRR5Proj1RR5Proj2">
<span id="_CPPv2N3hpx8parallel2v18search_nERR8ExPolicy7FwdIterNSt6size_tE8FwdIter28FwdIter2RR4PredRR5Proj1RR5Proj2"></span><span id="hpx::parallel::v1::search_n__ExPolicyRR.FwdIter.std::s.FwdIter2.FwdIter2.PredRR.Proj1RR.Proj2RR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> Pred = detail::equal_to, <em class="property">typename</em> Proj1 = util::projection_identity, <em class="property">typename</em> Proj2 = util::projection_identity&gt;<br /><span class="target" id="algorithms_2search_8hpp_1ad56291e6bf23d7d9ecf498368c55017c"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type <code class="descname">search_n</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, <a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::size_t <em>count</em>, FwdIter2 <em>s_first</em>, FwdIter2 <em>s_last</em>, Pred &amp;&amp;<em>op</em> = Pred(), Proj1 &amp;&amp;<em>proj1</em> = Proj1(), Proj2 &amp;&amp;<em>proj2</em> = Proj2()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v18search_nERR8ExPolicy7FwdIterNSt6size_tE8FwdIter28FwdIter2RR4PredRR5Proj1RR5Proj2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Searches the range [first, last) for any elements in the range [s_first, s_last). Uses a provided predicate to compare elements.</p>
<p><p>The comparison operations in the parallel </p>
<em>search_n</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: at most (S*N) comparisons where <em>S</em> = distance(s_first, s_last) and <em>N</em> = count.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used for the first range (deduced). This iterator type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the source iterators used for the second range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <em>adjacent_find</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::equal_to&lt;&gt;</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">count</span></code>: Refers to the range of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">s_first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be searching for. </li>
<li><code class="docutils literal notranslate"><span class="pre">s_last</span></code>: Refers to the end of the sequence of elements of the algorithm will be searching for. </li>
<li><code class="docutils literal notranslate"><span class="pre">op</span></code>: Refers to the binary predicate which returns true if the elements should be treated as equal. the signature of the function should be equivalent to <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type2</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> and <em>Type2</em> must be such that objects of types <em>FwdIter1</em> and <em>FwdIter2</em> can be dereferenced and then implicitly converted to <em>Type1</em> and <em>Type2</em> respectively </li>
<li><code class="docutils literal notranslate"><span class="pre">proj1</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of type dereferenced <em>FwdIter1</em> as a projection operation before the actual predicate <em>is</em> invoked. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj2</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of type dereferenced <em>FwdIter2</em> as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The comparison operations in the parallel <em>search_n</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>search_n</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>task_execution_policy</em> and returns <em>FwdIter</em> otherwise. The <em>search_n</em> algorithm returns an iterator to the beginning of the last subsequence [s_first, s_last) in range [first, first+count). If the length of the subsequence [s_first, s_last) is greater than the length of the range [first, first+count), <em>first</em> is returned. Additionally if the size of the subsequence is empty or no subsequence is found, <em>first</em> is also returned. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-is-sorted-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/is_sorted.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-is-sorted-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v19is_sortedERR8ExPolicy7FwdIter7FwdIterRR4Pred">
<span id="_CPPv2N3hpx8parallel2v19is_sortedERR8ExPolicy7FwdIter7FwdIterRR4Pred"></span><span id="hpx::parallel::v1::is_sorted__ExPolicyRR.FwdIter.FwdIter.PredRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> Pred = detail::less&gt;<br /><span class="target" id="is__sorted_8hpp_1a5c7657c229562ed7cf7599f5cbfed0ea"></span><a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::enable_if&lt;<a class="reference internal" href="../compute/api.html#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="../execution/api.html#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, bool&gt;::type&gt;::type <code class="descname">is_sorted</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, Pred &amp;&amp;<em>pred</em> = Pred()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v19is_sortedERR8ExPolicy7FwdIter7FwdIterRR4Pred" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Determines if the range [first, last) is sorted. Uses pred to compare elements.</p>
<p><p>The comparison operations in the parallel </p>
<em>is_sorted</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> executes in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: at most (N+S-1) comparisons where <em>N</em> = distance(first, last). <em>S</em> = number of partitions</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used for the This iterator type must meet the requirements of a forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <em>is_sorted</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::less&lt;&gt;</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements of that the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements of that the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">pred</span></code>: Refers to the binary predicate which returns true if the first argument should be treated as less than the second argument. The signature of the function should be equivalent to <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that objects of types <em>FwdIter</em> can be dereferenced and then implicitly converted to Type.</li>
</ul>
</dd>
</dl>
</p>
<p>The comparison operations in the parallel <em>is_sorted</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>is_sorted</em> algorithm returns a <em>hpx::future&lt;bool&gt;</em> if the execution policy is of type <em>task_execution_policy</em> and returns <em>bool</em> otherwise. The <em>is_sorted</em> algorithm returns a bool if each element in the sequence [first, last) satisfies the predicate passed. If the range [first, last) contains less than two elements, the function always returns true. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v115is_sorted_untilERR8ExPolicy7FwdIter7FwdIterRR4Pred">
<span id="_CPPv2N3hpx8parallel2v115is_sorted_untilERR8ExPolicy7FwdIter7FwdIterRR4Pred"></span><span id="hpx::parallel::v1::is_sorted_until__ExPolicyRR.FwdIter.FwdIter.PredRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> Pred = detail::less&gt;<br /><span class="target" id="is__sorted_8hpp_1a7d8bc0647f16619906d600d112b2a06a"></span><a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::enable_if&lt;<a class="reference internal" href="../compute/api.html#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="../execution/api.html#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type&gt;::type <code class="descname">is_sorted_until</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, Pred &amp;&amp;<em>pred</em> = Pred()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v115is_sorted_untilERR8ExPolicy7FwdIter7FwdIterRR4Pred" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the first element in the range [first, last) that is not sorted. Uses a predicate to compare elements or the less than operator.</p>
<p><p>The comparison operations in the parallel </p>
<em>is_sorted_until</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> executes in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: at most (N+S-1) comparisons where <em>N</em> = distance(first, last). <em>S</em> = number of partitions</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used for the This iterator type must meet the requirements of a forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <em>is_sorted_until</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::less&lt;&gt;</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements of that the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements of that the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">pred</span></code>: Refers to the binary predicate which returns true if the first argument should be treated as less than the second argument. The signature of the function should be equivalent to <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that objects of types <em>FwdIter</em> can be dereferenced and then implicitly converted to Type.</li>
</ul>
</dd>
</dl>
</p>
<p>The comparison operations in the parallel <em>is_sorted_until</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>is_sorted_until</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>task_execution_policy</em> and returns <em>FwdIter</em> otherwise. The <em>is_sorted_until</em> algorithm returns the first unsorted element. If the sequence has less than two elements or the sequence is sorted, last is returned. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-reduce-by-key-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/reduce_by_key.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-reduce-by-key-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v113reduce_by_keyERR8ExPolicy7RanIter7RanIter8RanIter28FwdIter18FwdIter2RR7CompareRR4Func">
<span id="_CPPv2N3hpx8parallel2v113reduce_by_keyERR8ExPolicy7RanIter7RanIter8RanIter28FwdIter18FwdIter2RR7CompareRR4Func"></span><span id="hpx::parallel::v1::reduce_by_key__ExPolicyRR.RanIter.RanIter.RanIter2.FwdIter1.FwdIter2.CompareRR.FuncRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> RanIter, <em class="property">typename</em> RanIter2, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> Compare = std::equal_to&lt;typename std::iterator_traits&lt;RanIter&gt;::value_type&gt;, <em class="property">typename</em> Func = std::plus&lt;typename std::iterator_traits&lt;RanIter2&gt;::value_type&gt;&gt;<br /><span class="target" id="reduce__by__key_8hpp_1adce74d6b4153229567a969e16a738183"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::pair&lt;FwdIter1, FwdIter2&gt;&gt;::type <code class="descname">reduce_by_key</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, RanIter <em>key_first</em>, RanIter <em>key_last</em>, RanIter2 <em>values_first</em>, FwdIter1 <em>keys_output</em>, FwdIter2 <em>values_output</em>, Compare &amp;&amp;<em>comp</em> = Compare(), Func &amp;&amp;<em>func</em> = Func()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v113reduce_by_keyERR8ExPolicy7RanIter7RanIter8RanIter28FwdIter18FwdIter2RR7CompareRR4Func" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Reduce by Key performs an inclusive scan reduction operation on elements supplied in key/value pairs. The algorithm produces a single output value for each set of equal consecutive keys in [key_first, key_last). the value being the GENERALIZED_NONCOMMUTATIVE_SUM(op, init, *first, …, *(first + (i - result))). for the run of consecutive matching keys. The number of keys supplied must match the number of values.</p>
<p><em>comp</em> has to induce a strict weak ordering on the values.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: O(<em>last</em> - <em>first</em>) applications of the predicate <em>op</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </li>
<li><code class="docutils literal notranslate"><span class="pre">RanIter</span></code>: The type of the key iterators used (deduced). This iterator type must meet the requirements of a random access iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">RanIter2</span></code>: The type of the value iterators used (deduced). This iterator type must meet the requirements of a random access iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the iterator representing the destination key range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination value range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Compare</span></code>: The type of the optional function/function object to use to compare keys (deduced). Assumed to be std::equal_to otherwise. </li>
<li><code class="docutils literal notranslate"><span class="pre">Func</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>copy_if</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">key_first</span></code>: Refers to the beginning of the sequence of key elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">key_last</span></code>: Refers to the end of the sequence of key elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">values_first</span></code>: Refers to the beginning of the sequence of value elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">keys_output</span></code>: Refers to the start output location for the keys produced by the algorithm. </li>
<li><code class="docutils literal notranslate"><span class="pre">values_output</span></code>: Refers to the start output location for the values produced by the algorithm. </li>
<li><code class="docutils literal notranslate"><span class="pre">comp</span></code>: comp is a callable object. The return value of the INVOKE operation applied to an object of type Comp, when contextually converted to bool, yields true if the first argument of the call is less than the second, and false otherwise. It is assumed that comp will not apply any non-constant function through the dereferenced iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">func</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). This is a binary predicate. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ret</span> <span class="nf">fun</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;. The types </p>
<em>Type1</em> <em>Ret</em> must be such that an object of type <em>FwdIter</em> can be dereferenced and then implicitly converted to any of those types.</li>
</ul>
</dd>
</dl>
</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>reduce_by_key</em> algorithm returns a <em>hpx::future&lt;pair&lt;Iter1,Iter2&gt;&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>pair&lt;Iter1,Iter2&gt;</em> otherwise. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-fill-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/fill.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-fill-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v14fillERR8ExPolicy7FwdIter7FwdIter1T">
<span id="_CPPv2N3hpx8parallel2v14fillERR8ExPolicy7FwdIter7FwdIter1T"></span><span id="hpx::parallel::v1::fill__ExPolicyRR.FwdIter.FwdIter.T"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> T&gt;<br /><span class="target" id="algorithms_2fill_8hpp_1ab171416328f41cfba30983f0ed87d857"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy&gt;::type <code class="descname">fill</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, T <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v14fillERR8ExPolicy7FwdIter7FwdIter1T" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assigns the given value to the elements in the range [first, last).</p>
<p><p>The comparisons in the parallel </p>
<em>fill</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>last</em> - <em>first</em> assignments.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the value to be assigned (deduced).</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">value</span></code>: The value to be assigned.</li>
</ul>
</dd>
</dl>
</p>
<p>The comparisons in the parallel <em>fill</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>fill</em> algorithm returns a <em>hpx::future&lt;void&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>difference_type</em> otherwise (where <em>difference_type</em> is defined by <em>void</em>. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v16fill_nERR8ExPolicy7FwdIter4Size1T">
<span id="_CPPv2N3hpx8parallel2v16fill_nERR8ExPolicy7FwdIter4Size1T"></span><span id="hpx::parallel::v1::fill_n__ExPolicyRR.FwdIter.Size.T"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> Size, <em class="property">typename</em> T&gt;<br /><span class="target" id="algorithms_2fill_8hpp_1a7af4288c99d46acbc017b1f8e7ef7ac8"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type <code class="descname">fill_n</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, Size <em>count</em>, T <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v16fill_nERR8ExPolicy7FwdIter4Size1T" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assigns the given value value to the first count elements in the range beginning at first if count &gt; 0. Does nothing otherwise.</p>
<p><p>The comparisons in the parallel </p>
<em>fill_n</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>count</em> assignments, for count &gt; 0.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an output iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Size</span></code>: The type of the argument specifying the number of elements to apply <em>f</em> to. </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the value to be assigned (deduced).</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">count</span></code>: Refers to the number of elements starting at <em>first</em> the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">value</span></code>: The value to be assigned.</li>
</ul>
</dd>
</dl>
</p>
<p>The comparisons in the parallel <em>fill_n</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>fill_n</em> algorithm returns a <em>hpx::future&lt;void&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>difference_type</em> otherwise (where <em>difference_type</em> is defined by <em>void</em>. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-transform-inclusive-scan-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/transform_inclusive_scan.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-transform-inclusive-scan-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v124transform_inclusive_scanERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR2OpRR4Conv1T">
<span id="_CPPv2N3hpx8parallel2v124transform_inclusive_scanERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR2OpRR4Conv1T"></span><span id="hpx::parallel::v1::transform_inclusive_scan__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.OpRR.ConvRR.T"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> Op, <em class="property">typename</em> Conv, <em class="property">typename</em> T&gt;<br /><span class="target" id="transform__inclusive__scan_8hpp_1afa7b5c6696fe051a8871ee813c88c255"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter2&gt;::type <code class="descname">transform_inclusive_scan</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, FwdIter1 <em>last</em>, FwdIter2 <em>dest</em>, Op &amp;&amp;<em>op</em>, Conv &amp;&amp;<em>conv</em>, T <em>init</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v124transform_inclusive_scanERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR2OpRR4Conv1T" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assigns through each iterator <em>i</em> in [result, result + (last - first)) the value of GENERALIZED_NONCOMMUTATIVE_SUM(op, init, conv(*first), …, conv(*(first + (i - result)))).</p>
<p><p>The reduce operations in the parallel </p>
<em>transform_inclusive_scan</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: O(<em>last</em> - <em>first</em>) applications of the predicate <em>op</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Conv</span></code>: The type of the unary function object used for the conversion operation. </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the value to be used as initial (and intermediate) values (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">Op</span></code>: The type of the binary function object used for the reduction operation.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">conv</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). This is a unary predicate. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">R</span> <span class="nf">fun</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter1</em> can be dereferenced and then implicitly converted to Type. The type <em>R</em> must be such that an object of this type can be implicitly converted to <em>T</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">init</span></code>: The initial value for the generalized sum. </li>
<li><code class="docutils literal notranslate"><span class="pre">op</span></code>: Specifies the function (or function object) which will be invoked for each of the values of the input sequence. This is a binary predicate. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ret</span> <span class="nf">fun</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> and <em>Ret</em> must be such that an object of a type as given by the input sequence can be implicitly converted to any of those types.</li>
</ul>
</dd>
</dl>
</p>
<p>The reduce operations in the parallel <em>transform_inclusive_scan</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><p>Neither </p>
<em>conv</em> nor <em>op</em> shall invalidate iterators or subranges, or modify elements in the ranges [first,last) or [result,result + (last - first)).<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>copy_n</em> algorithm returns a <em>hpx::future&lt;FwdIter2&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter2</em> otherwise. The <em>transform_inclusive_scan</em> algorithm returns the output iterator to the element in the destination range, one past the last element copied.</dd>
<dt><strong>Note</strong></dt>
<dd>GENERALIZED_NONCOMMUTATIVE_SUM(op, a1, …, aN) is defined as:<ul class="simple">
<li>a1 when N is 1</li>
<li>op(GENERALIZED_NONCOMMUTATIVE_SUM(op, a1, …, aK), GENERALIZED_NONCOMMUTATIVE_SUM(op, aM, …, aN)) where 1 &lt; K+1 = M &lt;= N.</li>
</ul>
</dd>
</dl>
</p>
<p>The difference between <em>exclusive_scan</em> and <em>transform_inclusive_scan</em> is that <em>transform_inclusive_scan</em> includes the ith input element in the ith sum. If <em>op</em> is not mathematically associative, the behavior of <em>transform_inclusive_scan</em> may be non-deterministic. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v124transform_inclusive_scanERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR2OpRR4Conv">
<span id="_CPPv2N3hpx8parallel2v124transform_inclusive_scanERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR2OpRR4Conv"></span><span id="hpx::parallel::v1::transform_inclusive_scan__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.OpRR.ConvRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> Conv, <em class="property">typename</em> Op&gt;<br /><span class="target" id="transform__inclusive__scan_8hpp_1a9485c4191609660bd226d64a7d53df78"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter2&gt;::type <code class="descname">transform_inclusive_scan</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, FwdIter1 <em>last</em>, FwdIter2 <em>dest</em>, Op &amp;&amp;<em>op</em>, Conv &amp;&amp;<em>conv</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v124transform_inclusive_scanERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR2OpRR4Conv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assigns through each iterator <em>i</em> in [result, result + (last - first)) the value of GENERALIZED_NONCOMMUTATIVE_SUM(op, conv(*first), …, conv(*(first + (i - result)))).</p>
<p><p>The reduce operations in the parallel </p>
<em>transform_inclusive_scan</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: O(<em>last</em> - <em>first</em>) applications of the predicate <em>op</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Conv</span></code>: The type of the unary function object used for the conversion operation. </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the value to be used as initial (and intermediate) values (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">Op</span></code>: The type of the binary function object used for the reduction operation.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">conv</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). This is a unary predicate. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">R</span> <span class="nf">fun</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter1</em> can be dereferenced and then implicitly converted to Type. The type <em>R</em> must be such that an object of this type can be implicitly converted to <em>T</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">op</span></code>: Specifies the function (or function object) which will be invoked for each of the values of the input sequence. This is a binary predicate. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ret</span> <span class="nf">fun</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> and <em>Ret</em> must be such that an object of a type as given by the input sequence can be implicitly converted to any of those types.</li>
</ul>
</dd>
</dl>
</p>
<p>The reduce operations in the parallel <em>transform_inclusive_scan</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><p>Neither </p>
<em>conv</em> nor <em>op</em> shall invalidate iterators or subranges, or modify elements in the ranges [first,last) or [result,result + (last - first)).<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>copy_n</em> algorithm returns a <em>hpx::future&lt;FwdIter2&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter2</em> otherwise. The <em>transform_inclusive_scan</em> algorithm returns the output iterator to the element in the destination range, one past the last element copied.</dd>
<dt><strong>Note</strong></dt>
<dd>GENERALIZED_NONCOMMUTATIVE_SUM(op, a1, …, aN) is defined as:<ul class="simple">
<li>a1 when N is 1</li>
<li>op(GENERALIZED_NONCOMMUTATIVE_SUM(op, a1, …, aK), GENERALIZED_NONCOMMUTATIVE_SUM(op, aM, …, aN)) where 1 &lt; K+1 = M &lt;= N.</li>
</ul>
</dd>
</dl>
</p>
<p>The difference between <em>exclusive_scan</em> and <em>transform_inclusive_scan</em> is that <em>transform_inclusive_scan</em> includes the ith input element in the ith sum. </p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-adjacent-find-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/adjacent_find.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-adjacent-find-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v113adjacent_findERR8ExPolicy7FwdIter7FwdIterRR4Pred">
<span id="_CPPv2N3hpx8parallel2v113adjacent_findERR8ExPolicy7FwdIter7FwdIterRR4Pred"></span><span id="hpx::parallel::v1::adjacent_find__ExPolicyRR.FwdIter.FwdIter.PredRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> Pred = detail::equal_to&gt;<br /><span class="target" id="adjacent__find_8hpp_1a90f0b00afac12ea23528d7222d23dbfd"></span><a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::enable_if&lt;<a class="reference internal" href="../compute/api.html#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="../execution/api.html#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type&gt;::type <code class="descname">adjacent_find</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, Pred &amp;&amp;<em>op</em> = Pred()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v113adjacent_findERR8ExPolicy7FwdIter7FwdIterRR4Pred" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Searches the range [first, last) for two consecutive identical elements. This version uses the given binary predicate op</p>
<p><p>The comparison operations in the parallel </p>
<em>adjacent_find</em> invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Exactly the smaller of (result - first) + 1 and (last - first) - 1 application of the predicate where <em>result</em> is the value returned</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used for the range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <em>adjacent_find</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::equal_to&lt;&gt;</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements of the range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements of the range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">op</span></code>: The binary predicate which returns <em>true</em> if the elements should be treated as equal. The signature should be equivalent to the following: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> must be such that objects of type <em>FwdIter</em> can be dereferenced and then implicitly converted to <em>Type1</em> .</li>
</ul>
</dd>
</dl>
</p>
<p>The comparison operations in the parallel <em>adjacent_find</em> invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><p>This overload of </p>
<em>adjacent_find</em> is available if the user decides to provide their algorithm their own binary predicate <em>op</em>. <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>adjacent_find</em> algorithm returns a <em>hpx::future&lt;InIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>InIter</em> otherwise. The <em>adjacent_find</em> algorithm returns an iterator to the first of the identical elements. If no such elements are found, <em>last</em> is returned.</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-set-intersection-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/set_intersection.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-set-intersection-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v116set_intersectionERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter28FwdIter3RR4Pred">
<span id="_CPPv2N3hpx8parallel2v116set_intersectionERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter28FwdIter3RR4Pred"></span><span id="hpx::parallel::v1::set_intersection__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.FwdIter2.FwdIter3.PredRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> FwdIter3, <em class="property">typename</em> Pred = detail::less&gt;<br /><span class="target" id="set__intersection_8hpp_1aba58249e4f7f172217b60bcaed6dd23a"></span><a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::enable_if&lt;<a class="reference internal" href="../compute/api.html#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="../execution/api.html#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter3&gt;::type&gt;::type <code class="descname">set_intersection</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first1</em>, FwdIter1 <em>last1</em>, FwdIter2 <em>first2</em>, FwdIter2 <em>last2</em>, FwdIter3 <em>dest</em>, Pred &amp;&amp;<em>op</em> = Pred()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v116set_intersectionERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter28FwdIter3RR4Pred" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructs a sorted range beginning at dest consisting of all elements present in both sorted ranges [first1, last1) and [first2, last2). This algorithm expects both input ranges to be sorted with the given binary predicate <em>f</em>.</p>
<p><p>If some element is found </p>
<em>m</em> times in [first1, last1) and <em>n</em> times in [first2, last2), the first std::min(m, n) elements will be copied from the first range to the destination range. The order of equivalent elements is preserved. The resulting range cannot overlap with either of the input ranges.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: At most 2*(N1 + N2 - 1) comparisons, where <em>N1</em> is the length of the first sequence and <em>N2</em> is the length of the second sequence.</dd>
</dl>
</p>
<p>The resulting range cannot overlap with either of the input ranges.</p>
<p><p>The application of function objects in parallel algorithm invoked with a sequential execution policy object execute in sequential order in the calling thread (</p>
<em>sequenced_policy</em>) or in a single new thread spawned from the current thread (for <em>sequenced_task_policy</em>).<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced) representing the first sequence. This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the source iterators used (deduced) representing the first sequence. This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter3</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an output iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <em>set_intersection</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::less&lt;&gt;</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first1</span></code>: Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last1</span></code>: Refers to the end of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">first2</span></code>: Refers to the beginning of the sequence of elements of the second range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last2</span></code>: Refers to the end of the sequence of elements of the second range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">op</span></code>: The binary predicate which returns true if the elements should be treated as equal. The signature of the predicate function should be equivalent to the following: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type1</em> must be such that objects of type <em>InIter</em> can be dereferenced and then implicitly converted to <em>Type1</em> </li>
</ul>
</dd>
</dl>
</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>set_intersection</em> algorithm returns a <em>hpx::future&lt;FwdIter3&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter3</em> otherwise. The <em>set_intersection</em> algorithm returns the output iterator to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-sort-by-key-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/sort_by_key.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-sort-by-key-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v111sort_by_keyERR8ExPolicy7KeyIter7KeyIter9ValueIterRR7Compare">
<span id="_CPPv2N3hpx8parallel2v111sort_by_keyERR8ExPolicy7KeyIter7KeyIter9ValueIterRR7Compare"></span><span id="hpx::parallel::v1::sort_by_key__ExPolicyRR.KeyIter.KeyIter.ValueIter.CompareRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> KeyIter, <em class="property">typename</em> ValueIter, <em class="property">typename</em> Compare = detail::less&gt;<br /><span class="target" id="sort__by__key_8hpp_1a48674d2e8f63432a32a397d6a7008966"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::in1<span class="sig-paren">(</span>KeyIter<span class="sig-paren">)</span>, tag::in2<span class="sig-paren">(</span>ValueIter<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">sort_by_key</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, KeyIter <em>key_first</em>, KeyIter <em>key_last</em>, ValueIter <em>value_first</em>, Compare &amp;&amp;<em>comp</em> = Compare()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v111sort_by_keyERR8ExPolicy7KeyIter7KeyIter9ValueIterRR7Compare" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Sorts one range of data using keys supplied in another range. The key elements in the range [key_first, key_last) are sorted in ascending order with the corresponding elements in the value range moved to follow the sorted order. The algorithm is not stable, the order of equal elements is not guaranteed to be preserved. The function uses the given comparison function object comp (defaults to using operator&lt;()).</p>
<p><p>A sequence is sorted with respect to a comparator </p>
<em>comp</em> and a projection <em>proj</em> if for every iterator i pointing to the sequence and every non-negative integer n such that i + n is a valid iterator pointing to an element of the sequence, and INVOKE(comp, INVOKE(proj, *(i + n)), INVOKE(proj, *i)) == false.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: O(Nlog(N)), where N = std::distance(first, last) comparisons.</dd>
</dl>
</p>
<p><em>comp</em> has to induce a strict weak ordering on the values.<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </li>
<li><code class="docutils literal notranslate"><span class="pre">KeyIter</span></code>: The type of the key iterators used (deduced). This iterator type must meet the requirements of a random access iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueIter</span></code>: The type of the value iterators used (deduced). This iterator type must meet the requirements of a random access iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Comp</span></code>: The type of the function/function object to use (deduced).</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">key_first</span></code>: Refers to the beginning of the sequence of key elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">key_last</span></code>: Refers to the end of the sequence of key elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">value_first</span></code>: Refers to the beginning of the sequence of value elements the algorithm will be applied to, the range of elements must match [key_first, key_last) </li>
<li><code class="docutils literal notranslate"><span class="pre">comp</span></code>: comp is a callable object. The return value of the INVOKE operation applied to an object of type Comp, when contextually converted to bool, yields true if the first argument of the call is less than the second, and false otherwise. It is assumed that comp will not apply any non-constant function through the dereferenced iterator.</li>
</ul>
</dd>
</dl>
</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>sort_by-key</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::in1(KeyIter&gt;</em>, tag::in2(ValueIter)&gt; &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em> otherwise</em>. The algorithm returns a pair holding an iterator pointing to the first element after the last element in the input key sequence and an iterator pointing to the first element after the last element in the input value sequence. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-swap-ranges-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/swap_ranges.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-swap-ranges-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v111swap_rangesERR8ExPolicy8FwdIter18FwdIter18FwdIter2">
<span id="_CPPv2N3hpx8parallel2v111swap_rangesERR8ExPolicy8FwdIter18FwdIter18FwdIter2"></span><span id="hpx::parallel::v1::swap_ranges__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2&gt;<br /><span class="target" id="swap__ranges_8hpp_1a9cf83d419e1017163cf32cb72b52d4d3"></span><a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::enable_if&lt;<a class="reference internal" href="../compute/api.html#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="../execution/api.html#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter2&gt;::type&gt;::type <code class="descname">swap_ranges</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first1</em>, FwdIter1 <em>last1</em>, FwdIter2 <em>first2</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v111swap_rangesERR8ExPolicy8FwdIter18FwdIter18FwdIter2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Exchanges elements between range [first1, last1) and another range starting at <em>first2</em>.</p>
<p><p>The swap operations in the parallel </p>
<em>swap_ranges</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Linear in the distance between <em>first1</em> and <em>last1</em> </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the swap operations. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the first range of iterators to swap (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the second range of iterators to swap (deduced). This iterator type must meet the requirements of an forward iterator.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first1</span></code>: Refers to the beginning of the first sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last1</span></code>: Refers to the end of the first sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">first2</span></code>: Refers to the beginning of the second sequence of elements the algorithm will be applied to.</li>
</ul>
</dd>
</dl>
</p>
<p>The swap operations in the parallel <em>swap_ranges</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>swap_ranges</em> algorithm returns a <em>hpx::future&lt;FwdIter2&gt;</em> if the execution policy is of type <em>parallel_task_policy</em> and returns <em>FwdIter2</em> otherwise. The <em>swap_ranges</em> algorithm returns iterator to the element past the last element exchanged in the range beginning with <em>first2</em>. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-uninitialized-default-construct-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/uninitialized_default_construct.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-uninitialized-default-construct-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v131uninitialized_default_constructERR8ExPolicy7FwdIter7FwdIter">
<span id="_CPPv2N3hpx8parallel2v131uninitialized_default_constructERR8ExPolicy7FwdIter7FwdIter"></span><span id="hpx::parallel::v1::uninitialized_default_construct__ExPolicyRR.FwdIter.FwdIter"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter&gt;<br /><span class="target" id="uninitialized__default__construct_8hpp_1a0d3350b1ae15721218ff2578988fb3f6"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy&gt;::type <code class="descname">uninitialized_default_construct</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v131uninitialized_default_constructERR8ExPolicy7FwdIter7FwdIter" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructs objects of type typename iterator_traits&lt;ForwardIt&gt;::value_type in the uninitialized storage designated by the range [first, last) by default-initialization. If an exception is thrown during the initialization, the function has no effects.</p>
<p><p>The assignments in the parallel </p>
<em>uninitialized_default_construct</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>last</em> - <em>first</em> assignments.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>uninitialized_default_construct</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>uninitialized_default_construct</em> algorithm returns a <em>hpx::future&lt;void&gt;</em>, if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>void</em> otherwise. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v133uninitialized_default_construct_nERR8ExPolicy7FwdIter4Size">
<span id="_CPPv2N3hpx8parallel2v133uninitialized_default_construct_nERR8ExPolicy7FwdIter4Size"></span><span id="hpx::parallel::v1::uninitialized_default_construct_n__ExPolicyRR.FwdIter.Size"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> Size&gt;<br /><span class="target" id="uninitialized__default__construct_8hpp_1a2090d59706bbdecf6463dc8419d94d7b"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type <code class="descname">uninitialized_default_construct_n</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, Size <em>count</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v133uninitialized_default_construct_nERR8ExPolicy7FwdIter4Size" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructs objects of type typename iterator_traits&lt;ForwardIt&gt;::value_type in the uninitialized storage designated by the range [first, first + count) by default-initialization. If an exception is thrown during the initialization, the function has no effects.</p>
<p><p>The assignments in the parallel </p>
<em>uninitialized_default_construct_n</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>count</em> assignments, if count &gt; 0, no assignments otherwise.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Size</span></code>: The type of the argument specifying the number of elements to apply <em>f</em> to.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">count</span></code>: Refers to the number of elements starting at <em>first</em> the algorithm will be applied to.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>uninitialized_default_construct_n</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>uninitialized_default_construct_n</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter</em> otherwise. The <em>uninitialized_default_construct_n</em> algorithm returns the iterator to the element in the source range, one past the last element constructed. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-merge-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/merge.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-merge-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v15mergeERR8ExPolicy9RandIter19RandIter19RandIter29RandIter29RandIter3RR4CompRR5Proj1RR5Proj2">
<span id="_CPPv2N3hpx8parallel2v15mergeERR8ExPolicy9RandIter19RandIter19RandIter29RandIter29RandIter3RR4CompRR5Proj1RR5Proj2"></span><span id="hpx::parallel::v1::merge__ExPolicyRR.RandIter1.RandIter1.RandIter2.RandIter2.RandIter3.CompRR.Proj1RR.Proj2RR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> RandIter1, <em class="property">typename</em> RandIter2, <em class="property">typename</em> RandIter3, <em class="property">typename</em> Comp = detail::less, <em class="property">typename</em> Proj1 = util::projection_identity, <em class="property">typename</em> Proj2 = util::projection_identity&gt;<br /><span class="target" id="algorithms_2merge_8hpp_1aa6a4a9f5ad1b481db644e0abb3e904d8"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_tuple&lt;tag::in1<span class="sig-paren">(</span>RandIter1<span class="sig-paren">)</span>, tag::in2<span class="sig-paren">(</span>RandIter2<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>RandIter3<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">merge</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, RandIter1 <em>first1</em>, RandIter1 <em>last1</em>, RandIter2 <em>first2</em>, RandIter2 <em>last2</em>, RandIter3 <em>dest</em>, Comp &amp;&amp;<em>comp</em> = Comp(), Proj1 &amp;&amp;<em>proj1</em> = Proj1(), Proj2 &amp;&amp;<em>proj2</em> = Proj2()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v15mergeERR8ExPolicy9RandIter19RandIter19RandIter29RandIter29RandIter3RR4CompRR5Proj1RR5Proj2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Merges two sorted ranges [first1, last1) and [first2, last2) into one sorted range beginning at <em>dest</em>. The order of equivalent elements in the each of original two ranges is preserved. For equivalent elements in the original two ranges, the elements from the first range precede the elements from the second range. The destination range cannot overlap with either of the input ranges.</p>
<p><p>The assignments in the parallel </p>
<em>merge</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs O(std::distance(first1, last1) + std::distance(first2, last2)) applications of the comparison <em>comp</em> and the each projection.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">RandIter1</span></code>: The type of the source iterators used (deduced) representing the first sorted range. This iterator type must meet the requirements of an random access iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">RandIter2</span></code>: The type of the source iterators used (deduced) representing the second sorted range. This iterator type must meet the requirements of an random access iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">RandIter3</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an random access iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Comp</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>merge</em> requires <em>Comp</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::less&lt;&gt; </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj1</span></code>: The type of an optional projection function to be used for elements of the first range. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj2</span></code>: The type of an optional projection function to be used for elements of the second range. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first1</span></code>: Refers to the beginning of the first range of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last1</span></code>: Refers to the end of the first range of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">first2</span></code>: Refers to the beginning of the second range of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last2</span></code>: Refers to the end of the second range of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">comp</span></code>: <em>comp</em> is a callable object which returns true if the first argument is less than the second, and false otherwise. The signature of this comparison should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">comp</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type2</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> and <em>Type2</em> must be such that objects of types <em>RandIter1</em> and <em>RandIter2</em> can be dereferenced and then implicitly converted to both <em>Type1</em> and <em>Type2</em> </li>
<li><code class="docutils literal notranslate"><span class="pre">proj1</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of the first range as a projection operation before the actual comparison <em>comp</em> is invoked. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj2</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of the second range as a projection operation before the actual comparison <em>comp</em> is invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>merge</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>merge</em> algorithm returns a <em>hpx::future&lt;tagged_tuple&lt;tag::in1(RandIter1), tag::in2(RandIter2), tag::out(RandIter3)&gt;</em> &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>tagged_tuple&lt;tag::in1(RandIter1), tag::in2(RandIter2), tag::out(RandIter3)&gt;</em> otherwise. The <em>merge</em> algorithm returns the tuple of the source iterator <em>last1</em>, the source iterator <em>last2</em>, the destination iterator to the end of the <em>dest</em> range. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v113inplace_mergeERR8ExPolicy8RandIter8RandIter8RandIterRR4CompRR4Proj">
<span id="_CPPv2N3hpx8parallel2v113inplace_mergeERR8ExPolicy8RandIter8RandIter8RandIterRR4CompRR4Proj"></span><span id="hpx::parallel::v1::inplace_merge__ExPolicyRR.RandIter.RandIter.RandIter.CompRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> RandIter, <em class="property">typename</em> Comp = detail::less, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="algorithms_2merge_8hpp_1a24b9c903cb9f330126ea35ebb42d3bbf"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, RandIter&gt;::type <code class="descname">inplace_merge</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, RandIter <em>first</em>, RandIter <em>middle</em>, RandIter <em>last</em>, Comp &amp;&amp;<em>comp</em> = Comp(), Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v113inplace_mergeERR8ExPolicy8RandIter8RandIter8RandIterRR4CompRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Merges two consecutive sorted ranges [first, middle) and [middle, last) into one sorted range [first, last). The order of equivalent elements in the each of original two ranges is preserved. For equivalent elements in the original two ranges, the elements from the first range precede the elements from the second range.</p>
<p><p>The assignments in the parallel </p>
<em>inplace_merge</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs O(std::distance(first, last)) applications of the comparison <em>comp</em> and the each projection.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">RandIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an random access iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Comp</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>inplace_merge</em> requires <em>Comp</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::less&lt;&gt; </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the first sorted range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">middle</span></code>: Refers to the end of the first sorted range and the beginning of the second sorted range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the second sorted range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">comp</span></code>: <em>comp</em> is a callable object which returns true if the first argument is less than the second, and false otherwise. The signature of this comparison should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">comp</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type2</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> and <em>Type2</em> must be such that objects of types <em>RandIter</em> can be dereferenced and then implicitly converted to both <em>Type1</em> and <em>Type2</em> </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>inplace_merge</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>inplace_merge</em> algorithm returns a <em>hpx::future&lt;RandIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>RandIter</em> otherwise. The <em>inplace_merge</em> algorithm returns the source iterator <em>last</em> </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-remove-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/remove.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-remove-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v19remove_ifERR8ExPolicy7FwdIter7FwdIterRR4PredRR4Proj">
<span id="_CPPv2N3hpx8parallel2v19remove_ifERR8ExPolicy7FwdIter7FwdIterRR4PredRR4Proj"></span><span id="hpx::parallel::v1::remove_if__ExPolicyRR.FwdIter.FwdIter.PredRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> Pred, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="algorithms_2remove_8hpp_1a1f02be393428751a709b52aa6ca83afc"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type <code class="descname">remove_if</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, Pred &amp;&amp;<em>pred</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v19remove_ifERR8ExPolicy7FwdIter7FwdIterRR4PredRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Removes all elements satisfying specific criteria from the range [first, last) and returns a past-the-end iterator for the new end of the range. This version removes all elements for which predicate <em>pred</em> returns true.</p>
<p><p>The assignments in the parallel </p>
<em>remove_if</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs not more than <em>last</em> - <em>first</em> assignments, exactly <em>last</em> - <em>first</em> applications of the predicate <em>pred</em> and the projection <em>proj</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>remove_if</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">pred</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is an unary predicate which returns <em>true</em> for the required elements. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter</em> can be dereferenced and then implicitly converted to Type. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>remove_if</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>remove_if</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter</em> otherwise. The <em>remove_if</em> algorithm returns the iterator to the new end of the range. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v16removeERR8ExPolicy7FwdIter7FwdIterR1TRR4Proj">
<span id="_CPPv2N3hpx8parallel2v16removeERR8ExPolicy7FwdIter7FwdIterR1TRR4Proj"></span><span id="hpx::parallel::v1::remove__ExPolicyRR.FwdIter.FwdIter.TCR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> T, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="algorithms_2remove_8hpp_1a835690a9df6672e020e0e62104da7344"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type <code class="descname">remove</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, T <em class="property">const</em> &amp;<em>value</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v16removeERR8ExPolicy7FwdIter7FwdIterR1TRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Removes all elements satisfying specific criteria from the range [first, last) and returns a past-the-end iterator for the new end of the range. This version removes all elements that are equal to <em>value</em>.</p>
<p><p>The assignments in the parallel </p>
<em>remove</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs not more than <em>last</em> - <em>first</em> assignments, exactly <em>last</em> - <em>first</em> applications of the operator==() and the projection <em>proj</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the value to remove (deduced). This value type must meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">value</span></code>: Specifies the value of elements to remove. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>remove</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>remove</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter</em> otherwise. The <em>remove</em> algorithm returns the iterator to the new end of the range. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-set-union-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/set_union.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-set-union-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v19set_unionERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter28FwdIter3RR4Pred">
<span id="_CPPv2N3hpx8parallel2v19set_unionERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter28FwdIter3RR4Pred"></span><span id="hpx::parallel::v1::set_union__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.FwdIter2.FwdIter3.PredRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> FwdIter3, <em class="property">typename</em> Pred = detail::less&gt;<br /><span class="target" id="set__union_8hpp_1a440b39f934897f0c7dd6c29484eb28cb"></span><a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::enable_if&lt;<a class="reference internal" href="../compute/api.html#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="../execution/api.html#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter3&gt;::type&gt;::type <code class="descname">set_union</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first1</em>, FwdIter1 <em>last1</em>, FwdIter2 <em>first2</em>, FwdIter2 <em>last2</em>, FwdIter3 <em>dest</em>, Pred &amp;&amp;<em>op</em> = Pred()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v19set_unionERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter28FwdIter3RR4Pred" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructs a sorted range beginning at dest consisting of all elements present in one or both sorted ranges [first1, last1) and [first2, last2). This algorithm expects both input ranges to be sorted with the given binary predicate <em>f</em>.</p>
<p><p>If some element is found </p>
<em>m</em> times in [first1, last1) and <em>n</em> times in [first2, last2), then all <em>m</em> elements will be copied from [first1, last1) to dest, preserving order, and then exactly std::max(n-m, 0) elements will be copied from [first2, last2) to dest, also preserving order.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: At most 2*(N1 + N2 - 1) comparisons, where <em>N1</em> is the length of the first sequence and <em>N2</em> is the length of the second sequence.</dd>
</dl>
</p>
<p>The resulting range cannot overlap with either of the input ranges.</p>
<p><p>The application of function objects in parallel algorithm invoked with a sequential execution policy object execute in sequential order in the calling thread (</p>
<em>sequenced_policy</em>) or in a single new thread spawned from the current thread (for <em>sequenced_task_policy</em>).<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced) representing the first sequence. This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the source iterators used (deduced) representing the first sequence. This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter3</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an output iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Op</span></code>: The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <em>set_union</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::less&lt;&gt;</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first1</span></code>: Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last1</span></code>: Refers to the end of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">first2</span></code>: Refers to the beginning of the sequence of elements of the second range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last2</span></code>: Refers to the end of the sequence of elements of the second range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">op</span></code>: The binary predicate which returns true if the elements should be treated as equal. The signature of the predicate function should be equivalent to the following: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type1</em> must be such that objects of type <em>InIter</em> can be dereferenced and then implicitly converted to <em>Type1</em> </li>
</ul>
</dd>
</dl>
</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>set_union</em> algorithm returns a <em>hpx::future&lt;FwdIter3&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter3</em> otherwise. The <em>set_union</em> algorithm returns the output iterator to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-minmax-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/minmax.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-minmax-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v111min_elementERR8ExPolicy7FwdIter7FwdIterRR1FRR4Proj">
<span id="_CPPv2N3hpx8parallel2v111min_elementERR8ExPolicy7FwdIter7FwdIterRR1FRR4Proj"></span><span id="hpx::parallel::v1::min_element__ExPolicyRR.FwdIter.FwdIter.FRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> Proj = util::projection_identity, <em class="property">typename</em> F = detail::less&gt;<br /><span class="target" id="algorithms_2minmax_8hpp_1a24dba382bbce6a2fb11fadf711656d95"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type <code class="descname">min_element</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, F &amp;&amp;<em>f</em> = F(), Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v111min_elementERR8ExPolicy7FwdIter7FwdIterRR1FRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Finds the smallest element in the range [first, last) using the given comparison function <em>f</em>.</p>
<p><p>The comparisons in the parallel </p>
<em>min_element</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Exactly <em>max</em>(N-1, 0) comparisons, where N = std::distance(first, last).</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of a forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>min_element</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: The binary predicate which returns true if the the left argument is less than the right element. The signature of the predicate function should be equivalent to the following: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type1</em> must be such that objects of type <em>FwdIter</em> can be dereferenced and then implicitly converted to <em>Type1</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The comparisons in the parallel <em>min_element</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>min_element</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter</em> otherwise. The <em>min_element</em> algorithm returns the iterator to the smallest element in the range [first, last). If several elements in the range are equivalent to the smallest element, returns the iterator to the first such element. Returns last if the range is empty. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v111max_elementERR8ExPolicy7FwdIter7FwdIterRR1FRR4Proj">
<span id="_CPPv2N3hpx8parallel2v111max_elementERR8ExPolicy7FwdIter7FwdIterRR1FRR4Proj"></span><span id="hpx::parallel::v1::max_element__ExPolicyRR.FwdIter.FwdIter.FRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> Proj = util::projection_identity, <em class="property">typename</em> F = detail::less&gt;<br /><span class="target" id="algorithms_2minmax_8hpp_1a624ca7fa873d5c8200717ab1f2c15e35"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type <code class="descname">max_element</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, F &amp;&amp;<em>f</em> = F(), Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v111max_elementERR8ExPolicy7FwdIter7FwdIterRR1FRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Finds the greatest element in the range [first, last) using the given comparison function <em>f</em>.</p>
<p><p>The comparisons in the parallel </p>
<em>max_element</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Exactly <em>max</em>(N-1, 0) comparisons, where N = std::distance(first, last).</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of a forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>max_element</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: The binary predicate which returns true if the This argument is optional and defaults to std::less. the left argument is less than the right element. The signature of the predicate function should be equivalent to the following: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type1</em> must be such that objects of type <em>FwdIter</em> can be dereferenced and then implicitly converted to <em>Type1</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The comparisons in the parallel <em>max_element</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>max_element</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter</em> otherwise. The <em>max_element</em> algorithm returns the iterator to the smallest element in the range [first, last). If several elements in the range are equivalent to the smallest element, returns the iterator to the first such element. Returns last if the range is empty. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v114minmax_elementERR8ExPolicy7FwdIter7FwdIterRR1FRR4Proj">
<span id="_CPPv2N3hpx8parallel2v114minmax_elementERR8ExPolicy7FwdIter7FwdIterRR1FRR4Proj"></span><span id="hpx::parallel::v1::minmax_element__ExPolicyRR.FwdIter.FwdIter.FRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> Proj = util::projection_identity, <em class="property">typename</em> F = detail::less&gt;<br /><span class="target" id="algorithms_2minmax_8hpp_1a754e86f3910112fd23d3141d503ab5f5"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::min<span class="sig-paren">(</span>FwdIter<span class="sig-paren">)</span>, tag::max<span class="sig-paren">(</span>FwdIter<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">minmax_element</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, F &amp;&amp;<em>f</em> = F(), Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v114minmax_elementERR8ExPolicy7FwdIter7FwdIterRR1FRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Finds the greatest element in the range [first, last) using the given comparison function <em>f</em>.</p>
<p><p>The comparisons in the parallel </p>
<em>minmax_element</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: At most <em>max</em>(floor(3/2*(N-1)), 0) applications of the predicate, where N = std::distance(first, last).</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of a forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>minmax_element</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: The binary predicate which returns true if the the left argument is less than the right element. This argument is optional and defaults to std::less. The signature of the predicate function should be equivalent to the following: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type1</em> must be such that objects of type <em>FwdIter</em> can be dereferenced and then implicitly converted to <em>Type1</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The comparisons in the parallel <em>minmax_element</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>minmax_element</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::min(FwdIter), tag::max(FwdIter)&gt;</em> &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::min(FwdIter), tag::max(FwdIter)&gt;</em> otherwise. The <em>minmax_element</em> algorithm returns a pair consisting of an iterator to the smallest element as the first element and an iterator to the greatest element as the second. Returns std::make_pair(first, first) if the range is empty. If several elements are equivalent to the smallest element, the iterator to the first such element is returned. If several elements are equivalent to the largest element, the iterator to the last such element is returned. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-set-difference-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/set_difference.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-set-difference-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v114set_differenceERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter28FwdIter3RR4Pred">
<span id="_CPPv2N3hpx8parallel2v114set_differenceERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter28FwdIter3RR4Pred"></span><span id="hpx::parallel::v1::set_difference__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.FwdIter2.FwdIter3.PredRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> FwdIter3, <em class="property">typename</em> Pred = detail::less&gt;<br /><span class="target" id="set__difference_8hpp_1a6b4dce8f6ba81c0351cfcce51c9c924b"></span><a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::enable_if&lt;<a class="reference internal" href="../compute/api.html#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="../execution/api.html#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter3&gt;::type&gt;::type <code class="descname">set_difference</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first1</em>, FwdIter1 <em>last1</em>, FwdIter2 <em>first2</em>, FwdIter2 <em>last2</em>, FwdIter3 <em>dest</em>, Pred &amp;&amp;<em>op</em> = Pred()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v114set_differenceERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter28FwdIter3RR4Pred" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructs a sorted range beginning at dest consisting of all elements present in the range [first1, last1) and not present in the range [first2, last2). This algorithm expects both input ranges to be sorted with the given binary predicate <em>f</em>.</p>
<p><p>Equivalent elements are treated individually, that is, if some element is found </p>
<em>m</em> times in [first1, last1) and <em>n</em> times in [first2, last2), it will be copied to <em>dest</em> exactly std::max(m-n, 0) times. The resulting range cannot overlap with either of the input ranges.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: At most 2*(N1 + N2 - 1) comparisons, where <em>N1</em> is the length of the first sequence and <em>N2</em> is the length of the second sequence.</dd>
</dl>
</p>
<p>The resulting range cannot overlap with either of the input ranges.</p>
<p><p>The application of function objects in parallel algorithm invoked with a sequential execution policy object execute in sequential order in the calling thread (</p>
<em>sequenced_policy</em>) or in a single new thread spawned from the current thread (for <em>sequenced_task_policy</em>).<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced) representing the first sequence. This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the source iterators used (deduced) representing the first sequence. This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter3</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an output iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <em>set_difference</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::less&lt;&gt;</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first1</span></code>: Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last1</span></code>: Refers to the end of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">first2</span></code>: Refers to the beginning of the sequence of elements of the second range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last2</span></code>: Refers to the end of the sequence of elements of the second range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">op</span></code>: The binary predicate which returns true if the elements should be treated as equal. The signature of the predicate function should be equivalent to the following: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type1</em> must be such that objects of type <em>InIter</em> can be dereferenced and then implicitly converted to <em>Type1</em> </li>
</ul>
</dd>
</dl>
</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>set_difference</em> algorithm returns a <em>hpx::future&lt;FwdIter3&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter3</em> otherwise. The <em>set_difference</em> algorithm returns the output iterator to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-for-loop-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/for_loop.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-for-loop-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt id="_CPPv3N3hpx8parallel2v2E">
<span id="_CPPv2N3hpx8parallel2v2E"></span><span id="hpx::parallel::v2"></span><span class="target" id="namespacehpx_1_1parallel_1_1v2"></span><em class="property">namespace </em><code class="descname">v2</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v28for_loopERR8ExPolicyNSt5decayI1IE4typeE1IDpRR4Args">
<span id="_CPPv2N3hpx8parallel2v28for_loopERR8ExPolicyNSt5decayI1IE4typeE1IDpRR4Args"></span><span id="hpx::parallel::v2::for_loop__ExPolicyRR.std::decay:I:::type.I.ArgsRRDp"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> I, typename... <em>Args</em>&gt;<br /><span class="target" id="for__loop_8hpp_1a2e881d0376708a91f56835a1aa010f38"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy&gt;::type <code class="descname">for_loop</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, <em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::decay&lt;I&gt;::type <em>first</em>, I <em>last</em>, Args&amp;&amp;... <em>args</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v28for_loopERR8ExPolicyNSt5decayI1IE4typeE1IDpRR4Args" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The for_loop implements loop functionality over a range specified by integral or iterator bounds. For the iterator case, these algorithms resemble for_each from the Parallelism TS, but leave to the programmer when and if to dereference the iterator.</p>
<p><p>Requires: </p>
<em>I</em> shall be an integral type or meet the requirements of an input iterator type. The <em>args</em> parameter pack shall have at least one element, comprising objects returned by invocations of <em>reduction</em> and/or <em>induction</em> function templates followed by exactly one element invocable element-access function, <em>f</em>. <em>f</em> shall meet the requirements of MoveConstructible.<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </li>
<li><code class="docutils literal notranslate"><span class="pre">I</span></code>: The type of the iteration variable. This could be an (forward) iterator type or an integral type. </li>
<li><code class="docutils literal notranslate"><span class="pre">Args</span></code>: A parameter pack, it’s last element is a function object to be invoked for each iteration, the others have to be either conforming to the induction or reduction concept.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">args</span></code>: The last element of this parameter pack is the function (object) to invoke, while the remaining elements of the parameter pack are instances of either induction or reduction objects. The function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last) should expose a signature equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">ignored</span><span class="o">&gt;</span> <span class="n">pred</span><span class="p">(</span><span class="n">I</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="p">...);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;. It will receive the current value of the iteration variable and one argument for each of the induction or reduction objects passed to the algorithms, representing their current values.</p>
</li>
</ul>
</dd>
</dl>
</p>
<p>Effects: Applies <em>f</em> to each element in the input sequence, with additional arguments corresponding to the reductions and inductions in the <em>args</em> parameter pack. The length of the input sequence is last - first.</p>
<p>The first element in the input sequence is specified by <em>first</em>. Each subsequent element is generated by incrementing the previous element.</p>
<p><p>Along with an element from the input sequence, for each member of the </p>
<em>args</em> parameter pack excluding <em>f</em>, an additional argument is passed to each application of <em>f</em> as follows:<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>As described in the C++ standard, arithmetic on non-random-access iterators is performed using advance and distance.</dd>
<dt><strong>Note</strong></dt>
<dd>The order of the elements of the input sequence is important for determining ordinal position of an application of <em>f</em>, even though the applications themselves may be unordered.</dd>
</dl>
</p>
<p>If the pack member is an object returned by a call to a reduction function listed in section, then the additional argument is a reference to a view of that reduction object. If the pack member is an object returned by a call to induction, then the additional argument is the induction value for that induction object corresponding to the position of the application of <em>f</em> in the input sequence.</p>
<p>Complexity: Applies <em>f</em> exactly once for each element of the input sequence.</p>
<p>Remarks: If <em>f</em> returns a result, the result is ignored.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>for_loop</em> algorithm returns a <em>hpx::future&lt;void&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>void</em> otherwise. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v28for_loopENSt5decayI1IE4typeE1IDpRR4Args">
<span id="_CPPv2N3hpx8parallel2v28for_loopENSt5decayI1IE4typeE1IDpRR4Args"></span><span id="hpx::parallel::v2::for_loop__std::decay:I:::type.I.ArgsRRDp"></span><em class="property">template </em>&lt;<em class="property">typename</em> I, typename... <em>Args</em>&gt;<br /><span class="target" id="for__loop_8hpp_1ae8a4d624a15eba516f03df8d84df9215"></span>void <code class="descname">for_loop</code><span class="sig-paren">(</span><em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::decay&lt;I&gt;::type <em>first</em>, I <em>last</em>, Args&amp;&amp;... <em>args</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v28for_loopENSt5decayI1IE4typeE1IDpRR4Args" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The for_loop implements loop functionality over a range specified by integral or iterator bounds. For the iterator case, these algorithms resemble for_each from the Parallelism TS, but leave to the programmer when and if to dereference the iterator.</p>
<p>The execution of for_loop without specifying an execution policy is equivalent to specifying <em>parallel::execution::seq</em> as the execution policy.</p>
<p><p>Requires: </p>
<em>I</em> shall be an integral type or meet the requirements of an input iterator type. The <em>args</em> parameter pack shall have at least one element, comprising objects returned by invocations of <em>reduction</em> and/or <em>induction</em> function templates followed by exactly one element invocable element-access function, <em>f</em>. <em>f</em> shall meet the requirements of MoveConstructible.<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">I</span></code>: The type of the iteration variable. This could be an (forward) iterator type or an integral type. </li>
<li><code class="docutils literal notranslate"><span class="pre">Args</span></code>: A parameter pack, it’s last element is a function object to be invoked for each iteration, the others have to be either conforming to the induction or reduction concept.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">args</span></code>: The last element of this parameter pack is the function (object) to invoke, while the remaining elements of the parameter pack are instances of either induction or reduction objects. The function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last) should expose a signature equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">ignored</span><span class="o">&gt;</span> <span class="n">pred</span><span class="p">(</span><span class="n">I</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="p">...);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;. It will receive the current value of the iteration variable and one argument for each of the induction or reduction objects passed to the algorithms, representing their current values.</p>
</li>
</ul>
</dd>
</dl>
</p>
<p>Effects: Applies <em>f</em> to each element in the input sequence, with additional arguments corresponding to the reductions and inductions in the <em>args</em> parameter pack. The length of the input sequence is last - first.</p>
<p>The first element in the input sequence is specified by <em>first</em>. Each subsequent element is generated by incrementing the previous element.</p>
<p><p>Along with an element from the input sequence, for each member of the </p>
<em>args</em> parameter pack excluding <em>f</em>, an additional argument is passed to each application of <em>f</em> as follows:<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>As described in the C++ standard, arithmetic on non-random-access iterators is performed using advance and distance.</dd>
<dt><strong>Note</strong></dt>
<dd>The order of the elements of the input sequence is important for determining ordinal position of an application of <em>f</em>, even though the applications themselves may be unordered.</dd>
</dl>
</p>
<p>If the pack member is an object returned by a call to a reduction function listed in section, then the additional argument is a reference to a view of that reduction object. If the pack member is an object returned by a call to induction, then the additional argument is the induction value for that induction object corresponding to the position of the application of <em>f</em> in the input sequence.</p>
<p>Complexity: Applies <em>f</em> exactly once for each element of the input sequence.</p>
<p>Remarks: If <em>f</em> returns a result, the result is ignored. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v216for_loop_stridedERR8ExPolicyNSt5decayI1IE4typeE1I1SDpRR4Args">
<span id="_CPPv2N3hpx8parallel2v216for_loop_stridedERR8ExPolicyNSt5decayI1IE4typeE1I1SDpRR4Args"></span><span id="hpx::parallel::v2::for_loop_strided__ExPolicyRR.std::decay:I:::type.I.S.ArgsRRDp"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> I, <em class="property">typename</em> S, typename... <em>Args</em>, &amp;&amp;std::is_integral&lt; S &gt;::value&gt;<br /><span class="target" id="for__loop_8hpp_1ad463dfcd2eb83e031cc403402a0d91e4"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy&gt;::type <code class="descname">for_loop_strided</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, <em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::decay&lt;I&gt;::type <em>first</em>, I <em>last</em>, S <em>stride</em>, Args&amp;&amp;... <em>args</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v216for_loop_stridedERR8ExPolicyNSt5decayI1IE4typeE1I1SDpRR4Args" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The for_loop_strided implements loop functionality over a range specified by integral or iterator bounds. For the iterator case, these algorithms resemble for_each from the Parallelism TS, but leave to the programmer when and if to dereference the iterator.</p>
<p><p>Requires: </p>
<em>I</em> shall be an integral type or meet the requirements of an input iterator type. The <em>args</em> parameter pack shall have at least one element, comprising objects returned by invocations of <em>reduction</em> and/or <em>induction</em> function templates followed by exactly one element invocable element-access function, <em>f</em>. <em>f</em> shall meet the requirements of MoveConstructible.<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </li>
<li><code class="docutils literal notranslate"><span class="pre">I</span></code>: The type of the iteration variable. This could be an (forward) iterator type or an integral type. </li>
<li><code class="docutils literal notranslate"><span class="pre">S</span></code>: The type of the stride variable. This should be an integral type. </li>
<li><code class="docutils literal notranslate"><span class="pre">Args</span></code>: A parameter pack, it’s last element is a function object to be invoked for each iteration, the others have to be either conforming to the induction or reduction concept.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">stride</span></code>: Refers to the stride of the iteration steps. This shall have non-zero value and shall be negative only if I has integral type or meets the requirements of a bidirectional iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">args</span></code>: The last element of this parameter pack is the function (object) to invoke, while the remaining elements of the parameter pack are instances of either induction or reduction objects. The function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last) should expose a signature equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">ignored</span><span class="o">&gt;</span> <span class="n">pred</span><span class="p">(</span><span class="n">I</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="p">...);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;. It will receive the current value of the iteration variable and one argument for each of the induction or reduction objects passed to the algorithms, representing their current values.</p>
</li>
</ul>
</dd>
</dl>
</p>
<p>Effects: Applies <em>f</em> to each element in the input sequence, with additional arguments corresponding to the reductions and inductions in the <em>args</em> parameter pack. The length of the input sequence is last - first.</p>
<p>The first element in the input sequence is specified by <em>first</em>. Each subsequent element is generated by incrementing the previous element.</p>
<p><p>Along with an element from the input sequence, for each member of the </p>
<em>args</em> parameter pack excluding <em>f</em>, an additional argument is passed to each application of <em>f</em> as follows:<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>As described in the C++ standard, arithmetic on non-random-access iterators is performed using advance and distance.</dd>
<dt><strong>Note</strong></dt>
<dd>The order of the elements of the input sequence is important for determining ordinal position of an application of <em>f</em>, even though the applications themselves may be unordered.</dd>
</dl>
</p>
<p>If the pack member is an object returned by a call to a reduction function listed in section, then the additional argument is a reference to a view of that reduction object. If the pack member is an object returned by a call to induction, then the additional argument is the induction value for that induction object corresponding to the position of the application of <em>f</em> in the input sequence.</p>
<p>Complexity: Applies <em>f</em> exactly once for each element of the input sequence.</p>
<p>Remarks: If <em>f</em> returns a result, the result is ignored.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>for_loop_strided</em> algorithm returns a <em>hpx::future&lt;void&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>void</em> otherwise. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v216for_loop_stridedENSt5decayI1IE4typeE1I1SDpRR4Args">
<span id="_CPPv2N3hpx8parallel2v216for_loop_stridedENSt5decayI1IE4typeE1I1SDpRR4Args"></span><span id="hpx::parallel::v2::for_loop_strided__std::decay:I:::type.I.S.ArgsRRDp"></span><em class="property">template </em>&lt;<em class="property">typename</em> I, <em class="property">typename</em> S, typename... <em>Args</em>, &amp;&amp;std::is_integral&lt; S &gt;::value&gt;<br /><span class="target" id="for__loop_8hpp_1a1f410bcfe5d10f47c397e8676758d1b8"></span>void <code class="descname">for_loop_strided</code><span class="sig-paren">(</span><em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::decay&lt;I&gt;::type <em>first</em>, I <em>last</em>, S <em>stride</em>, Args&amp;&amp;... <em>args</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v216for_loop_stridedENSt5decayI1IE4typeE1I1SDpRR4Args" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The for_loop_strided implements loop functionality over a range specified by integral or iterator bounds. For the iterator case, these algorithms resemble for_each from the Parallelism TS, but leave to the programmer when and if to dereference the iterator.</p>
<p>The execution of for_loop without specifying an execution policy is equivalent to specifying <em>parallel::execution::seq</em> as the execution policy.</p>
<p><p>Requires: </p>
<em>I</em> shall be an integral type or meet the requirements of an input iterator type. The <em>args</em> parameter pack shall have at least one element, comprising objects returned by invocations of <em>reduction</em> and/or <em>induction</em> function templates followed by exactly one element invocable element-access function, <em>f</em>. <em>f</em> shall meet the requirements of MoveConstructible.<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">I</span></code>: The type of the iteration variable. This could be an (forward) iterator type or an integral type. </li>
<li><code class="docutils literal notranslate"><span class="pre">S</span></code>: The type of the stride variable. This should be an integral type. </li>
<li><code class="docutils literal notranslate"><span class="pre">Args</span></code>: A parameter pack, it’s last element is a function object to be invoked for each iteration, the others have to be either conforming to the induction or reduction concept.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">stride</span></code>: Refers to the stride of the iteration steps. This shall have non-zero value and shall be negative only if I has integral type or meets the requirements of a bidirectional iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">args</span></code>: The last element of this parameter pack is the function (object) to invoke, while the remaining elements of the parameter pack are instances of either induction or reduction objects. The function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last) should expose a signature equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">ignored</span><span class="o">&gt;</span> <span class="n">pred</span><span class="p">(</span><span class="n">I</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="p">...);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;. It will receive the current value of the iteration variable and one argument for each of the induction or reduction objects passed to the algorithms, representing their current values.</p>
</li>
</ul>
</dd>
</dl>
</p>
<p>Effects: Applies <em>f</em> to each element in the input sequence, with additional arguments corresponding to the reductions and inductions in the <em>args</em> parameter pack. The length of the input sequence is last - first.</p>
<p>The first element in the input sequence is specified by <em>first</em>. Each subsequent element is generated by incrementing the previous element.</p>
<p><p>Along with an element from the input sequence, for each member of the </p>
<em>args</em> parameter pack excluding <em>f</em>, an additional argument is passed to each application of <em>f</em> as follows:<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>As described in the C++ standard, arithmetic on non-random-access iterators is performed using advance and distance.</dd>
<dt><strong>Note</strong></dt>
<dd>The order of the elements of the input sequence is important for determining ordinal position of an application of <em>f</em>, even though the applications themselves may be unordered.</dd>
</dl>
</p>
<p>If the pack member is an object returned by a call to a reduction function listed in section, then the additional argument is a reference to a view of that reduction object. If the pack member is an object returned by a call to induction, then the additional argument is the induction value for that induction object corresponding to the position of the application of <em>f</em> in the input sequence.</p>
<p>Complexity: Applies <em>f</em> exactly once for each element of the input sequence.</p>
<p>Remarks: If <em>f</em> returns a result, the result is ignored. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v210for_loop_nERR8ExPolicy1I4SizeDpRR4Args">
<span id="_CPPv2N3hpx8parallel2v210for_loop_nERR8ExPolicy1I4SizeDpRR4Args"></span><span id="hpx::parallel::v2::for_loop_n__ExPolicyRR.I.Size.ArgsRRDp"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> I, <em class="property">typename</em> Size, typename... <em>Args</em>, &amp;&amp;std::is_integral&lt; Size &gt;::value&gt;<br /><span class="target" id="for__loop_8hpp_1a752b271ba967b563d9541c26e8758734"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy&gt;::type <code class="descname">for_loop_n</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, I <em>first</em>, Size <em>size</em>, Args&amp;&amp;... <em>args</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v210for_loop_nERR8ExPolicy1I4SizeDpRR4Args" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The for_loop_n implements loop functionality over a range specified by integral or iterator bounds. For the iterator case, these algorithms resemble for_each from the Parallelism TS, but leave to the programmer when and if to dereference the iterator.</p>
<p><p>Requires: </p>
<em>I</em> shall be an integral type or meet the requirements of an input iterator type. The <em>args</em> parameter pack shall have at least one element, comprising objects returned by invocations of <em>reduction</em> and/or <em>induction</em> function templates followed by exactly one element invocable element-access function, <em>f</em>. <em>f</em> shall meet the requirements of MoveConstructible.<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </li>
<li><code class="docutils literal notranslate"><span class="pre">I</span></code>: The type of the iteration variable. This could be an (forward) iterator type or an integral type. </li>
<li><code class="docutils literal notranslate"><span class="pre">Size</span></code>: The type of a non-negative integral value specifying the number of items to iterate over. </li>
<li><code class="docutils literal notranslate"><span class="pre">Args</span></code>: A parameter pack, it’s last element is a function object to be invoked for each iteration, the others have to be either conforming to the induction or reduction concept.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: Refers to the number of items the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">args</span></code>: The last element of this parameter pack is the function (object) to invoke, while the remaining elements of the parameter pack are instances of either induction or reduction objects. The function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last) should expose a signature equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">ignored</span><span class="o">&gt;</span> <span class="n">pred</span><span class="p">(</span><span class="n">I</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="p">...);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;. It will receive the current value of the iteration variable and one argument for each of the induction or reduction objects passed to the algorithms, representing their current values.</p>
</li>
</ul>
</dd>
</dl>
</p>
<p>Effects: Applies <em>f</em> to each element in the input sequence, with additional arguments corresponding to the reductions and inductions in the <em>args</em> parameter pack. The length of the input sequence is last - first.</p>
<p>The first element in the input sequence is specified by <em>first</em>. Each subsequent element is generated by incrementing the previous element.</p>
<p><p>Along with an element from the input sequence, for each member of the </p>
<em>args</em> parameter pack excluding <em>f</em>, an additional argument is passed to each application of <em>f</em> as follows:<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>As described in the C++ standard, arithmetic on non-random-access iterators is performed using advance and distance.</dd>
<dt><strong>Note</strong></dt>
<dd>The order of the elements of the input sequence is important for determining ordinal position of an application of <em>f</em>, even though the applications themselves may be unordered.</dd>
</dl>
</p>
<p>If the pack member is an object returned by a call to a reduction function listed in section, then the additional argument is a reference to a view of that reduction object. If the pack member is an object returned by a call to induction, then the additional argument is the induction value for that induction object corresponding to the position of the application of <em>f</em> in the input sequence.</p>
<p>Complexity: Applies <em>f</em> exactly once for each element of the input sequence.</p>
<p>Remarks: If <em>f</em> returns a result, the result is ignored.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>for_loop_n</em> algorithm returns a <em>hpx::future&lt;void&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>void</em> otherwise. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v210for_loop_nE1I4SizeDpRR4Args">
<span id="_CPPv2N3hpx8parallel2v210for_loop_nE1I4SizeDpRR4Args"></span><span id="hpx::parallel::v2::for_loop_n__I.Size.ArgsRRDp"></span><em class="property">template </em>&lt;<em class="property">typename</em> I, <em class="property">typename</em> Size, typename... <em>Args</em>, &amp;&amp;std::is_integral&lt; Size &gt;::value&gt;<br /><span class="target" id="for__loop_8hpp_1a7e65fb50c96e09d2f9ba296726d9f82d"></span>void <code class="descname">for_loop_n</code><span class="sig-paren">(</span>I <em>first</em>, Size <em>size</em>, Args&amp;&amp;... <em>args</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v210for_loop_nE1I4SizeDpRR4Args" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The for_loop implements loop functionality over a range specified by integral or iterator bounds. For the iterator case, these algorithms resemble for_each from the Parallelism TS, but leave to the programmer when and if to dereference the iterator.</p>
<p>The execution of for_loop without specifying an execution policy is equivalent to specifying <em>parallel::execution::seq</em> as the execution policy.</p>
<p><p>Requires: </p>
<em>I</em> shall be an integral type or meet the requirements of an input iterator type. The <em>args</em> parameter pack shall have at least one element, comprising objects returned by invocations of <em>reduction</em> and/or <em>induction</em> function templates followed by exactly one element invocable element-access function, <em>f</em>. <em>f</em> shall meet the requirements of MoveConstructible.<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">I</span></code>: The type of the iteration variable. This could be an (forward) iterator type or an integral type. </li>
<li><code class="docutils literal notranslate"><span class="pre">Size</span></code>: The type of a non-negative integral value specifying the number of items to iterate over. </li>
<li><code class="docutils literal notranslate"><span class="pre">Args</span></code>: A parameter pack, it’s last element is a function object to be invoked for each iteration, the others have to be either conforming to the induction or reduction concept.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: Refers to the number of items the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">args</span></code>: The last element of this parameter pack is the function (object) to invoke, while the remaining elements of the parameter pack are instances of either induction or reduction objects. The function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last) should expose a signature equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">ignored</span><span class="o">&gt;</span> <span class="n">pred</span><span class="p">(</span><span class="n">I</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="p">...);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;. It will receive the current value of the iteration variable and one argument for each of the induction or reduction objects passed to the algorithms, representing their current values.</p>
</li>
</ul>
</dd>
</dl>
</p>
<p>Effects: Applies <em>f</em> to each element in the input sequence, with additional arguments corresponding to the reductions and inductions in the <em>args</em> parameter pack. The length of the input sequence is last - first.</p>
<p>The first element in the input sequence is specified by <em>first</em>. Each subsequent element is generated by incrementing the previous element.</p>
<p><p>Along with an element from the input sequence, for each member of the </p>
<em>args</em> parameter pack excluding <em>f</em>, an additional argument is passed to each application of <em>f</em> as follows:<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>As described in the C++ standard, arithmetic on non-random-access iterators is performed using advance and distance.</dd>
<dt><strong>Note</strong></dt>
<dd>The order of the elements of the input sequence is important for determining ordinal position of an application of <em>f</em>, even though the applications themselves may be unordered.</dd>
</dl>
</p>
<p>If the pack member is an object returned by a call to a reduction function listed in section, then the additional argument is a reference to a view of that reduction object. If the pack member is an object returned by a call to induction, then the additional argument is the induction value for that induction object corresponding to the position of the application of <em>f</em> in the input sequence.</p>
<p>Complexity: Applies <em>f</em> exactly once for each element of the input sequence.</p>
<p>Remarks: If <em>f</em> returns a result, the result is ignored. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v218for_loop_n_stridedERR8ExPolicy1I4Size1SDpRR4Args">
<span id="_CPPv2N3hpx8parallel2v218for_loop_n_stridedERR8ExPolicy1I4Size1SDpRR4Args"></span><span id="hpx::parallel::v2::for_loop_n_strided__ExPolicyRR.I.Size.S.ArgsRRDp"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> I, <em class="property">typename</em> Size, <em class="property">typename</em> S, typename... <em>Args</em>, &amp;&amp;std::is_integral&lt; Size &gt;::value &amp;&amp;std::is_integral&lt; S &gt;::value&gt;<br /><span class="target" id="for__loop_8hpp_1aa4c8b229a961f9161b1dfd818309f59a"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy&gt;::type <code class="descname">for_loop_n_strided</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, I <em>first</em>, Size <em>size</em>, S <em>stride</em>, Args&amp;&amp;... <em>args</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v218for_loop_n_stridedERR8ExPolicy1I4Size1SDpRR4Args" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The for_loop_n_strided implements loop functionality over a range specified by integral or iterator bounds. For the iterator case, these algorithms resemble for_each from the Parallelism TS, but leave to the programmer when and if to dereference the iterator.</p>
<p><p>Requires: </p>
<em>I</em> shall be an integral type or meet the requirements of an input iterator type. The <em>args</em> parameter pack shall have at least one element, comprising objects returned by invocations of <em>reduction</em> and/or <em>induction</em> function templates followed by exactly one element invocable element-access function, <em>f</em>. <em>f</em> shall meet the requirements of MoveConstructible.<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </li>
<li><code class="docutils literal notranslate"><span class="pre">I</span></code>: The type of the iteration variable. This could be an (forward) iterator type or an integral type. </li>
<li><code class="docutils literal notranslate"><span class="pre">Size</span></code>: The type of a non-negative integral value specifying the number of items to iterate over. </li>
<li><code class="docutils literal notranslate"><span class="pre">S</span></code>: The type of the stride variable. This should be an integral type. </li>
<li><code class="docutils literal notranslate"><span class="pre">Args</span></code>: A parameter pack, it’s last element is a function object to be invoked for each iteration, the others have to be either conforming to the induction or reduction concept.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: Refers to the number of items the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">stride</span></code>: Refers to the stride of the iteration steps. This shall have non-zero value and shall be negative only if I has integral type or meets the requirements of a bidirectional iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">args</span></code>: The last element of this parameter pack is the function (object) to invoke, while the remaining elements of the parameter pack are instances of either induction or reduction objects. The function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last) should expose a signature equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">ignored</span><span class="o">&gt;</span> <span class="n">pred</span><span class="p">(</span><span class="n">I</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="p">...);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;. It will receive the current value of the iteration variable and one argument for each of the induction or reduction objects passed to the algorithms, representing their current values.</p>
</li>
</ul>
</dd>
</dl>
</p>
<p>Effects: Applies <em>f</em> to each element in the input sequence, with additional arguments corresponding to the reductions and inductions in the <em>args</em> parameter pack. The length of the input sequence is last - first.</p>
<p>The first element in the input sequence is specified by <em>first</em>. Each subsequent element is generated by incrementing the previous element.</p>
<p><p>Along with an element from the input sequence, for each member of the </p>
<em>args</em> parameter pack excluding <em>f</em>, an additional argument is passed to each application of <em>f</em> as follows:<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>As described in the C++ standard, arithmetic on non-random-access iterators is performed using advance and distance.</dd>
<dt><strong>Note</strong></dt>
<dd>The order of the elements of the input sequence is important for determining ordinal position of an application of <em>f</em>, even though the applications themselves may be unordered.</dd>
</dl>
</p>
<p>If the pack member is an object returned by a call to a reduction function listed in section, then the additional argument is a reference to a view of that reduction object. If the pack member is an object returned by a call to induction, then the additional argument is the induction value for that induction object corresponding to the position of the application of <em>f</em> in the input sequence.</p>
<p>Complexity: Applies <em>f</em> exactly once for each element of the input sequence.</p>
<p>Remarks: If <em>f</em> returns a result, the result is ignored.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>for_loop_n_strided</em> algorithm returns a <em>hpx::future&lt;void&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>void</em> otherwise. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v218for_loop_n_stridedE1I4Size1SDpRR4Args">
<span id="_CPPv2N3hpx8parallel2v218for_loop_n_stridedE1I4Size1SDpRR4Args"></span><span id="hpx::parallel::v2::for_loop_n_strided__I.Size.S.ArgsRRDp"></span><em class="property">template </em>&lt;<em class="property">typename</em> I, <em class="property">typename</em> Size, <em class="property">typename</em> S, typename... <em>Args</em>, &amp;&amp;std::is_integral&lt; Size &gt;::value &amp;&amp;std::is_integral&lt; S &gt;::value&gt;<br /><span class="target" id="for__loop_8hpp_1ab632abf48b39fa6e2e90c588277a41d1"></span>void <code class="descname">for_loop_n_strided</code><span class="sig-paren">(</span>I <em>first</em>, Size <em>size</em>, S <em>stride</em>, Args&amp;&amp;... <em>args</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v218for_loop_n_stridedE1I4Size1SDpRR4Args" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The for_loop_n_strided implements loop functionality over a range specified by integral or iterator bounds. For the iterator case, these algorithms resemble for_each from the Parallelism TS, but leave to the programmer when and if to dereference the iterator.</p>
<p>The execution of for_loop without specifying an execution policy is equivalent to specifying <em>parallel::execution::seq</em> as the execution policy.</p>
<p><p>Requires: </p>
<em>I</em> shall be an integral type or meet the requirements of an input iterator type. The <em>args</em> parameter pack shall have at least one element, comprising objects returned by invocations of <em>reduction</em> and/or <em>induction</em> function templates followed by exactly one element invocable element-access function, <em>f</em>. <em>f</em> shall meet the requirements of MoveConstructible.<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">I</span></code>: The type of the iteration variable. This could be an (forward) iterator type or an integral type. </li>
<li><code class="docutils literal notranslate"><span class="pre">Size</span></code>: The type of a non-negative integral value specifying the number of items to iterate over. </li>
<li><code class="docutils literal notranslate"><span class="pre">S</span></code>: The type of the stride variable. This should be an integral type. </li>
<li><code class="docutils literal notranslate"><span class="pre">Args</span></code>: A parameter pack, it’s last element is a function object to be invoked for each iteration, the others have to be either conforming to the induction or reduction concept.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: Refers to the number of items the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">stride</span></code>: Refers to the stride of the iteration steps. This shall have non-zero value and shall be negative only if I has integral type or meets the requirements of a bidirectional iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">args</span></code>: The last element of this parameter pack is the function (object) to invoke, while the remaining elements of the parameter pack are instances of either induction or reduction objects. The function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last) should expose a signature equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">ignored</span><span class="o">&gt;</span> <span class="n">pred</span><span class="p">(</span><span class="n">I</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="p">...);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;. It will receive the current value of the iteration variable and one argument for each of the induction or reduction objects passed to the algorithms, representing their current values.</p>
</li>
</ul>
</dd>
</dl>
</p>
<p>Effects: Applies <em>f</em> to each element in the input sequence, with additional arguments corresponding to the reductions and inductions in the <em>args</em> parameter pack. The length of the input sequence is last - first.</p>
<p>The first element in the input sequence is specified by <em>first</em>. Each subsequent element is generated by incrementing the previous element.</p>
<p><p>Along with an element from the input sequence, for each member of the </p>
<em>args</em> parameter pack excluding <em>f</em>, an additional argument is passed to each application of <em>f</em> as follows:<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>As described in the C++ standard, arithmetic on non-random-access iterators is performed using advance and distance.</dd>
<dt><strong>Note</strong></dt>
<dd>The order of the elements of the input sequence is important for determining ordinal position of an application of <em>f</em>, even though the applications themselves may be unordered.</dd>
</dl>
</p>
<p>If the pack member is an object returned by a call to a reduction function listed in section, then the additional argument is a reference to a view of that reduction object. If the pack member is an object returned by a call to induction, then the additional argument is the induction value for that induction object corresponding to the position of the application of <em>f</em> in the input sequence.</p>
<p>Complexity: Applies <em>f</em> exactly once for each element of the input sequence.</p>
<p>Remarks: If <em>f</em> returns a result, the result is ignored. </p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-transform-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/transform.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-transform-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v19transformERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR1FRR4Proj">
<span id="_CPPv2N3hpx8parallel2v19transformERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR1FRR4Proj"></span><span id="hpx::parallel::v1::transform__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.FRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> F, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="algorithms_2transform_8hpp_1afe123e60433fe2243f7245caf6a56776"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::in<span class="sig-paren">(</span>FwdIter1<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>FwdIter2<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">transform</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, FwdIter1 <em>last</em>, FwdIter2 <em>dest</em>, F &amp;&amp;<em>f</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v19transformERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR1FRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Applies the given function <em>f</em> to the range [first, last) and stores the result in another range, beginning at dest.</p>
<p><p>The invocations of </p>
<em>f</em> in the parallel <em>transform</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Exactly <em>last</em> - <em>first</em> applications of <em>f</em> </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the invocations of <em>f</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>transform</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is an unary predicate. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ret</span> <span class="nf">fun</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter</em> can be dereferenced and then implicitly converted to <em>Type</em>. The type <em>Ret</em> must be such that an object of type <em>FwdIter2</em> can be dereferenced and assigned a value of type <em>Ret</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>f</em> is invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The invocations of <em>f</em> in the parallel <em>transform</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>transform</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</em> &gt; if the execution policy is of type <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</em> otherwise. The <em>transform</em> algorithm returns a tuple holding an iterator referring to the first element after the input sequence and the output iterator to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v19transformERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter3RR1FRR5Proj1RR5Proj2">
<span id="_CPPv2N3hpx8parallel2v19transformERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter3RR1FRR5Proj1RR5Proj2"></span><span id="hpx::parallel::v1::transform__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.FwdIter3.FRR.Proj1RR.Proj2RR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> FwdIter3, <em class="property">typename</em> F, <em class="property">typename</em> Proj1 = util::projection_identity, <em class="property">typename</em> Proj2 = util::projection_identity&gt;<br /><span class="target" id="algorithms_2transform_8hpp_1afcf0be29f07067dc0e8cf4acfe2c77df"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_tuple&lt;tag::in1<span class="sig-paren">(</span>FwdIter1<span class="sig-paren">)</span>, tag::in2<span class="sig-paren">(</span>FwdIter2<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>FwdIter3<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">transform</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first1</em>, FwdIter1 <em>last1</em>, FwdIter2 <em>first2</em>, FwdIter3 <em>dest</em>, F &amp;&amp;<em>f</em>, Proj1 &amp;&amp;<em>proj1</em> = Proj1(), Proj2 &amp;&amp;<em>proj2</em> = Proj2()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v19transformERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter3RR1FRR5Proj1RR5Proj2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Applies the given function <em>f</em> to pairs of elements from two ranges: one defined by [first1, last1) and the other beginning at first2, and stores the result in another range, beginning at dest.</p>
<p><p>The invocations of </p>
<em>f</em> in the parallel <em>transform</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Exactly <em>last</em> - <em>first</em> applications of <em>f</em> </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the invocations of <em>f</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators for the first range used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the source iterators for the second range used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter3</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>transform</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj1</span></code>: The type of an optional projection function to be used for elements of the first sequence. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj2</span></code>: The type of an optional projection function to be used for elements of the second sequence. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first1</span></code>: Refers to the beginning of the first sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last1</span></code>: Refers to the end of the first sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">first2</span></code>: Refers to the beginning of the second sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is a binary predicate. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ret</span> <span class="nf">fun</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type2</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;. The types </p>
<em>Type1</em> and <em>Type2</em> must be such that objects of types FwdIter1 and FwdIter2 can be dereferenced and then implicitly converted to <em>Type1</em> and <em>Type2</em> respectively. The type <em>Ret</em> must be such that an object of type <em>FwdIter3</em> can be dereferenced and assigned a value of type <em>Ret</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj1</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of the first sequence as a projection operation before the actual predicate <em>f</em> is invoked. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj2</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of the second sequence as a projection operation before the actual predicate <em>f</em> is invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The invocations of <em>f</em> in the parallel <em>transform</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>transform</em> algorithm returns a <em>hpx::future&lt;tagged_tuple&lt;tag::in1(FwdIter1), tag::in2(FwdIter2), tag::out(FwdIter3)&gt;</em> &gt; if the execution policy is of type <em>parallel_task_policy</em> and returns <em>tagged_tuple&lt;tag::in1(FwdIter1), tag::in2(FwdIter2), tag::out(FwdIter3)&gt;</em> otherwise. The <em>transform</em> algorithm returns a tuple holding an iterator referring to the first element after the first input sequence, an iterator referring to the first element after the second input sequence, and the output iterator referring to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v19transformERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter28FwdIter3RR1FRR5Proj1RR5Proj2">
<span id="_CPPv2N3hpx8parallel2v19transformERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter28FwdIter3RR1FRR5Proj1RR5Proj2"></span><span id="hpx::parallel::v1::transform__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.FwdIter2.FwdIter3.FRR.Proj1RR.Proj2RR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> FwdIter3, <em class="property">typename</em> F, <em class="property">typename</em> Proj1 = util::projection_identity, <em class="property">typename</em> Proj2 = util::projection_identity&gt;<br /><span class="target" id="algorithms_2transform_8hpp_1ad88c2156d71d5c5470ce2bc1b4402bab"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_tuple&lt;tag::in1<span class="sig-paren">(</span>FwdIter1<span class="sig-paren">)</span>, tag::in2<span class="sig-paren">(</span>FwdIter2<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>FwdIter3<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">transform</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first1</em>, FwdIter1 <em>last1</em>, FwdIter2 <em>first2</em>, FwdIter2 <em>last2</em>, FwdIter3 <em>dest</em>, F &amp;&amp;<em>f</em>, Proj1 &amp;&amp;<em>proj1</em> = Proj1(), Proj2 &amp;&amp;<em>proj2</em> = Proj2()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v19transformERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter28FwdIter3RR1FRR5Proj1RR5Proj2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Applies the given function <em>f</em> to pairs of elements from two ranges: one defined by [first1, last1) and the other beginning at first2, and stores the result in another range, beginning at dest.</p>
<p><p>The invocations of </p>
<em>f</em> in the parallel <em>transform</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Exactly min(last2-first2, last1-first1) applications of <em>f</em> </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the invocations of <em>f</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators for the first range used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the source iterators for the second range used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter3</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>transform</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj1</span></code>: The type of an optional projection function to be used for elements of the first sequence. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj2</span></code>: The type of an optional projection function to be used for elements of the second sequence. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first1</span></code>: Refers to the beginning of the first sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last1</span></code>: Refers to the end of the first sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">first2</span></code>: Refers to the beginning of the second sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last2</span></code>: Refers to the end of the second sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is a binary predicate. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ret</span> <span class="nf">fun</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type2</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;. The types </p>
<em>Type1</em> and <em>Type2</em> must be such that objects of types FwdIter1 and FwdIter2 can be dereferenced and then implicitly converted to <em>Type1</em> and <em>Type2</em> respectively. The type <em>Ret</em> must be such that an object of type <em>FwdIter3</em> can be dereferenced and assigned a value of type <em>Ret</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj1</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of the first sequence as a projection operation before the actual predicate <em>f</em> is invoked. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj2</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of the second sequence as a projection operation before the actual predicate <em>f</em> is invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The invocations of <em>f</em> in the parallel <em>transform</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The algorithm will invoke the binary predicate until it reaches the end of the shorter of the two given input sequences</dd>
<dt><strong>Return</strong></dt>
<dd>The <em>transform</em> algorithm returns a <em>hpx::future&lt;tagged_tuple&lt;tag::in1(FwdIter1), tag::in2(FwdIter2), tag::out(FwdIter3)&gt;</em> &gt; if the execution policy is of type <em>parallel_task_policy</em> and returns <em>tagged_tuple&lt;tag::in1(FwdIter1), tag::in2(FwdIter2), tag::out(FwdIter3)&gt;</em> otherwise. The <em>transform</em> algorithm returns a tuple holding an iterator referring to the first element after the first input sequence, an iterator referring to the first element after the second input sequence, and the output iterator referring to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-unique-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/unique.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-unique-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v16uniqueERR8ExPolicy7FwdIter7FwdIterRR4PredRR4Proj">
<span id="_CPPv2N3hpx8parallel2v16uniqueERR8ExPolicy7FwdIter7FwdIterRR4PredRR4Proj"></span><span id="hpx::parallel::v1::unique__ExPolicyRR.FwdIter.FwdIter.PredRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> Pred = detail::equal_to, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="algorithms_2unique_8hpp_1a4cdfd22142e00f57092cf3dbd594c7b4"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type <code class="descname">unique</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, Pred &amp;&amp;<em>pred</em> = Pred(), Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v16uniqueERR8ExPolicy7FwdIter7FwdIterRR4PredRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Eliminates all but the first element from every consecutive group of equivalent elements from the range [first, last) and returns a past-the-end iterator for the new logical end of the range.</p>
<p><p>The assignments in the parallel </p>
<em>unique</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs not more than <em>last</em> - <em>first</em> assignments, exactly <em>last</em> - <em>first</em> - 1 applications of the predicate <em>pred</em> and no more than twice as many applications of the projection <em>proj</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>unique</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::equal_to&lt;&gt; </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">pred</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). This is an binary predicate which returns <em>true</em> for the required elements. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type2</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> and <em>Type2</em> must be such that objects of types <em>FwdIter</em> can be dereferenced and then implicitly converted to both <em>Type1</em> and <em>Type2</em> </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>unique</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>unique</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter</em> otherwise. The <em>unique</em> algorithm returns the iterator to the new end of the range. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v111unique_copyERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR4PredRR4Proj">
<span id="_CPPv2N3hpx8parallel2v111unique_copyERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR4PredRR4Proj"></span><span id="hpx::parallel::v1::unique_copy__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.PredRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> Pred = detail::equal_to, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="algorithms_2unique_8hpp_1adb3d04b7e437cdc7abbb150de240c74d"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::in<span class="sig-paren">(</span>FwdIter1<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>FwdIter2<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">unique_copy</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, FwdIter1 <em>last</em>, FwdIter2 <em>dest</em>, Pred &amp;&amp;<em>pred</em> = Pred(), Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v111unique_copyERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR4PredRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the elements from the range [first, last), to another range beginning at <em>dest</em> in such a way that there are no consecutive equal elements. Only the first element of each group of equal elements is copied.</p>
<p><p>The assignments in the parallel </p>
<em>unique_copy</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs not more than <em>last</em> - <em>first</em> assignments, exactly <em>last</em> - <em>first</em> - 1 applications of the predicate <em>pred</em> and no more than twice as many applications of the projection <em>proj</em> </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>unique_copy</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::equal_to&lt;&gt; </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">pred</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). This is an binary predicate which returns <em>true</em> for the required elements. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter1</em> can be dereferenced and then implicitly converted to <em>Type</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>unique_copy</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>unique_copy</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</em> &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</em> otherwise. The <em>unique_copy</em> algorithm returns the pair of the source iterator to <em>last</em>, and the destination iterator to the end of the <em>dest</em> range. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-for-loop-reduction-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/for_loop_reduction.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-for-loop-reduction-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt id="_CPPv3N3hpx8parallel2v2E">
<span id="_CPPv2N3hpx8parallel2v2E"></span><span class="target" id="namespacehpx_1_1parallel_1_1v2"></span><em class="property">namespace </em><code class="descname">v2</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v29reductionER1TR1TRR2Op">
<span id="_CPPv2N3hpx8parallel2v29reductionER1TR1TRR2Op"></span><span id="hpx::parallel::v2::reduction__TR.TCR.OpRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> T, <em class="property">typename</em> Op&gt;<br /><span class="target" id="for__loop__reduction_8hpp_1a91790c50467a62ae722eb502621f84dc"></span>detail::reduction_helper&lt;T, <em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::decay&lt;Op&gt;::type&gt; <code class="descname">reduction</code><span class="sig-paren">(</span>T &amp;<em>var</em>, T <em class="property">const</em> &amp;<em>identity</em>, Op &amp;&amp;<em>combiner</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v29reductionER1TR1TRR2Op" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function template returns a reduction object of unspecified type having a value type and encapsulating an identity value for the reduction, a combiner function object, and a live-out object from which the initial value is obtained and into which the final value is stored.</p>
<p>A parallel algorithm uses reduction objects by allocating an unspecified number of instances, called views, of the reduction’s value type. Each view is initialized with the reduction object’s identity value, except that the live-out object (which was initialized by the caller) comprises one of the views. The algorithm passes a reference to a view to each application of an element-access function, ensuring that no two concurrently-executing invocations share the same view. A view can be shared between two applications that do not execute concurrently, but initialization is performed only once per view.</p>
<p>Modifications to the view by the application of element access functions accumulate as partial results. At some point before the algorithm returns, the partial results are combined, two at a time, using the reduction object’s combiner operation until a single value remains, which is then assigned back to the live-out object.</p>
<p><p>T shall meet the requirements of CopyConstructible and MoveAssignable. The expression var = combiner(var, var) shall be well formed.</p>
<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The value type to be used by the induction object. </li>
<li><code class="docutils literal notranslate"><span class="pre">Op</span></code>: The type of the binary function (object) used to perform the reduction operation.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">var</span></code>: [in,out] The life-out value to use for the reduction object. This will hold the reduced value after the algorithm is finished executing. </li>
<li><code class="docutils literal notranslate"><span class="pre">identity</span></code>: [in] The identity value to use for the reduction operation. </li>
<li><code class="docutils literal notranslate"><span class="pre">combiner</span></code>: [in] The binary function (object) used to perform a pairwise reduction on the elements.</li>
</ul>
</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>In order to produce useful results, modifications to the view should be limited to commutative operations closely related to the combiner operation. For example if the combiner is plus&lt;T&gt;, incrementing the view would be consistent with the combiner but doubling it or assigning to it would not.</dd>
<dt><strong>Return</strong></dt>
<dd>This returns a reduction object of unspecified type having a value type of <em>T</em>. When the return value is used by an algorithm, the reference to <em>var</em> is used as the live-out object, new views are initialized to a copy of identity, and views are combined by invoking the copy of combiner, passing it the two views to be combined. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-replace-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/replace.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-replace-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v17replaceERR8ExPolicy7FwdIter7FwdIterR2T1R2T2RR4Proj">
<span id="_CPPv2N3hpx8parallel2v17replaceERR8ExPolicy7FwdIter7FwdIterR2T1R2T2RR4Proj"></span><span id="hpx::parallel::v1::replace__ExPolicyRR.FwdIter.FwdIter.T1CR.T2CR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> T1, <em class="property">typename</em> T2, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="algorithms_2replace_8hpp_1a2a8af54cd1078cc756853a5f5fdf4550"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type <code class="descname">replace</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, T1 <em class="property">const</em> &amp;<em>old_value</em>, T2 <em class="property">const</em> &amp;<em>new_value</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v17replaceERR8ExPolicy7FwdIter7FwdIterR2T1R2T2RR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Replaces all elements satisfying specific criteria with <em>new_value</em> in the range [first, last).</p>
<p>Effects: Substitutes elements referred by the iterator it in the range [first, last) with new_value, when the following corresponding conditions hold: INVOKE(proj, *it) == old_value</p>
<p><p>The assignments in the parallel </p>
<em>replace</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>last</em> - <em>first</em> assignments.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of a forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">T1</span></code>: The type of the old value to replace (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">T2</span></code>: The type of the new values to replace (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">old_value</span></code>: Refers to the old value of the elements to replace. </li>
<li><code class="docutils literal notranslate"><span class="pre">new_value</span></code>: Refers to the new value to use as the replacement. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>replace</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>replace</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>void</em> otherwise. It returns <em>last</em>. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v110replace_ifERR8ExPolicy7FwdIter7FwdIterRR1FR1TRR4Proj">
<span id="_CPPv2N3hpx8parallel2v110replace_ifERR8ExPolicy7FwdIter7FwdIterRR1FR1TRR4Proj"></span><span id="hpx::parallel::v1::replace_if__ExPolicyRR.FwdIter.FwdIter.FRR.TCR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> F, <em class="property">typename</em> T, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="algorithms_2replace_8hpp_1a2e9ea84f6ce4d49680ade7b6b0be95c4"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type <code class="descname">replace_if</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, F &amp;&amp;<em>f</em>, T <em class="property">const</em> &amp;<em>new_value</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v110replace_ifERR8ExPolicy7FwdIter7FwdIterRR1FR1TRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Replaces all elements satisfying specific criteria (for which predicate <em>f</em> returns true) with <em>new_value</em> in the range [first, last).</p>
<p>Effects: Substitutes elements referred by the iterator it in the range [first, last) with new_value, when the following corresponding conditions hold: INVOKE(f, INVOKE(proj, *it)) != false</p>
<p><p>The assignments in the parallel </p>
<em>replace_if</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>last</em> - <em>first</em> applications of the predicate.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of a forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>equal</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the new values to replace (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is an unary predicate which returns <em>true</em> for the elements which need to replaced. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter</em> can be dereferenced and then implicitly converted to <em>Type</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">new_value</span></code>: Refers to the new value to use as the replacement. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>replace_if</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>replace_if</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter</em> otherwise. It returns <em>last</em>. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v112replace_copyERR8ExPolicy8FwdIter18FwdIter18FwdIter2R2T1R2T2RR4Proj">
<span id="_CPPv2N3hpx8parallel2v112replace_copyERR8ExPolicy8FwdIter18FwdIter18FwdIter2R2T1R2T2RR4Proj"></span><span id="hpx::parallel::v1::replace_copy__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.T1CR.T2CR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> T1, <em class="property">typename</em> T2, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="algorithms_2replace_8hpp_1aaee4d117fd1f6f1ca4791e0866b9e090"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::in<span class="sig-paren">(</span>FwdIter1<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>FwdIter2<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">replace_copy</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, FwdIter1 <em>last</em>, FwdIter2 <em>dest</em>, T1 <em class="property">const</em> &amp;<em>old_value</em>, T2 <em class="property">const</em> &amp;<em>new_value</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v112replace_copyERR8ExPolicy8FwdIter18FwdIter18FwdIter2R2T1R2T2RR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the all elements from the range [first, last) to another range beginning at <em>dest</em> replacing all elements satisfying a specific criteria with <em>new_value</em>.</p>
<p>Effects: Assigns to every iterator it in the range [result, result + (last - first)) either new_value or *(first + (it - result)) depending on whether the following corresponding condition holds: INVOKE(proj, *(first + (i - result))) == old_value</p>
<p><p>The assignments in the parallel </p>
<em>replace_copy</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>last</em> - <em>first</em> applications of the predicate.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">T1</span></code>: The type of the old value to replace (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">T2</span></code>: The type of the new values to replace (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">old_value</span></code>: Refers to the old value of the elements to replace. </li>
<li><code class="docutils literal notranslate"><span class="pre">new_value</span></code>: Refers to the new value to use as the replacement. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>replace_copy</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>replace_copy</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</em> &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</em> otherwise. The <em>copy</em> algorithm returns the pair of the input iterator <em>last</em> and the output iterator to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v115replace_copy_ifERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR1FR1TRR4Proj">
<span id="_CPPv2N3hpx8parallel2v115replace_copy_ifERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR1FR1TRR4Proj"></span><span id="hpx::parallel::v1::replace_copy_if__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.FRR.TCR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> F, <em class="property">typename</em> T, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="algorithms_2replace_8hpp_1a219670d09db94ffcae04ca4f89063a01"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::in<span class="sig-paren">(</span>FwdIter1<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>FwdIter2<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">replace_copy_if</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, FwdIter1 <em>last</em>, FwdIter2 <em>dest</em>, F &amp;&amp;<em>f</em>, T <em class="property">const</em> &amp;<em>new_value</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v115replace_copy_ifERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR1FR1TRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the all elements from the range [first, last) to another range beginning at <em>dest</em> replacing all elements satisfying a specific criteria with <em>new_value</em>.</p>
<p>Effects: Assigns to every iterator it in the range [result, result + (last - first)) either new_value or *(first + (it - result)) depending on whether the following corresponding condition holds: INVOKE(f, INVOKE(proj, *(first + (i - result)))) != false</p>
<p><p>The assignments in the parallel </p>
<em>replace_copy_if</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>last</em> - <em>first</em> applications of the predicate.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>equal</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the new values to replace (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is an unary predicate which returns <em>true</em> for the elements which need to replaced. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter1</em> can be dereferenced and then implicitly converted to <em>Type</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">new_value</span></code>: Refers to the new value to use as the replacement. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>replace_copy_if</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>replace_copy_if</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</em> &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</em> otherwise. The <em>replace_copy_if</em> algorithm returns the input iterator <em>last</em> and the output iterator to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-lexicographical-compare-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/lexicographical_compare.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-lexicographical-compare-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v123lexicographical_compareERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter2RR4Pred">
<span id="_CPPv2N3hpx8parallel2v123lexicographical_compareERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter2RR4Pred"></span><span id="hpx::parallel::v1::lexicographical_compare__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.FwdIter2.PredRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> Pred = detail::less&gt;<br /><span class="target" id="lexicographical__compare_8hpp_1abbb51eb74545a3b56fd4c68eeb182888"></span><a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::enable_if&lt;<a class="reference internal" href="../compute/api.html#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="../execution/api.html#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, bool&gt;::type&gt;::type <code class="descname">lexicographical_compare</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first1</em>, FwdIter1 <em>last1</em>, FwdIter2 <em>first2</em>, FwdIter2 <em>last2</em>, Pred &amp;&amp;<em>pred</em> = Pred()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v123lexicographical_compareERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter2RR4Pred" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Checks if the first range [first1, last1) is lexicographically less than the second range [first2, last2). uses a provided predicate to compare elements.</p>
<p><p>The comparison operations in the parallel </p>
<em>lexicographical_compare</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: At most 2 * min(N1, N2) applications of the comparison operation, where N1 = std::distance(first1, last) and N2 = std::distance(first2, last2).</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used for the first range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the source iterators used for the second range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <em>lexicographical_compare</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::less&lt;&gt;</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first1</span></code>: Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last1</span></code>: Refers to the end of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">first2</span></code>: Refers to the beginning of the sequence of elements of the second range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last2</span></code>: Refers to the end of the sequence of elements of the second range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">pred</span></code>: Refers to the comparison function that the first and second ranges will be applied to</li>
</ul>
</dd>
</dl>
</p>
<p>The comparison operations in the parallel <em>lexicographical_compare</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Lexicographical comparison is an operation with the following properties<ul class="simple">
<li>Two ranges are compared element by element</li>
<li>The first mismatching element defines which range is lexicographically <em>less</em> or <em>greater</em> than the other</li>
<li>If one range is a prefix of another, the shorter range is lexicographically <em>less</em> than the other</li>
<li>If two ranges have equivalent elements and are of the same length, then the ranges are lexicographically <em>equal</em> </li>
<li>An empty range is lexicographically <em>less</em> than any non-empty range</li>
<li>Two empty ranges are lexicographically <em>equal</em> </li>
</ul>
</dd>
<dt><strong>Return</strong></dt>
<dd>The <em>lexicographically_compare</em> algorithm returns a <em>hpx::future&lt;bool&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>bool</em> otherwise. The <em>lexicographically_compare</em> algorithm returns true if the first range is lexicographically less, otherwise it returns false. range [first2, last2), it returns false. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-uninitialized-fill-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/uninitialized_fill.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-uninitialized-fill-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v118uninitialized_fillERR8ExPolicy7FwdIter7FwdIterR1T">
<span id="_CPPv2N3hpx8parallel2v118uninitialized_fillERR8ExPolicy7FwdIter7FwdIterR1T"></span><span id="hpx::parallel::v1::uninitialized_fill__ExPolicyRR.FwdIter.FwdIter.TCR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> T&gt;<br /><span class="target" id="uninitialized__fill_8hpp_1ac5fd01a8ff6df22acc884726bc4ab887"></span><a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::enable_if&lt;<a class="reference internal" href="../compute/api.html#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="../execution/api.html#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy&gt;::type&gt;::type <code class="descname">uninitialized_fill</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, T <em class="property">const</em> &amp;<em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v118uninitialized_fillERR8ExPolicy7FwdIter7FwdIterR1T" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the given <em>value</em> to an uninitialized memory area, defined by the range [first, last). If an exception is thrown during the initialization, the function has no effects.</p>
<p><p>The initializations in the parallel </p>
<em>uninitialized_fill</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Linear in the distance between <em>first</em> and <em>last</em> </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the value to be assigned (deduced).</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">value</span></code>: The value to be assigned.</li>
</ul>
</dd>
</dl>
</p>
<p>The initializations in the parallel <em>uninitialized_fill</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>uninitialized_fill</em> algorithm returns a <em>hpx::future&lt;void&gt;</em>, if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns nothing otherwise. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v120uninitialized_fill_nERR8ExPolicy7FwdIter4SizeR1T">
<span id="_CPPv2N3hpx8parallel2v120uninitialized_fill_nERR8ExPolicy7FwdIter4SizeR1T"></span><span id="hpx::parallel::v1::uninitialized_fill_n__ExPolicyRR.FwdIter.Size.TCR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> Size, <em class="property">typename</em> T&gt;<br /><span class="target" id="uninitialized__fill_8hpp_1a64bff17a555cc36ea2b32ebbd53b3a14"></span><a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::enable_if&lt;<a class="reference internal" href="../compute/api.html#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="../execution/api.html#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy&gt;::type&gt;::type <code class="descname">uninitialized_fill_n</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, Size <em>count</em>, T <em class="property">const</em> &amp;<em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v120uninitialized_fill_nERR8ExPolicy7FwdIter4SizeR1T" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the given <em>value</em> value to the first count elements in an uninitialized memory area beginning at first. If an exception is thrown during the initialization, the function has no effects.</p>
<p><p>The initializations in the parallel </p>
<em>uninitialized_fill_n</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>count</em> assignments, if count &gt; 0, no assignments otherwise.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of a forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Size</span></code>: The type of the argument specifying the number of elements to apply <em>f</em> to. </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the value to be assigned (deduced).</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">count</span></code>: Refers to the number of elements starting at <em>first</em> the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">value</span></code>: The value to be assigned.</li>
</ul>
</dd>
</dl>
</p>
<p>The initializations in the parallel <em>uninitialized_fill_n</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>uninitialized_fill_n</em> algorithm returns a <em>hpx::future&lt;void&gt;</em>, if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns nothing otherwise. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-includes-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/includes.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-includes-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v18includesERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter2RR4Pred">
<span id="_CPPv2N3hpx8parallel2v18includesERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter2RR4Pred"></span><span id="hpx::parallel::v1::includes__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.FwdIter2.PredRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> Pred = detail::less&gt;<br /><span class="target" id="includes_8hpp_1a3f19a0960e7f96dcbc6dfc8b199ccd60"></span><a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::enable_if&lt;<a class="reference internal" href="../compute/api.html#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="../execution/api.html#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, bool&gt;::type&gt;::type <code class="descname">includes</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first1</em>, FwdIter1 <em>last1</em>, FwdIter2 <em>first2</em>, FwdIter2 <em>last2</em>, Pred &amp;&amp;<em>op</em> = Pred()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v18includesERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter2RR4Pred" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns true if every element from the sorted range [first2, last2) is found within the sorted range [first1, last1). Also returns true if [first2, last2) is empty. The version expects both ranges to be sorted with the user supplied binary predicate <em>f</em>.</p>
<p><p>The comparison operations in the parallel </p>
<em>includes</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>At most 2*(N1+N2-1) comparisons, where N1 = std::distance(first1, last1) and N2 = std::distance(first2, last2).</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used for the first range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the source iterators used for the second range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <em>includes</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::less&lt;&gt;</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first1</span></code>: Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last1</span></code>: Refers to the end of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">first2</span></code>: Refers to the beginning of the sequence of elements of the second range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last2</span></code>: Refers to the end of the sequence of elements of the second range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">op</span></code>: The binary predicate which returns true if the elements should be treated as includes. The signature of the predicate function should be equivalent to the following: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type2</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> and <em>Type2</em> must be such that objects of types <em>FwdIter1</em> and <em>FwdIter2</em> can be dereferenced and then implicitly converted to <em>Type1</em> and <em>Type2</em> respectively</li>
</ul>
</dd>
</dl>
</p>
<p>The comparison operations in the parallel <em>includes</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>includes</em> algorithm returns a <em>hpx::future&lt;bool&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>bool</em> otherwise. The <em>includes</em> algorithm returns true every element from the sorted range [first2, last2) is found within the sorted range [first1, last1). Also returns true if [first2, last2) is empty. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-exclusive-scan-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/exclusive_scan.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-exclusive-scan-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v114exclusive_scanERR8ExPolicy8FwdIter18FwdIter18FwdIter21TRR2Op">
<span id="_CPPv2N3hpx8parallel2v114exclusive_scanERR8ExPolicy8FwdIter18FwdIter18FwdIter21TRR2Op"></span><span id="hpx::parallel::v1::exclusive_scan__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.T.OpRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> T, <em class="property">typename</em> Op&gt;<br /><span class="target" id="exclusive__scan_8hpp_1ab474ab2b38b4dfe9eb4221f013b3a890"></span><a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::enable_if&lt;<a class="reference internal" href="../compute/api.html#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="../execution/api.html#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter2&gt;::type&gt;::type <code class="descname">exclusive_scan</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, FwdIter1 <em>last</em>, FwdIter2 <em>dest</em>, T <em>init</em>, Op &amp;&amp;<em>op</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v114exclusive_scanERR8ExPolicy8FwdIter18FwdIter18FwdIter21TRR2Op" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assigns through each iterator <em>i</em> in [result, result + (last - first)) the value of GENERALIZED_NONCOMMUTATIVE_SUM(binary_op, init, *first, …, *(first + (i - result) - 1)).</p>
<p><p>The reduce operations in the parallel </p>
<em>exclusive_scan</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: O(<em>last</em> - <em>first</em>) applications of the predicate <em>op</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the value to be used as initial (and intermediate) values (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">Op</span></code>: The type of the binary function object used for the reduction operation.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">init</span></code>: The initial value for the generalized sum. </li>
<li><code class="docutils literal notranslate"><span class="pre">op</span></code>: Specifies the function (or function object) which will be invoked for each of the values of the input sequence. This is a binary predicate. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ret</span> <span class="nf">fun</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> and <em>Ret</em> must be such that an object of a type as given by the input sequence can be implicitly converted to any of those types.</li>
</ul>
</dd>
</dl>
</p>
<p>The reduce operations in the parallel <em>exclusive_scan</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><p>The difference between </p>
<em>exclusive_scan</em> and <em>inclusive_scan</em> is that <em>inclusive_scan</em> includes the ith input element in the ith sum. If <em>op</em> is not mathematically associative, the behavior of <em>inclusive_scan</em> may be non-deterministic. <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>copy_n</em> algorithm returns a <em>hpx::future&lt;FwdIter2&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter2</em> otherwise. The <em>exclusive_scan</em> algorithm returns the output iterator to the element in the destination range, one past the last element copied.</dd>
<dt><strong>Note</strong></dt>
<dd>GENERALIZED_NONCOMMUTATIVE_SUM(op, a1, …, aN) is defined as:<ul class="simple">
<li>a1 when N is 1</li>
<li>op(GENERALIZED_NONCOMMUTATIVE_SUM(op, a1, …, aK), GENERALIZED_NONCOMMUTATIVE_SUM(op, aM, …, aN)) where 1 &lt; K+1 = M &lt;= N.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v114exclusive_scanERR8ExPolicy8FwdIter18FwdIter18FwdIter21T">
<span id="_CPPv2N3hpx8parallel2v114exclusive_scanERR8ExPolicy8FwdIter18FwdIter18FwdIter21T"></span><span id="hpx::parallel::v1::exclusive_scan__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.T"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> T&gt;<br /><span class="target" id="exclusive__scan_8hpp_1ac276e65113e72cb0ba8257fabeac0fa2"></span><a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::enable_if&lt;<a class="reference internal" href="../compute/api.html#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="../execution/api.html#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter2&gt;::type&gt;::type <code class="descname">exclusive_scan</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, FwdIter1 <em>last</em>, FwdIter2 <em>dest</em>, T <em>init</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v114exclusive_scanERR8ExPolicy8FwdIter18FwdIter18FwdIter21T" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assigns through each iterator <em>i</em> in [result, result + (last - first)) the value of GENERALIZED_NONCOMMUTATIVE_SUM(+, init, *first, …, *(first + (i - result) - 1))</p>
<p><p>The reduce operations in the parallel </p>
<em>exclusive_scan</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: O(<em>last</em> - <em>first</em>) applications of the predicate <em>std::plus&lt;T&gt;</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the value to be used as initial (and intermediate) values (deduced).</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">init</span></code>: The initial value for the generalized sum.</li>
</ul>
</dd>
</dl>
</p>
<p>The reduce operations in the parallel <em>exclusive_scan</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><p>The difference between </p>
<em>exclusive_scan</em> and <em>inclusive_scan</em> is that <em>inclusive_scan</em> includes the ith input element in the ith sum. <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>copy_n</em> algorithm returns a <em>hpx::future&lt;FwdIter2&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter2</em> otherwise. The <em>exclusive_scan</em> algorithm returns the output iterator to the element in the destination range, one past the last element copied.</dd>
<dt><strong>Note</strong></dt>
<dd>GENERALIZED_NONCOMMUTATIVE_SUM(+, a1, …, aN) is defined as:<ul class="simple">
<li>a1 when N is 1</li>
<li>GENERALIZED_NONCOMMUTATIVE_SUM(+, a1, …, aK)<ul>
<li>GENERALIZED_NONCOMMUTATIVE_SUM(+, aM, …, aN) where 1 &lt; K+1 = M &lt;= N.</li>
</ul>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-move-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/move.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-move-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v14moveERR8ExPolicy8FwdIter18FwdIter18FwdIter2">
<span id="_CPPv2N3hpx8parallel2v14moveERR8ExPolicy8FwdIter18FwdIter18FwdIter2"></span><span id="hpx::parallel::v1::move__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2&gt;<br /><span class="target" id="algorithms_2move_8hpp_1af3d1beb6f29dd4c10ee98be6efc7f14b"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::in<span class="sig-paren">(</span>FwdIter1<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>FwdIter2<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">move</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, FwdIter1 <em>last</em>, FwdIter2 <em>dest</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v14moveERR8ExPolicy8FwdIter18FwdIter18FwdIter2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Moves the elements in the range [first, last), to another range beginning at <em>dest</em>. After this operation the elements in the moved-from range will still contain valid values of the appropriate type, but not necessarily the same values as before the move.</p>
<p><p>The move assignments in the parallel </p>
<em>move</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>last</em> - <em>first</em> move assignments.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the move assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range.</li>
</ul>
</dd>
</dl>
</p>
<p>The move assignments in the parallel <em>move</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>move</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</em> &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</em> otherwise. The <em>move</em> algorithm returns the pair of the input iterator <em>last</em> and the output iterator to the element in the destination range, one past the last element moved. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-copy-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/copy.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-copy-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v14copyERR8ExPolicy8FwdIter18FwdIter18FwdIter2">
<span id="_CPPv2N3hpx8parallel2v14copyERR8ExPolicy8FwdIter18FwdIter18FwdIter2"></span><span id="hpx::parallel::v1::copy__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2&gt;<br /><span class="target" id="algorithms_2copy_8hpp_1a2b93e45792106317905f9d1e59a57fb9"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::in<span class="sig-paren">(</span>FwdIter1<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>FwdIter2<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">copy</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, FwdIter1 <em>last</em>, FwdIter2 <em>dest</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v14copyERR8ExPolicy8FwdIter18FwdIter18FwdIter2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the elements in the range, defined by [first, last), to another range beginning at <em>dest</em>.</p>
<p><p>The assignments in the parallel </p>
<em>copy</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>last</em> - <em>first</em> assignments.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>copy</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>copy</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</em> &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</em> otherwise. The <em>copy</em> algorithm returns the pair of the input iterator <em>last</em> and the output iterator to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v16copy_nERR8ExPolicy8FwdIter14Size8FwdIter2">
<span id="_CPPv2N3hpx8parallel2v16copy_nERR8ExPolicy8FwdIter14Size8FwdIter2"></span><span id="hpx::parallel::v1::copy_n__ExPolicyRR.FwdIter1.Size.FwdIter2"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> Size, <em class="property">typename</em> FwdIter2&gt;<br /><span class="target" id="algorithms_2copy_8hpp_1a90bb2d2e3d6205b123c6968a57a4c83c"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::in<span class="sig-paren">(</span>FwdIter1<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>FwdIter2<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">copy_n</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, Size <em>count</em>, FwdIter2 <em>dest</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v16copy_nERR8ExPolicy8FwdIter14Size8FwdIter2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the elements in the range [first, first + count), starting from first and proceeding to first + count - 1., to another range beginning at dest.</p>
<p><p>The assignments in the parallel </p>
<em>copy_n</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>count</em> assignments, if count &gt; 0, no assignments otherwise.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Size</span></code>: The type of the argument specifying the number of elements to apply <em>f</em> to. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">count</span></code>: Refers to the number of elements starting at <em>first</em> the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>copy_n</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>copy_n</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</em> &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</em> otherwise. The <em>copy</em> algorithm returns the pair of the input iterator forwarded to the first element after the last in the input sequence and the output iterator to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v17copy_ifERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR1FRR4Proj">
<span id="_CPPv2N3hpx8parallel2v17copy_ifERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR1FRR4Proj"></span><span id="hpx::parallel::v1::copy_if__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.FRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> F, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="algorithms_2copy_8hpp_1a3b6ff8eb6b7f290a4c6552bf4ceaa9ac"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::in<span class="sig-paren">(</span>FwdIter1<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>FwdIter2<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">copy_if</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, FwdIter1 <em>last</em>, FwdIter2 <em>dest</em>, F &amp;&amp;<em>f</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v17copy_ifERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR1FRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the elements in the range, defined by [first, last), to another range beginning at <em>dest</em>. Copies only the elements for which the predicate <em>f</em> returns true. The order of the elements that are not removed is preserved.</p>
<p><p>The assignments in the parallel </p>
<em>copy_if</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs not more than <em>last</em> - <em>first</em> assignments, exactly <em>last</em> - <em>first</em> applications of the predicate <em>f</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>copy_if</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is an unary predicate which returns <em>true</em> for the required elements. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter1</em> can be dereferenced and then implicitly converted to Type. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>copy_if</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>copy_if</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</em> &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</em> otherwise. The <em>copy</em> algorithm returns the pair of the input iterator forwarded to the first element after the last in the input sequence and the output iterator to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-for-loop-induction-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/for_loop_induction.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-for-loop-induction-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt id="_CPPv3N3hpx8parallel2v2E">
<span class="target" id="namespacehpx_1_1parallel_1_1v2"></span><em class="property">namespace </em><code class="descname">v2</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v29inductionERR1TNSt6size_tE">
<span id="_CPPv2N3hpx8parallel2v29inductionERR1TNSt6size_tE"></span><span id="hpx::parallel::v2::induction__TRR.std::s"></span><em class="property">template </em>&lt;<em class="property">typename</em> T&gt;<br /><span class="target" id="for__loop__induction_8hpp_1a98dd8d7295299a30ba869b782d6bd1f8"></span>detail::induction_stride_helper&lt;T&gt; <code class="descname">induction</code><span class="sig-paren">(</span>T &amp;&amp;<em>value</em>, <a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::size_t <em>stride</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v29inductionERR1TNSt6size_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function template returns an induction object of unspecified type having a value type and encapsulating an initial value <em>value</em> of that type and, optionally, a stride.</p>
<p>For each element in the input range, a looping algorithm over input sequence <em>S</em> computes an induction value from an induction variable and ordinal position <em>p</em> within <em>S</em> by the formula i + p * stride if a stride was specified or i + p otherwise. This induction value is passed to the element access function.</p>
<p>If the <em>value</em> argument to <em>induction</em> is a non-const lvalue, then that lvalue becomes the live-out object for the returned induction object. For each induction object that has a live-out object, the looping algorithm assigns the value of i + n * stride to the live-out object upon return, where <em>n</em> is the number of elements in the input range.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>This returns an induction object with value type <em>T</em>, initial value <em>value</em>, and (if specified) stride <em>stride</em>. If <em>T</em> is an lvalue of non-const type, <em>value</em> is used as the live-out object for the induction object; otherwise there is no live-out object. </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The value type to be used by the induction object.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">value</span></code>: [in] The initial value to use for the induction object </li>
<li><code class="docutils literal notranslate"><span class="pre">stride</span></code>: [in] The (optional) stride to use for the induction object (default: 1)</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-uninitialized-copy-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/uninitialized_copy.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-uninitialized-copy-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v118uninitialized_copyERR8ExPolicy8FwdIter18FwdIter18FwdIter2">
<span id="_CPPv2N3hpx8parallel2v118uninitialized_copyERR8ExPolicy8FwdIter18FwdIter18FwdIter2"></span><span id="hpx::parallel::v1::uninitialized_copy__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2&gt;<br /><span class="target" id="uninitialized__copy_8hpp_1ac8ce2190b8fe6d980bdf68cf364e0ae1"></span><a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::enable_if&lt;<a class="reference internal" href="../compute/api.html#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="../execution/api.html#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter2&gt;::type&gt;::type <code class="descname">uninitialized_copy</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, FwdIter1 <em>last</em>, FwdIter2 <em>dest</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v118uninitialized_copyERR8ExPolicy8FwdIter18FwdIter18FwdIter2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the elements in the range, defined by [first, last), to an uninitialized memory area beginning at <em>dest</em>. If an exception is thrown during the copy operation, the function has no effects.</p>
<p><p>The assignments in the parallel </p>
<em>uninitialized_copy</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>last</em> - <em>first</em> assignments.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of a forward iterator.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>uninitialized_copy</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>uninitialized_copy</em> algorithm returns a <em>hpx::future&lt;FwdIter2&gt;</em>, if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter2</em> otherwise. The <em>uninitialized_copy</em> algorithm returns the output iterator to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v120uninitialized_copy_nERR8ExPolicy8FwdIter14Size8FwdIter2">
<span id="_CPPv2N3hpx8parallel2v120uninitialized_copy_nERR8ExPolicy8FwdIter14Size8FwdIter2"></span><span id="hpx::parallel::v1::uninitialized_copy_n__ExPolicyRR.FwdIter1.Size.FwdIter2"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> Size, <em class="property">typename</em> FwdIter2&gt;<br /><span class="target" id="uninitialized__copy_8hpp_1ad68ae559943a4f2bd335457f2185b6b2"></span><a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::enable_if&lt;<a class="reference internal" href="../compute/api.html#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="../execution/api.html#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter2&gt;::type&gt;::type <code class="descname">uninitialized_copy_n</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, Size <em>count</em>, FwdIter2 <em>dest</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v120uninitialized_copy_nERR8ExPolicy8FwdIter14Size8FwdIter2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the elements in the range [first, first + count), starting from first and proceeding to first + count - 1., to another range beginning at dest. If an exception is thrown during the copy operation, the function has no effects.</p>
<p><p>The assignments in the parallel </p>
<em>uninitialized_copy_n</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>count</em> assignments, if count &gt; 0, no assignments otherwise.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Size</span></code>: The type of the argument specifying the number of elements to apply <em>f</em> to. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of a forward iterator.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">count</span></code>: Refers to the number of elements starting at <em>first</em> the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>uninitialized_copy_n</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>uninitialized_copy_n</em> algorithm returns a <em>hpx::future&lt;FwdIter2&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter2</em> otherwise. The <em>uninitialized_copy_n</em> algorithm returns the output iterator to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-generate-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/generate.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-generate-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v18generateERR8ExPolicy7FwdIter7FwdIterRR1F">
<span id="_CPPv2N3hpx8parallel2v18generateERR8ExPolicy7FwdIter7FwdIterRR1F"></span><span id="hpx::parallel::v1::generate__ExPolicyRR.FwdIter.FwdIter.FRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> F&gt;<br /><span class="target" id="algorithms_2generate_8hpp_1a8b4e673fc690318448e989c780055d17"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type <code class="descname">generate</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, F &amp;&amp;<em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v18generateERR8ExPolicy7FwdIter7FwdIterRR1F" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assign each element in range [first, last) a value generated by the given function object f</p>
<p><p>The assignments in the parallel </p>
<em>generate</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Exactly <em>distance(first, last)</em> invocations of <em>f</em> and assignments.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of a forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>equal</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: generator function that will be called. signature of function should be equivalent to the following: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ret</span> <span class="nf">fun</span><span class="p">();</span>
</pre></div>
</div>
 <p> The type </p>
<em>Ret</em> must be such that an object of type <em>FwdIter</em> can be dereferenced and assigned a value of type <em>Ret</em>.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>generate</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>replace_if</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter</em> otherwise. It returns <em>last</em>. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v110generate_nERR8ExPolicy7FwdIter4SizeRR1F">
<span id="_CPPv2N3hpx8parallel2v110generate_nERR8ExPolicy7FwdIter4SizeRR1F"></span><span id="hpx::parallel::v1::generate_n__ExPolicyRR.FwdIter.Size.FRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> Size, <em class="property">typename</em> F&gt;<br /><span class="target" id="algorithms_2generate_8hpp_1a76accd6d0c29469d74b51c9ebb3d4586"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type <code class="descname">generate_n</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, Size <em>count</em>, F &amp;&amp;<em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v110generate_nERR8ExPolicy7FwdIter4SizeRR1F" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assigns each element in range [first, first+count) a value generated by the given function object g.</p>
<p><p>The assignments in the parallel </p>
<em>generate_n</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Exactly <em>count</em> invocations of <em>f</em> and assignments, for count &gt; 0.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>equal</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">count</span></code>: Refers to the number of elements in the sequence the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Refers to the generator function object that will be called. The signature of the function should be equivalent to <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ret</span> <span class="nf">fun</span><span class="p">();</span>
</pre></div>
</div>
 <p> The type </p>
<em>Ret</em> must be such that an object of type <em>OutputIt</em> can be dereferenced and assigned a value of type <em>Ret</em>.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>generate_n</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>replace_if</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter</em> otherwise. It returns <em>last</em>. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-inclusive-scan-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/inclusive_scan.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-inclusive-scan-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v114inclusive_scanERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR2Op1T">
<span id="_CPPv2N3hpx8parallel2v114inclusive_scanERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR2Op1T"></span><span id="hpx::parallel::v1::inclusive_scan__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.OpRR.T"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> Op, <em class="property">typename</em> T&gt;<br /><span class="target" id="inclusive__scan_8hpp_1a7d18e1d19d9f0c47b01fea61deb4af81"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter2&gt;::type <code class="descname">inclusive_scan</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, FwdIter1 <em>last</em>, FwdIter2 <em>dest</em>, Op &amp;&amp;<em>op</em>, T <em>init</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v114inclusive_scanERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR2Op1T" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assigns through each iterator <em>i</em> in [result, result + (last - first)) the value of GENERALIZED_NONCOMMUTATIVE_SUM(op, init, *first, …, *(first + (i - result))).</p>
<p><p>The reduce operations in the parallel </p>
<em>inclusive_scan</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: O(<em>last</em> - <em>first</em>) applications of the predicate <em>op</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the value to be used as initial (and intermediate) values (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">Op</span></code>: The type of the binary function object used for the reduction operation.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">init</span></code>: The initial value for the generalized sum. </li>
<li><code class="docutils literal notranslate"><span class="pre">op</span></code>: Specifies the function (or function object) which will be invoked for each of the values of the input sequence. This is a binary predicate. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ret</span> <span class="nf">fun</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> and <em>Ret</em> must be such that an object of a type as given by the input sequence can be implicitly converted to any of those types.</li>
</ul>
</dd>
</dl>
</p>
<p>The reduce operations in the parallel <em>inclusive_scan</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><p>The difference between </p>
<em>exclusive_scan</em> and <em>inclusive_scan</em> is that <em>inclusive_scan</em> includes the ith input element in the ith sum. If <em>op</em> is not mathematically associative, the behavior of <em>inclusive_scan</em> may be non-deterministic. <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>copy_n</em> algorithm returns a <em>hpx::future&lt;FwdIter2&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter2</em> otherwise. The <em>inclusive_scan</em> algorithm returns the output iterator to the element in the destination range, one past the last element copied.</dd>
<dt><strong>Note</strong></dt>
<dd>GENERALIZED_NONCOMMUTATIVE_SUM(op, a1, …, aN) is defined as:<ul class="simple">
<li>a1 when N is 1</li>
<li>op(GENERALIZED_NONCOMMUTATIVE_SUM(op, a1, …, aK), GENERALIZED_NONCOMMUTATIVE_SUM(op, aM, …, aN)) where 1 &lt; K+1 = M &lt;= N.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v114inclusive_scanERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR2Op">
<span id="_CPPv2N3hpx8parallel2v114inclusive_scanERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR2Op"></span><span id="hpx::parallel::v1::inclusive_scan__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.OpRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> Op&gt;<br /><span class="target" id="inclusive__scan_8hpp_1a7b29dcbcbfc375cf8b2f24ee539a2c81"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter2&gt;::type <code class="descname">inclusive_scan</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, FwdIter1 <em>last</em>, FwdIter2 <em>dest</em>, Op &amp;&amp;<em>op</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v114inclusive_scanERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR2Op" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assigns through each iterator <em>i</em> in [result, result + (last - first)) the value of GENERALIZED_NONCOMMUTATIVE_SUM(op, *first, …, *(first + (i - result))).</p>
<p><p>The reduce operations in the parallel </p>
<em>inclusive_scan</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: O(<em>last</em> - <em>first</em>) applications of the predicate <em>op</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Op</span></code>: The type of the binary function object used for the reduction operation.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">op</span></code>: Specifies the function (or function object) which will be invoked for each of the values of the input sequence. This is a binary predicate. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ret</span> <span class="nf">fun</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> and <em>Ret</em> must be such that an object of a type as given by the input sequence can be implicitly converted to any of those types.</li>
</ul>
</dd>
</dl>
</p>
<p>The reduce operations in the parallel <em>inclusive_scan</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><p>The difference between </p>
<em>exclusive_scan</em> and <em>inclusive_scan</em> is that <em>inclusive_scan</em> includes the ith input element in the ith sum. <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>copy_n</em> algorithm returns a <em>hpx::future&lt;FwdIter2&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter2</em> otherwise. The <em>inclusive_scan</em> algorithm returns the output iterator to the element in the destination range, one past the last element copied.</dd>
<dt><strong>Note</strong></dt>
<dd>GENERALIZED_NONCOMMUTATIVE_SUM(+, a1, …, aN) is defined as:<ul class="simple">
<li>a1 when N is 1</li>
<li>GENERALIZED_NONCOMMUTATIVE_SUM(op, a1, …, aK)<ul>
<li>GENERALIZED_NONCOMMUTATIVE_SUM(+, aM, …, aN) where 1 &lt; K+1 = M &lt;= N.</li>
</ul>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v114inclusive_scanERR8ExPolicy8FwdIter18FwdIter18FwdIter2">
<span id="_CPPv2N3hpx8parallel2v114inclusive_scanERR8ExPolicy8FwdIter18FwdIter18FwdIter2"></span><span id="hpx::parallel::v1::inclusive_scan__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2&gt;<br /><span class="target" id="inclusive__scan_8hpp_1a466d53794e6a6fa52d6ad41610fd4e58"></span><a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::enable_if&lt;<a class="reference internal" href="../compute/api.html#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="../execution/api.html#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter2&gt;::type&gt;::type <code class="descname">inclusive_scan</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, FwdIter1 <em>last</em>, FwdIter2 <em>dest</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v114inclusive_scanERR8ExPolicy8FwdIter18FwdIter18FwdIter2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assigns through each iterator <em>i</em> in [result, result + (last - first)) the value of gENERALIZED_NONCOMMUTATIVE_SUM(+, *first, …, *(first + (i - result))).</p>
<p><p>The reduce operations in the parallel </p>
<em>inclusive_scan</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: O(<em>last</em> - <em>first</em>) applications of the predicate <em>op</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range.</li>
</ul>
</dd>
</dl>
</p>
<p>The reduce operations in the parallel <em>inclusive_scan</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><p>The difference between </p>
<em>exclusive_scan</em> and <em>inclusive_scan</em> is that <em>inclusive_scan</em> includes the ith input element in the ith sum. <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>copy_n</em> algorithm returns a <em>hpx::future&lt;FwdIter2&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter2</em> otherwise. The <em>inclusive_scan</em> algorithm returns the output iterator to the element in the destination range, one past the last element copied.</dd>
<dt><strong>Note</strong></dt>
<dd>GENERALIZED_NONCOMMUTATIVE_SUM(+, a1, …, aN) is defined as:<ul class="simple">
<li>a1 when N is 1</li>
<li>GENERALIZED_NONCOMMUTATIVE_SUM(+, a1, …, aK)<ul>
<li>GENERALIZED_NONCOMMUTATIVE_SUM(+, aM, …, aN) where 1 &lt; K+1 = M &lt;= N.</li>
</ul>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-mismatch-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/mismatch.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-mismatch-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v18mismatchERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter2RR4Pred">
<span id="_CPPv2N3hpx8parallel2v18mismatchERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter2RR4Pred"></span><span id="hpx::parallel::v1::mismatch__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.FwdIter2.PredRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> Pred = detail::equal_to&gt;<br /><span class="target" id="mismatch_8hpp_1aac9f9389eccc684f101d4100482caa8c"></span><a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::enable_if&lt;<a class="reference internal" href="../compute/api.html#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="../execution/api.html#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::pair&lt;FwdIter1, FwdIter2&gt;&gt;::type&gt;::type <code class="descname">mismatch</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first1</em>, FwdIter1 <em>last1</em>, FwdIter2 <em>first2</em>, FwdIter2 <em>last2</em>, Pred &amp;&amp;<em>op</em> = Pred()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v18mismatchERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter2RR4Pred" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns true if the range [first1, last1) is mismatch to the range [first2, last2), and false otherwise.</p>
<p><p>The comparison operations in the parallel </p>
<em>mismatch</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: At most min(last1 - first1, last2 - first2) applications of the predicate <em>f</em>. If <em>FwdIter1</em> and <em>FwdIter2</em> meet the requirements of <em>RandomAccessIterator</em> and (last1 - first1) != (last2 - first2) then no applications of the predicate <em>f</em> are made.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used for the first range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the source iterators used for the second range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <em>mismatch</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::equal_to&lt;&gt;</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first1</span></code>: Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last1</span></code>: Refers to the end of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">first2</span></code>: Refers to the beginning of the sequence of elements of the second range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last2</span></code>: Refers to the end of the sequence of elements of the second range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">op</span></code>: The binary predicate which returns true if the elements should be treated as mismatch. The signature of the predicate function should be equivalent to the following: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type2</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> and <em>Type2</em> must be such that objects of types <em>FwdIter1</em> and <em>FwdIter2</em> can be dereferenced and then implicitly converted to <em>Type1</em> and <em>Type2</em> respectively</li>
</ul>
</dd>
</dl>
</p>
<p>The comparison operations in the parallel <em>mismatch</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The two ranges are considered mismatch if, for every iterator i in the range [first1,last1), *i mismatchs *(first2 + (i - first1)). This overload of mismatch uses operator== to determine if two elements are mismatch.</dd>
<dt><strong>Return</strong></dt>
<dd>The <em>mismatch</em> algorithm returns a <em>hpx::future&lt;bool&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>bool</em> otherwise. The <em>mismatch</em> algorithm returns true if the elements in the two ranges are mismatch, otherwise it returns false. If the length of the range [first1, last1) does not mismatch the length of the range [first2, last2), it returns false. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v18mismatchERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR4Pred">
<span id="_CPPv2N3hpx8parallel2v18mismatchERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR4Pred"></span><span id="hpx::parallel::v1::mismatch__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.PredRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> Pred = detail::equal_to&gt;<br /><span class="target" id="mismatch_8hpp_1a88e421cce401c243ae7fceef6e046292"></span><a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::enable_if&lt;<a class="reference internal" href="../compute/api.html#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="../execution/api.html#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::pair&lt;FwdIter1, FwdIter2&gt;&gt;::type&gt;::type <code class="descname">mismatch</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first1</em>, FwdIter1 <em>last1</em>, FwdIter2 <em>first2</em>, Pred &amp;&amp;<em>op</em> = Pred()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v18mismatchERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR4Pred" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns std::pair with iterators to the first two non-equivalent elements.</p>
<p><p>The comparison operations in the parallel </p>
<em>mismatch</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: At most <em>last1</em> - <em>first1</em> applications of the predicate <em>f</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used for the first range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the source iterators used for the second range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <em>mismatch</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::equal_to&lt;&gt;</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first1</span></code>: Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last1</span></code>: Refers to the end of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">first2</span></code>: Refers to the beginning of the sequence of elements of the second range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">op</span></code>: The binary predicate which returns true if the elements should be treated as mismatch. The signature of the predicate function should be equivalent to the following: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type2</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> and <em>Type2</em> must be such that objects of types <em>FwdIter1</em> and <em>FwdIter2</em> can be dereferenced and then implicitly converted to <em>Type1</em> and <em>Type2</em> respectively</li>
</ul>
</dd>
</dl>
</p>
<p>The comparison operations in the parallel <em>mismatch</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>mismatch</em> algorithm returns a <em>hpx::future&lt;std::pair&lt;FwdIter1, FwdIter2&gt;</em> &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>std::pair&lt;FwdIter1, FwdIter2&gt;</em> otherwise. The <em>mismatch</em> algorithm returns the first mismatching pair of elements from two ranges: one defined by [first1, last1) and another defined by [first2, last2). </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-set-symmetric-difference-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/set_symmetric_difference.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-set-symmetric-difference-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v124set_symmetric_differenceERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter28FwdIter3RR4Pred">
<span id="_CPPv2N3hpx8parallel2v124set_symmetric_differenceERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter28FwdIter3RR4Pred"></span><span id="hpx::parallel::v1::set_symmetric_difference__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.FwdIter2.FwdIter3.PredRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> FwdIter3, <em class="property">typename</em> Pred = detail::less&gt;<br /><span class="target" id="set__symmetric__difference_8hpp_1aaf715214764a0768c17c7541ce3690bf"></span><a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::enable_if&lt;<a class="reference internal" href="../compute/api.html#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="../execution/api.html#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter3&gt;::type&gt;::type <code class="descname">set_symmetric_difference</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first1</em>, FwdIter1 <em>last1</em>, FwdIter2 <em>first2</em>, FwdIter2 <em>last2</em>, FwdIter3 <em>dest</em>, Pred &amp;&amp;<em>op</em> = Pred()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v124set_symmetric_differenceERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter28FwdIter3RR4Pred" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructs a sorted range beginning at dest consisting of all elements present in either of the sorted ranges [first1, last1) and [first2, last2), but not in both of them are copied to the range beginning at <em>dest</em>. The resulting range is also sorted. This algorithm expects both input ranges to be sorted with the given binary predicate <em>f</em>.</p>
<p><p>If some element is found </p>
<em>m</em> times in [first1, last1) and <em>n</em> times in [first2, last2), it will be copied to <em>dest</em> exactly std::abs(m-n) times. If m&gt;n, then the last m-n of those elements are copied from [first1,last1), otherwise the last n-m elements are copied from [first2,last2). The resulting range cannot overlap with either of the input ranges.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: At most 2*(N1 + N2 - 1) comparisons, where <em>N1</em> is the length of the first sequence and <em>N2</em> is the length of the second sequence.</dd>
</dl>
</p>
<p>The resulting range cannot overlap with either of the input ranges.</p>
<p><p>The application of function objects in parallel algorithm invoked with a sequential execution policy object execute in sequential order in the calling thread (</p>
<em>sequenced_policy</em>) or in a single new thread spawned from the current thread (for <em>sequenced_task_policy</em>).<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced) representing the first sequence. This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the source iterators used (deduced) representing the first sequence. This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter3</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an output iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <em>set_symmetric_difference</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::less&lt;&gt;</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first1</span></code>: Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last1</span></code>: Refers to the end of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">first2</span></code>: Refers to the beginning of the sequence of elements of the second range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last2</span></code>: Refers to the end of the sequence of elements of the second range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">op</span></code>: The binary predicate which returns true if the elements should be treated as equal. The signature of the predicate function should be equivalent to the following: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type1</em> must be such that objects of type <em>InIter</em> can be dereferenced and then implicitly converted to <em>Type1</em> </li>
</ul>
</dd>
</dl>
</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>set_symmetric_difference</em> algorithm returns a <em>hpx::future&lt;FwdIter3&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter3</em> otherwise. The <em>set_symmetric_difference</em> algorithm returns the output iterator to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-is-heap-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/is_heap.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-is-heap-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v17is_heapERR8ExPolicy8RandIter8RandIterRR4CompRR4Proj">
<span id="_CPPv2N3hpx8parallel2v17is_heapERR8ExPolicy8RandIter8RandIterRR4CompRR4Proj"></span><span id="hpx::parallel::v1::is_heap__ExPolicyRR.RandIter.RandIter.CompRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> RandIter, <em class="property">typename</em> Comp = detail::less, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="algorithms_2is__heap_8hpp_1a284adaa6f9b0e09f16df5985b9750f93"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, bool&gt;::type <code class="descname">is_heap</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, RandIter <em>first</em>, RandIter <em>last</em>, Comp &amp;&amp;<em>comp</em> = Comp(), Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v17is_heapERR8ExPolicy8RandIter8RandIterRR4CompRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns whether the range is max heap. That is, true if the range is max heap, false otherwise. The function uses the given comparison function object <em>comp</em> (defaults to using operator&lt;()).</p>
<p><em>comp</em> has to induce a strict weak ordering on the values.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs at most N applications of the comparison <em>comp</em>, at most 2 * N applications of the projection <em>proj</em>, where N = last - first.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">RandIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of a random access iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Comp</span></code>: The type of the function/function object to use (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">comp</span></code>: <em>comp</em> is a callable object. The return value of the INVOKE operation applied to an object of type <em>Comp</em>, when contextually converted to bool, yields true if the first argument of the call is less than the second, and false otherwise. It is assumed that comp will not apply any non-constant function through the dereferenced iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>is_heap</em> algorithm returns a <em>hpx::future&lt;bool&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>bool</em> otherwise. The <em>is_heap</em> algorithm returns whether the range is max heap. That is, true if the range is max heap, false otherwise. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v113is_heap_untilERR8ExPolicy8RandIter8RandIterRR4CompRR4Proj">
<span id="_CPPv2N3hpx8parallel2v113is_heap_untilERR8ExPolicy8RandIter8RandIterRR4CompRR4Proj"></span><span id="hpx::parallel::v1::is_heap_until__ExPolicyRR.RandIter.RandIter.CompRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> RandIter, <em class="property">typename</em> Comp = detail::less, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="algorithms_2is__heap_8hpp_1af348f9ef4c58daed9fb9cb1d057678fb"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, RandIter&gt;::type <code class="descname">is_heap_until</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, RandIter <em>first</em>, RandIter <em>last</em>, Comp &amp;&amp;<em>comp</em> = Comp(), Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v113is_heap_untilERR8ExPolicy8RandIter8RandIterRR4CompRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the upper bound of the largest range beginning at <em>first</em> which is a max heap. That is, the last iterator <em>it</em> for which range [first, it) is a max heap. The function uses the given comparison function object <em>comp</em> (defaults to using operator&lt;()).</p>
<p><em>comp</em> has to induce a strict weak ordering on the values.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs at most N applications of the comparison <em>comp</em>, at most 2 * N applications of the projection <em>proj</em>, where N = last - first.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">RandIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of a random access iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Comp</span></code>: The type of the function/function object to use (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">comp</span></code>: <em>comp</em> is a callable object. The return value of the INVOKE operation applied to an object of type <em>Comp</em>, when contextually converted to bool, yields true if the first argument of the call is less than the second, and false otherwise. It is assumed that comp will not apply any non-constant function through the dereferenced iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>is_heap_until</em> algorithm returns a <em>hpx::future&lt;RandIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>RandIter</em> otherwise. The <em>is_heap_until</em> algorithm returns the upper bound of the largest range beginning at first which is a max heap. That is, the last iterator <em>it</em> for which range [first, it) is a max heap. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-equal-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/equal.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-equal-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v15equalERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter2RR4Pred">
<span id="_CPPv2N3hpx8parallel2v15equalERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter2RR4Pred"></span><span id="hpx::parallel::v1::equal__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.FwdIter2.PredRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> Pred = detail::equal_to&gt;<br /><span class="target" id="equal_8hpp_1a16707e11d2949ea5a983b3198e529a3f"></span><a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::enable_if&lt;<a class="reference internal" href="../compute/api.html#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="../execution/api.html#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, bool&gt;::type&gt;::type <code class="descname">equal</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first1</em>, FwdIter1 <em>last1</em>, FwdIter2 <em>first2</em>, FwdIter2 <em>last2</em>, Pred &amp;&amp;<em>op</em> = Pred()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v15equalERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter2RR4Pred" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns true if the range [first1, last1) is equal to the range [first2, last2), and false otherwise.</p>
<p><p>The comparison operations in the parallel </p>
<em>equal</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: At most min(last1 - first1, last2 - first2) applications of the predicate <em>f</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used for the first range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the source iterators used for the second range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <em>equal</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::equal_to&lt;&gt;</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first1</span></code>: Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last1</span></code>: Refers to the end of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">first2</span></code>: Refers to the beginning of the sequence of elements of the second range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last2</span></code>: Refers to the end of the sequence of elements of the second range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">op</span></code>: The binary predicate which returns true if the elements should be treated as equal. The signature of the predicate function should be equivalent to the following: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type2</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> and <em>Type2</em> must be such that objects of types <em>FwdIter1</em> and <em>FwdIter2</em> can be dereferenced and then implicitly converted to <em>Type1</em> and <em>Type2</em> respectively</li>
</ul>
</dd>
</dl>
</p>
<p>The comparison operations in the parallel <em>equal</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The two ranges are considered equal if, for every iterator i in the range [first1,last1), *i equals *(first2 + (i - first1)). This overload of equal uses operator== to determine if two elements are equal.</dd>
<dt><strong>Return</strong></dt>
<dd>The <em>equal</em> algorithm returns a <em>hpx::future&lt;bool&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>bool</em> otherwise. The <em>equal</em> algorithm returns true if the elements in the two ranges are equal, otherwise it returns false. If the length of the range [first1, last1) does not equal the length of the range [first2, last2), it returns false. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v15equalERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR4Pred">
<span id="_CPPv2N3hpx8parallel2v15equalERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR4Pred"></span><span id="hpx::parallel::v1::equal__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.PredRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> Pred = detail::equal_to&gt;<br /><span class="target" id="equal_8hpp_1af27d9931a1e508f6aa599a43bf215b7a"></span><a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::enable_if&lt;<a class="reference internal" href="../compute/api.html#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="../execution/api.html#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, bool&gt;::type&gt;::type <code class="descname">equal</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first1</em>, FwdIter1 <em>last1</em>, FwdIter2 <em>first2</em>, Pred &amp;&amp;<em>op</em> = Pred()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v15equalERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR4Pred" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns true if the range [first1, last1) is equal to the range starting at first2, and false otherwise.</p>
<p><p>The comparison operations in the parallel </p>
<em>equal</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: At most <em>last1</em> - <em>first1</em> applications of the predicate <em>f</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used for the first range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the source iterators used for the second range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <em>equal</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::equal_to&lt;&gt;</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first1</span></code>: Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last1</span></code>: Refers to the end of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">first2</span></code>: Refers to the beginning of the sequence of elements of the second range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">op</span></code>: The binary predicate which returns true if the elements should be treated as equal. The signature of the predicate function should be equivalent to the following: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type2</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> and <em>Type2</em> must be such that objects of types <em>FwdIter1</em> and <em>FwdIter2</em> can be dereferenced and then implicitly converted to <em>Type1</em> and <em>Type2</em> respectively</li>
</ul>
</dd>
</dl>
</p>
<p>The comparison operations in the parallel <em>equal</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The two ranges are considered equal if, for every iterator i in the range [first1,last1), *i equals *(first2 + (i - first1)). This overload of equal uses operator== to determine if two elements are equal.</dd>
<dt><strong>Return</strong></dt>
<dd>The <em>equal</em> algorithm returns a <em>hpx::future&lt;bool&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>bool</em> otherwise. The <em>equal</em> algorithm returns true if the elements in the two ranges are equal, otherwise it returns false. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-remove-copy-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/remove_copy.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-remove-copy-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v111remove_copyERR8ExPolicy8FwdIter18FwdIter18FwdIter2R1TRR4Proj">
<span id="_CPPv2N3hpx8parallel2v111remove_copyERR8ExPolicy8FwdIter18FwdIter18FwdIter2R1TRR4Proj"></span><span id="hpx::parallel::v1::remove_copy__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.TCR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> T, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="algorithms_2remove__copy_8hpp_1aabfa48923f1f436809a45a7f550ff059"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::in<span class="sig-paren">(</span>FwdIter1<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>FwdIter2<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">remove_copy</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, FwdIter1 <em>last</em>, FwdIter2 <em>dest</em>, T <em class="property">const</em> &amp;<em>val</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v111remove_copyERR8ExPolicy8FwdIter18FwdIter18FwdIter2R1TRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the elements in the range, defined by [first, last), to another range beginning at <em>dest</em>. Copies only the elements for which the comparison operator returns false when compare to val. The order of the elements that are not removed is preserved.</p>
<p>Effects: Copies all the elements referred to by the iterator it in the range [first,last) for which the following corresponding conditions do not hold: INVOKE(proj, *it) == value</p>
<p><p>The assignments in the parallel </p>
<em>remove_copy</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs not more than <em>last</em> - <em>first</em> assignments, exactly <em>last</em> - <em>first</em> applications of the predicate <em>f</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type that the result of dereferencing FwdIter1 is compared to. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">val</span></code>: Value to be removed. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>remove_copy</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>remove_copy</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</em> &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</em> otherwise. The <em>copy</em> algorithm returns the pair of the input iterator forwarded to the first element after the last in the input sequence and the output iterator to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v114remove_copy_ifERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR1FRR4Proj">
<span id="_CPPv2N3hpx8parallel2v114remove_copy_ifERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR1FRR4Proj"></span><span id="hpx::parallel::v1::remove_copy_if__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.FRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> F, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="algorithms_2remove__copy_8hpp_1ab4b93370fc1e3f47e23be3060de0f922"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::in<span class="sig-paren">(</span>FwdIter1<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>FwdIter2<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">remove_copy_if</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, FwdIter1 <em>last</em>, FwdIter2 <em>dest</em>, F &amp;&amp;<em>f</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v114remove_copy_ifERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR1FRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the elements in the range, defined by [first, last), to another range beginning at <em>dest</em>. Copies only the elements for which the predicate <em>f</em> returns false. The order of the elements that are not removed is preserved.</p>
<p>Effects: Copies all the elements referred to by the iterator it in the range [first,last) for which the following corresponding conditions do not hold: INVOKE(pred, INVOKE(proj, *it)) != false.</p>
<p><p>The assignments in the parallel </p>
<em>remove_copy_if</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs not more than <em>last</em> - <em>first</em> assignments, exactly <em>last</em> - <em>first</em> applications of the predicate <em>f</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>copy_if</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is an unary predicate which returns <em>true</em> for the elements to be removed. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter1</em> can be dereferenced and then implicitly converted to Type. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>remove_copy_if</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>remove_copy_if</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</em> &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</em> otherwise. The <em>copy</em> algorithm returns the pair of the input iterator forwarded to the first element after the last in the input sequence and the output iterator to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-destroy-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/destroy.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-destroy-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v17destroyERR8ExPolicy7FwdIter7FwdIter">
<span id="_CPPv2N3hpx8parallel2v17destroyERR8ExPolicy7FwdIter7FwdIter"></span><span id="hpx::parallel::v1::destroy__ExPolicyRR.FwdIter.FwdIter"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter&gt;<br /><span class="target" id="destroy_8hpp_1a70065cb704eb09d1fa9328763fe358d3"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy&gt;::type <code class="descname">destroy</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v17destroyERR8ExPolicy7FwdIter7FwdIter" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Destroys objects of type typename iterator_traits&lt;ForwardIt&gt;::value_type in the range [first, last).</p>
<p><p>The operations in the parallel </p>
<em>destroy</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>last</em> - <em>first</em> operations.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to.</li>
</ul>
</dd>
</dl>
</p>
<p>The operations in the parallel <em>destroy</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>destroy</em> algorithm returns a <em>hpx::future&lt;void&gt;</em>, if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>void</em> otherwise. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v19destroy_nERR8ExPolicy7FwdIter4Size">
<span id="_CPPv2N3hpx8parallel2v19destroy_nERR8ExPolicy7FwdIter4Size"></span><span id="hpx::parallel::v1::destroy_n__ExPolicyRR.FwdIter.Size"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> Size&gt;<br /><span class="target" id="destroy_8hpp_1abe254a1d5dfcac6f794487708b10f63a"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type <code class="descname">destroy_n</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, Size <em>count</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v19destroy_nERR8ExPolicy7FwdIter4Size" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Destroys objects of type typename iterator_traits&lt;ForwardIt&gt;::value_type in the range [first, first + count).</p>
<p><p>The operations in the parallel </p>
<em>destroy_n</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>count</em> operations, if count &gt; 0, no assignments otherwise.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Size</span></code>: The type of the argument specifying the number of elements to apply this algorithm to.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">count</span></code>: Refers to the number of elements starting at <em>first</em> the algorithm will be applied to.</li>
</ul>
</dd>
</dl>
</p>
<p>The operations in the parallel <em>destroy_n</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>destroy_n</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter</em> otherwise. The <em>destroy_n</em> algorithm returns the iterator to the element in the source range, one past the last element constructed. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-adjacent-difference-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/adjacent_difference.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-adjacent-difference-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v119adjacent_differenceERR8ExPolicy8FwdIter18FwdIter18FwdIter2">
<span id="_CPPv2N3hpx8parallel2v119adjacent_differenceERR8ExPolicy8FwdIter18FwdIter18FwdIter2"></span><span id="hpx::parallel::v1::adjacent_difference__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2&gt;<br /><span class="target" id="adjacent__difference_8hpp_1a4ca7f8c280e43bc74fe6592babd08246"></span><a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::enable_if&lt;<a class="reference internal" href="../compute/api.html#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="../execution/api.html#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter2&gt;::type&gt;::type <code class="descname">adjacent_difference</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, FwdIter1 <em>last</em>, FwdIter2 <em>dest</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v119adjacent_differenceERR8ExPolicy8FwdIter18FwdIter18FwdIter2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assigns each value in the range given by result its corresponding element in the range [first, last] and the one preceding it except *result, which is assigned *first</p>
<p><p>The difference operations in the parallel </p>
<em>adjacent_difference</em> invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Exactly (last - first) - 1 application of the binary operator and (last - first) assignments.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used for the input range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the source iterators used for the output range (deduced). This iterator type must meet the requirements of an forward iterator.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements of the range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements of the range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the sequence of elements the results will be assigned to.</li>
</ul>
</dd>
</dl>
</p>
<p>The difference operations in the parallel <em>adjacent_difference</em> invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><p>This overload of </p>
<em>adjacent_find</em> is available if the user decides to provide their algorithm their own binary predicate <em>op</em>. <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>adjacent_difference</em> algorithm returns a <em>hpx::future&lt;FwdIter2&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter2</em> otherwise. The <em>adjacent_find</em> algorithm returns an iterator to the last element in the output range.</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v119adjacent_differenceERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR2Op">
<span id="_CPPv2N3hpx8parallel2v119adjacent_differenceERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR2Op"></span><span id="hpx::parallel::v1::adjacent_difference__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.OpRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> Op&gt;<br /><span class="target" id="adjacent__difference_8hpp_1a42440eca11d94fdb5aefaa8c1bce6408"></span><a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::enable_if&lt;<a class="reference internal" href="../compute/api.html#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="../execution/api.html#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter2&gt;::type&gt;::type <code class="descname">adjacent_difference</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, FwdIter1 <em>last</em>, FwdIter2 <em>dest</em>, Op &amp;&amp;<em>op</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v119adjacent_differenceERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR2Op" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assigns each value in the range given by result its corresponding element in the range [first, last] and the one preceding it except *result, which is assigned *first</p>
<p><p>The difference operations in the parallel </p>
<em>adjacent_difference</em> invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Exactly (last - first) - 1 application of the binary operator and (last - first) assignments.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used for the input range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the source iterators used for the output range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Op</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>adjacent_difference</em> requires <em>Op</em> to meet the requirements of <em>CopyConstructible</em>.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements of the range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements of the range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the sequence of elements the results will be assigned to. </li>
<li><code class="docutils literal notranslate"><span class="pre">op</span></code>: The binary operator which returns the difference of elements. The signature should be equivalent to the following: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">op</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> must be such that objects of type <em>FwdIter1</em> can be dereferenced and then implicitly converted to the dereferenced type of <em>dest</em>.</li>
</ul>
</dd>
</dl>
</p>
<p>The difference operations in the parallel <em>adjacent_difference</em> invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>adjacent_difference</em> algorithm returns a <em>hpx::future&lt;FwdIter2&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter2</em> otherwise. The <em>adjacent_find</em> algorithm returns an iterator to the last element in the output range. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-transform-exclusive-scan-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/transform_exclusive_scan.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-transform-exclusive-scan-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v124transform_exclusive_scanERR8ExPolicy8FwdIter18FwdIter18FwdIter21TRR2OpRR4Conv">
<span id="_CPPv2N3hpx8parallel2v124transform_exclusive_scanERR8ExPolicy8FwdIter18FwdIter18FwdIter21TRR2OpRR4Conv"></span><span id="hpx::parallel::v1::transform_exclusive_scan__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.T.OpRR.ConvRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> T, <em class="property">typename</em> Op, <em class="property">typename</em> Conv&gt;<br /><span class="target" id="transform__exclusive__scan_8hpp_1a5b927b96e3f7a187d5762f2e88217319"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter2&gt;::type <code class="descname">transform_exclusive_scan</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, FwdIter1 <em>last</em>, FwdIter2 <em>dest</em>, T <em>init</em>, Op &amp;&amp;<em>op</em>, Conv &amp;&amp;<em>conv</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v124transform_exclusive_scanERR8ExPolicy8FwdIter18FwdIter18FwdIter21TRR2OpRR4Conv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assigns through each iterator <em>i</em> in [result, result + (last - first)) the value of GENERALIZED_NONCOMMUTATIVE_SUM(binary_op, init, conv(*first), …, conv(*(first + (i - result) - 1))).</p>
<p><p>The reduce operations in the parallel </p>
<em>transform_exclusive_scan</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: O(<em>last</em> - <em>first</em>) applications of the predicates <em>op</em> and <em>conv</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Conv</span></code>: The type of the unary function object used for the conversion operation. </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the value to be used as initial (and intermediate) values (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">Op</span></code>: The type of the binary function object used for the reduction operation.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">conv</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). This is a unary predicate. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">R</span> <span class="nf">fun</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter1</em> can be dereferenced and then implicitly converted to Type. The type <em>R</em> must be such that an object of this type can be implicitly converted to <em>T</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">init</span></code>: The initial value for the generalized sum. </li>
<li><code class="docutils literal notranslate"><span class="pre">op</span></code>: Specifies the function (or function object) which will be invoked for each of the values of the input sequence. This is a binary predicate. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ret</span> <span class="nf">fun</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> and <em>Ret</em> must be such that an object of a type as given by the input sequence can be implicitly converted to any of those types.</li>
</ul>
</dd>
</dl>
</p>
<p>The reduce operations in the parallel <em>transform_exclusive_scan</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><p>Neither </p>
<em>conv</em> nor <em>op</em> shall invalidate iterators or subranges, or modify elements in the ranges [first,last) or [result,result + (last - first)).<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>copy_n</em> algorithm returns a <em>hpx::future&lt;FwdIter2&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter2</em> otherwise. The <em>transform_exclusive_scan</em> algorithm returns the output iterator to the element in the destination range, one past the last element copied.</dd>
<dt><strong>Note</strong></dt>
<dd>GENERALIZED_NONCOMMUTATIVE_SUM(op, a1, …, aN) is defined as:<ul class="simple">
<li>a1 when N is 1</li>
<li>op(GENERALIZED_NONCOMMUTATIVE_SUM(op, a1, …, aK), GENERALIZED_NONCOMMUTATIVE_SUM(op, aM, …, aN) where 1 &lt; K+1 = M &lt;= N.</li>
</ul>
</dd>
</dl>
</p>
<p>The behavior of transform_exclusive_scan may be non-deterministic for a non-associative predicate. </p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-transform-reduce-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/transform_reduce.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-transform-reduce-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v116transform_reduceERR8ExPolicy7FwdIter7FwdIter1TRR6ReduceRR7Convert">
<span id="_CPPv2N3hpx8parallel2v116transform_reduceERR8ExPolicy7FwdIter7FwdIter1TRR6ReduceRR7Convert"></span><span id="hpx::parallel::v1::transform_reduce__ExPolicyRR.FwdIter.FwdIter.T.ReduceRR.ConvertRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> T, <em class="property">typename</em> Reduce, <em class="property">typename</em> Convert&gt;<br /><span class="target" id="transform__reduce_8hpp_1aa9f78549181118dc94894d157027bdb7"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, T&gt;::type <code class="descname">transform_reduce</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, T <em>init</em>, Reduce &amp;&amp;<em>red_op</em>, Convert &amp;&amp;<em>conv_op</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v116transform_reduceERR8ExPolicy7FwdIter7FwdIter1TRR6ReduceRR7Convert" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns GENERALIZED_SUM(red_op, init, conv_op(*first), …, conv_op(*(first + (last - first) - 1))).</p>
<p><p>The reduce operations in the parallel </p>
<em>transform_reduce</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: O(<em>last</em> - <em>first</em>) applications of the predicates <em>red_op</em> and <em>conv_op</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>copy_if</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the value to be used as initial (and intermediate) values (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">Reduce</span></code>: The type of the binary function object used for the reduction operation. </li>
<li><code class="docutils literal notranslate"><span class="pre">Convert</span></code>: The type of the unary function object used to transform the elements of the input sequence before invoking the reduce function.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">conv_op</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). This is a unary predicate. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">R</span> <span class="nf">fun</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter</em> can be dereferenced and then implicitly converted to Type. The type <em>R</em> must be such that an object of this type can be implicitly converted to <em>T</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">init</span></code>: The initial value for the generalized sum. </li>
<li><code class="docutils literal notranslate"><span class="pre">red_op</span></code>: Specifies the function (or function object) which will be invoked for each of the values returned from the invocation of <em>conv_op</em>. This is a binary predicate. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ret</span> <span class="nf">fun</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type2</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em>, <em>Type2</em>, and <em>Ret</em> must be such that an object of a type as returned from <em>conv_op</em> can be implicitly converted to any of those types.</li>
</ul>
</dd>
</dl>
</p>
<p>The reduce operations in the parallel <em>transform_reduce</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><p>The difference between </p>
<em>transform_reduce</em> and <em>accumulate</em> is that the behavior of transform_reduce may be non-deterministic for non-associative or non-commutative binary predicate. <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>transform_reduce</em> algorithm returns a <em>hpx::future&lt;T&gt;</em> if the execution policy is of type <em>parallel_task_policy</em> and returns <em>T</em> otherwise. The <em>transform_reduce</em> algorithm returns the result of the generalized sum over the values returned from <em>conv_op</em> when applied to the elements given by the input range [first, last).</dd>
<dt><strong>Note</strong></dt>
<dd>GENERALIZED_SUM(op, a1, …, aN) is defined as follows:<ul class="simple">
<li>a1 when N is 1</li>
<li>op(GENERALIZED_SUM(op, b1, …, bK), GENERALIZED_SUM(op, bM, …, bN)), where:<ul>
<li>b1, …, bN may be any permutation of a1, …, aN and</li>
<li>1 &lt; K+1 = M &lt;= N.</li>
</ul>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-sort-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/sort.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-sort-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v14sortERR8ExPolicy8RandomIt8RandomItRR7CompareRR4Proj">
<span id="_CPPv2N3hpx8parallel2v14sortERR8ExPolicy8RandomIt8RandomItRR7CompareRR4Proj"></span><span id="hpx::parallel::v1::sort__ExPolicyRR.RandomIt.RandomIt.CompareRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> RandomIt, <em class="property">typename</em> Proj = util::projection_identity, <em class="property">typename</em> Compare = detail::less&gt;<br /><span class="target" id="algorithms_2sort_8hpp_1a19a39eb03a906b3fc2a00a9916d3d183"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, RandomIt&gt;::type <code class="descname">sort</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, RandomIt <em>first</em>, RandomIt <em>last</em>, Compare &amp;&amp;<em>comp</em> = Compare(), Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v14sortERR8ExPolicy8RandomIt8RandomItRR7CompareRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Sorts the elements in the range [first, last) in ascending order. The order of equal elements is not guaranteed to be preserved. The function uses the given comparison function object comp (defaults to using operator&lt;()).</p>
<p><p>A sequence is sorted with respect to a comparator </p>
<em>comp</em> and a projection <em>proj</em> if for every iterator i pointing to the sequence and every non-negative integer n such that i + n is a valid iterator pointing to an element of the sequence, and INVOKE(comp, INVOKE(proj, *(i + n)), INVOKE(proj, *i)) == false.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: O(Nlog(N)), where N = std::distance(first, last) comparisons.</dd>
</dl>
</p>
<p><em>comp</em> has to induce a strict weak ordering on the values.<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </li>
<li><code class="docutils literal notranslate"><span class="pre">Iter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of a random access iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Comp</span></code>: The type of the function/function object to use (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">comp</span></code>: comp is a callable object. The return value of the INVOKE operation applied to an object of type Comp, when contextually converted to bool, yields true if the first argument of the call is less than the second, and false otherwise. It is assumed that comp will not apply any non-constant function through the dereferenced iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each pair of elements as a projection operation before the actual predicate <em>comp</em> is invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>sort</em> algorithm returns a <em>hpx::future&lt;RandomIt&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>RandomIt</em> otherwise. The algorithm returns an iterator pointing to the first element after the last element in the input sequence. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-algorithms-count-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/algorithms/count.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-algorithms-count-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v15countERR8ExPolicy8FwdIterB8FwdIterER1TRR4Proj">
<span id="_CPPv2N3hpx8parallel2v15countERR8ExPolicy8FwdIterB8FwdIterER1TRR4Proj"></span><span id="hpx::parallel::v1::count__ExPolicyRR.FwdIterB.FwdIterE.TCR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIterB, <em class="property">typename</em> FwdIterE, <em class="property">typename</em> T, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="algorithms_2count_8hpp_1a40626af1e7ad7df4486ca9d652b9521c"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::iterator_traits&lt;FwdIterB&gt;::difference_type&gt;::type <code class="descname">count</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIterB <em>first</em>, FwdIterE <em>last</em>, T <em class="property">const</em> &amp;<em>value</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v15countERR8ExPolicy8FwdIterB8FwdIterER1TRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the number of elements in the range [first, last) satisfying a specific criteria. This version counts the elements that are equal to the given <em>value</em>.</p>
<p><p>The comparisons in the parallel </p>
<em>count</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>last</em> - <em>first</em> comparisons.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the comparisons. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIterB</span></code>: The type of the source begin iterator used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIterE</span></code>: The type of the source end iterator used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the value to search for (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">value</span></code>: The value to search for. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The comparisons in the parallel <em>count</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</dd>
<dt><strong>Return</strong></dt>
<dd>The <em>count</em> algorithm returns a <em>hpx::future&lt;difference_type&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>difference_type</em> otherwise (where <em>difference_type</em> is defined by <em>std::iterator_traits&lt;FwdIterB&gt;::difference_type</em>. The <em>count</em> algorithm returns the number of elements satisfying the given criteria. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v18count_ifERR8ExPolicy8FwdIterB8FwdIterERR1FRR4Proj">
<span id="_CPPv2N3hpx8parallel2v18count_ifERR8ExPolicy8FwdIterB8FwdIterERR1FRR4Proj"></span><span id="hpx::parallel::v1::count_if__ExPolicyRR.FwdIterB.FwdIterE.FRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIterB, <em class="property">typename</em> FwdIterE, <em class="property">typename</em> F, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="algorithms_2count_8hpp_1a448e2ea9aebf60017aee1e8f61774755"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel4utilE" title="hpx::parallel::util">util</a>::detail::algorithm_result&lt;ExPolicy, <em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::iterator_traits&lt;FwdIterB&gt;::difference_type&gt;::type <code class="descname">count_if</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIterB <em>first</em>, FwdIterE <em>last</em>, F &amp;&amp;<em>f</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v18count_ifERR8ExPolicy8FwdIterB8FwdIterERR1FRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the number of elements in the range [first, last) satisfying a specific criteria. This version counts elements for which predicate <em>f</em> returns true.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>last</em> - <em>first</em> applications of the predicate.</dd>
<dt><strong>Note</strong></dt>
<dd>The assignments in the parallel <em>count_if</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread. </dd>
<dt><strong>Note</strong></dt>
<dd>The assignments in the parallel <em>count_if</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</dd>
<dt><strong>Return</strong></dt>
<dd>The <em>count_if</em> algorithm returns <em>hpx::future&lt;difference_type&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>difference_type</em> otherwise (where <em>difference_type</em> is defined by <em>std::iterator_traits&lt;FwdIterB&gt;::difference_type</em>. The <em>count</em> algorithm returns the number of elements satisfying the given criteria. </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the comparisons. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIterB</span></code>: The type of the source begin iterator used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIterE</span></code>: The type of the source end iterator used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>count_if</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1util_1_1projection__identity"><span class="std std-ref">util::projection_identity</span></a></em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is an unary predicate which returns <em>true</em> for the required elements. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIterB</em> can be dereferenced and then implicitly converted to Type. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-traits-projected-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/traits/projected.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-traits-projected-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv3IEN3hpx6traits18projected_iteratorI8IteratorNSt9enable_ifIN21is_segmented_iteratorI8IteratorE5valueEE4typeEEE">
<span id="_CPPv2IEN3hpx6traits18projected_iteratorI8IteratorNSt9enable_ifIN21is_segmented_iteratorI8IteratorE5valueEE4typeEEE"></span><span class="target" id="structhpx_1_1traits_1_1projected__iterator_3_01_iterator_00_01typename_01std_1_1enable__if_3_01i1e6d339d5108c0c57364600f01a8c124"></span><em class="property">template </em>&lt;<em class="property">typename</em> Iterator&gt;<br />template&lt;&gt;<br /><em class="property">struct </em><code class="descname">projected_iterator</code>&lt;Iterator, <em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::enable_if&lt;is_segmented_iterator&lt;Iterator&gt;::value&gt;::type&gt;<a class="headerlink" href="#_CPPv3IEN3hpx6traits18projected_iteratorI8IteratorNSt9enable_ifIN21is_segmented_iteratorI8IteratorE5valueEE4typeEEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="type">
<dt id="_CPPv3N3hpx6traits18projected_iterator14local_iteratorE">
<span id="_CPPv2N3hpx6traits18projected_iterator14local_iteratorE"></span><span id="hpx::traits::projected_iterator::local_iterator"></span><span class="target" id="structhpx_1_1traits_1_1projected__iterator_3_01_iterator_00_01typename_01std_1_1enable__if_3_01i1e6d339d5108c0c57364600f01a8c124_1a94f69718752d0a0b99306abff58507ff"></span><em class="property">typedef </em><a class="reference internal" href="#_CPPv3N3hpx6traits25segmented_iterator_traitsE" title="hpx::traits::segmented_iterator_traits">segmented_iterator_traits</a>&lt;Iterator&gt;::local_iterator <code class="descname">local_iterator</code><a class="headerlink" href="#_CPPv3N3hpx6traits18projected_iterator14local_iteratorE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx6traits18projected_iterator4typeE">
<span id="_CPPv2N3hpx6traits18projected_iterator4typeE"></span><span id="hpx::traits::projected_iterator::type"></span><span class="target" id="structhpx_1_1traits_1_1projected__iterator_3_01_iterator_00_01typename_01std_1_1enable__if_3_01i1e6d339d5108c0c57364600f01a8c124_1aba6ff2112de3750818ecb0d0178ed835"></span><em class="property">typedef </em><a class="reference internal" href="#_CPPv3N3hpx6traits31segmented_local_iterator_traitsE" title="hpx::traits::segmented_local_iterator_traits">segmented_local_iterator_traits</a>&lt;<a class="reference internal" href="#_CPPv3N3hpx6traits18projected_iterator14local_iteratorE" title="hpx::traits::projected_iterator::local_iterator">local_iterator</a>&gt;::local_raw_iterator <code class="descname">type</code><a class="headerlink" href="#_CPPv3N3hpx6traits18projected_iterator4typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv3IEN3hpx6traits18projected_iteratorI8IteratorN3hpx4util11always_voidIN3hpx4util5decayI8IteratorE4type10proxy_typeEE4typeEEE">
<span id="_CPPv2IEN3hpx6traits18projected_iteratorI8IteratorN3hpx4util11always_voidIN3hpx4util5decayI8IteratorE4type10proxy_typeEE4typeEEE"></span><span class="target" id="structhpx_1_1traits_1_1projected__iterator_3_01_iterator_00_01typename_01hpx_1_1util_1_1always__ec1097b680ec94a68e9c1a9aefe34c52"></span><em class="property">template </em>&lt;<em class="property">typename</em> Iterator&gt;<br />template&lt;&gt;<br /><em class="property">struct </em><code class="descname">projected_iterator</code>&lt;Iterator, <em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::<a class="reference internal" href="../type_support/api.html#_CPPv3N3hpx4util11always_voidE" title="hpx::util::always_void">always_void</a>&lt;<em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::decay&lt;Iterator&gt;::type::proxy_type&gt;::type&gt;<a class="headerlink" href="#_CPPv3IEN3hpx6traits18projected_iteratorI8IteratorN3hpx4util11always_voidIN3hpx4util5decayI8IteratorE4type10proxy_typeEE4typeEEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="type">
<dt id="_CPPv3N3hpx6traits18projected_iterator4typeE">
<span id="_CPPv2N3hpx6traits18projected_iterator4typeE"></span><span class="target" id="structhpx_1_1traits_1_1projected__iterator_3_01_iterator_00_01typename_01hpx_1_1util_1_1always__ec1097b680ec94a68e9c1a9aefe34c52_1a9060c93302ab046ad94f31627ad41e49"></span><em class="property">typedef </em><a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::decay&lt;Iterator&gt;::type::proxy_type <code class="descname">type</code><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt id="_CPPv3N3hpx8parallel6traitsE">
<span id="_CPPv2N3hpx8parallel6traitsE"></span><span id="hpx::parallel::traits"></span><span class="target" id="namespacehpx_1_1parallel_1_1traits"></span><em class="property">namespace </em><code class="descname">traits</code><a class="headerlink" href="#_CPPv3N3hpx8parallel6traitsE" title="Permalink to this definition">¶</a><br /></dt>
<dd><dl class="class">
<dt id="_CPPv3N3hpx8parallel6traits9projectedE">
<span id="_CPPv2N3hpx8parallel6traits9projectedE"></span><span id="hpx::parallel::traits::projected"></span><span class="target" id="structhpx_1_1parallel_1_1traits_1_1projected"></span><em class="property">template </em>&lt;<em class="property">typename</em> Proj, <em class="property">typename</em> Iter&gt;<br /><em class="property">struct </em><code class="descname">projected</code><a class="headerlink" href="#_CPPv3N3hpx8parallel6traits9projectedE" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="type">
<dt id="_CPPv3N3hpx8parallel6traits9projected14projector_typeE">
<span id="_CPPv2N3hpx8parallel6traits9projected14projector_typeE"></span><span id="hpx::parallel::traits::projected::projector_type"></span><span class="target" id="structhpx_1_1parallel_1_1traits_1_1projected_1a541bc8fc4f95dceb912178214cd40299"></span><em class="property">typedef </em><a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::decay&lt;Proj&gt;::type <code class="descname">projector_type</code><a class="headerlink" href="#_CPPv3N3hpx8parallel6traits9projected14projector_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx8parallel6traits9projected13iterator_typeE">
<span id="_CPPv2N3hpx8parallel6traits9projected13iterator_typeE"></span><span id="hpx::parallel::traits::projected::iterator_type"></span><span class="target" id="structhpx_1_1parallel_1_1traits_1_1projected_1a0ce09c6687a66280a8f2c8542fcb6a57"></span><em class="property">typedef </em><a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::<a class="reference internal" href="#_CPPv3N3hpx6traits18projected_iteratorE" title="hpx::traits::projected_iterator">projected_iterator</a>&lt;Iter&gt;::type <code class="descname">iterator_type</code><a class="headerlink" href="#_CPPv3N3hpx8parallel6traits9projected13iterator_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx6traitsE">
<span id="_CPPv2N3hpx6traitsE"></span><span class="target" id="namespacehpx_1_1traits"></span><em class="property">namespace </em><code class="descname">traits</code><br /></dt>
<dd><dl class="class">
<dt id="_CPPv3N3hpx6traits18projected_iteratorE">
<span id="_CPPv2N3hpx6traits18projected_iteratorE"></span><span id="hpx::traits::projected_iterator"></span><span class="target" id="structhpx_1_1traits_1_1projected__iterator"></span><em class="property">template </em>&lt;typename <em>T</em>, typename <em>Enable</em> = void&gt;<br /><em class="property">struct </em><code class="descname">projected_iterator</code><a class="headerlink" href="#_CPPv3N3hpx6traits18projected_iteratorE" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="type">
<dt id="_CPPv3N3hpx6traits18projected_iterator4typeE">
<span class="target" id="structhpx_1_1traits_1_1projected__iterator_1ab5497e40b7beee3f261dafbaaadc137f"></span><em class="property">typedef </em><a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::decay&lt;T&gt;::type <code class="descname">type</code><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv3IEN3hpx6traits18projected_iteratorI8IteratorN3hpx4util11always_voidIN3hpx4util5decayI8IteratorE4type10proxy_typeEE4typeEEE">
<span class="target" id="structhpx_1_1traits_1_1projected__iterator_3_01_iterator_00_01typename_01hpx_1_1util_1_1always__ec1097b680ec94a68e9c1a9aefe34c52"></span><em class="property">template </em>&lt;<em class="property">typename</em> Iterator&gt;<br />template&lt;&gt;<br /><em class="property">struct </em><code class="descname">projected_iterator</code>&lt;Iterator, <em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::<a class="reference internal" href="../type_support/api.html#_CPPv3N3hpx4util11always_voidE" title="hpx::util::always_void">always_void</a>&lt;<em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::decay&lt;Iterator&gt;::type::proxy_type&gt;::type&gt;<br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="type">
<dt>
<span class="target" id="structhpx_1_1traits_1_1projected__iterator_3_01_iterator_00_01typename_01hpx_1_1util_1_1always__ec1097b680ec94a68e9c1a9aefe34c52_1a9060c93302ab046ad94f31627ad41e49"></span><em class="property">typedef </em><a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::decay&lt;Iterator&gt;::type::proxy_type <code class="descname">type</code><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv3IEN3hpx6traits18projected_iteratorI8IteratorNSt9enable_ifIN21is_segmented_iteratorI8IteratorE5valueEE4typeEEE">
<span class="target" id="structhpx_1_1traits_1_1projected__iterator_3_01_iterator_00_01typename_01std_1_1enable__if_3_01i1e6d339d5108c0c57364600f01a8c124"></span><em class="property">template </em>&lt;<em class="property">typename</em> Iterator&gt;<br />template&lt;&gt;<br /><em class="property">struct </em><code class="descname">projected_iterator</code>&lt;Iterator, <em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::enable_if&lt;is_segmented_iterator&lt;Iterator&gt;::value&gt;::type&gt;<br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="type">
<dt id="_CPPv3N3hpx6traits18projected_iterator14local_iteratorE">
<span id="_CPPv2N3hpx6traits18projected_iterator14local_iteratorE"></span><span class="target" id="structhpx_1_1traits_1_1projected__iterator_3_01_iterator_00_01typename_01std_1_1enable__if_3_01i1e6d339d5108c0c57364600f01a8c124_1a94f69718752d0a0b99306abff58507ff"></span><em class="property">typedef </em><a class="reference internal" href="#_CPPv3N3hpx6traits25segmented_iterator_traitsE" title="hpx::traits::segmented_iterator_traits">segmented_iterator_traits</a>&lt;Iterator&gt;::local_iterator <code class="descname">local_iterator</code><br /></dt>
<dd></dd></dl>

<dl class="type">
<dt>
<span class="target" id="structhpx_1_1traits_1_1projected__iterator_3_01_iterator_00_01typename_01std_1_1enable__if_3_01i1e6d339d5108c0c57364600f01a8c124_1aba6ff2112de3750818ecb0d0178ed835"></span><em class="property">typedef </em><a class="reference internal" href="#_CPPv3N3hpx6traits31segmented_local_iterator_traitsE" title="hpx::traits::segmented_local_iterator_traits">segmented_local_iterator_traits</a>&lt;<a class="reference internal" href="#_CPPv3N3hpx6traits18projected_iterator14local_iteratorE" title="hpx::traits::projected_iterator::local_iterator">local_iterator</a>&gt;::local_raw_iterator <code class="descname">type</code><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-traits-projected-range-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/traits/projected_range.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-traits-projected-range-hpp" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="_CPPv3IEN3hpx8parallel6traits15projected_rangeI4Proj3RngNSt9enable_ifIN3hpx6traits8is_rangeI3RngE5valueEE4typeEEE">
<span id="_CPPv2IEN3hpx8parallel6traits15projected_rangeI4Proj3RngNSt9enable_ifIN3hpx6traits8is_rangeI3RngE5valueEE4typeEEE"></span><span class="target" id="structhpx_1_1parallel_1_1traits_1_1projected__range_3_01_proj_00_01_rng_00_01typename_01std_1_1e8a6647b3e8b3d01b2d6ae04ba7f2cce1"></span><em class="property">template </em>&lt;<em class="property">typename</em> Proj, <em class="property">typename</em> Rng&gt;<br />template&lt;&gt;<br /><em class="property">struct </em><code class="descname">projected_range</code>&lt;Proj, Rng, <em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::enable_if&lt;<a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::is_range&lt;Rng&gt;::value&gt;::type&gt;<a class="headerlink" href="#_CPPv3IEN3hpx8parallel6traits15projected_rangeI4Proj3RngNSt9enable_ifIN3hpx6traits8is_rangeI3RngE5valueEE4typeEEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="type">
<dt id="_CPPv3N3hpx8parallel6traits15projected_range14projector_typeE">
<span id="_CPPv2N3hpx8parallel6traits15projected_range14projector_typeE"></span><span id="hpx::parallel::traits::projected_range::projector_type"></span><span class="target" id="structhpx_1_1parallel_1_1traits_1_1projected__range_3_01_proj_00_01_rng_00_01typename_01std_1_1e8a6647b3e8b3d01b2d6ae04ba7f2cce1_1ac5aac6eb406c5a6802ffba57bbf18eec"></span><em class="property">typedef </em><a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::decay&lt;Proj&gt;::type <code class="descname">projector_type</code><a class="headerlink" href="#_CPPv3N3hpx8parallel6traits15projected_range14projector_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx8parallel6traits15projected_range13iterator_typeE">
<span id="_CPPv2N3hpx8parallel6traits15projected_range13iterator_typeE"></span><span id="hpx::parallel::traits::projected_range::iterator_type"></span><span class="target" id="structhpx_1_1parallel_1_1traits_1_1projected__range_3_01_proj_00_01_rng_00_01typename_01std_1_1e8a6647b3e8b3d01b2d6ae04ba7f2cce1_1a65838fcbf74d893045259c765c779398"></span><em class="property">typedef </em><a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng&gt;::type <code class="descname">iterator_type</code><a class="headerlink" href="#_CPPv3N3hpx8parallel6traits15projected_range13iterator_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

<dl class="type">
<dt>
<span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><br /></dt>
<dd><dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><br /></dt>
<dd><dl class="type">
<dt id="_CPPv3N3hpx8parallel6traitsE">
<span id="_CPPv2N3hpx8parallel6traitsE"></span><span class="target" id="namespacehpx_1_1parallel_1_1traits"></span><em class="property">namespace </em><code class="descname">traits</code><br /></dt>
<dd><dl class="class">
<dt id="_CPPv3IEN3hpx8parallel6traits15projected_rangeI4Proj3RngNSt9enable_ifIN3hpx6traits8is_rangeI3RngE5valueEE4typeEEE">
<span class="target" id="structhpx_1_1parallel_1_1traits_1_1projected__range_3_01_proj_00_01_rng_00_01typename_01std_1_1e8a6647b3e8b3d01b2d6ae04ba7f2cce1"></span><em class="property">template </em>&lt;<em class="property">typename</em> Proj, <em class="property">typename</em> Rng&gt;<br />template&lt;&gt;<br /><em class="property">struct </em><code class="descname">projected_range</code>&lt;Proj, Rng, <em class="property">typename</em> <a class="reference internal" href="../../api.html#_CPPv3St" title="std">std</a>::enable_if&lt;<a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::is_range&lt;Rng&gt;::value&gt;::type&gt;<br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="type">
<dt id="_CPPv3N3hpx8parallel6traits15projected_range14projector_typeE">
<span id="_CPPv2N3hpx8parallel6traits15projected_range14projector_typeE"></span><span class="target" id="structhpx_1_1parallel_1_1traits_1_1projected__range_3_01_proj_00_01_rng_00_01typename_01std_1_1e8a6647b3e8b3d01b2d6ae04ba7f2cce1_1ac5aac6eb406c5a6802ffba57bbf18eec"></span><em class="property">typedef </em><a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::decay&lt;Proj&gt;::type <code class="descname">projector_type</code><br /></dt>
<dd></dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx8parallel6traits15projected_range13iterator_typeE">
<span id="_CPPv2N3hpx8parallel6traits15projected_range13iterator_typeE"></span><span class="target" id="structhpx_1_1parallel_1_1traits_1_1projected__range_3_01_proj_00_01_rng_00_01typename_01std_1_1e8a6647b3e8b3d01b2d6ae04ba7f2cce1_1a65838fcbf74d893045259c765c779398"></span><em class="property">typedef </em><a class="reference internal" href="../../api.html#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="../../api.html#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng&gt;::type <code class="descname">iterator_type</code><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

</dd></dl>

</dd></dl>

</dd></dl>

</div>
<div class="section" id="include-hpx-parallel-datapar-iterator-helpers-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/datapar/iterator_helpers.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-datapar-iterator-helpers-hpp" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="include-hpx-parallel-datapar-loop-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/datapar/loop.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-datapar-loop-hpp" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="include-hpx-parallel-datapar-zip-iterator-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/datapar/zip_iterator.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-datapar-zip-iterator-hpp" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="include-hpx-parallel-datapar-transform-loop-hpp">
<h2><code class="docutils literal notranslate"><span class="pre">#include</span> <span class="pre">&lt;hpx/parallel/datapar/transform_loop.hpp&gt;</span></code><a class="headerlink" href="#include-hpx-parallel-datapar-transform-loop-hpp" title="Permalink to this headline">¶</a></h2>
</div>
</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <!-- Copyright (c) 2018 Mikael Simberg

     Distributed under the Boost Software License, Version 1.0. (See accompanying
     file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) -->
<!-- Make HPX inspect tool happy: hpxinspect:nounlinked -->

<footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../filesystem/api.html" class="btn btn-neutral float-right" title="filesystem" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../plugin/api.html" class="btn btn-neutral" title="plugin" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2008-2019, The STE||AR Group.
      
        <span class="commit">
          Revision <code>64cc56b</code>.
        </span>
      

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
 

SPDX-License-Identifier: BSL-1.0
Distributed under the Boost Software License, Version 1.0. (See accompanying file
LICENSE_1_0.txt or copy at
<a href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</a>)



</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'1.4.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>