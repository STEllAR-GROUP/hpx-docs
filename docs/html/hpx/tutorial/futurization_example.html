<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Futurization Example</title>
<link rel="stylesheet" href="../../src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.78.1">
<link rel="home" href="../../index.html" title="HPX 1.0.0">
<link rel="up" href="../tutorial.html" title="Tutorial">
<link rel="prev" href="examples/interest_calculator.html" title="Interest Calculator">
<link rel="next" href="../manual.html" title="Manual">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table cellpadding="2" width="100%"><tr><td valign="top"><img alt="HPX" width="562" height="104" src="../../images/hpx_1_0_0_draft.png"></td></tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="examples/interest_calculator.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../tutorial.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="../manual.html"><img src="../../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="hpx.tutorial.futurization_example"></a><a class="link" href="futurization_example.html" title="Futurization Example">Futurization Example</a>
</h3></div></div></div>
<p>
        When developers write code they typically begin with a simple serial code
        and build upon it until all of the required functionality is present. The
        following set of examples were developed to demonstrate this iterative process
        of evolving a simple serial program to an efficient, fully distributed HPX
        application. For this demonstration, we implemented a 1D heat distribution
        problem. This calculation simulates the diffusion of heat across a ring from
        an initialized state to some user defined point in the future. It does this
        by breaking each portion of the ring into discrete segments and using the
        current segment's temperature and the temperature of the surrounding segments
        to calculate the temperature of the current segment in the next timestep
        as shown by the <a class="link" href="futurization_example.html#examples.1d_pgf" title="Figure&#160;2.&#160;Heat Diffusion Example Program Flow">figure</a> below.
      </p>
<p>
        </p>
<div class="figure">
<a name="examples.1d_pgf"></a><p class="title"><b>Figure&#160;2.&#160;Heat Diffusion Example Program Flow</b></p>
<div class="figure-contents"><span class="inlinemediaobject"><img src="../.././images/1d_stencil_program_flow.png" alt="Heat Diffusion Example Program Flow"></span></div>
</div>
<p><br class="figure-break">
      </p>
<p>
        We parallelize this code over the following eight examples:
      </p>
<div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; ">
<li class="listitem">
            <a href="../.././code/examples/1d_stencil/1d_stencil_1.cpp" target="_top">Example 1</a>
          </li>
<li class="listitem">
            <a href="../.././code/examples/1d_stencil/1d_stencil_2.cpp" target="_top">Example 2</a>
          </li>
<li class="listitem">
            <a href="../.././code/examples/1d_stencil/1d_stencil_3.cpp" target="_top">Example 3</a>
          </li>
<li class="listitem">
            <a href="../.././code/examples/1d_stencil/1d_stencil_4.cpp" target="_top">Example 4</a>
          </li>
<li class="listitem">
            <a href="../.././code/examples/1d_stencil/1d_stencil_5.cpp" target="_top">Example 5</a>
          </li>
<li class="listitem">
            <a href="../.././code/examples/1d_stencil/1d_stencil_6.cpp" target="_top">Example 6</a>
          </li>
<li class="listitem">
            <a href="../.././code/examples/1d_stencil/1d_stencil_7.cpp" target="_top">Example 7</a>
          </li>
<li class="listitem">
            <a href="../.././code/examples/1d_stencil/1d_stencil_8.cpp" target="_top">Example 8</a>
          </li>
</ul></div>
<p>
        The first example is straight serial code. In this code we instantiate a
        vector <code class="literal">U</code> which contains two vectors of doubles as seen
        in the structure <code class="literal">stepper</code>.
      </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">stepper</span>
<span class="special">{</span>
    <span class="comment">// Our partition type</span>
    <span class="keyword">typedef</span> <span class="keyword">double</span> <span class="identifier">partition</span><span class="special">;</span>

    <span class="comment">// Our data for one time step</span>
    <span class="keyword">typedef</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">partition</span><span class="special">&gt;</span> <span class="identifier">space</span><span class="special">;</span>

    <span class="comment">// Our operator</span>
    <span class="keyword">static</span> <span class="keyword">double</span> <span class="identifier">heat</span><span class="special">(</span><span class="keyword">double</span> <span class="identifier">left</span><span class="special">,</span> <span class="keyword">double</span> <span class="identifier">middle</span><span class="special">,</span> <span class="keyword">double</span> <span class="identifier">right</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">middle</span> <span class="special">+</span> <span class="special">(</span><span class="identifier">k</span><span class="special">*</span><span class="identifier">dt</span><span class="special">/(</span><span class="identifier">dx</span><span class="special">*</span><span class="identifier">dx</span><span class="special">))</span> <span class="special">*</span> <span class="special">(</span><span class="identifier">left</span> <span class="special">-</span> <span class="number">2</span><span class="special">*</span><span class="identifier">middle</span> <span class="special">+</span> <span class="identifier">right</span><span class="special">);</span>
    <span class="special">}</span>

    <span class="comment">// do all the work on 'nx' data points for 'nt' time steps</span>
    <span class="identifier">space</span> <span class="identifier">do_work</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">nx</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">nt</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="comment">// U[t][i] is the state of position i at time t.</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">space</span><span class="special">&gt;</span> <span class="identifier">U</span><span class="special">(</span><span class="number">2</span><span class="special">);</span>
        <span class="keyword">for</span> <span class="special">(</span><span class="identifier">space</span><span class="special">&amp;</span> <span class="identifier">s</span> <span class="special">:</span> <span class="identifier">U</span><span class="special">)</span>
            <span class="identifier">s</span><span class="special">.</span><span class="identifier">resize</span><span class="special">(</span><span class="identifier">nx</span><span class="special">);</span>

        <span class="comment">// Initial conditions: f(0, i) = i</span>
        <span class="keyword">for</span> <span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">!=</span> <span class="identifier">nx</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span>
            <span class="identifier">U</span><span class="special">[</span><span class="number">0</span><span class="special">][</span><span class="identifier">i</span><span class="special">]</span> <span class="special">=</span> <span class="keyword">double</span><span class="special">(</span><span class="identifier">i</span><span class="special">);</span>

        <span class="comment">// Actual time step loop</span>
        <span class="keyword">for</span> <span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">t</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="identifier">t</span> <span class="special">!=</span> <span class="identifier">nt</span><span class="special">;</span> <span class="special">++</span><span class="identifier">t</span><span class="special">)</span>
        <span class="special">{</span>
            <span class="identifier">space</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">current</span> <span class="special">=</span> <span class="identifier">U</span><span class="special">[</span><span class="identifier">t</span> <span class="special">%</span> <span class="number">2</span><span class="special">];</span>
            <span class="identifier">space</span><span class="special">&amp;</span> <span class="identifier">next</span> <span class="special">=</span> <span class="identifier">U</span><span class="special">[(</span><span class="identifier">t</span> <span class="special">+</span> <span class="number">1</span><span class="special">)</span> <span class="special">%</span> <span class="number">2</span><span class="special">];</span>

            <span class="identifier">next</span><span class="special">[</span><span class="number">0</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">heat</span><span class="special">(</span><span class="identifier">current</span><span class="special">[</span><span class="identifier">nx</span><span class="special">-</span><span class="number">1</span><span class="special">],</span> <span class="identifier">current</span><span class="special">[</span><span class="number">0</span><span class="special">],</span> <span class="identifier">current</span><span class="special">[</span><span class="number">1</span><span class="special">]);</span>

            <span class="keyword">for</span> <span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">1</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">!=</span> <span class="identifier">nx</span><span class="special">-</span><span class="number">1</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span>
                <span class="identifier">next</span><span class="special">[</span><span class="identifier">i</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">heat</span><span class="special">(</span><span class="identifier">current</span><span class="special">[</span><span class="identifier">i</span><span class="special">-</span><span class="number">1</span><span class="special">],</span> <span class="identifier">current</span><span class="special">[</span><span class="identifier">i</span><span class="special">],</span> <span class="identifier">current</span><span class="special">[</span><span class="identifier">i</span><span class="special">+</span><span class="number">1</span><span class="special">]);</span>

            <span class="identifier">next</span><span class="special">[</span><span class="identifier">nx</span><span class="special">-</span><span class="number">1</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">heat</span><span class="special">(</span><span class="identifier">current</span><span class="special">[</span><span class="identifier">nx</span><span class="special">-</span><span class="number">2</span><span class="special">],</span> <span class="identifier">current</span><span class="special">[</span><span class="identifier">nx</span><span class="special">-</span><span class="number">1</span><span class="special">],</span> <span class="identifier">current</span><span class="special">[</span><span class="number">0</span><span class="special">]);</span>
        <span class="special">}</span>

        <span class="comment">// Return the solution at time-step 'nt'.</span>
        <span class="keyword">return</span> <span class="identifier">U</span><span class="special">[</span><span class="identifier">nt</span> <span class="special">%</span> <span class="number">2</span><span class="special">];</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
        Each element in the vector of doubles represents a single grid point. To
        calculate the change in heat distribution, the temperature of each grid point,
        along with its neighbors, are passed to the function <code class="literal">heat</code>.
        In order to improve readability, references named <code class="literal">current</code>
        and <code class="literal">next</code> are created which, depending on the time step,
        point to the first and second vector of doubles. The first vector of doubles
        is initialized with a simple heat ramp. After calling the heat function with
        the data in the "current" vector, the results are placed into the
        "next" vector.
      </p>
<p>
        In example 2 we employ a technique called futurization. Futurization is a
        method by which we can easily transform a code which is serially executed
        into a code which creates asynchronous threads. In the simplest case this
        involves replacing a variable with a future to a variable, a function with
        a future to a function, and adding a <code class="literal">.get()</code> at the point
        where a value is actually needed. The code below shows how this technique
        was applied to the <code class="literal">struct stepper</code>.
      </p>
<pre class="programlisting"><span class="keyword">struct</span> <span class="identifier">stepper</span>
<span class="special">{</span>
    <span class="comment">// Our partition type</span>
    <span class="keyword">typedef</span> <span class="identifier">hpx</span><span class="special">::</span><span class="identifier">shared_future</span><span class="special">&lt;</span><span class="keyword">double</span><span class="special">&gt;</span> <span class="identifier">partition</span><span class="special">;</span>

    <span class="comment">// Our data for one time step</span>
    <span class="keyword">typedef</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">partition</span><span class="special">&gt;</span> <span class="identifier">space</span><span class="special">;</span>

    <span class="comment">// Our operator</span>
    <span class="keyword">static</span> <span class="keyword">double</span> <span class="identifier">heat</span><span class="special">(</span><span class="keyword">double</span> <span class="identifier">left</span><span class="special">,</span> <span class="keyword">double</span> <span class="identifier">middle</span><span class="special">,</span> <span class="keyword">double</span> <span class="identifier">right</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="keyword">return</span> <span class="identifier">middle</span> <span class="special">+</span> <span class="special">(</span><span class="identifier">k</span><span class="special">*</span><span class="identifier">dt</span><span class="special">/(</span><span class="identifier">dx</span><span class="special">*</span><span class="identifier">dx</span><span class="special">))</span> <span class="special">*</span> <span class="special">(</span><span class="identifier">left</span> <span class="special">-</span> <span class="number">2</span><span class="special">*</span><span class="identifier">middle</span> <span class="special">+</span> <span class="identifier">right</span><span class="special">);</span>
    <span class="special">}</span>

    <span class="comment">// do all the work on 'nx' data points for 'nt' time steps</span>
    <span class="identifier">hpx</span><span class="special">::</span><span class="identifier">future</span><span class="special">&lt;</span><span class="identifier">space</span><span class="special">&gt;</span> <span class="identifier">do_work</span><span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">nx</span><span class="special">,</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">nt</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="keyword">using</span> <span class="identifier">hpx</span><span class="special">::</span><span class="identifier">dataflow</span><span class="special">;</span>
        <span class="keyword">using</span> <span class="identifier">hpx</span><span class="special">::</span><span class="identifier">util</span><span class="special">::</span><span class="identifier">unwrapped</span><span class="special">;</span>

        <span class="comment">// U[t][i] is the state of position i at time t.</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">vector</span><span class="special">&lt;</span><span class="identifier">space</span><span class="special">&gt;</span> <span class="identifier">U</span><span class="special">(</span><span class="number">2</span><span class="special">);</span>
        <span class="keyword">for</span> <span class="special">(</span><span class="identifier">space</span><span class="special">&amp;</span> <span class="identifier">s</span> <span class="special">:</span> <span class="identifier">U</span><span class="special">)</span>
            <span class="identifier">s</span><span class="special">.</span><span class="identifier">resize</span><span class="special">(</span><span class="identifier">nx</span><span class="special">);</span>

        <span class="comment">// Initial conditions: f(0, i) = i</span>
        <span class="keyword">for</span> <span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">!=</span> <span class="identifier">nx</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span>
            <span class="identifier">U</span><span class="special">[</span><span class="number">0</span><span class="special">][</span><span class="identifier">i</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">hpx</span><span class="special">::</span><span class="identifier">make_ready_future</span><span class="special">(</span><span class="keyword">double</span><span class="special">(</span><span class="identifier">i</span><span class="special">));</span>

        <span class="keyword">auto</span> <span class="identifier">Op</span> <span class="special">=</span> <span class="identifier">unwrapped</span><span class="special">(&amp;</span><span class="identifier">stepper</span><span class="special">::</span><span class="identifier">heat</span><span class="special">);</span>

        <span class="comment">// Actual time step loop</span>
        <span class="keyword">for</span> <span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">t</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="identifier">t</span> <span class="special">!=</span> <span class="identifier">nt</span><span class="special">;</span> <span class="special">++</span><span class="identifier">t</span><span class="special">)</span>
        <span class="special">{</span>
            <span class="identifier">space</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">current</span> <span class="special">=</span> <span class="identifier">U</span><span class="special">[</span><span class="identifier">t</span> <span class="special">%</span> <span class="number">2</span><span class="special">];</span>
            <span class="identifier">space</span><span class="special">&amp;</span> <span class="identifier">next</span> <span class="special">=</span> <span class="identifier">U</span><span class="special">[(</span><span class="identifier">t</span> <span class="special">+</span> <span class="number">1</span><span class="special">)</span> <span class="special">%</span> <span class="number">2</span><span class="special">];</span>

            <span class="comment">// WHEN U[t][i-1], U[t][i], and U[t][i+1] have been computed, THEN we</span>
            <span class="comment">// can compute U[t+1][i]</span>
            <span class="keyword">for</span> <span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">!=</span> <span class="identifier">nx</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span>
            <span class="special">{</span>
                <span class="identifier">next</span><span class="special">[</span><span class="identifier">i</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">dataflow</span><span class="special">(</span>
                        <span class="identifier">hpx</span><span class="special">::</span><span class="identifier">launch</span><span class="special">::</span><span class="identifier">async</span><span class="special">,</span> <span class="identifier">Op</span><span class="special">,</span>
                        <span class="identifier">current</span><span class="special">[</span><span class="identifier">idx</span><span class="special">(</span><span class="identifier">i</span><span class="special">,</span> <span class="special">-</span><span class="number">1</span><span class="special">,</span> <span class="identifier">nx</span><span class="special">)],</span> <span class="identifier">current</span><span class="special">[</span><span class="identifier">i</span><span class="special">],</span> <span class="identifier">current</span><span class="special">[</span><span class="identifier">idx</span><span class="special">(</span><span class="identifier">i</span><span class="special">,</span> <span class="special">+</span><span class="number">1</span><span class="special">,</span> <span class="identifier">nx</span><span class="special">)]</span>
                    <span class="special">);</span>
            <span class="special">}</span>
        <span class="special">}</span>

        <span class="comment">// Now the asynchronous computation is running; the above for-loop does not</span>
        <span class="comment">// wait on anything. There is no implicit waiting at the end of each timestep;</span>
        <span class="comment">// the computation of each U[t][i] will begin when as soon as its dependencies</span>
        <span class="comment">// are ready and hardware is available.</span>

        <span class="comment">// Return the solution at time-step 'nt'.</span>
        <span class="keyword">return</span> <span class="identifier">hpx</span><span class="special">::</span><span class="identifier">when_all</span><span class="special">(</span><span class="identifier">U</span><span class="special">[</span><span class="identifier">nt</span> <span class="special">%</span> <span class="number">2</span><span class="special">]);</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
        In example 2, we re-define our partition type as a <code class="literal">shared_future</code>
        and, in <code class="literal">main</code>, create the object "result" which
        is a future to a vector of partitions. We use <code class="literal">result</code> to
        represent the last vector in a string of vectors created for each timestep.
        In order to move to the next timestep, the values of a partition and its
        neighbors must be passed to <code class="literal">heat</code> once the futures that
        contain them are ready. In HPX, we have an LCO (Local Control Object) named
        Dataflow which assists the programmer in expressing this dependency. Dataflow
        allows us to pass the results of a set of futures to a specified function
        when the futures are ready. Dataflow takes three types of arguments, one
        which instructs the dataflow on how to perform the function call (async or
        sync), the function to call (in this case <code class="literal">Op</code>), and futures
        to the arguments that will be passed to the function. When called, dataflow
        immediately returns a future to the result of the specified function. This
        allows users to string dataflows together and construct an execution tree.
      </p>
<p>
        After the values of the futures in dataflow are ready, the values must be
        pulled out of the future container to be passed to the function <code class="literal">heat</code>.
        In order to do this, we use the HPX facility <code class="literal">unwrapped</code>,
        which underneath calls <code class="literal">.get()</code> on each of the futures so
        that the function <code class="literal">heat</code> will be passed doubles and not
        futures to doubles.
      </p>
<p>
        By setting up the algorithm this way, the program will be able to execute
        as quickly as the dependencies of each future are met. Unfortunately, this
        example runs terribly slow. This increase in execution time is caused by
        the overheads needed to create a future for each data point. Because the
        work done within each call to heat is very small, the overhead of creating
        and scheduling each of the three futures is greater than that of the actual
        useful work! In order to amortize the overheads of our synchronization techniques,
        we need to be able to control the amount of work that will be done with each
        future. We call this amount of work per overhead grain size.
      </p>
<p>
        In example 3, we return to our serial code to figure out how to control the
        grain size of our program. The strategy that we employ is to create "partitions"
        of data points. The user can define how many partitions are created and how
        many data points are contained in each partition. This is accomplished by
        creating the <code class="literal">struct partition</code> which contains a member
        object <code class="literal">data_</code>, a vector of doubles which holds the data
        points assigned to a particular instance of <code class="literal">partition</code>.
      </p>
<p>
        In example 4, we take advantage of the partition setup by redefining <code class="literal">space</code>
        to be a vector of shared_futures with each future representing a partition.
        In this manner, each future represents several data points. Because the user
        can define how many data points are contained in each partition (and therefore
        how many data points that are represented by one future) a user can now control
        the grainsize of the simulation. The rest of the code was then futurized
        in the same manner that was done in example 2. It should be noted how strikingly
        similar example 4 is to example 2.
      </p>
<p>
        Example 4 finally shows good results. This code scales equivalently to the
        OpenMP version. While these results are promising, there are more opportunities
        to improve the application's scalability. Currently this code only runs on
        one locality, but to get the full benefit of HPX we need to be able to distribute
        the work to other machines in a cluster. We begin to add this functionality
        in example 5.
      </p>
<p>
        In order to run on a distributed system, a large amount of boilerplate code
        must be added. Fortunately, HPX provides us with the concept of a "component"
        which saves us from having to write quite as much code. A component is an
        object which can be remotely accessed using its global address. Components
        are made of two parts: a server and a client class. While the client class
        is not required, abstracting the server behind a client allows us to ensure
        type safety instead of having to pass around pointers to global objects.
        Example 5 renames example 4's <code class="literal">struct partition</code> to <code class="literal">partition_data</code>
        and adds serialization support. Next we add the server side representation
        of the data in the structure <code class="literal">partition_server</code>. <code class="literal">Partition_server</code>
        inherits from <code class="literal">hpx::components::simple_component_base</code> which
        contains a server side component boilerplate. The boilerplate code allows
        a component's public members to be accessible anywhere on the machine via
        its Global Identifier (GID). To encapsulate the component, we create a client
        side helper class. This object allows us to create new instances of our component,
        and access its members without having to know its GID. In addition, we are
        using the client class to assist us with managing our asynchrony. For example,
        our client class <code class="literal">partition</code>'s member function <code class="literal">get_data()</code>
        returns a future to <code class="literal">partition_data get_data()</code>. This struct
        inherits its boilerplate code from <code class="literal">hpx::components::client_base</code>.
      </p>
<p>
        In the structure <code class="literal">stepper</code>, we have also had to make some
        changes to accommodate a distributed environment. In order to get the data
        from a neighboring partition, which could be remote, we must retrieve the
        data from the neighboring partitions. These retrievals are asynchronous and
        the function <code class="literal">heat_part_data</code>, which amongst other things
        calls <code class="literal">heat</code>, should not be called unless the data from
        the neighboring partitions have arrived. Therefore it should come as no surprise
        that we synchronize this operation with another instance of dataflow (found
        in <code class="literal">heat_part</code>). This dataflow is passed futures to the
        data in the current and surrounding partitions by calling <code class="literal">get_data()</code>
        on each respective partition. When these futures are ready dataflow passes
        then to the <code class="literal">unwrapped</code> function, which extracts the shared_array
        of doubles and passes them to the lambda. The lambda calls <code class="literal">heat_part_data</code>
        on the locality which the middle partition is on.
      </p>
<p>
        Although this example could run in distributed, it only runs on one locality
        as it always uses <code class="literal">hpx::find_here()</code> as the target for the
        functions to run on.
      </p>
<p>
        In example 6, we begin to distribute the partition data on different nodes.
        This is accomplished in <code class="literal">stepper::do_work()</code> by passing
        the GID of the locality where we wish to create the partition to the the
        partition constructor.
      </p>
<pre class="programlisting"><span class="keyword">for</span> <span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">!=</span> <span class="identifier">np</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span>
    <span class="identifier">U</span><span class="special">[</span><span class="number">0</span><span class="special">][</span><span class="identifier">i</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">partition</span><span class="special">(</span><span class="identifier">localities</span><span class="special">[</span><span class="identifier">locidx</span><span class="special">(</span><span class="identifier">i</span><span class="special">,</span> <span class="identifier">np</span><span class="special">,</span> <span class="identifier">nl</span><span class="special">)],</span> <span class="identifier">nx</span><span class="special">,</span> <span class="keyword">double</span><span class="special">(</span><span class="identifier">i</span><span class="special">));</span>
</pre>
<p>
        We distribute the partitions evenly based on the number of localities used,
        which is described in the function <code class="literal">locidx</code>. Because some
        of the data needed to update the partition in <code class="literal">heat_part</code>
        could now be on a new locality, we must devise a way of moving data to the
        locality of the middle partition. We accomplished this by adding a switch
        in the function <code class="literal">get_data()</code> which returns the end element
        of the <code class="literal">buffer data_</code> if it is from the left partition or
        the first element of the buffer if the data is from the right partition.
        In this way only the necessary elements, not the whole buffer, are exchanged
        between nodes. The reader should be reminded that this exchange of end elements
        occurs in the function <code class="literal">get_data()</code> and therefore is executed
        asynchronously.
      </p>
<p>
        Now that we have the code running in distributed, it is time to make some
        optimizations. The function <code class="literal">heat_part</code> spends most of its
        time on two tasks: retrieving remote data and working on the data in the
        middle partition. Because we know that the data for the middle partition
        is local, we can overlap the work on the middle partition with that of the
        possibly remote call of <code class="literal">get_data()</code>. This algorithmic change
        which was implemented in example 7 can be seen below:
      </p>
<pre class="programlisting"><span class="comment">// The partitioned operator, it invokes the heat operator above on all elements</span>
<span class="comment">// of a partition.</span>
<span class="keyword">static</span> <span class="identifier">partition</span> <span class="identifier">heat_part</span><span class="special">(</span><span class="identifier">partition</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">left</span><span class="special">,</span>
    <span class="identifier">partition</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">middle</span><span class="special">,</span> <span class="identifier">partition</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">right</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">using</span> <span class="identifier">hpx</span><span class="special">::</span><span class="identifier">dataflow</span><span class="special">;</span>
    <span class="keyword">using</span> <span class="identifier">hpx</span><span class="special">::</span><span class="identifier">util</span><span class="special">::</span><span class="identifier">unwrapped</span><span class="special">;</span>

    <span class="identifier">hpx</span><span class="special">::</span><span class="identifier">shared_future</span><span class="special">&lt;</span><span class="identifier">partition_data</span><span class="special">&gt;</span> <span class="identifier">middle_data</span> <span class="special">=</span>
        <span class="identifier">middle</span><span class="special">.</span><span class="identifier">get_data</span><span class="special">(</span><span class="identifier">partition_server</span><span class="special">::</span><span class="identifier">middle_partition</span><span class="special">);</span>

    <span class="identifier">hpx</span><span class="special">::</span><span class="identifier">future</span><span class="special">&lt;</span><span class="identifier">partition_data</span><span class="special">&gt;</span> <span class="identifier">next_middle</span> <span class="special">=</span> <span class="identifier">middle_data</span><span class="special">.</span><span class="identifier">then</span><span class="special">(</span>
        <span class="identifier">unwrapped</span><span class="special">(</span>
            <span class="special">[</span><span class="identifier">middle</span><span class="special">](</span><span class="identifier">partition_data</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">m</span><span class="special">)</span> <span class="special">-&gt;</span> <span class="identifier">partition_data</span>
            <span class="special">{</span>
                <span class="comment">// All local operations are performed once the middle data of</span>
                <span class="comment">// the previous time step becomes available.</span>
                <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">size</span> <span class="special">=</span> <span class="identifier">m</span><span class="special">.</span><span class="identifier">size</span><span class="special">();</span>
                <span class="identifier">partition_data</span> <span class="identifier">next</span><span class="special">(</span><span class="identifier">size</span><span class="special">);</span>
                <span class="keyword">for</span> <span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">1</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">!=</span> <span class="identifier">size</span><span class="special">-</span><span class="number">1</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span>
                    <span class="identifier">next</span><span class="special">[</span><span class="identifier">i</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">heat</span><span class="special">(</span><span class="identifier">m</span><span class="special">[</span><span class="identifier">i</span><span class="special">-</span><span class="number">1</span><span class="special">],</span> <span class="identifier">m</span><span class="special">[</span><span class="identifier">i</span><span class="special">],</span> <span class="identifier">m</span><span class="special">[</span><span class="identifier">i</span><span class="special">+</span><span class="number">1</span><span class="special">]);</span>
                <span class="keyword">return</span> <span class="identifier">next</span><span class="special">;</span>
            <span class="special">}</span>
        <span class="special">)</span>
    <span class="special">);</span>

    <span class="keyword">return</span> <span class="identifier">dataflow</span><span class="special">(</span>
        <span class="identifier">hpx</span><span class="special">::</span><span class="identifier">launch</span><span class="special">::</span><span class="identifier">async</span><span class="special">,</span>
        <span class="identifier">unwrapped</span><span class="special">(</span>
            <span class="special">[</span><span class="identifier">left</span><span class="special">,</span> <span class="identifier">middle</span><span class="special">,</span> <span class="identifier">right</span><span class="special">](</span><span class="identifier">partition_data</span> <span class="identifier">next</span><span class="special">,</span> <span class="identifier">partition_data</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">l</span><span class="special">,</span>
                <span class="identifier">partition_data</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">m</span><span class="special">,</span> <span class="identifier">partition_data</span> <span class="keyword">const</span><span class="special">&amp;</span> <span class="identifier">r</span><span class="special">)</span> <span class="special">-&gt;</span> <span class="identifier">partition</span>
            <span class="special">{</span>
                <span class="comment">// Calculate the missing boundary elements once the</span>
                <span class="comment">// corresponding data has become available.</span>
                <span class="identifier">std</span><span class="special">::</span><span class="identifier">size_t</span> <span class="identifier">size</span> <span class="special">=</span> <span class="identifier">m</span><span class="special">.</span><span class="identifier">size</span><span class="special">();</span>
                <span class="identifier">next</span><span class="special">[</span><span class="number">0</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">heat</span><span class="special">(</span><span class="identifier">l</span><span class="special">[</span><span class="identifier">size</span><span class="special">-</span><span class="number">1</span><span class="special">],</span> <span class="identifier">m</span><span class="special">[</span><span class="number">0</span><span class="special">],</span> <span class="identifier">m</span><span class="special">[</span><span class="number">1</span><span class="special">]);</span>
                <span class="identifier">next</span><span class="special">[</span><span class="identifier">size</span><span class="special">-</span><span class="number">1</span><span class="special">]</span> <span class="special">=</span> <span class="identifier">heat</span><span class="special">(</span><span class="identifier">m</span><span class="special">[</span><span class="identifier">size</span><span class="special">-</span><span class="number">2</span><span class="special">],</span> <span class="identifier">m</span><span class="special">[</span><span class="identifier">size</span><span class="special">-</span><span class="number">1</span><span class="special">],</span> <span class="identifier">r</span><span class="special">[</span><span class="number">0</span><span class="special">]);</span>

                <span class="comment">// The new partition_data will be allocated on the same locality</span>
                <span class="comment">// as 'middle'.</span>
                <span class="keyword">return</span> <span class="identifier">partition</span><span class="special">(</span><span class="identifier">middle</span><span class="special">.</span><span class="identifier">get_id</span><span class="special">(),</span> <span class="identifier">next</span><span class="special">);</span>
            <span class="special">}</span>
        <span class="special">),</span>
        <span class="identifier">std</span><span class="special">::</span><span class="identifier">move</span><span class="special">(</span><span class="identifier">next_middle</span><span class="special">),</span>
        <span class="identifier">left</span><span class="special">.</span><span class="identifier">get_data</span><span class="special">(</span><span class="identifier">partition_server</span><span class="special">::</span><span class="identifier">left_partition</span><span class="special">),</span>
        <span class="identifier">middle_data</span><span class="special">,</span>
        <span class="identifier">right</span><span class="special">.</span><span class="identifier">get_data</span><span class="special">(</span><span class="identifier">partition_server</span><span class="special">::</span><span class="identifier">right_partition</span><span class="special">)</span>
    <span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
        Example 8 completes the futurization process and utilizes the full potential
        of HPX by distributing the program flow to multiple localities, usually defined
        as nodes in a cluster. It accomplishes this task by running an instance of
        HPX main on each locality. In order to coordinate the execution of the program
        the <code class="literal">struct stepper</code> is wrapped into a component. In this
        way, each locality contains an instance of stepper which executes its own
        instance of the function <code class="literal">do_work()</code>. This scheme does create
        an interesting synchronization problem that must be solved. When the program
        flow was being coordinated on the head node the, GID of each component was
        known. However, when we distribute the program flow, each partition has no
        notion of the GID of its neighbor if the next partition is on another locality.
        In order to make the GIDs of neighboring partitions visible to each other,
        we created two buffers to store the GIDs of the remote neighboring partitions
        on the left and right respectively. These buffers are filled by sending the
        GID of a newly created edge partitions to the right and left buffers of the
        neighboring localities.
      </p>
<p>
        In order to finish the simulation the solution vectors named "result"
        are then gathered together on locality 0 and added into a vector of spaces
        <code class="literal">overall_result</code> using the HPX functions <code class="literal">gather_id</code>
        and <code class="literal">gather_here</code>.
      </p>
<p>
        Example 8 completes this example series which takes the serial code of example
        1 and incrementally morphs it into a fully distributed parallel code. This
        evolution was guided by the simple principles of futurization, the knowledge
        of grainsize, and utilization of components. Applying these techniques easily
        facilitates the scalable parallelization of most applications.
      </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2011-2017 The STE||AR Group (http://stellar-group.org)<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">LICENSE_1_0.txt</a>
        or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="examples/interest_calculator.html"><img src="../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../tutorial.html"><img src="../../images/up.png" alt="Up"></a><a accesskey="h" href="../../index.html"><img src="../../images/home.png" alt="Home"></a><a accesskey="n" href="../manual.html"><img src="../../images/next.png" alt="Next"></a>
</div>
</body>
</html>
