

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>API reference &mdash; HPX 1.2.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="_static/css/theme_overrides.css" type="text/css" />
  

  
        <link rel="index" title="Index"
              href="genindex.html"/>
        <link rel="search" title="Search" href="search.html"/>
    <link rel="top" title="HPX 1.2.0 documentation" href="index.html"/>
        <link rel="next" title="Contributing to HPX" href="contributing.html"/>
        <link rel="prev" title="Additional material" href="additional_material.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> HPX
          

          
            
            <img src="_static/HPX_STELLAR.png" class="logo" />
          
          </a>

          
            
            
              <div class="version">
                1.2.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">User documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="why_hpx.html">Why <em>HPX</em>?</a></li>
<li class="toctree-l1"><a class="reference internal" href="quickstart.html">Quick start</a></li>
<li class="toctree-l1"><a class="reference internal" href="terminology.html">Terminology</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="manual.html">Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="additional_material.html">Additional material</a></li>
</ul>
<p class="caption"><span class="caption-text">Reference</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">API reference</a></li>
</ul>
<p class="caption"><span class="caption-text">Developer documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributing to <em>HPX</em></a></li>
</ul>
<p class="caption"><span class="caption-text">Other</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="releases.html">Releases</a></li>
<li class="toctree-l1"><a class="reference internal" href="about_hpx.html">About <em>HPX</em></a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">HPX</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>API reference</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            
              <a href="https://github.com/STEllAR-GROUP/hpx/blob/master/docs/sphinx/api.rst" class="fa fa-github"> Edit on GitHub</a>
            
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="api-reference">
<h1>API reference<a class="headerlink" href="#api-reference" title="Permalink to this headline">¶</a></h1>
<dl class="class">
<dt id="_CPPv3N3hpx10components30colocating_distribution_policy12async_resultE">
<span id="_CPPv2N3hpx10components30colocating_distribution_policy12async_resultE"></span><span id="hpx::components::colocating_distribution_policy::async_result"></span><span class="target" id="structhpx_1_1components_1_1colocating__distribution__policy_1_1async__result"></span><em class="property">template </em>&lt;typename <em>Action</em>&gt;<br /><em class="property">struct </em><code class="descname">async_result</code><a class="headerlink" href="#_CPPv3N3hpx10components30colocating_distribution_policy12async_resultE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;colocating_distribution_policy.hpp&gt;</em><p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function is part of the invocation policy implemented by this class </dd>
</dl>
</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="type">
<dt id="_CPPv3IEN3hpx10components30colocating_distribution_policy12async_resultI6ActionE4typeE">
<span id="_CPPv2IEN3hpx10components30colocating_distribution_policy12async_resultI6ActionE4typeE"></span>template&lt;&gt;<br /><span class="target" id="structhpx_1_1components_1_1colocating__distribution__policy_1_1async__result_1aaf15fa7c4b2d0d574130c8c1ad5561d2"></span><em class="property">using </em><code class="descname">type</code> = <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::future&lt;<em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::promise_local_result&lt;<em class="property">typename</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::extract_action&lt;Action&gt;::remote_result_type&gt;::type&gt;<a class="headerlink" href="#_CPPv3IEN3hpx10components30colocating_distribution_policy12async_resultI6ActionE4typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx10components27default_distribution_policy12async_resultE">
<span id="_CPPv2N3hpx10components27default_distribution_policy12async_resultE"></span><span id="hpx::components::default_distribution_policy::async_result"></span><span class="target" id="structhpx_1_1components_1_1default__distribution__policy_1_1async__result"></span><em class="property">template </em>&lt;typename <em>Action</em>&gt;<br /><em class="property">struct </em><code class="descname">async_result</code><a class="headerlink" href="#_CPPv3N3hpx10components27default_distribution_policy12async_resultE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;default_distribution_policy.hpp&gt;</em><p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function is part of the invocation policy implemented by this class </dd>
</dl>
</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="type">
<dt id="_CPPv3IEN3hpx10components27default_distribution_policy12async_resultI6ActionE4typeE">
<span id="_CPPv2IEN3hpx10components27default_distribution_policy12async_resultI6ActionE4typeE"></span>template&lt;&gt;<br /><span class="target" id="structhpx_1_1components_1_1default__distribution__policy_1_1async__result_1abda7ba16c233310b756b5e383587f4fc"></span><em class="property">using </em><code class="descname">type</code> = <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::future&lt;<em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::promise_local_result&lt;<em class="property">typename</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::extract_action&lt;Action&gt;::remote_result_type&gt;::type&gt;<a class="headerlink" href="#_CPPv3IEN3hpx10components27default_distribution_policy12async_resultI6ActionE4typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx8parallel9execution15auto_chunk_sizeE">
<span id="_CPPv2N3hpx8parallel9execution15auto_chunk_sizeE"></span><span id="hpx::parallel::execution::auto_chunk_size"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1auto__chunk__size"></span><em class="property">struct </em><code class="descname">auto_chunk_size</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution15auto_chunk_sizeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;auto_chunk_size.hpp&gt;</em><p>Loop iterations are divided into pieces and then assigned to threads. The number of loop iterations combined is determined based on measurements of how long the execution of 1% of the overall number of iterations takes. This executor parameters type makes sure that as many loop iterations are combined as necessary to run for the amount of time specified. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel9execution15auto_chunk_size15auto_chunk_sizeEv">
<span id="_CPPv2N3hpx8parallel9execution15auto_chunk_size15auto_chunk_sizeEv"></span><span id="hpx::parallel::execution::auto_chunk_size::auto_chunk_size"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1auto__chunk__size_1aa410db9d8687294175a35d59a7b7aef1"></span><code class="descname">auto_chunk_size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution15auto_chunk_size15auto_chunk_sizeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct an <em><a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1auto__chunk__size"><span class="std std-ref">auto_chunk_size</span></a></em> executor parameters object</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Default constructed <em><a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1auto__chunk__size"><span class="std std-ref">auto_chunk_size</span></a></em> executor parameter types will use 80 microseconds as the minimal time for which any of the scheduled chunks should run. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel9execution15auto_chunk_size15auto_chunk_sizeERN3hpx4util15steady_durationE">
<span id="_CPPv2N3hpx8parallel9execution15auto_chunk_size15auto_chunk_sizeERN3hpx4util15steady_durationE"></span><span id="hpx::parallel::execution::auto_chunk_size::auto_chunk_size__hpx::util::steady_durationCR"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1auto__chunk__size_1a6e15ec4087b2b3847bb9c50e82866e20"></span><code class="descname">auto_chunk_size</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::steady_duration <em class="property">const</em> &amp;<em>rel_time</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution15auto_chunk_size15auto_chunk_sizeERN3hpx4util15steady_durationE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct an <em><a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1auto__chunk__size"><span class="std std-ref">auto_chunk_size</span></a></em> executor parameters object</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">rel_time</span></code>: [in] The time duration to use as the minimum to decide how many loop iterations should be combined. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx4lcos7barrierE">
<span id="_CPPv2N3hpx4lcos7barrierE"></span><span id="hpx::lcos::barrier"></span><span class="target" id="classhpx_1_1lcos_1_1barrier"></span><em class="property">class </em><code class="descname">barrier</code><a class="headerlink" href="#_CPPv3N3hpx4lcos7barrierE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;barrier.hpp&gt;</em><p>The barrier is an implementation performing a barrier over a number of participating threads. The different threads don’t have to be on the same locality. This barrier can be invoked in a distributed application.</p>
<p>For a local only barrier <dl class="docutils">
<dt><strong>See</strong></dt>
<dd>hpx::lcos::local::barrier. </dd>
</dl>
</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx4lcos7barrier7barrierERNSt6stringE">
<span id="_CPPv2N3hpx4lcos7barrier7barrierERNSt6stringE"></span><span id="hpx::lcos::barrier::barrier__ssCR"></span><span class="target" id="classhpx_1_1lcos_1_1barrier_1ae8e5bad1b2828970404b5d280137d579"></span><code class="descname">barrier</code><span class="sig-paren">(</span>std::string <em class="property">const</em> &amp;<em>base_name</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4lcos7barrier7barrierERNSt6stringE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Creates a barrier, rank is locality id, size is number of localities</p>
<p><p>A barrier </p>
<em>base_name</em> is created. It expects that <a class="reference internal" href="#namespacehpx_1a4dd860f6c435319c019eed326455f646"><span class="std std-ref">hpx::get_num_localities()</span></a> participate and the local rank is <a class="reference internal" href="#namespacehpx_1a158d7c54a657bb364c1704033010697b"><span class="std std-ref">hpx::get_locality_id()</span></a>. <dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">base_name</span></code>: The name of the barrier</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4lcos7barrier7barrierERNSt6stringENSt6size_tE">
<span id="_CPPv2N3hpx4lcos7barrier7barrierERNSt6stringENSt6size_tE"></span><span id="hpx::lcos::barrier::barrier__ssCR.std::s"></span><span class="target" id="classhpx_1_1lcos_1_1barrier_1ab7bd797e9f804496b537f2fc8be9ee76"></span><code class="descname">barrier</code><span class="sig-paren">(</span>std::string <em class="property">const</em> &amp;<em>base_name</em>, std::size_t <em>num</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4lcos7barrier7barrierERNSt6stringENSt6size_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Creates a barrier with a given size, rank is locality id</p>
<p><p>A barrier </p>
<em>base_name</em> is created. It expects that <em>num</em> participate and the local rank is <a class="reference internal" href="#namespacehpx_1a158d7c54a657bb364c1704033010697b"><span class="std std-ref">hpx::get_locality_id()</span></a>. <dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">base_name</span></code>: The name of the barrier </li>
<li><code class="docutils literal notranslate"><span class="pre">num</span></code>: The number of participating threads</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4lcos7barrier7barrierERNSt6stringENSt6size_tENSt6size_tE">
<span id="_CPPv2N3hpx4lcos7barrier7barrierERNSt6stringENSt6size_tENSt6size_tE"></span><span id="hpx::lcos::barrier::barrier__ssCR.std::s.std::s"></span><span class="target" id="classhpx_1_1lcos_1_1barrier_1a8a9fc05508fad7cd1d8014bee0e1d221"></span><code class="descname">barrier</code><span class="sig-paren">(</span>std::string <em class="property">const</em> &amp;<em>base_name</em>, std::size_t <em>num</em>, std::size_t <em>rank</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4lcos7barrier7barrierERNSt6stringENSt6size_tENSt6size_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Creates a barrier with a given size and rank</p>
<p><p>A barrier </p>
<em>base_name</em> is created. It expects that <em>num</em> participate and the local rank is <em>rank</em>. <dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">base_name</span></code>: The name of the barrier </li>
<li><code class="docutils literal notranslate"><span class="pre">num</span></code>: The number of participating threads </li>
<li><code class="docutils literal notranslate"><span class="pre">rank</span></code>: The rank of the calling site for this invocation</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4lcos7barrier4waitEv">
<span id="_CPPv2N3hpx4lcos7barrier4waitEv"></span><span id="hpx::lcos::barrier::wait"></span><span class="target" id="classhpx_1_1lcos_1_1barrier_1af0e09dd00764a182081cf2e356bfa824"></span>void <code class="descname">wait</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4lcos7barrier4waitEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Wait until each participant entered the barrier. Must be called by all participants</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>This function returns once all participants have entered the barrier (have called <em>wait</em>). </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4lcos7barrier4waitEN3hpx6launch12async_policyE">
<span id="_CPPv2N3hpx4lcos7barrier4waitEN3hpx6launch12async_policyE"></span><span id="hpx::lcos::barrier::wait__hpx::launch::async_policy"></span><span class="target" id="classhpx_1_1lcos_1_1barrier_1ad2a33feb18de78e8aefd3aaf0068fe02"></span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::future&lt;void&gt; <code class="descname">wait</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6launchE" title="hpx::launch">launch</a>::async_policy<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4lcos7barrier4waitEN3hpx6launch12async_policyE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Wait until each participant entered the barrier. Must be called by all participants</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>a future that becomes ready once all participants have entered the barrier (have called <em>wait</em>). </dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Static Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx4lcos7barrier11synchronizeEv">
<span id="_CPPv2N3hpx4lcos7barrier11synchronizeEv"></span><span id="hpx::lcos::barrier::synchronize"></span><span class="target" id="classhpx_1_1lcos_1_1barrier_1a76bb0453cded0cb3d3d9f8fd3d2ccbbd"></span><em class="property">static</em> void <code class="descname">synchronize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4lcos7barrier11synchronizeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Perform a global synchronization using the default global barrier The barrier is created once at startup and can be reused throughout the lifetime of an HPX application.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function currently does not support dynamic connection and disconnection of localities. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx10components30binpacking_distribution_policyE">
<span id="_CPPv2N3hpx10components30binpacking_distribution_policyE"></span><span id="hpx::components::binpacking_distribution_policy"></span><span class="target" id="structhpx_1_1components_1_1binpacking__distribution__policy"></span><em class="property">struct </em><code class="descname">binpacking_distribution_policy</code><a class="headerlink" href="#_CPPv3N3hpx10components30binpacking_distribution_policyE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;binpacking_distribution_policy.hpp&gt;</em><p>This class specifies the parameters for a binpacking distribution policy to use for creating a given number of items on a given set of localities. The binpacking policy will distribute the new objects in a way such that each of the localities will equalize the number of overall objects of this type based on a given criteria (by default this criteria is the overall number of objects of this type). </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx10components30binpacking_distribution_policy30binpacking_distribution_policyEv">
<span id="_CPPv2N3hpx10components30binpacking_distribution_policy30binpacking_distribution_policyEv"></span><span id="hpx::components::binpacking_distribution_policy::binpacking_distribution_policy"></span><span class="target" id="structhpx_1_1components_1_1binpacking__distribution__policy_1a9d5fd257766628771372978847cdd98b"></span><code class="descname">binpacking_distribution_policy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx10components30binpacking_distribution_policy30binpacking_distribution_policyEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Default-construct a new instance of a <em><a class="reference internal" href="#structhpx_1_1components_1_1binpacking__distribution__policy"><span class="std std-ref">binpacking_distribution_policy</span></a></em>. This policy will represent one locality (the local locality). </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx10components30binpacking_distribution_policyclERNSt6vectorI7id_typeEEPc">
<span id="_CPPv2NK3hpx10components30binpacking_distribution_policyclERNSt6vectorI7id_typeEEPc"></span><span id="hpx::components::binpacking_distribution_policy::call-operator__std::vector:id_type:CR.cCPC"></span><span class="target" id="structhpx_1_1components_1_1binpacking__distribution__policy_1a2f4f3fa90f2873a356436b2843acfed7"></span><a class="reference internal" href="#_CPPv3N3hpx10components30binpacking_distribution_policyE" title="hpx::components::binpacking_distribution_policy">binpacking_distribution_policy</a> <code class="descname">operator()</code><span class="sig-paren">(</span>std::vector&lt;id_type&gt; <em class="property">const</em> &amp;<em>locs</em>, char <em class="property">const</em> *<em>perf_counter_name</em> = <a class="reference internal" href="#_CPPv3N3hpx10components31default_binpacking_counter_nameE" title="hpx::components::default_binpacking_counter_name">default_binpacking_counter_name</a><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx10components30binpacking_distribution_policyclERNSt6vectorI7id_typeEEPc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a new <em>default_distribution</em> policy representing the given set of localities.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">locs</span></code>: [in] The list of localities the new instance should represent </li>
<li><code class="docutils literal notranslate"><span class="pre">perf_counter_name</span></code>: [in] The name of the performance counter which should be used as the distribution criteria (by default the overall number of existing instances of the given component type will be used). </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx10components30binpacking_distribution_policyclERRNSt6vectorI7id_typeEEPc">
<span id="_CPPv2NK3hpx10components30binpacking_distribution_policyclERRNSt6vectorI7id_typeEEPc"></span><span id="hpx::components::binpacking_distribution_policy::call-operator__std::vector:id_type:RR.cCPC"></span><span class="target" id="structhpx_1_1components_1_1binpacking__distribution__policy_1ab615032f27fd599e1c8d53e3084f063d"></span><a class="reference internal" href="#_CPPv3N3hpx10components30binpacking_distribution_policyE" title="hpx::components::binpacking_distribution_policy">binpacking_distribution_policy</a> <code class="descname">operator()</code><span class="sig-paren">(</span>std::vector&lt;id_type&gt; &amp;&amp;<em>locs</em>, char <em class="property">const</em> *<em>perf_counter_name</em> = <a class="reference internal" href="#_CPPv3N3hpx10components31default_binpacking_counter_nameE" title="hpx::components::default_binpacking_counter_name">default_binpacking_counter_name</a><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx10components30binpacking_distribution_policyclERRNSt6vectorI7id_typeEEPc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a new <em>default_distribution</em> policy representing the given set of localities.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">locs</span></code>: [in] The list of localities the new instance should represent </li>
<li><code class="docutils literal notranslate"><span class="pre">perf_counter_name</span></code>: [in] The name of the performance counter which should be used as the distribution criteria (by default the overall number of existing instances of the given component type will be used). </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx10components30binpacking_distribution_policyclER7id_typePc">
<span id="_CPPv2NK3hpx10components30binpacking_distribution_policyclER7id_typePc"></span><span id="hpx::components::binpacking_distribution_policy::call-operator__id_typeCR.cCPC"></span><span class="target" id="structhpx_1_1components_1_1binpacking__distribution__policy_1a786934b9391bf472982966c6b80bf56e"></span><a class="reference internal" href="#_CPPv3N3hpx10components30binpacking_distribution_policyE" title="hpx::components::binpacking_distribution_policy">binpacking_distribution_policy</a> <code class="descname">operator()</code><span class="sig-paren">(</span>id_type <em class="property">const</em> &amp;<em>loc</em>, char <em class="property">const</em> *<em>perf_counter_name</em> = <a class="reference internal" href="#_CPPv3N3hpx10components31default_binpacking_counter_nameE" title="hpx::components::default_binpacking_counter_name">default_binpacking_counter_name</a><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx10components30binpacking_distribution_policyclER7id_typePc" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a new <em>default_distribution</em> policy representing the given locality</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">loc</span></code>: [in] The locality the new instance should represent </li>
<li><code class="docutils literal notranslate"><span class="pre">perf_counter_name</span></code>: [in] The name of the performance counter which should be used as the distribution criteria (by default the overall number of existing instances of the given component type will be used). </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx10components30binpacking_distribution_policy6createEDpRR2Ts">
<span id="_CPPv2NK3hpx10components30binpacking_distribution_policy6createEDpRR2Ts"></span><span id="hpx::components::binpacking_distribution_policy::create__TsRRDpC"></span><em class="property">template </em>&lt;<em class="property">typename</em> Component, <em class="property">typename</em> ... <em>Ts</em>&gt;<br /><span class="target" id="structhpx_1_1components_1_1binpacking__distribution__policy_1a92923eb829b6a94f553039369cb22000"></span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::future&lt;<a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::id_type&gt; <code class="descname">create</code><span class="sig-paren">(</span>Ts&amp;&amp;... <em>vs</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx10components30binpacking_distribution_policy6createEDpRR2Ts" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create one object on one of the localities associated by this policy instance</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>A future holding the global address which represents the newly created object </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">vs</span></code>: [in] The arguments which will be forwarded to the constructor of the new object.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx10components30binpacking_distribution_policy11bulk_createENSt6size_tEDpRR2Ts">
<span id="_CPPv2NK3hpx10components30binpacking_distribution_policy11bulk_createENSt6size_tEDpRR2Ts"></span><span id="hpx::components::binpacking_distribution_policy::bulk_create__std::s.TsRRDpC"></span><em class="property">template </em>&lt;<em class="property">typename</em> Component, <em class="property">typename</em> ... <em>Ts</em>&gt;<br /><span class="target" id="structhpx_1_1components_1_1binpacking__distribution__policy_1abc008e09b2c9369800c7af065d329a05"></span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::future&lt;std::vector&lt;bulk_locality_result&gt;&gt; <code class="descname">bulk_create</code><span class="sig-paren">(</span>std::size_t <em>count</em>, Ts&amp;&amp;... <em>vs</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx10components30binpacking_distribution_policy11bulk_createENSt6size_tEDpRR2Ts" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create multiple objects on the localities associated by this policy instance</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>A future holding the list of global addresses which represent the newly created objects </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">count</span></code>: [in] The number of objects to create </li>
<li><code class="docutils literal notranslate"><span class="pre">vs</span></code>: [in] The arguments which will be forwarded to the constructors of the new objects.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx10components30binpacking_distribution_policy16get_counter_nameEv">
<span id="_CPPv2NK3hpx10components30binpacking_distribution_policy16get_counter_nameEv"></span><span id="hpx::components::binpacking_distribution_policy::get_counter_nameC"></span><span class="target" id="structhpx_1_1components_1_1binpacking__distribution__policy_1ae006ee32b001ce527f18ff4ed8c0034f"></span>std::string <em class="property">const</em> &amp;<code class="descname">get_counter_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx10components30binpacking_distribution_policy16get_counter_nameEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the name of the performance counter associated with this policy instance. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx10components30binpacking_distribution_policy18get_num_localitiesEv">
<span id="_CPPv2NK3hpx10components30binpacking_distribution_policy18get_num_localitiesEv"></span><span id="hpx::components::binpacking_distribution_policy::get_num_localitiesC"></span><span class="target" id="structhpx_1_1components_1_1binpacking__distribution__policy_1a98e472dae1f5e8c68589fb3c9e729287"></span>std::size_t <code class="descname">get_num_localities</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx10components30binpacking_distribution_policy18get_num_localitiesEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the number of associated localities for this distribution policy</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function is part of the creation policy implemented by this class </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx4util10checkpointE">
<span id="_CPPv2N3hpx4util10checkpointE"></span><span id="hpx::util::checkpoint"></span><span class="target" id="classhpx_1_1util_1_1checkpoint"></span><em class="property">class </em><code class="descname">checkpoint</code><a class="headerlink" href="#_CPPv3N3hpx4util10checkpointE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;checkpoint.hpp&gt;</em><p>Checkpoint Object</p>
<p>Checkpoint is the container object which is produced by save_checkpoint and is consumed by a restore_checkpoint. A checkpoint may be moved into the save_checkpoint object to write the byte stream to the pre-created checkpoint object. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="type">
<dt id="_CPPv3N3hpx4util10checkpoint14const_iteratorE">
<span id="_CPPv2N3hpx4util10checkpoint14const_iteratorE"></span><span class="target" id="classhpx_1_1util_1_1checkpoint_1a82de877cacbb15cfdeee974d6f3c63af"></span><em class="property">using </em><code class="descname">const_iterator</code> = std::vector::const_iterator<a class="headerlink" href="#_CPPv3N3hpx4util10checkpoint14const_iteratorE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx4util10checkpoint10checkpointEv">
<span id="_CPPv2N3hpx4util10checkpoint10checkpointEv"></span><span id="hpx::util::checkpoint::checkpoint"></span><span class="target" id="classhpx_1_1util_1_1checkpoint_1a73fa7ae72803c1595b90fa0b3c7415dc"></span><code class="descname">checkpoint</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4util10checkpoint10checkpointEv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4util10checkpoint10checkpointER10checkpoint">
<span id="_CPPv2N3hpx4util10checkpoint10checkpointER10checkpoint"></span><span id="hpx::util::checkpoint::checkpoint__checkpointCR"></span><span class="target" id="classhpx_1_1util_1_1checkpoint_1a3d4919b754f7de5939121f2bb0281302"></span><code class="descname">checkpoint</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx4util10checkpoint10checkpointEv" title="hpx::util::checkpoint::checkpoint">checkpoint</a> <em class="property">const</em> &amp;<em>c</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4util10checkpoint10checkpointER10checkpoint" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4util10checkpoint10checkpointERR10checkpoint">
<span id="_CPPv2N3hpx4util10checkpoint10checkpointERR10checkpoint"></span><span id="hpx::util::checkpoint::checkpoint__checkpointRR"></span><span class="target" id="classhpx_1_1util_1_1checkpoint_1ac46e515ed346c0b282cb3d41e87e7c0d"></span><code class="descname">checkpoint</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx4util10checkpoint10checkpointEv" title="hpx::util::checkpoint::checkpoint">checkpoint</a> &amp;&amp;<em>c</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4util10checkpoint10checkpointERR10checkpoint" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4util10checkpointD0Ev">
<span id="_CPPv2N3hpx4util10checkpointD0Ev"></span><span id="hpx::util::checkpoint::~checkpoint"></span><span class="target" id="classhpx_1_1util_1_1checkpoint_1a0b260023e856328d1b7d62bd291218ca"></span><code class="descname">~checkpoint</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4util10checkpointD0Ev" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4util10checkpoint10checkpointERNSt6vectorIcEE">
<span id="_CPPv2N3hpx4util10checkpoint10checkpointERNSt6vectorIcEE"></span><span id="hpx::util::checkpoint::checkpoint__std::vector:c:CR"></span><span class="target" id="classhpx_1_1util_1_1checkpoint_1a203c02b31d67597ef996c38a5bdf58d1"></span><code class="descname">checkpoint</code><span class="sig-paren">(</span>std::vector&lt;char&gt; <em class="property">const</em> &amp;<em>vec</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4util10checkpoint10checkpointERNSt6vectorIcEE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4util10checkpoint10checkpointERRNSt6vectorIcEE">
<span id="_CPPv2N3hpx4util10checkpoint10checkpointERRNSt6vectorIcEE"></span><span id="hpx::util::checkpoint::checkpoint__std::vector:c:RR"></span><span class="target" id="classhpx_1_1util_1_1checkpoint_1a8f8d5808e06cdd6e0d47488c042b0417"></span><code class="descname">checkpoint</code><span class="sig-paren">(</span>std::vector&lt;char&gt; &amp;&amp;<em>vec</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4util10checkpoint10checkpointERRNSt6vectorIcEE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4util10checkpointaSER10checkpoint">
<span id="_CPPv2N3hpx4util10checkpointaSER10checkpoint"></span><span id="hpx::util::checkpoint::assign-operator__checkpointCR"></span><span class="target" id="classhpx_1_1util_1_1checkpoint_1a107d0a201a33a291a219696c33d57105"></span><a class="reference internal" href="#_CPPv3N3hpx4util10checkpointE" title="hpx::util::checkpoint">checkpoint</a> &amp;<code class="descname">operator=</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx4util10checkpointE" title="hpx::util::checkpoint">checkpoint</a> <em class="property">const</em> &amp;<em>c</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4util10checkpointaSER10checkpoint" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4util10checkpointaSERR10checkpoint">
<span id="_CPPv2N3hpx4util10checkpointaSERR10checkpoint"></span><span id="hpx::util::checkpoint::assign-operator__checkpointRR"></span><span class="target" id="classhpx_1_1util_1_1checkpoint_1a86db36199979ad9d29ea902c6d168c37"></span><a class="reference internal" href="#_CPPv3N3hpx4util10checkpointE" title="hpx::util::checkpoint">checkpoint</a> &amp;<code class="descname">operator=</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx4util10checkpointE" title="hpx::util::checkpoint">checkpoint</a> &amp;&amp;<em>c</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4util10checkpointaSERR10checkpoint" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx4util10checkpointeqER10checkpoint">
<span id="_CPPv2NK3hpx4util10checkpointeqER10checkpoint"></span><span id="hpx::util::checkpoint::eq-operator__checkpointCRC"></span><span class="target" id="classhpx_1_1util_1_1checkpoint_1af9fef339d94767fb51f31e036649367b"></span>bool <code class="descname">operator==</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx4util10checkpointE" title="hpx::util::checkpoint">checkpoint</a> <em class="property">const</em> &amp;<em>c</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx4util10checkpointeqER10checkpoint" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx4util10checkpointneER10checkpoint">
<span id="_CPPv2NK3hpx4util10checkpointneER10checkpoint"></span><span id="hpx::util::checkpoint::neq-operator__checkpointCRC"></span><span class="target" id="classhpx_1_1util_1_1checkpoint_1a8ff15b7105a53ac0733bbbdc6e85b7d1"></span>bool <code class="descname">operator!=</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx4util10checkpointE" title="hpx::util::checkpoint">checkpoint</a> <em class="property">const</em> &amp;<em>c</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx4util10checkpointneER10checkpoint" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx4util10checkpoint5beginEv">
<span id="_CPPv2NK3hpx4util10checkpoint5beginEv"></span><span id="hpx::util::checkpoint::beginC"></span><span class="target" id="classhpx_1_1util_1_1checkpoint_1a763e553bf23b0ebe3d79e887b734d2d4"></span><a class="reference internal" href="#_CPPv3N3hpx4util10checkpoint14const_iteratorE" title="hpx::util::checkpoint::const_iterator">const_iterator</a> <code class="descname">begin</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx4util10checkpoint5beginEv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx4util10checkpoint3endEv">
<span id="_CPPv2NK3hpx4util10checkpoint3endEv"></span><span id="hpx::util::checkpoint::endC"></span><span class="target" id="classhpx_1_1util_1_1checkpoint_1a7719f7ad1bfacb0f15b083d5b7b6c88e"></span><a class="reference internal" href="#_CPPv3N3hpx4util10checkpoint14const_iteratorE" title="hpx::util::checkpoint::const_iterator">const_iterator</a> <code class="descname">end</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx4util10checkpoint3endEv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx4util10checkpoint4sizeEv">
<span id="_CPPv2NK3hpx4util10checkpoint4sizeEv"></span><span id="hpx::util::checkpoint::sizeC"></span><span class="target" id="classhpx_1_1util_1_1checkpoint_1ad33cab513f15c34bc56a8a0d2c82baca"></span>size_t <code class="descname">size</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx4util10checkpoint4sizeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx4util10checkpoint9serializeER7ArchiveKj">
<span id="_CPPv2N3hpx4util10checkpoint9serializeER7ArchiveKj"></span><span id="hpx::util::checkpoint::serialize__ArchiveR.unsigned-iC"></span><em class="property">template </em>&lt;<em class="property">typename</em> Archive&gt;<br /><span class="target" id="classhpx_1_1util_1_1checkpoint_1a3a86f9af2c42be37deb07f9f88800c17"></span>void <code class="descname">serialize</code><span class="sig-paren">(</span>Archive &amp;<em>arch</em>, <em class="property">const</em> unsigned int <em>version</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4util10checkpoint9serializeER7ArchiveKj" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Members</p>
<dl class="member">
<dt id="_CPPv3N3hpx4util10checkpoint4dataE">
<span id="_CPPv2N3hpx4util10checkpoint4dataE"></span><span id="hpx::util::checkpoint::data__std::vector:c:"></span><span class="target" id="classhpx_1_1util_1_1checkpoint_1ad8b2a1f0ca04c257c7a6b007ff6c802d"></span>std::vector&lt;char&gt; <code class="descname">data</code><a class="headerlink" href="#_CPPv3N3hpx4util10checkpoint4dataE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Friends</p>
<dl class="function">
<dt>
<span class="target" id="classhpx_1_1util_1_1checkpoint_1add50dcae00a1300662d4d2f8c52c804f"></span><em class="property">friend </em><code class="descname">hpx::util::checkpoint::hpx::serialization::access</code></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3lsRNSt7ostreamER10checkpoint">
<span id="_CPPv2lsRNSt7ostreamER10checkpoint"></span><span id="lshift-operator__osR.checkpointCR"></span><span class="target" id="classhpx_1_1util_1_1checkpoint_1ae4abc2da95d873bfacce9b6f969c9319"></span>std::ostream &amp;<code class="descname">operator&lt;&lt;</code><span class="sig-paren">(</span>std::ostream &amp;<em>ost</em>, checkpoint <em class="property">const</em> &amp;<em>ckp</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3lsRNSt7ostreamER10checkpoint" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Operator&lt;&lt; Overload</p>
<p><p>This overload is the main way to write data from a checkpoint to an object such as a file. Inside the function, the size of the checkpoint will be written to the stream before the checkpoint’s data. The operator&gt;&gt; overload uses this to read the correct number of bytes. Be mindful of this additional write and read when you use different facilities to write out or read in data to a checkpoint!</p>
<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ost</span></code>: Output stream to write to.</li>
<li><code class="docutils literal notranslate"><span class="pre">ckp</span></code>: Checkpoint to copy from.</li>
</ul>
</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Operator&lt;&lt; returns the ostream object. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3rsRNSt7istreamER10checkpoint">
<span id="_CPPv2rsRNSt7istreamER10checkpoint"></span><span id="rshift-operator__isR.checkpointR"></span><span class="target" id="classhpx_1_1util_1_1checkpoint_1a17563b5358dc4372447c4471e93d66f7"></span>std::istream &amp;<code class="descname">operator&gt;&gt;</code><span class="sig-paren">(</span>std::istream &amp;<em>ist</em>, checkpoint &amp;<em>ckp</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3rsRNSt7istreamER10checkpoint" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Operator&gt;&gt; Overload</p>
<p><p>This overload is the main way to read in data from an object such as a file to a checkpoint. It is important to note that inside the function, the first variable to be read is the size of the checkpoint. This size variable is written to the stream before the checkpoint’s data in the operator&lt;&lt; overload. Be mindful of this additional read and write when you use different facilities to read in or write out data from a checkpoint!</p>
<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ist</span></code>: Input stream to write from.</li>
<li><code class="docutils literal notranslate"><span class="pre">ckp</span></code>: Checkpoint to write to.</li>
</ul>
</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Operator&gt;&gt; returns the ostream object. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv318restore_checkpointR10checkpointR1TDpR2Ts">
<span id="_CPPv218restore_checkpointR10checkpointR1TDpR2Ts"></span><span id="restore_checkpoint__checkpointCR.TR.TsRDp"></span><em class="property">template </em>&lt;<em class="property">typename</em> T, typename... <em>Ts</em>&gt;<br /><span class="target" id="classhpx_1_1util_1_1checkpoint_1ad29203790e2102706b1394aa139ee4ef"></span>void <code class="descname">restore_checkpoint</code><span class="sig-paren">(</span>checkpoint <em class="property">const</em> &amp;<em>c</em>, T &amp;<em>t</em>, Ts&amp;... <em>ts</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv318restore_checkpointR10checkpointR1TDpR2Ts" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Resurrect</p>
<p>Restore_checkpoint takes a checkpoint object as a first argument and the containers which will be filled from the byte stream (in the same order as they were placed in save_checkpoint).</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Restore_checkpoint returns void. </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: A container to restore.</li>
<li><code class="docutils literal notranslate"><span class="pre">Ts</span></code>: Other containers to restore. Containers must be in the same order that they were inserted into the checkpoint.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">c</span></code>: The checkpoint to restore.</li>
<li><code class="docutils literal notranslate"><span class="pre">t</span></code>: A container to restore.</li>
<li><code class="docutils literal notranslate"><span class="pre">ts</span></code>: Other containers to restore Containers must be in the same order that they were inserted into the checkpoint.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx10components30colocating_distribution_policyE">
<span id="_CPPv2N3hpx10components30colocating_distribution_policyE"></span><span id="hpx::components::colocating_distribution_policy"></span><span class="target" id="structhpx_1_1components_1_1colocating__distribution__policy"></span><em class="property">struct </em><code class="descname">colocating_distribution_policy</code><a class="headerlink" href="#_CPPv3N3hpx10components30colocating_distribution_policyE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;colocating_distribution_policy.hpp&gt;</em><p>This class specifies the parameters for a distribution policy to use for creating a given number of items on the locality where a given object is currently placed. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx10components30colocating_distribution_policy30colocating_distribution_policyEv">
<span id="_CPPv2N3hpx10components30colocating_distribution_policy30colocating_distribution_policyEv"></span><span id="hpx::components::colocating_distribution_policy::colocating_distribution_policy"></span><span class="target" id="structhpx_1_1components_1_1colocating__distribution__policy_1a48d6e52cd2ad764554955ecd074e343c"></span><code class="descname">colocating_distribution_policy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx10components30colocating_distribution_policy30colocating_distribution_policyEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Default-construct a new instance of a <em><a class="reference internal" href="#structhpx_1_1components_1_1colocating__distribution__policy"><span class="std std-ref">colocating_distribution_policy</span></a></em>. This policy will represent the local locality. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx10components30colocating_distribution_policyclER7id_type">
<span id="_CPPv2NK3hpx10components30colocating_distribution_policyclER7id_type"></span><span id="hpx::components::colocating_distribution_policy::call-operator__id_typeCRC"></span><span class="target" id="structhpx_1_1components_1_1colocating__distribution__policy_1af6ca19c711527555c2e6baeabc2087d3"></span><a class="reference internal" href="#_CPPv3N3hpx10components30colocating_distribution_policyE" title="hpx::components::colocating_distribution_policy">colocating_distribution_policy</a> <code class="descname">operator()</code><span class="sig-paren">(</span>id_type <em class="property">const</em> &amp;<em>id</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx10components30colocating_distribution_policyclER7id_type" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a new <em><a class="reference internal" href="#structhpx_1_1components_1_1colocating__distribution__policy"><span class="std std-ref">colocating_distribution_policy</span></a></em> representing the locality where the given object os current located</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">id</span></code>: [in] The global address of the object with which the new instances should be colocated on </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx10components30colocating_distribution_policyclER11client_baseI6Client4StubE">
<span id="_CPPv2NK3hpx10components30colocating_distribution_policyclER11client_baseI6Client4StubE"></span><span id="hpx::components::colocating_distribution_policy::call-operator__client_base:Client.Stub:CRC"></span><em class="property">template </em>&lt;<em class="property">typename</em> Client, <em class="property">typename</em> Stub&gt;<br /><span class="target" id="structhpx_1_1components_1_1colocating__distribution__policy_1a8fbe3b618901efaa4587c99816046793"></span><a class="reference internal" href="#_CPPv3N3hpx10components30colocating_distribution_policyE" title="hpx::components::colocating_distribution_policy">colocating_distribution_policy</a> <code class="descname">operator()</code><span class="sig-paren">(</span>client_base&lt;Client, Stub&gt; <em class="property">const</em> &amp;<em>client</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx10components30colocating_distribution_policyclER11client_baseI6Client4StubE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a new <em><a class="reference internal" href="#structhpx_1_1components_1_1colocating__distribution__policy"><span class="std std-ref">colocating_distribution_policy</span></a></em> representing the locality where the given object os current located</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">client</span></code>: [in] The client side representation of the object with which the new instances should be colocated on </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx10components30colocating_distribution_policy6createEDpRR2Ts">
<span id="_CPPv2NK3hpx10components30colocating_distribution_policy6createEDpRR2Ts"></span><span id="hpx::components::colocating_distribution_policy::create__TsRRDpC"></span><em class="property">template </em>&lt;<em class="property">typename</em> Component, <em class="property">typename</em> ... <em>Ts</em>&gt;<br /><span class="target" id="structhpx_1_1components_1_1colocating__distribution__policy_1ad42527e98056824f346ec839e7218d17"></span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::future&lt;<a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::id_type&gt; <code class="descname">create</code><span class="sig-paren">(</span>Ts&amp;&amp;... <em>vs</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx10components30colocating_distribution_policy6createEDpRR2Ts" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create one object on the locality of the object this distribution policy instance is associated with</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function is part of the placement policy implemented by this class</dd>
<dt><strong>Return</strong></dt>
<dd>A future holding the global address which represents the newly created object </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">vs</span></code>: [in] The arguments which will be forwarded to the constructor of the new object.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx10components30colocating_distribution_policy11bulk_createENSt6size_tEDpRR2Ts">
<span id="_CPPv2NK3hpx10components30colocating_distribution_policy11bulk_createENSt6size_tEDpRR2Ts"></span><span id="hpx::components::colocating_distribution_policy::bulk_create__std::s.TsRRDpC"></span><em class="property">template </em>&lt;<em class="property">typename</em> Component, <em class="property">typename</em> ... <em>Ts</em>&gt;<br /><span class="target" id="structhpx_1_1components_1_1colocating__distribution__policy_1a194bc8cf80fab8143ab23b85358ca6a0"></span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::future&lt;std::vector&lt;bulk_locality_result&gt;&gt; <code class="descname">bulk_create</code><span class="sig-paren">(</span>std::size_t <em>count</em>, Ts&amp;&amp;... <em>vs</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx10components30colocating_distribution_policy11bulk_createENSt6size_tEDpRR2Ts" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create multiple objects colocated with the object represented by this policy instance</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function is part of the placement policy implemented by this class</dd>
<dt><strong>Return</strong></dt>
<dd>A future holding the list of global addresses which represent the newly created objects </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">count</span></code>: [in] The number of objects to create </li>
<li><code class="docutils literal notranslate"><span class="pre">vs</span></code>: [in] The arguments which will be forwarded to the constructors of the new objects.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx10components30colocating_distribution_policy5asyncE6launchDpRR2Ts">
<span id="_CPPv2NK3hpx10components30colocating_distribution_policy5asyncE6launchDpRR2Ts"></span><span id="hpx::components::colocating_distribution_policy::async__launch.TsRRDpC"></span><em class="property">template </em>&lt;<em class="property">typename</em> Action, <em class="property">typename</em> ... <em>Ts</em>&gt;<br /><span class="target" id="structhpx_1_1components_1_1colocating__distribution__policy_1ac71a3f3986b8029c09ac28d905b529e5"></span>async_result&lt;Action&gt;::<a class="reference internal" href="#_CPPv3IEN3hpx10components30colocating_distribution_policy12async_resultI6ActionE4typeE" title="hpx::components::colocating_distribution_policy::async_result&lt;Action&gt;::type">type</a> <code class="descname">async</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx6launchE" title="hpx::launch">launch</a> <em>policy</em>, Ts&amp;&amp;... <em>vs</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx10components30colocating_distribution_policy5asyncE6launchDpRR2Ts" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx10components30colocating_distribution_policy8async_cbE6launchRR8CallbackDpRR2Ts">
<span id="_CPPv2NK3hpx10components30colocating_distribution_policy8async_cbE6launchRR8CallbackDpRR2Ts"></span><span id="hpx::components::colocating_distribution_policy::async_cb__launch.CallbackRR.TsRRDpC"></span><em class="property">template </em>&lt;<em class="property">typename</em> Action, <em class="property">typename</em> Callback, <em class="property">typename</em> ... <em>Ts</em>&gt;<br /><span class="target" id="structhpx_1_1components_1_1colocating__distribution__policy_1a1a3dc11e340f487ca5a18563e6725e9b"></span>async_result&lt;Action&gt;::<a class="reference internal" href="#_CPPv3IEN3hpx10components30colocating_distribution_policy12async_resultI6ActionE4typeE" title="hpx::components::colocating_distribution_policy::async_result&lt;Action&gt;::type">type</a> <code class="descname">async_cb</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx6launchE" title="hpx::launch">launch</a> <em>policy</em>, Callback &amp;&amp;<em>cb</em>, Ts&amp;&amp;... <em>vs</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx10components30colocating_distribution_policy8async_cbE6launchRR8CallbackDpRR2Ts" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function is part of the invocation policy implemented by this class </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx10components30colocating_distribution_policy5applyERR12ContinuationN7threads15thread_priorityEDpRR2Ts">
<span id="_CPPv2NK3hpx10components30colocating_distribution_policy5applyERR12ContinuationN7threads15thread_priorityEDpRR2Ts"></span><span id="hpx::components::colocating_distribution_policy::apply__ContinuationRR.threads::thread_priority.TsRRDpC"></span><em class="property">template </em>&lt;<em class="property">typename</em> Action, <em class="property">typename</em> Continuation, <em class="property">typename</em> ... <em>Ts</em>&gt;<br /><span class="target" id="structhpx_1_1components_1_1colocating__distribution__policy_1a7c8155da7c40e908fe35764a08946372"></span>bool <code class="descname">apply</code><span class="sig-paren">(</span>Continuation &amp;&amp;<em>c</em>, <a class="reference internal" href="#_CPPv3N3hpx7threadsE" title="hpx::threads">threads</a>::<a class="reference internal" href="#_CPPv3N3hpx7threads15thread_priorityE" title="hpx::threads::thread_priority">thread_priority</a> <em>priority</em>, Ts&amp;&amp;... <em>vs</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx10components30colocating_distribution_policy5applyERR12ContinuationN7threads15thread_priorityEDpRR2Ts" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function is part of the invocation policy implemented by this class </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx10components30colocating_distribution_policy5applyEN7threads15thread_priorityEDpRR2Ts">
<span id="_CPPv2NK3hpx10components30colocating_distribution_policy5applyEN7threads15thread_priorityEDpRR2Ts"></span><span id="hpx::components::colocating_distribution_policy::apply__threads::thread_priority.TsRRDpC"></span><em class="property">template </em>&lt;<em class="property">typename</em> Action, <em class="property">typename</em> ... <em>Ts</em>&gt;<br /><span class="target" id="structhpx_1_1components_1_1colocating__distribution__policy_1aa7ed4f511c51292bf1db16ff7c3f9181"></span>bool <code class="descname">apply</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx7threadsE" title="hpx::threads">threads</a>::<a class="reference internal" href="#_CPPv3N3hpx7threads15thread_priorityE" title="hpx::threads::thread_priority">thread_priority</a> <em>priority</em>, Ts&amp;&amp;... <em>vs</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx10components30colocating_distribution_policy5applyEN7threads15thread_priorityEDpRR2Ts" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx10components30colocating_distribution_policy8apply_cbERR12ContinuationN7threads15thread_priorityERR8CallbackDpRR2Ts">
<span id="_CPPv2NK3hpx10components30colocating_distribution_policy8apply_cbERR12ContinuationN7threads15thread_priorityERR8CallbackDpRR2Ts"></span><span id="hpx::components::colocating_distribution_policy::apply_cb__ContinuationRR.threads::thread_priority.CallbackRR.TsRRDpC"></span><em class="property">template </em>&lt;<em class="property">typename</em> Action, <em class="property">typename</em> Continuation, <em class="property">typename</em> Callback, <em class="property">typename</em> ... <em>Ts</em>&gt;<br /><span class="target" id="structhpx_1_1components_1_1colocating__distribution__policy_1acf906ebacd8a91ebb40f07e9ab9a4cae"></span>bool <code class="descname">apply_cb</code><span class="sig-paren">(</span>Continuation &amp;&amp;<em>c</em>, <a class="reference internal" href="#_CPPv3N3hpx7threadsE" title="hpx::threads">threads</a>::<a class="reference internal" href="#_CPPv3N3hpx7threads15thread_priorityE" title="hpx::threads::thread_priority">thread_priority</a> <em>priority</em>, Callback &amp;&amp;<em>cb</em>, Ts&amp;&amp;... <em>vs</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx10components30colocating_distribution_policy8apply_cbERR12ContinuationN7threads15thread_priorityERR8CallbackDpRR2Ts" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function is part of the invocation policy implemented by this class </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx10components30colocating_distribution_policy8apply_cbEN7threads15thread_priorityERR8CallbackDpRR2Ts">
<span id="_CPPv2NK3hpx10components30colocating_distribution_policy8apply_cbEN7threads15thread_priorityERR8CallbackDpRR2Ts"></span><span id="hpx::components::colocating_distribution_policy::apply_cb__threads::thread_priority.CallbackRR.TsRRDpC"></span><em class="property">template </em>&lt;<em class="property">typename</em> Action, <em class="property">typename</em> Callback, <em class="property">typename</em> ... <em>Ts</em>&gt;<br /><span class="target" id="structhpx_1_1components_1_1colocating__distribution__policy_1ab73bd0903f043ed86a8ec3e6b5ba2f4f"></span>bool <code class="descname">apply_cb</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx7threadsE" title="hpx::threads">threads</a>::<a class="reference internal" href="#_CPPv3N3hpx7threads15thread_priorityE" title="hpx::threads::thread_priority">thread_priority</a> <em>priority</em>, Callback &amp;&amp;<em>cb</em>, Ts&amp;&amp;... <em>vs</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx10components30colocating_distribution_policy8apply_cbEN7threads15thread_priorityERR8CallbackDpRR2Ts" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx10components30colocating_distribution_policy18get_num_localitiesEv">
<span id="_CPPv2NK3hpx10components30colocating_distribution_policy18get_num_localitiesEv"></span><span id="hpx::components::colocating_distribution_policy::get_num_localitiesC"></span><span class="target" id="structhpx_1_1components_1_1colocating__distribution__policy_1aced5ed3e34aad0b1a77772e9fcd3175b"></span>std::size_t <code class="descname">get_num_localities</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx10components30colocating_distribution_policy18get_num_localitiesEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the number of associated localities for this distribution policy</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function is part of the creation policy implemented by this class </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx10components30colocating_distribution_policy15get_next_targetEv">
<span id="_CPPv2NK3hpx10components30colocating_distribution_policy15get_next_targetEv"></span><span id="hpx::components::colocating_distribution_policy::get_next_targetC"></span><span class="target" id="structhpx_1_1components_1_1colocating__distribution__policy_1aac00cb18a85c3868e72d9327cab06bf7"></span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::id_type <code class="descname">get_next_target</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx10components30colocating_distribution_policy15get_next_targetEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the locality which is anticipated to be used for the next async operation </p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx8resource4coreE">
<span id="_CPPv2N3hpx8resource4coreE"></span><span id="hpx::resource::core"></span><span class="target" id="classhpx_1_1resource_1_1core"></span><em class="property">class </em><code class="descname">core</code><a class="headerlink" href="#_CPPv3N3hpx8resource4coreE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;partitioner.hpp&gt;</em><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8resource4core4coreENSt6size_tEP11numa_domain">
<span id="_CPPv2N3hpx8resource4core4coreENSt6size_tEP11numa_domain"></span><span id="hpx::resource::core::core__std::s.numa_domainP"></span><span class="target" id="classhpx_1_1resource_1_1core_1aee20d4928d153287fe597eb4d56043a9"></span><code class="descname">core</code><span class="sig-paren">(</span>std::size_t <em>id</em> = <a class="reference internal" href="#_CPPv3N3hpx8resource4core15invalid_core_idE" title="hpx::resource::core::invalid_core_id">invalid_core_id</a>, <a class="reference internal" href="#_CPPv3N3hpx8resource11numa_domainE" title="hpx::resource::numa_domain">numa_domain</a> *<em>domain</em> = nullptr<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8resource4core4coreENSt6size_tEP11numa_domain" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx8resource4core3pusEv">
<span id="_CPPv2NK3hpx8resource4core3pusEv"></span><span id="hpx::resource::core::pusC"></span><span class="target" id="classhpx_1_1resource_1_1core_1aff875466d87a989eec14c465892c6bba"></span>std::vector&lt;<a class="reference internal" href="#_CPPv3N3hpx8resource2puE" title="hpx::resource::pu">pu</a>&gt; <em class="property">const</em> &amp;<code class="descname">pus</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8resource4core3pusEv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx8resource4core2idEv">
<span id="_CPPv2NK3hpx8resource4core2idEv"></span><span id="hpx::resource::core::idC"></span><span class="target" id="classhpx_1_1resource_1_1core_1aed0e7517a61415910ae7d35c9afa837e"></span>std::size_t <code class="descname">id</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8resource4core2idEv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8resource4core25cores_sharing_numa_domainEv">
<span id="_CPPv2N3hpx8resource4core25cores_sharing_numa_domainEv"></span><span id="hpx::resource::core::cores_sharing_numa_domain"></span><span class="target" id="classhpx_1_1resource_1_1core_1a3d2f1913d546c4a5ea956f747249ba83"></span>std::vector&lt;<a class="reference internal" href="#_CPPv3N3hpx8resource4coreE" title="hpx::resource::core">core</a>&gt; <code class="descname">cores_sharing_numa_domain</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8resource4core25cores_sharing_numa_domainEv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Members</p>
<dl class="member">
<dt id="_CPPv3N3hpx8resource4core3id_E">
<span id="_CPPv2N3hpx8resource4core3id_E"></span><span id="hpx::resource::core::id___std::s"></span><span class="target" id="classhpx_1_1resource_1_1core_1ab0b9747641fdb76d6be9aadd67cd0007"></span>std::size_t <code class="descname">id_</code><a class="headerlink" href="#_CPPv3N3hpx8resource4core3id_E" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv3N3hpx8resource4core7domain_E">
<span id="_CPPv2N3hpx8resource4core7domain_E"></span><span id="hpx::resource::core::domain___numa_domainP"></span><span class="target" id="classhpx_1_1resource_1_1core_1ae397ca48f982e79146ba27650385b624"></span><a class="reference internal" href="#_CPPv3N3hpx8resource11numa_domainE" title="hpx::resource::numa_domain">numa_domain</a> *<code class="descname">domain_</code><a class="headerlink" href="#_CPPv3N3hpx8resource4core7domain_E" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv3N3hpx8resource4core4pus_E">
<span id="_CPPv2N3hpx8resource4core4pus_E"></span><span id="hpx::resource::core::pus___std::vector:pu:"></span><span class="target" id="classhpx_1_1resource_1_1core_1a7afdab94ea3a5c58b612ae5623c8f7d3"></span>std::vector&lt;<a class="reference internal" href="#_CPPv3N3hpx8resource2puE" title="hpx::resource::pu">pu</a>&gt; <code class="descname">pus_</code><a class="headerlink" href="#_CPPv3N3hpx8resource4core4pus_E" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Static Attributes</p>
<dl class="member">
<dt id="_CPPv3N3hpx8resource4core15invalid_core_idE">
<span id="_CPPv2N3hpx8resource4core15invalid_core_idE"></span><span id="hpx::resource::core::invalid_core_id__std::sC"></span><span class="target" id="classhpx_1_1resource_1_1core_1abaa4bbf29ca17417b14951e393907694"></span><em class="property">const</em> std::size_t <code class="descname">invalid_core_id</code> = std::size_t(-1)<a class="headerlink" href="#_CPPv3N3hpx8resource4core15invalid_core_idE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Friends</p>
<dl class="function">
<dt>
<span class="target" id="classhpx_1_1resource_1_1core_1a3d1082481a9a21aecb71d04b3fe4f657"></span><em class="property">friend </em><code class="descname">hpx::resource::core::pu</code></dt>
<dd></dd></dl>

<dl class="function">
<dt>
<span class="target" id="classhpx_1_1resource_1_1core_1a2cd848189ba1a47ca3c3150ad45e974c"></span><em class="property">friend </em><code class="descname">hpx::resource::core::numa_domain</code></dt>
<dd></dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx10components27default_distribution_policyE">
<span id="_CPPv2N3hpx10components27default_distribution_policyE"></span><span id="hpx::components::default_distribution_policy"></span><span class="target" id="structhpx_1_1components_1_1default__distribution__policy"></span><em class="property">struct </em><code class="descname">default_distribution_policy</code><a class="headerlink" href="#_CPPv3N3hpx10components27default_distribution_policyE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;default_distribution_policy.hpp&gt;</em><p>This class specifies the parameters for a simple distribution policy to use for creating (and evenly distributing) a given number of items on a given set of localities. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx10components27default_distribution_policy27default_distribution_policyEv">
<span id="_CPPv2N3hpx10components27default_distribution_policy27default_distribution_policyEv"></span><span id="hpx::components::default_distribution_policy::default_distribution_policy"></span><span class="target" id="structhpx_1_1components_1_1default__distribution__policy_1a617e682eae476590119fde1c17a00b0f"></span><code class="descname">default_distribution_policy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx10components27default_distribution_policy27default_distribution_policyEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Default-construct a new instance of a <em><a class="reference internal" href="#structhpx_1_1components_1_1default__distribution__policy"><span class="std std-ref">default_distribution_policy</span></a></em>. This policy will represent one locality (the local locality). </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx10components27default_distribution_policyclERNSt6vectorI7id_typeEE">
<span id="_CPPv2NK3hpx10components27default_distribution_policyclERNSt6vectorI7id_typeEE"></span><span id="hpx::components::default_distribution_policy::call-operator__std::vector:id_type:CRC"></span><span class="target" id="structhpx_1_1components_1_1default__distribution__policy_1ae03c7be9b5fa863f55f36dcfeb545e4a"></span><a class="reference internal" href="#_CPPv3N3hpx10components27default_distribution_policyE" title="hpx::components::default_distribution_policy">default_distribution_policy</a> <code class="descname">operator()</code><span class="sig-paren">(</span>std::vector&lt;id_type&gt; <em class="property">const</em> &amp;<em>locs</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx10components27default_distribution_policyclERNSt6vectorI7id_typeEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a new <em>default_distribution</em> policy representing the given set of localities.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">locs</span></code>: [in] The list of localities the new instance should represent </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx10components27default_distribution_policyclERRNSt6vectorI7id_typeEE">
<span id="_CPPv2NK3hpx10components27default_distribution_policyclERRNSt6vectorI7id_typeEE"></span><span id="hpx::components::default_distribution_policy::call-operator__std::vector:id_type:RRC"></span><span class="target" id="structhpx_1_1components_1_1default__distribution__policy_1a5983c96c2c892d84619896fa07d34173"></span><a class="reference internal" href="#_CPPv3N3hpx10components27default_distribution_policyE" title="hpx::components::default_distribution_policy">default_distribution_policy</a> <code class="descname">operator()</code><span class="sig-paren">(</span>std::vector&lt;id_type&gt; &amp;&amp;<em>locs</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx10components27default_distribution_policyclERRNSt6vectorI7id_typeEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a new <em>default_distribution</em> policy representing the given set of localities.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">locs</span></code>: [in] The list of localities the new instance should represent </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx10components27default_distribution_policyclER7id_type">
<span id="_CPPv2NK3hpx10components27default_distribution_policyclER7id_type"></span><span id="hpx::components::default_distribution_policy::call-operator__id_typeCRC"></span><span class="target" id="structhpx_1_1components_1_1default__distribution__policy_1a4f231854652e8bd54dfb0efe57c494b5"></span><a class="reference internal" href="#_CPPv3N3hpx10components27default_distribution_policyE" title="hpx::components::default_distribution_policy">default_distribution_policy</a> <code class="descname">operator()</code><span class="sig-paren">(</span>id_type <em class="property">const</em> &amp;<em>loc</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx10components27default_distribution_policyclER7id_type" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a new <em>default_distribution</em> policy representing the given locality</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">loc</span></code>: [in] The locality the new instance should represent </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx10components27default_distribution_policy6createEDpRR2Ts">
<span id="_CPPv2NK3hpx10components27default_distribution_policy6createEDpRR2Ts"></span><span id="hpx::components::default_distribution_policy::create__TsRRDpC"></span><em class="property">template </em>&lt;<em class="property">typename</em> Component, <em class="property">typename</em> ... <em>Ts</em>&gt;<br /><span class="target" id="structhpx_1_1components_1_1default__distribution__policy_1ab11b5d0604c244769a11589303333ad7"></span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::future&lt;<a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::id_type&gt; <code class="descname">create</code><span class="sig-paren">(</span>Ts&amp;&amp;... <em>vs</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx10components27default_distribution_policy6createEDpRR2Ts" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create one object on one of the localities associated by this policy instance</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function is part of the placement policy implemented by this class</dd>
<dt><strong>Return</strong></dt>
<dd>A future holding the global address which represents the newly created object </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">vs</span></code>: [in] The arguments which will be forwarded to the constructor of the new object.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx10components27default_distribution_policy11bulk_createENSt6size_tEDpRR2Ts">
<span id="_CPPv2NK3hpx10components27default_distribution_policy11bulk_createENSt6size_tEDpRR2Ts"></span><span id="hpx::components::default_distribution_policy::bulk_create__std::s.TsRRDpC"></span><em class="property">template </em>&lt;<em class="property">typename</em> Component, <em class="property">typename</em> ... <em>Ts</em>&gt;<br /><span class="target" id="structhpx_1_1components_1_1default__distribution__policy_1aeb34ed76fb8dcf469dc87414ef37e8b0"></span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::future&lt;std::vector&lt;bulk_locality_result&gt;&gt; <code class="descname">bulk_create</code><span class="sig-paren">(</span>std::size_t <em>count</em>, Ts&amp;&amp;... <em>vs</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx10components27default_distribution_policy11bulk_createENSt6size_tEDpRR2Ts" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create multiple objects on the localities associated by this policy instance</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function is part of the placement policy implemented by this class</dd>
<dt><strong>Return</strong></dt>
<dd>A future holding the list of global addresses which represent the newly created objects </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">count</span></code>: [in] The number of objects to create </li>
<li><code class="docutils literal notranslate"><span class="pre">vs</span></code>: [in] The arguments which will be forwarded to the constructors of the new objects.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx10components27default_distribution_policy5asyncE6launchDpRR2Ts">
<span id="_CPPv2NK3hpx10components27default_distribution_policy5asyncE6launchDpRR2Ts"></span><span id="hpx::components::default_distribution_policy::async__launch.TsRRDpC"></span><em class="property">template </em>&lt;<em class="property">typename</em> Action, <em class="property">typename</em> ... <em>Ts</em>&gt;<br /><span class="target" id="structhpx_1_1components_1_1default__distribution__policy_1a1c4a8e01a94c0a01d97f2179d866f1d1"></span>async_result&lt;Action&gt;::<a class="reference internal" href="#_CPPv3IEN3hpx10components27default_distribution_policy12async_resultI6ActionE4typeE" title="hpx::components::default_distribution_policy::async_result&lt;Action&gt;::type">type</a> <code class="descname">async</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx6launchE" title="hpx::launch">launch</a> <em>policy</em>, Ts&amp;&amp;... <em>vs</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx10components27default_distribution_policy5asyncE6launchDpRR2Ts" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx10components27default_distribution_policy8async_cbE6launchRR8CallbackDpRR2Ts">
<span id="_CPPv2NK3hpx10components27default_distribution_policy8async_cbE6launchRR8CallbackDpRR2Ts"></span><span id="hpx::components::default_distribution_policy::async_cb__launch.CallbackRR.TsRRDpC"></span><em class="property">template </em>&lt;<em class="property">typename</em> Action, <em class="property">typename</em> Callback, <em class="property">typename</em> ... <em>Ts</em>&gt;<br /><span class="target" id="structhpx_1_1components_1_1default__distribution__policy_1a196aa3411cbd7df348f233afa1f1a2a0"></span>async_result&lt;Action&gt;::<a class="reference internal" href="#_CPPv3IEN3hpx10components27default_distribution_policy12async_resultI6ActionE4typeE" title="hpx::components::default_distribution_policy::async_result&lt;Action&gt;::type">type</a> <code class="descname">async_cb</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx6launchE" title="hpx::launch">launch</a> <em>policy</em>, Callback &amp;&amp;<em>cb</em>, Ts&amp;&amp;... <em>vs</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx10components27default_distribution_policy8async_cbE6launchRR8CallbackDpRR2Ts" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function is part of the invocation policy implemented by this class </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx10components27default_distribution_policy5applyERR12ContinuationN7threads15thread_priorityEDpRR2Ts">
<span id="_CPPv2NK3hpx10components27default_distribution_policy5applyERR12ContinuationN7threads15thread_priorityEDpRR2Ts"></span><span id="hpx::components::default_distribution_policy::apply__ContinuationRR.threads::thread_priority.TsRRDpC"></span><em class="property">template </em>&lt;<em class="property">typename</em> Action, <em class="property">typename</em> Continuation, <em class="property">typename</em> ... <em>Ts</em>&gt;<br /><span class="target" id="structhpx_1_1components_1_1default__distribution__policy_1a9e5a0ced175d31bedd9490f06848629d"></span>bool <code class="descname">apply</code><span class="sig-paren">(</span>Continuation &amp;&amp;<em>c</em>, <a class="reference internal" href="#_CPPv3N3hpx7threadsE" title="hpx::threads">threads</a>::<a class="reference internal" href="#_CPPv3N3hpx7threads15thread_priorityE" title="hpx::threads::thread_priority">thread_priority</a> <em>priority</em>, Ts&amp;&amp;... <em>vs</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx10components27default_distribution_policy5applyERR12ContinuationN7threads15thread_priorityEDpRR2Ts" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function is part of the invocation policy implemented by this class </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx10components27default_distribution_policy5applyEN7threads15thread_priorityEDpRR2Ts">
<span id="_CPPv2NK3hpx10components27default_distribution_policy5applyEN7threads15thread_priorityEDpRR2Ts"></span><span id="hpx::components::default_distribution_policy::apply__threads::thread_priority.TsRRDpC"></span><em class="property">template </em>&lt;<em class="property">typename</em> Action, <em class="property">typename</em> ... <em>Ts</em>&gt;<br /><span class="target" id="structhpx_1_1components_1_1default__distribution__policy_1a9e2e42821235d3a79d1e4855cc13a444"></span>bool <code class="descname">apply</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx7threadsE" title="hpx::threads">threads</a>::<a class="reference internal" href="#_CPPv3N3hpx7threads15thread_priorityE" title="hpx::threads::thread_priority">thread_priority</a> <em>priority</em>, Ts&amp;&amp;... <em>vs</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx10components27default_distribution_policy5applyEN7threads15thread_priorityEDpRR2Ts" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx10components27default_distribution_policy8apply_cbERR12ContinuationN7threads15thread_priorityERR8CallbackDpRR2Ts">
<span id="_CPPv2NK3hpx10components27default_distribution_policy8apply_cbERR12ContinuationN7threads15thread_priorityERR8CallbackDpRR2Ts"></span><span id="hpx::components::default_distribution_policy::apply_cb__ContinuationRR.threads::thread_priority.CallbackRR.TsRRDpC"></span><em class="property">template </em>&lt;<em class="property">typename</em> Action, <em class="property">typename</em> Continuation, <em class="property">typename</em> Callback, <em class="property">typename</em> ... <em>Ts</em>&gt;<br /><span class="target" id="structhpx_1_1components_1_1default__distribution__policy_1afb58fef290f0b7807c7d085c4078b318"></span>bool <code class="descname">apply_cb</code><span class="sig-paren">(</span>Continuation &amp;&amp;<em>c</em>, <a class="reference internal" href="#_CPPv3N3hpx7threadsE" title="hpx::threads">threads</a>::<a class="reference internal" href="#_CPPv3N3hpx7threads15thread_priorityE" title="hpx::threads::thread_priority">thread_priority</a> <em>priority</em>, Callback &amp;&amp;<em>cb</em>, Ts&amp;&amp;... <em>vs</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx10components27default_distribution_policy8apply_cbERR12ContinuationN7threads15thread_priorityERR8CallbackDpRR2Ts" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function is part of the invocation policy implemented by this class </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx10components27default_distribution_policy8apply_cbEN7threads15thread_priorityERR8CallbackDpRR2Ts">
<span id="_CPPv2NK3hpx10components27default_distribution_policy8apply_cbEN7threads15thread_priorityERR8CallbackDpRR2Ts"></span><span id="hpx::components::default_distribution_policy::apply_cb__threads::thread_priority.CallbackRR.TsRRDpC"></span><em class="property">template </em>&lt;<em class="property">typename</em> Action, <em class="property">typename</em> Callback, <em class="property">typename</em> ... <em>Ts</em>&gt;<br /><span class="target" id="structhpx_1_1components_1_1default__distribution__policy_1a63219ebf01ebcd943373d49c1a827896"></span>bool <code class="descname">apply_cb</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx7threadsE" title="hpx::threads">threads</a>::<a class="reference internal" href="#_CPPv3N3hpx7threads15thread_priorityE" title="hpx::threads::thread_priority">thread_priority</a> <em>priority</em>, Callback &amp;&amp;<em>cb</em>, Ts&amp;&amp;... <em>vs</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx10components27default_distribution_policy8apply_cbEN7threads15thread_priorityERR8CallbackDpRR2Ts" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx10components27default_distribution_policy18get_num_localitiesEv">
<span id="_CPPv2NK3hpx10components27default_distribution_policy18get_num_localitiesEv"></span><span id="hpx::components::default_distribution_policy::get_num_localitiesC"></span><span class="target" id="structhpx_1_1components_1_1default__distribution__policy_1af90ce3eb6617c2c95a0cedfbf3c2096f"></span>std::size_t <code class="descname">get_num_localities</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx10components27default_distribution_policy18get_num_localitiesEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the number of associated localities for this distribution policy</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function is part of the creation policy implemented by this class </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx10components27default_distribution_policy15get_next_targetEv">
<span id="_CPPv2NK3hpx10components27default_distribution_policy15get_next_targetEv"></span><span id="hpx::components::default_distribution_policy::get_next_targetC"></span><span class="target" id="structhpx_1_1components_1_1default__distribution__policy_1a4e1bef382e3d6843ff6dda045595dd4e"></span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::id_type <code class="descname">get_next_target</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx10components27default_distribution_policy15get_next_targetEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the locality which is anticipated to be used for the next async operation </p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx8parallel9execution18dynamic_chunk_sizeE">
<span id="_CPPv2N3hpx8parallel9execution18dynamic_chunk_sizeE"></span><span id="hpx::parallel::execution::dynamic_chunk_size"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1dynamic__chunk__size"></span><em class="property">struct </em><code class="descname">dynamic_chunk_size</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution18dynamic_chunk_sizeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;dynamic_chunk_size.hpp&gt;</em><p>Loop iterations are divided into pieces of size <em>chunk_size</em> and then dynamically scheduled among the threads; when a thread finishes one chunk, it is dynamically assigned another If <em>chunk_size</em> is not specified, the default chunk size is 1.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This executor parameters type is equivalent to OpenMP’s DYNAMIC scheduling directive. </dd>
</dl>
</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel9execution18dynamic_chunk_size18dynamic_chunk_sizeENSt6size_tE">
<span id="_CPPv2N3hpx8parallel9execution18dynamic_chunk_size18dynamic_chunk_sizeENSt6size_tE"></span><span id="hpx::parallel::execution::dynamic_chunk_size::dynamic_chunk_size__std::s"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1dynamic__chunk__size_1a3d8a82deaae276c811a3c9e95849e59b"></span><code class="descname">dynamic_chunk_size</code><span class="sig-paren">(</span>std::size_t <em>chunk_size</em> = 1<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution18dynamic_chunk_size18dynamic_chunk_sizeENSt6size_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct a <em><a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1dynamic__chunk__size"><span class="std std-ref">dynamic_chunk_size</span></a></em> executor parameters object</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">chunk_size</span></code>: [in] The optional chunk size to use as the number of loop iterations to schedule together. The default chunk size is 1. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx10error_codeE">
<span id="_CPPv2N3hpx10error_codeE"></span><span id="hpx::error_code"></span><span class="target" id="classhpx_1_1error__code"></span><em class="property">class </em><code class="descname">error_code</code> : <em class="property">public</em> <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a><a class="headerlink" href="#_CPPv3N3hpx10error_codeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;error_code.hpp&gt;</em><p>A <a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">hpx::error_code</span></a> represents an arbitrary error condition. </p>
<p>The class <a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">hpx::error_code</span></a> describes an object used to hold error code values, such as those originating from the operating system or other low-level application program interfaces.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Class <a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">hpx::error_code</span></a> is an adjunct to error reporting by exception </dd>
</dl>
</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx10error_code10error_codeE9throwmode">
<span id="_CPPv2N3hpx10error_code10error_codeE9throwmode"></span><span id="hpx::error_code::error_code__throwmode"></span><span class="target" id="classhpx_1_1error__code_1ab10fcf6785420832f8cae2aef8f01f83"></span><code class="descname">error_code</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx9throwmodeE" title="hpx::throwmode">throwmode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv3N3hpx5plainE" title="hpx::plain">plain</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx10error_code10error_codeE9throwmode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct an object of type <a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">error_code</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">mode</span></code>: The parameter <code class="docutils literal notranslate"><span class="pre">mode</span></code> specifies whether the constructed <a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">hpx::error_code</span></a> belongs to the error category <em>hpx_category</em> (if mode is <em>plain</em>, this is the default) or to the category <em>hpx_category_rethrow</em> (if mode is <em>rethrow</em>).</li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">nothing</span></code>: </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx10error_code10error_codeE5error9throwmode">
<span id="_CPPv2N3hpx10error_code10error_codeE5error9throwmode"></span><span id="hpx::error_code::error_code__error.throwmode"></span><span class="target" id="classhpx_1_1error__code_1a6c75f772a727844e82acc4bda0478be1"></span><code class="descname">error_code</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx5errorE" title="hpx::error">error</a> <em>e</em>, <a class="reference internal" href="#_CPPv3N3hpx9throwmodeE" title="hpx::throwmode">throwmode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv3N3hpx5plainE" title="hpx::plain">plain</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx10error_code10error_codeE5error9throwmode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct an object of type <a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">error_code</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">e</span></code>: The parameter <code class="docutils literal notranslate"><span class="pre">e</span></code> holds the <a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663"><span class="std std-ref">hpx::error</span></a> code the new exception should encapsulate. </li>
<li><code class="docutils literal notranslate"><span class="pre">mode</span></code>: The parameter <code class="docutils literal notranslate"><span class="pre">mode</span></code> specifies whether the constructed <a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">hpx::error_code</span></a> belongs to the error category <em>hpx_category</em> (if mode is <em>plain</em>, this is the default) or to the category <em>hpx_category_rethrow</em> (if mode is <em>rethrow</em>).</li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">nothing</span></code>: </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx10error_code10error_codeE5errorPcPcl9throwmode">
<span id="_CPPv2N3hpx10error_code10error_codeE5errorPcPcl9throwmode"></span><span id="hpx::error_code::error_code__error.cCP.cCP.l.throwmode"></span><span class="target" id="classhpx_1_1error__code_1a4ebfe4584be67357aab6d957a4ae7ebf"></span><code class="descname">error_code</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx5errorE" title="hpx::error">error</a> <em>e</em>, char <em class="property">const</em> *<em>func</em>, char <em class="property">const</em> *<em>file</em>, long <em>line</em>, <a class="reference internal" href="#_CPPv3N3hpx9throwmodeE" title="hpx::throwmode">throwmode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv3N3hpx5plainE" title="hpx::plain">plain</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx10error_code10error_codeE5errorPcPcl9throwmode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct an object of type <a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">error_code</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">e</span></code>: The parameter <code class="docutils literal notranslate"><span class="pre">e</span></code> holds the <a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663"><span class="std std-ref">hpx::error</span></a> code the new exception should encapsulate. </li>
<li><code class="docutils literal notranslate"><span class="pre">func</span></code>: The name of the function where the error was raised. </li>
<li><code class="docutils literal notranslate"><span class="pre">file</span></code>: The file name of the code where the error was raised. </li>
<li><code class="docutils literal notranslate"><span class="pre">line</span></code>: The line number of the code line where the error was raised. </li>
<li><code class="docutils literal notranslate"><span class="pre">mode</span></code>: The parameter <code class="docutils literal notranslate"><span class="pre">mode</span></code> specifies whether the constructed <a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">hpx::error_code</span></a> belongs to the error category <em>hpx_category</em> (if mode is <em>plain</em>, this is the default) or to the category <em>hpx_category_rethrow</em> (if mode is <em>rethrow</em>).</li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">nothing</span></code>: </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx10error_code10error_codeE5errorPc9throwmode">
<span id="_CPPv2N3hpx10error_code10error_codeE5errorPc9throwmode"></span><span id="hpx::error_code::error_code__error.cCP.throwmode"></span><span class="target" id="classhpx_1_1error__code_1a68c0bf863140a6eac301f2019db5e3d7"></span><code class="descname">error_code</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx5errorE" title="hpx::error">error</a> <em>e</em>, char <em class="property">const</em> *<em>msg</em>, <a class="reference internal" href="#_CPPv3N3hpx9throwmodeE" title="hpx::throwmode">throwmode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv3N3hpx5plainE" title="hpx::plain">plain</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx10error_code10error_codeE5errorPc9throwmode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct an object of type <a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">error_code</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">e</span></code>: The parameter <code class="docutils literal notranslate"><span class="pre">e</span></code> holds the <a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663"><span class="std std-ref">hpx::error</span></a> code the new exception should encapsulate. </li>
<li><code class="docutils literal notranslate"><span class="pre">msg</span></code>: The parameter <code class="docutils literal notranslate"><span class="pre">msg</span></code> holds the error message the new exception should encapsulate. </li>
<li><code class="docutils literal notranslate"><span class="pre">mode</span></code>: The parameter <code class="docutils literal notranslate"><span class="pre">mode</span></code> specifies whether the constructed <a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">hpx::error_code</span></a> belongs to the error category <em>hpx_category</em> (if mode is <em>plain</em>, this is the default) or to the category <em>hpx_category_rethrow</em> (if mode is <em>rethrow</em>).</li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">std::bad_alloc</span></code>: (if allocation of a copy of the passed string fails). </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx10error_code10error_codeE5errorPcPcPcl9throwmode">
<span id="_CPPv2N3hpx10error_code10error_codeE5errorPcPcPcl9throwmode"></span><span id="hpx::error_code::error_code__error.cCP.cCP.cCP.l.throwmode"></span><span class="target" id="classhpx_1_1error__code_1a1361ff69783e482003e267bd5976c1b6"></span><code class="descname">error_code</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx5errorE" title="hpx::error">error</a> <em>e</em>, char <em class="property">const</em> *<em>msg</em>, char <em class="property">const</em> *<em>func</em>, char <em class="property">const</em> *<em>file</em>, long <em>line</em>, <a class="reference internal" href="#_CPPv3N3hpx9throwmodeE" title="hpx::throwmode">throwmode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv3N3hpx5plainE" title="hpx::plain">plain</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx10error_code10error_codeE5errorPcPcPcl9throwmode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct an object of type <a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">error_code</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">e</span></code>: The parameter <code class="docutils literal notranslate"><span class="pre">e</span></code> holds the <a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663"><span class="std std-ref">hpx::error</span></a> code the new exception should encapsulate. </li>
<li><code class="docutils literal notranslate"><span class="pre">msg</span></code>: The parameter <code class="docutils literal notranslate"><span class="pre">msg</span></code> holds the error message the new exception should encapsulate. </li>
<li><code class="docutils literal notranslate"><span class="pre">func</span></code>: The name of the function where the error was raised. </li>
<li><code class="docutils literal notranslate"><span class="pre">file</span></code>: The file name of the code where the error was raised. </li>
<li><code class="docutils literal notranslate"><span class="pre">line</span></code>: The line number of the code line where the error was raised. </li>
<li><code class="docutils literal notranslate"><span class="pre">mode</span></code>: The parameter <code class="docutils literal notranslate"><span class="pre">mode</span></code> specifies whether the constructed <a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">hpx::error_code</span></a> belongs to the error category <em>hpx_category</em> (if mode is <em>plain</em>, this is the default) or to the category <em>hpx_category_rethrow</em> (if mode is <em>rethrow</em>).</li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">std::bad_alloc</span></code>: (if allocation of a copy of the passed string fails). </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx10error_code10error_codeE5errorRNSt6stringE9throwmode">
<span id="_CPPv2N3hpx10error_code10error_codeE5errorRNSt6stringE9throwmode"></span><span id="hpx::error_code::error_code__error.ssCR.throwmode"></span><span class="target" id="classhpx_1_1error__code_1a9d5013aac9d3038b3519bcfece5afea9"></span><code class="descname">error_code</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx5errorE" title="hpx::error">error</a> <em>e</em>, std::string <em class="property">const</em> &amp;<em>msg</em>, <a class="reference internal" href="#_CPPv3N3hpx9throwmodeE" title="hpx::throwmode">throwmode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv3N3hpx5plainE" title="hpx::plain">plain</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx10error_code10error_codeE5errorRNSt6stringE9throwmode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct an object of type <a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">error_code</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">e</span></code>: The parameter <code class="docutils literal notranslate"><span class="pre">e</span></code> holds the <a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663"><span class="std std-ref">hpx::error</span></a> code the new exception should encapsulate. </li>
<li><code class="docutils literal notranslate"><span class="pre">msg</span></code>: The parameter <code class="docutils literal notranslate"><span class="pre">msg</span></code> holds the error message the new exception should encapsulate. </li>
<li><code class="docutils literal notranslate"><span class="pre">mode</span></code>: The parameter <code class="docutils literal notranslate"><span class="pre">mode</span></code> specifies whether the constructed <a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">hpx::error_code</span></a> belongs to the error category <em>hpx_category</em> (if mode is <em>plain</em>, this is the default) or to the category <em>hpx_category_rethrow</em> (if mode is <em>rethrow</em>).</li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">std::bad_alloc</span></code>: (if allocation of a copy of the passed string fails). </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx10error_code10error_codeE5errorRNSt6stringEPcPcl9throwmode">
<span id="_CPPv2N3hpx10error_code10error_codeE5errorRNSt6stringEPcPcl9throwmode"></span><span id="hpx::error_code::error_code__error.ssCR.cCP.cCP.l.throwmode"></span><span class="target" id="classhpx_1_1error__code_1ae935c2ac12b6424073bb293514fe8c87"></span><code class="descname">error_code</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx5errorE" title="hpx::error">error</a> <em>e</em>, std::string <em class="property">const</em> &amp;<em>msg</em>, char <em class="property">const</em> *<em>func</em>, char <em class="property">const</em> *<em>file</em>, long <em>line</em>, <a class="reference internal" href="#_CPPv3N3hpx9throwmodeE" title="hpx::throwmode">throwmode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv3N3hpx5plainE" title="hpx::plain">plain</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx10error_code10error_codeE5errorRNSt6stringEPcPcl9throwmode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct an object of type <a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">error_code</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">e</span></code>: The parameter <code class="docutils literal notranslate"><span class="pre">e</span></code> holds the <a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663"><span class="std std-ref">hpx::error</span></a> code the new exception should encapsulate. </li>
<li><code class="docutils literal notranslate"><span class="pre">msg</span></code>: The parameter <code class="docutils literal notranslate"><span class="pre">msg</span></code> holds the error message the new exception should encapsulate. </li>
<li><code class="docutils literal notranslate"><span class="pre">func</span></code>: The name of the function where the error was raised. </li>
<li><code class="docutils literal notranslate"><span class="pre">file</span></code>: The file name of the code where the error was raised. </li>
<li><code class="docutils literal notranslate"><span class="pre">line</span></code>: The line number of the code line where the error was raised. </li>
<li><code class="docutils literal notranslate"><span class="pre">mode</span></code>: The parameter <code class="docutils literal notranslate"><span class="pre">mode</span></code> specifies whether the constructed <a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">hpx::error_code</span></a> belongs to the error category <em>hpx_category</em> (if mode is <em>plain</em>, this is the default) or to the category <em>hpx_category_rethrow</em> (if mode is <em>rethrow</em>).</li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">std::bad_alloc</span></code>: (if allocation of a copy of the passed string fails). </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx10error_code11get_messageEv">
<span id="_CPPv2NK3hpx10error_code11get_messageEv"></span><span id="hpx::error_code::get_messageC"></span><span class="target" id="classhpx_1_1error__code_1a70ab613bf2dfd57edc658b4acc680a63"></span>std::string <code class="descname">get_message</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx10error_code11get_messageEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return a reference to the error message stored in the <a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">hpx::error_code</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">nothing</span></code>: </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx10error_code5clearEv">
<span id="_CPPv2N3hpx10error_code5clearEv"></span><span id="hpx::error_code::clear"></span><span class="target" id="classhpx_1_1error__code_1acf2bd6fd25e912167159e3afbac4a398"></span>void <code class="descname">clear</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx10error_code5clearEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Clear this <a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">error_code</span></a> object. The postconditions of invoking this method are. </p>
<p><ul class="simple">
<li>value() == <a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663aca008d80aec0aed361d392d4ea09adbb"><span class="std std-ref">hpx::success</span></a> and category() == <a class="reference internal" href="#namespacehpx_1ae1b41e445d214ad2cf30f6e1ebd4e3bf"><span class="std std-ref">hpx::get_hpx_category()</span></a> </li>
</ul>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx10error_codeaSER10error_code">
<span id="_CPPv2N3hpx10error_codeaSER10error_code"></span><span id="hpx::error_code::assign-operator__error_codeCR"></span><span class="target" id="classhpx_1_1error__code_1a38d7458f1d451ba5d8ce57df3cbc3be4"></span><a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<code class="descname">operator=</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> <em class="property">const</em> &amp;<em>rhs</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx10error_codeaSER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assignment operator for <a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">error_code</span></a></p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function maintains the error category of the left hand side if the right hand side is a success code. </dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx10error_code10error_codeEiRN3hpx9exceptionE">
<span id="_CPPv2N3hpx10error_code10error_codeEiRN3hpx9exceptionE"></span><span id="hpx::error_code::error_code__i.hpx::exceptionCR"></span><span class="target" id="classhpx_1_1error__code_1aed65f44e5d9bb9b5ce01583c41da77fa"></span><code class="descname">error_code</code><span class="sig-paren">(</span>int <em>err</em>, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx9exceptionE" title="hpx::exception">exception</a> <em class="property">const</em> &amp;<em>e</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx10error_code10error_codeEiRN3hpx9exceptionE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx10error_code10error_codeERNSt13exception_ptrE">
<span id="_CPPv2N3hpx10error_code10error_codeERNSt13exception_ptrE"></span><span id="hpx::error_code::error_code__std::exception_ptrCR"></span><span class="target" id="classhpx_1_1error__code_1a4fa6bca898b113f181188373722227cf"></span><code class="descname">error_code</code><span class="sig-paren">(</span>std::exception_ptr <em class="property">const</em> &amp;<em>e</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx10error_code10error_codeERNSt13exception_ptrE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Members</p>
<dl class="member">
<dt id="_CPPv3N3hpx10error_code10exception_E">
<span id="_CPPv2N3hpx10error_code10exception_E"></span><span id="hpx::error_code::exception___std::exception_ptr"></span><span class="target" id="classhpx_1_1error__code_1adf90d2edb601c4e9405870761e8922db"></span>std::exception_ptr <code class="descname">exception_</code><a class="headerlink" href="#_CPPv3N3hpx10error_code10exception_E" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Friends</p>
<dl class="function">
<dt>
<span class="target" id="classhpx_1_1error__code_1a7e1c03d201209aef6b9f2b9c43c8abcf"></span><em class="property">friend </em><code class="descname">hpx::error_code::exception</code></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv315make_error_codeRNSt13exception_ptrE">
<span id="_CPPv215make_error_codeRNSt13exception_ptrE"></span><span id="make_error_code__std::exception_ptrCR"></span><span class="target" id="classhpx_1_1error__code_1a19a5be892df2ca236ddee7d7e8c002fc"></span>error_code <code class="descname">make_error_code</code><span class="sig-paren">(</span>std::exception_ptr <em class="property">const</em> &amp;<em>e</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv315make_error_codeRNSt13exception_ptrE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx9exceptionE">
<span id="_CPPv2N3hpx9exceptionE"></span><span id="hpx::exception"></span><span class="target" id="classhpx_1_1exception"></span><em class="property">class </em><code class="descname">exception</code> : <em class="property">public</em> system_error<a class="headerlink" href="#_CPPv3N3hpx9exceptionE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;exception.hpp&gt;</em><p>A <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a> is the main exception type used by HPX to report errors. </p>
<p>The <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a> type is the main exception type used by HPX to report errors. Any exceptions thrown by functions in the HPX library are either of this type or of a type derived from it. This implies that it is always safe to use this type only in catch statements guarding HPX library calls. </p>
<p>Subclassed by <a class="reference internal" href="#classhpx_1_1exception__list"><span class="std std-ref">hpx::exception_list</span></a>, <a class="reference internal" href="#classhpx_1_1parallel_1_1v2_1_1task__canceled__exception"><span class="std std-ref">hpx::parallel::v2::task_canceled_exception</span></a></p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx9exception9exceptionE5error">
<span id="_CPPv2N3hpx9exception9exceptionE5error"></span><span id="hpx::exception::exception__error"></span><span class="target" id="classhpx_1_1exception_1a13610d02885fc91e014fdb58debe996b"></span><code class="descname">exception</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx5errorE" title="hpx::error">error</a> <em>e</em> = <a class="reference internal" href="#_CPPv3N3hpx7successE" title="hpx::success">success</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx9exception9exceptionE5error" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct a <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a> from a <em><a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663"><span class="std std-ref">hpx::error</span></a></em>.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">e</span></code>: The parameter <code class="docutils literal notranslate"><span class="pre">e</span></code> holds the <a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663"><span class="std std-ref">hpx::error</span></a> code the new exception should encapsulate. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx9exception9exceptionERN5boost6system12system_errorE">
<span id="_CPPv2N3hpx9exception9exceptionERN5boost6system12system_errorE"></span><span id="hpx::exception::exception__boost::system::system_errorCR"></span><span class="target" id="classhpx_1_1exception_1afa51e14009dcdcd574b86794771314f3"></span><code class="descname">exception</code><span class="sig-paren">(</span>boost::system::system_error <em class="property">const</em> &amp;<em>e</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx9exception9exceptionERN5boost6system12system_errorE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct a <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a> from a boost::system_error. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx9exception9exceptionE5errorPc9throwmode">
<span id="_CPPv2N3hpx9exception9exceptionE5errorPc9throwmode"></span><span id="hpx::exception::exception__error.cCP.throwmode"></span><span class="target" id="classhpx_1_1exception_1a06bc6239c2b0a4222d72e088a56c6146"></span><code class="descname">exception</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx5errorE" title="hpx::error">error</a> <em>e</em>, char <em class="property">const</em> *<em>msg</em>, <a class="reference internal" href="#_CPPv3N3hpx9throwmodeE" title="hpx::throwmode">throwmode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv3N3hpx5plainE" title="hpx::plain">plain</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx9exception9exceptionE5errorPc9throwmode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct a <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a> from a <em><a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663"><span class="std std-ref">hpx::error</span></a></em> and an error message.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">e</span></code>: The parameter <code class="docutils literal notranslate"><span class="pre">e</span></code> holds the <a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663"><span class="std std-ref">hpx::error</span></a> code the new exception should encapsulate. </li>
<li><code class="docutils literal notranslate"><span class="pre">msg</span></code>: The parameter <code class="docutils literal notranslate"><span class="pre">msg</span></code> holds the error message the new exception should encapsulate. </li>
<li><code class="docutils literal notranslate"><span class="pre">mode</span></code>: The parameter <code class="docutils literal notranslate"><span class="pre">mode</span></code> specifies whether the returned <a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">hpx::error_code</span></a> belongs to the error category <em>hpx_category</em> (if mode is <em>plain</em>, this is the default) or to the category <em>hpx_category_rethrow</em> (if mode is <em>rethrow</em>). </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx9exception9exceptionE5errorRNSt6stringE9throwmode">
<span id="_CPPv2N3hpx9exception9exceptionE5errorRNSt6stringE9throwmode"></span><span id="hpx::exception::exception__error.ssCR.throwmode"></span><span class="target" id="classhpx_1_1exception_1a25070a178aea9151b3ee9c853112a900"></span><code class="descname">exception</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx5errorE" title="hpx::error">error</a> <em>e</em>, std::string <em class="property">const</em> &amp;<em>msg</em>, <a class="reference internal" href="#_CPPv3N3hpx9throwmodeE" title="hpx::throwmode">throwmode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv3N3hpx5plainE" title="hpx::plain">plain</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx9exception9exceptionE5errorRNSt6stringE9throwmode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct a <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a> from a <em><a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663"><span class="std std-ref">hpx::error</span></a></em> and an error message.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">e</span></code>: The parameter <code class="docutils literal notranslate"><span class="pre">e</span></code> holds the <a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663"><span class="std std-ref">hpx::error</span></a> code the new exception should encapsulate. </li>
<li><code class="docutils literal notranslate"><span class="pre">msg</span></code>: The parameter <code class="docutils literal notranslate"><span class="pre">msg</span></code> holds the error message the new exception should encapsulate. </li>
<li><code class="docutils literal notranslate"><span class="pre">mode</span></code>: The parameter <code class="docutils literal notranslate"><span class="pre">mode</span></code> specifies whether the returned <a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">hpx::error_code</span></a> belongs to the error category <em>hpx_category</em> (if mode is <em>plain</em>, this is the default) or to the category <em>hpx_category_rethrow</em> (if mode is <em>rethrow</em>). </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx9exceptionD0Ev">
<span id="_CPPv2N3hpx9exceptionD0Ev"></span><span id="hpx::exception::~exception"></span><span class="target" id="classhpx_1_1exception_1a190210900086f84334dbcc24358ce4cc"></span><code class="descname">~exception</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx9exceptionD0Ev" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Destruct a <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a></p>
<p><dl class="docutils">
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">nothing</span></code>: </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx9exception9get_errorEv">
<span id="_CPPv2NK3hpx9exception9get_errorEv"></span><span id="hpx::exception::get_errorC"></span><span class="target" id="classhpx_1_1exception_1a24a553bfeb6e4a31090d81cde1cd0834"></span><a class="reference internal" href="#_CPPv3N3hpx5errorE" title="hpx::error">error</a> <code class="descname">get_error</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx9exception9get_errorEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em><a class="reference internal" href="#classhpx_1_1exception_1a24a553bfeb6e4a31090d81cde1cd0834"><span class="std std-ref">get_error()</span></a></em> returns the <a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663"><span class="std std-ref">hpx::error</span></a> code stored in the referenced instance of a <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a>. It returns the <a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663"><span class="std std-ref">hpx::error</span></a> code this exception instance was constructed from.</p>
<p><dl class="docutils">
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">nothing</span></code>: </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx9exception14get_error_codeE9throwmode">
<span id="_CPPv2NK3hpx9exception14get_error_codeE9throwmode"></span><span id="hpx::exception::get_error_code__throwmodeC"></span><span class="target" id="classhpx_1_1exception_1af1e2fd7574114a23cb9cd4d366d5ad30"></span><a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> <code class="descname">get_error_code</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx9throwmodeE" title="hpx::throwmode">throwmode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv3N3hpx5plainE" title="hpx::plain">plain</a><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx9exception14get_error_codeE9throwmode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em><a class="reference internal" href="#classhpx_1_1exception_1af1e2fd7574114a23cb9cd4d366d5ad30"><span class="std std-ref">get_error_code()</span></a></em> returns a <a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">hpx::error_code</span></a> which represents the same error condition as this <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a> instance.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">mode</span></code>: The parameter <code class="docutils literal notranslate"><span class="pre">mode</span></code> specifies whether the returned <a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">hpx::error_code</span></a> belongs to the error category <em>hpx_category</em> (if mode is <em>plain</em>, this is the default) or to the category <em>hpx_category_rethrow</em> (if mode is <em>rethrow</em>). </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx14exception_listE">
<span id="_CPPv2N3hpx14exception_listE"></span><span id="hpx::exception_list"></span><span class="target" id="classhpx_1_1exception__list"></span><em class="property">class </em><code class="descname">exception_list</code> : <em class="property">public</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx9exceptionE" title="hpx::exception">exception</a><a class="headerlink" href="#_CPPv3N3hpx14exception_listE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;exception_list.hpp&gt;</em><p>The class <a class="reference internal" href="#classhpx_1_1exception__list"><span class="std std-ref">exception_list</span></a> is a container of exception_ptr objects parallel algorithms may use to communicate uncaught exceptions encountered during parallel execution to the caller of the algorithm</p>
<p>The type exception_list::const_iterator fulfills the requirements of a forward iterator. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="type">
<dt id="_CPPv3N3hpx14exception_list8iteratorE">
<span id="_CPPv2N3hpx14exception_list8iteratorE"></span><span id="hpx::exception_list::iterator"></span><span class="target" id="classhpx_1_1exception__list_1ae0b75a125a76c3156ce3315e86596716"></span><em class="property">typedef </em><a class="reference internal" href="#_CPPv3N3hpx14exception_list19exception_list_typeE" title="hpx::exception_list::exception_list_type">exception_list_type</a>::const_iterator <code class="descname">iterator</code><a class="headerlink" href="#_CPPv3N3hpx14exception_list8iteratorE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>bidirectional iterator </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv3NK3hpx14exception_list4sizeEv">
<span id="_CPPv2NK3hpx14exception_list4sizeEv"></span><span id="hpx::exception_list::sizeC"></span><span class="target" id="classhpx_1_1exception__list_1ae4e3e1b70e8185033656d891749a234e"></span>std::size_t <code class="descname">size</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx14exception_list4sizeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The number of exception_ptr objects contained within the <a class="reference internal" href="#classhpx_1_1exception__list"><span class="std std-ref">exception_list</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Constant time. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx14exception_list5beginEv">
<span id="_CPPv2NK3hpx14exception_list5beginEv"></span><span id="hpx::exception_list::beginC"></span><span class="target" id="classhpx_1_1exception__list_1a94a921543c170e5fa21278613e60599a"></span><a class="reference internal" href="#_CPPv3N3hpx14exception_list19exception_list_typeE" title="hpx::exception_list::exception_list_type">exception_list_type</a>::const_iterator <code class="descname">begin</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx14exception_list5beginEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>An iterator referring to the first exception_ptr object contained within the <a class="reference internal" href="#classhpx_1_1exception__list"><span class="std std-ref">exception_list</span></a>. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx14exception_list3endEv">
<span id="_CPPv2NK3hpx14exception_list3endEv"></span><span id="hpx::exception_list::endC"></span><span class="target" id="classhpx_1_1exception__list_1a0ecc17888e5ec79776b45c872bf76584"></span><a class="reference internal" href="#_CPPv3N3hpx14exception_list19exception_list_typeE" title="hpx::exception_list::exception_list_type">exception_list_type</a>::const_iterator <code class="descname">end</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx14exception_list3endEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>An iterator which is the past-the-end value for the <a class="reference internal" href="#classhpx_1_1exception__list"><span class="std std-ref">exception_list</span></a>. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Types</p>
<dl class="type">
<dt id="_CPPv3N3hpx14exception_list10mutex_typeE">
<span id="_CPPv2N3hpx14exception_list10mutex_typeE"></span><span id="hpx::exception_list::mutex_type"></span><span class="target" id="classhpx_1_1exception__list_1ad64e34e1906c1d7be013f06e0972260c"></span><em class="property">typedef </em><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx4lcosE" title="hpx::lcos">lcos</a>::local::spinlock <code class="descname">mutex_type</code><a class="headerlink" href="#_CPPv3N3hpx14exception_list10mutex_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx14exception_list19exception_list_typeE">
<span id="_CPPv2N3hpx14exception_list19exception_list_typeE"></span><span id="hpx::exception_list::exception_list_type"></span><span class="target" id="classhpx_1_1exception__list_1acd236cdeb27c48c1e3a126adf95f2201"></span><em class="property">typedef </em>std::list&lt;std::exception_ptr&gt; <code class="descname">exception_list_type</code><a class="headerlink" href="#_CPPv3N3hpx14exception_list19exception_list_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Members</p>
<dl class="member">
<dt id="_CPPv3N3hpx14exception_list11exceptions_E">
<span id="_CPPv2N3hpx14exception_list11exceptions_E"></span><span id="hpx::exception_list::exceptions___exception_list_type"></span><span class="target" id="classhpx_1_1exception__list_1afc8c518f8677ae103839eb4f119e5959"></span><a class="reference internal" href="#_CPPv3N3hpx14exception_list19exception_list_typeE" title="hpx::exception_list::exception_list_type">exception_list_type</a> <code class="descname">exceptions_</code><a class="headerlink" href="#_CPPv3N3hpx14exception_list11exceptions_E" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv3N3hpx14exception_list4mtx_E">
<span id="_CPPv2N3hpx14exception_list4mtx_E"></span><span id="hpx::exception_list::mtx___mutex_type"></span><span class="target" id="classhpx_1_1exception__list_1ae0639af297017767265b9da164a4faac"></span><a class="reference internal" href="#_CPPv3N3hpx14exception_list10mutex_typeE" title="hpx::exception_list::mutex_type">mutex_type</a> <code class="descname">mtx_</code><a class="headerlink" href="#_CPPv3N3hpx14exception_list4mtx_E" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx8parallel9execution17guided_chunk_sizeE">
<span id="_CPPv2N3hpx8parallel9execution17guided_chunk_sizeE"></span><span id="hpx::parallel::execution::guided_chunk_size"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1guided__chunk__size"></span><em class="property">struct </em><code class="descname">guided_chunk_size</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution17guided_chunk_sizeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;guided_chunk_size.hpp&gt;</em><p>Iterations are dynamically assigned to threads in blocks as threads request them until no blocks remain to be assigned. Similar to <em><a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1dynamic__chunk__size"><span class="std std-ref">dynamic_chunk_size</span></a></em> except that the block size decreases each time a number of loop iterations is given to a thread. The size of the initial block is proportional to <em>number_of_iterations</em> / <em>number_of_cores</em>. Subsequent blocks are proportional to <em>number_of_iterations_remaining</em> / <em>number_of_cores</em>. The optional chunk size parameter defines the minimum block size. The default chunk size is 1.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This executor parameters type is equivalent to OpenMP’s GUIDED scheduling directive. </dd>
</dl>
</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel9execution17guided_chunk_size17guided_chunk_sizeENSt6size_tE">
<span id="_CPPv2N3hpx8parallel9execution17guided_chunk_size17guided_chunk_sizeENSt6size_tE"></span><span id="hpx::parallel::execution::guided_chunk_size::guided_chunk_size__std::s"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1guided__chunk__size_1a33c3a0b0bbd08cf812dc0df826ba0dca"></span><code class="descname">guided_chunk_size</code><span class="sig-paren">(</span>std::size_t <em>min_chunk_size</em> = 1<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution17guided_chunk_size17guided_chunk_sizeENSt6size_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct a <em><a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1guided__chunk__size"><span class="std std-ref">guided_chunk_size</span></a></em> executor parameters object</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">min_chunk_size</span></code>: [in] The optional minimal chunk size to use as the minimal number of loop iterations to schedule together. The default minimal chunk size is 1. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx8parallel9execution25is_async_execution_policyE">
<span id="_CPPv2N3hpx8parallel9execution25is_async_execution_policyE"></span><span id="hpx::parallel::execution::is_async_execution_policy"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1is__async__execution__policy"></span><em class="property">template </em>&lt;<em class="property">typename</em> T&gt;<br /><em class="property">struct </em><code class="descname">is_async_execution_policy</code> : <em class="property">public</em> <a class="reference internal" href="#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::detail::is_async_execution_policy&lt;<a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::decay&lt;T&gt;::type&gt;<a class="headerlink" href="#_CPPv3N3hpx8parallel9execution25is_async_execution_policyE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;is_execution_policy.hpp&gt;</em><p>Extension: Detect whether given execution policy makes algorithms asynchronous</p>
<p><ol class="arabic simple">
<li>The type <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1is__async__execution__policy"><span class="std std-ref">is_async_execution_policy</span></a> can be used to detect asynchronous execution policies for the purpose of excluding function signatures from otherwise ambiguous overload resolution participation.</li>
<li>If T is the type of a standard or implementation-defined execution policy, is_async_execution_policy&lt;T&gt; shall be publicly derived from integral_constant&lt;bool, true&gt;, otherwise from integral_constant&lt;bool, false&gt;.</li>
<li>The behavior of a program that adds specializations for <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1is__async__execution__policy"><span class="std std-ref">is_async_execution_policy</span></a> is undefined. </li>
</ol>
</p>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx8parallel9execution19is_execution_policyE">
<span id="_CPPv2N3hpx8parallel9execution19is_execution_policyE"></span><span id="hpx::parallel::execution::is_execution_policy"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1is__execution__policy"></span><em class="property">template </em>&lt;<em class="property">typename</em> T&gt;<br /><em class="property">struct </em><code class="descname">is_execution_policy</code> : <em class="property">public</em> <a class="reference internal" href="#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::detail::is_execution_policy&lt;<a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::decay&lt;T&gt;::type&gt;<a class="headerlink" href="#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;is_execution_policy.hpp&gt;</em><p><ol class="arabic simple">
<li>The type <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1is__execution__policy"><span class="std std-ref">is_execution_policy</span></a> can be used to detect execution policies for the purpose of excluding function signatures from otherwise ambiguous overload resolution participation.</li>
<li>If T is the type of a standard or implementation-defined execution policy, is_execution_policy&lt;T&gt; shall be publicly derived from integral_constant&lt;bool, true&gt;, otherwise from integral_constant&lt;bool, false&gt;.</li>
<li>The behavior of a program that adds specializations for <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1is__execution__policy"><span class="std std-ref">is_execution_policy</span></a> is undefined. </li>
</ol>
</p>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx8parallel9execution28is_parallel_execution_policyE">
<span id="_CPPv2N3hpx8parallel9execution28is_parallel_execution_policyE"></span><span id="hpx::parallel::execution::is_parallel_execution_policy"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1is__parallel__execution__policy"></span><em class="property">template </em>&lt;<em class="property">typename</em> T&gt;<br /><em class="property">struct </em><code class="descname">is_parallel_execution_policy</code> : <em class="property">public</em> <a class="reference internal" href="#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::detail::is_parallel_execution_policy&lt;<a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::decay&lt;T&gt;::type&gt;<a class="headerlink" href="#_CPPv3N3hpx8parallel9execution28is_parallel_execution_policyE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;is_execution_policy.hpp&gt;</em><p>Extension: Detect whether given execution policy enables parallelization</p>
<p><ol class="arabic simple">
<li>The type <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1is__parallel__execution__policy"><span class="std std-ref">is_parallel_execution_policy</span></a> can be used to detect parallel execution policies for the purpose of excluding function signatures from otherwise ambiguous overload resolution participation.</li>
<li>If T is the type of a standard or implementation-defined execution policy, is_parallel_execution_policy&lt;T&gt; shall be publicly derived from integral_constant&lt;bool, true&gt;, otherwise from integral_constant&lt;bool, false&gt;.</li>
<li>The behavior of a program that adds specializations for <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1is__parallel__execution__policy"><span class="std std-ref">is_parallel_execution_policy</span></a> is undefined. </li>
</ol>
</p>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx8parallel9execution29is_sequenced_execution_policyE">
<span id="_CPPv2N3hpx8parallel9execution29is_sequenced_execution_policyE"></span><span id="hpx::parallel::execution::is_sequenced_execution_policy"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1is__sequenced__execution__policy"></span><em class="property">template </em>&lt;<em class="property">typename</em> T&gt;<br /><em class="property">struct </em><code class="descname">is_sequenced_execution_policy</code> : <em class="property">public</em> <a class="reference internal" href="#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::detail::is_sequenced_execution_policy&lt;<a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::decay&lt;T&gt;::type&gt;<a class="headerlink" href="#_CPPv3N3hpx8parallel9execution29is_sequenced_execution_policyE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;is_execution_policy.hpp&gt;</em><p>Extension: Detect whether given execution policy does not enable parallelization</p>
<p><ol class="arabic simple">
<li>The type <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1is__sequenced__execution__policy"><span class="std std-ref">is_sequenced_execution_policy</span></a> can be used to detect non-parallel execution policies for the purpose of excluding function signatures from otherwise ambiguous overload resolution participation.</li>
<li>If T is the type of a standard or implementation-defined execution policy, is_sequenced_execution_policy&lt;T&gt; shall be publicly derived from integral_constant&lt;bool, true&gt;, otherwise from integral_constant&lt;bool, false&gt;.</li>
<li>The behavior of a program that adds specializations for <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1is__sequenced__execution__policy"><span class="std std-ref">is_sequenced_execution_policy</span></a> is undefined. </li>
</ol>
</p>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx6launchE">
<span id="_CPPv2N3hpx6launchE"></span><span id="hpx::launch"></span><span class="target" id="structhpx_1_1launch"></span><em class="property">struct </em><code class="descname">launch</code> : <em class="property">public</em> detail::policy_holder&lt;&gt;<a class="headerlink" href="#_CPPv3N3hpx6launchE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;launch_policy.hpp&gt;</em><p>Launch policies for <em>hpx::async</em> etc. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx6launch6launchEv">
<span id="_CPPv2N3hpx6launch6launchEv"></span><span id="hpx::launch::launch"></span><span class="target" id="structhpx_1_1launch_1a3d36a8b0f33657ec03f7795692c94bc4"></span><code class="descname">launch</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx6launch6launchEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Default constructor. This creates a launch policy representing all possible launch modes </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Static Attributes</p>
<dl class="member">
<dt id="_CPPv3N3hpx6launch4forkE">
<span id="_CPPv2N3hpx6launch4forkE"></span><span id="hpx::launch::fork__detail::fork_policyC"></span><span class="target" id="structhpx_1_1launch_1aa02e7d34f6e84663a91b65f31e7264a3"></span><em class="property">const</em> detail::fork_policy <code class="descname">fork</code><a class="headerlink" href="#_CPPv3N3hpx6launch4forkE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Predefined launch policy representing asynchronous execution.The new thread is executed in a preferred way </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv3N3hpx6launch4syncE">
<span id="_CPPv2N3hpx6launch4syncE"></span><span id="hpx::launch::sync__detail::sync_policyC"></span><span class="target" id="structhpx_1_1launch_1a63234dfc5eb5ddbd51fe2d0de1ecfa3c"></span><em class="property">const</em> detail::sync_policy <code class="descname">sync</code><a class="headerlink" href="#_CPPv3N3hpx6launch4syncE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Predefined launch policy representing synchronous execution. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv3N3hpx6launch8deferredE">
<span id="_CPPv2N3hpx6launch8deferredE"></span><span id="hpx::launch::deferred__detail::deferred_policyC"></span><span class="target" id="structhpx_1_1launch_1a5f584d23f74552da911e2dcd527bf70c"></span><em class="property">const</em> detail::deferred_policy <code class="descname">deferred</code><a class="headerlink" href="#_CPPv3N3hpx6launch8deferredE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Predefined launch policy representing deferred execution. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv3N3hpx6launch5applyE">
<span id="_CPPv2N3hpx6launch5applyE"></span><span id="hpx::launch::apply__detail::apply_policyC"></span><span class="target" id="structhpx_1_1launch_1a6b5538fba9ce84786c7f6370181f5a2f"></span><em class="property">const</em> detail::apply_policy <code class="descname">apply</code><a class="headerlink" href="#_CPPv3N3hpx6launch5applyE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Predefined launch policy representing fire and forget execution. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv3N3hpx6launch6selectE">
<span id="_CPPv2N3hpx6launch6selectE"></span><span id="hpx::launch::select__detail::select_policy_generatorC"></span><span class="target" id="structhpx_1_1launch_1a906b265d955a3249a317706556da83cf"></span><em class="property">const</em> detail::select_policy_generator <code class="descname">select</code><a class="headerlink" href="#_CPPv3N3hpx6launch6selectE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Predefined launch policy representing delayed policy selection. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx8resource11numa_domainE">
<span id="_CPPv2N3hpx8resource11numa_domainE"></span><span id="hpx::resource::numa_domain"></span><span class="target" id="classhpx_1_1resource_1_1numa__domain"></span><em class="property">class </em><code class="descname">numa_domain</code><a class="headerlink" href="#_CPPv3N3hpx8resource11numa_domainE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;partitioner.hpp&gt;</em><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8resource11numa_domain11numa_domainENSt6size_tE">
<span id="_CPPv2N3hpx8resource11numa_domain11numa_domainENSt6size_tE"></span><span id="hpx::resource::numa_domain::numa_domain__std::s"></span><span class="target" id="classhpx_1_1resource_1_1numa__domain_1adcd381c136649d2ee2f9adfff0536288"></span><code class="descname">numa_domain</code><span class="sig-paren">(</span>std::size_t <em>id</em> = <a class="reference internal" href="#_CPPv3N3hpx8resource11numa_domain22invalid_numa_domain_idE" title="hpx::resource::numa_domain::invalid_numa_domain_id">invalid_numa_domain_id</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8resource11numa_domain11numa_domainENSt6size_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx8resource11numa_domain5coresEv">
<span id="_CPPv2NK3hpx8resource11numa_domain5coresEv"></span><span id="hpx::resource::numa_domain::coresC"></span><span class="target" id="classhpx_1_1resource_1_1numa__domain_1a887012d81bbcc7b8f993d23a56c073b6"></span>std::vector&lt;<a class="reference internal" href="#_CPPv3N3hpx8resource4coreE" title="hpx::resource::core">core</a>&gt; <em class="property">const</em> &amp;<code class="descname">cores</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8resource11numa_domain5coresEv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx8resource11numa_domain2idEv">
<span id="_CPPv2NK3hpx8resource11numa_domain2idEv"></span><span id="hpx::resource::numa_domain::idC"></span><span class="target" id="classhpx_1_1resource_1_1numa__domain_1a93254aa4367755d08f9d0da12283fb00"></span>std::size_t <code class="descname">id</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8resource11numa_domain2idEv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Members</p>
<dl class="member">
<dt id="_CPPv3N3hpx8resource11numa_domain3id_E">
<span id="_CPPv2N3hpx8resource11numa_domain3id_E"></span><span id="hpx::resource::numa_domain::id___std::s"></span><span class="target" id="classhpx_1_1resource_1_1numa__domain_1a9494fa169931eb0f94ada3d056dd8de8"></span>std::size_t <code class="descname">id_</code><a class="headerlink" href="#_CPPv3N3hpx8resource11numa_domain3id_E" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv3N3hpx8resource11numa_domain6cores_E">
<span id="_CPPv2N3hpx8resource11numa_domain6cores_E"></span><span id="hpx::resource::numa_domain::cores___std::vector:core:"></span><span class="target" id="classhpx_1_1resource_1_1numa__domain_1ad21b3d8db2e9c657d7a6c59f1fdb69ae"></span>std::vector&lt;<a class="reference internal" href="#_CPPv3N3hpx8resource4coreE" title="hpx::resource::core">core</a>&gt; <code class="descname">cores_</code><a class="headerlink" href="#_CPPv3N3hpx8resource11numa_domain6cores_E" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Static Attributes</p>
<dl class="member">
<dt id="_CPPv3N3hpx8resource11numa_domain22invalid_numa_domain_idE">
<span id="_CPPv2N3hpx8resource11numa_domain22invalid_numa_domain_idE"></span><span id="hpx::resource::numa_domain::invalid_numa_domain_id__std::sC"></span><span class="target" id="classhpx_1_1resource_1_1numa__domain_1af73bd91f3e3b5bd332781f1fa0a01eab"></span><em class="property">const</em> std::size_t <code class="descname">invalid_numa_domain_id</code><p>=</p>
<p>            std::size_t(-1)</p>
<a class="headerlink" href="#_CPPv3N3hpx8resource11numa_domain22invalid_numa_domain_idE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Friends</p>
<dl class="function">
<dt>
<span class="target" id="classhpx_1_1resource_1_1numa__domain_1a3d1082481a9a21aecb71d04b3fe4f657"></span><em class="property">friend </em><code class="descname">hpx::resource::numa_domain::pu</code></dt>
<dd></dd></dl>

<dl class="function">
<dt>
<span class="target" id="classhpx_1_1resource_1_1numa__domain_1af764561c544bacc1b90b526ee8d3c708"></span><em class="property">friend </em><code class="descname">hpx::resource::numa_domain::core</code></dt>
<dd></dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx8parallel9execution22parallel_execution_tagE">
<span id="_CPPv2N3hpx8parallel9execution22parallel_execution_tagE"></span><span id="hpx::parallel::execution::parallel_execution_tag"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__execution__tag"></span><em class="property">struct </em><code class="descname">parallel_execution_tag</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution22parallel_execution_tagE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;execution_fwd.hpp&gt;</em><p>Function invocations executed by a group of parallel execution agents execute in unordered fashion. Any such invocations executing in the same thread are indeterminately sequenced with respect to each other.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd><em><a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1parallel__execution__tag"><span class="std std-ref">parallel_execution_tag</span></a></em> is weaker than <em><a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1sequenced__execution__tag"><span class="std std-ref">sequenced_execution_tag</span></a></em>. </dd>
</dl>
</p>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx8parallel9execution15parallel_policyE">
<span id="_CPPv2N3hpx8parallel9execution15parallel_policyE"></span><span id="hpx::parallel::execution::parallel_policy"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__policy"></span><em class="property">struct </em><code class="descname">parallel_policy</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution15parallel_policyE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;execution_policy.hpp&gt;</em><p>The class <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1parallel__policy"><span class="std std-ref">parallel_policy</span></a> is an execution policy type used as a unique type to disambiguate parallel algorithm overloading and indicate that a parallel algorithm’s execution may be parallelized. </p>
<p>Subclassed by <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1parallel__policy__shim"><span class="std std-ref">hpx::parallel::execution::parallel_policy_shim&lt; Executor, Parameters &gt;</span></a></p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="type">
<dt id="_CPPv3N3hpx8parallel9execution15parallel_policy13executor_typeE">
<span id="_CPPv2N3hpx8parallel9execution15parallel_policy13executor_typeE"></span><span id="hpx::parallel::execution::parallel_policy::executor_type"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__policy_1a17c23b98baee010f403dca17e98b9a4c"></span><em class="property">typedef </em>parallel_executor <code class="descname">executor_type</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution15parallel_policy13executor_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The type of the executor associated with this execution policy. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx8parallel9execution15parallel_policy24executor_parameters_typeE">
<span id="_CPPv2N3hpx8parallel9execution15parallel_policy24executor_parameters_typeE"></span><span id="hpx::parallel::execution::parallel_policy::executor_parameters_type"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__policy_1a3e928d3001dee58d07354f0931d0f745"></span><em class="property">typedef </em><a class="reference internal" href="#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::extract_executor_parameters&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution15parallel_policy13executor_typeE" title="hpx::parallel::execution::parallel_policy::executor_type">executor_type</a>&gt;::type <code class="descname">executor_parameters_type</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution15parallel_policy24executor_parameters_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The type of the associated executor parameters object which is associated with this execution policy </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx8parallel9execution15parallel_policy18execution_categoryE">
<span id="_CPPv2N3hpx8parallel9execution15parallel_policy18execution_categoryE"></span><span id="hpx::parallel::execution::parallel_policy::execution_category"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__policy_1abd013afa8116b30fc30f9dc5e81832ab"></span><em class="property">typedef </em><a class="reference internal" href="#_CPPv3N3hpx8parallel9execution22parallel_execution_tagE" title="hpx::parallel::execution::parallel_execution_tag">parallel_execution_tag</a> <code class="descname">execution_category</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution15parallel_policy18execution_categoryE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The category of the execution agents created by this execution policy. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv3NK3hpx8parallel9execution15parallel_policyclE15task_policy_tag">
<span id="_CPPv2NK3hpx8parallel9execution15parallel_policyclE15task_policy_tag"></span><span id="hpx::parallel::execution::parallel_policy::call-operator__task_policy_tagC"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__policy_1af1125f2a33d8b14ff9af1ac91b8d14e5"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel9execution20parallel_task_policyE" title="hpx::parallel::execution::parallel_task_policy">parallel_task_policy</a> <code class="descname">operator()</code><span class="sig-paren">(</span>task_policy_tag<span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8parallel9execution15parallel_policyclE15task_policy_tag" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a new <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1parallel__policy"><span class="std std-ref">parallel_policy</span></a> referencing a chunk size.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The new <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1parallel__policy"><span class="std std-ref">parallel_policy</span></a> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tag</span></code>: [in] Specify that the corresponding asynchronous execution policy should be used</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx8parallel9execution15parallel_policy2onERR8Executor">
<span id="_CPPv2NK3hpx8parallel9execution15parallel_policy2onERR8Executor"></span><span id="hpx::parallel::execution::parallel_policy::on__ExecutorRRC"></span><em class="property">template </em>&lt;<em class="property">typename</em> Executor&gt;<br /><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__policy_1a60d4707ab6d8c849399c4c461a822ce0"></span>rebind_executor&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution15parallel_policyE" title="hpx::parallel::execution::parallel_policy">parallel_policy</a>, Executor, <a class="reference internal" href="#_CPPv3N3hpx8parallel9execution15parallel_policy24executor_parameters_typeE" title="hpx::parallel::execution::parallel_policy::executor_parameters_type">executor_parameters_type</a>&gt;::type <code class="descname">on</code><span class="sig-paren">(</span>Executor &amp;&amp;<em>exec</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8parallel9execution15parallel_policy2onERR8Executor" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a new <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1parallel__policy"><span class="std std-ref">parallel_policy</span></a> referencing an executor and a chunk size.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The new <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1parallel__policy"><span class="std std-ref">parallel_policy</span></a> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">exec</span></code>: [in] The executor to use for the execution of the parallel algorithm the returned execution policy is used with</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx8parallel9execution15parallel_policy4withEDpRR10Parameters">
<span id="_CPPv2NK3hpx8parallel9execution15parallel_policy4withEDpRR10Parameters"></span><span id="hpx::parallel::execution::parallel_policy::with__ParametersRRDpC"></span><em class="property">template </em>&lt;typename... <em>Parameters</em>, <em class="property">typename</em> ParametersType = typename executor_parameters_join&lt;Parameters...&gt;::type&gt;<br /><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__policy_1a2f8b0890678785a9a703a8621d7281ef"></span>rebind_executor&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution15parallel_policyE" title="hpx::parallel::execution::parallel_policy">parallel_policy</a>, <a class="reference internal" href="#_CPPv3N3hpx8parallel9execution15parallel_policy13executor_typeE" title="hpx::parallel::execution::parallel_policy::executor_type">executor_type</a>, ParametersType&gt;::type <code class="descname">with</code><span class="sig-paren">(</span>Parameters&amp;&amp;... <em>params</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8parallel9execution15parallel_policy4withEDpRR10Parameters" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a new <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1parallel__policy"><span class="std std-ref">parallel_policy</span></a> from the given execution parameters</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Requires: is_executor_parameters&lt;Parameters&gt;::value is true</dd>
<dt><strong>Return</strong></dt>
<dd>The new <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1parallel__policy"><span class="std std-ref">parallel_policy</span></a> </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">Parameters</span></code>: The type of the executor parameters to associate with this execution policy.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">params</span></code>: [in] The executor parameters to use for the execution of the parallel algorithm the returned execution policy is used with.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel9execution15parallel_policy8executorEv">
<span id="_CPPv2N3hpx8parallel9execution15parallel_policy8executorEv"></span><span id="hpx::parallel::execution::parallel_policy::executor"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__policy_1a847a50529e5862b881aa2532e7c4d02c"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel9execution15parallel_policy13executor_typeE" title="hpx::parallel::execution::parallel_policy::executor_type">executor_type</a> &amp;<code class="descname">executor</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution15parallel_policy8executorEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the associated executor object. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx8parallel9execution15parallel_policy8executorEv">
<span id="_CPPv2NK3hpx8parallel9execution15parallel_policy8executorEv"></span><span id="hpx::parallel::execution::parallel_policy::executorC"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__policy_1a613fad4b7e810f90bead041729c0af89"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel9execution15parallel_policy13executor_typeE" title="hpx::parallel::execution::parallel_policy::executor_type">executor_type</a> <em class="property">const</em> &amp;<code class="descname">executor</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8parallel9execution15parallel_policy8executorEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the associated executor object. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel9execution15parallel_policy10parametersEv">
<span id="_CPPv2N3hpx8parallel9execution15parallel_policy10parametersEv"></span><span id="hpx::parallel::execution::parallel_policy::parameters"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__policy_1aa18ca78a0feb9b9ce21fa53e9982cee4"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel9execution15parallel_policy24executor_parameters_typeE" title="hpx::parallel::execution::parallel_policy::executor_parameters_type">executor_parameters_type</a> &amp;<code class="descname">parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution15parallel_policy10parametersEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the associated executor parameters object. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx8parallel9execution15parallel_policy10parametersEv">
<span id="_CPPv2NK3hpx8parallel9execution15parallel_policy10parametersEv"></span><span id="hpx::parallel::execution::parallel_policy::parametersC"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__policy_1a0caee3dccaf25d8bd3d41c2b77dd7224"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel9execution15parallel_policy24executor_parameters_typeE" title="hpx::parallel::execution::parallel_policy::executor_parameters_type">executor_parameters_type</a> <em class="property">const</em> &amp;<code class="descname">parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8parallel9execution15parallel_policy10parametersEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the associated executor parameters object. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel9execution15parallel_policy9serializeER7ArchiveKj">
<span id="_CPPv2N3hpx8parallel9execution15parallel_policy9serializeER7ArchiveKj"></span><span id="hpx::parallel::execution::parallel_policy::serialize__ArchiveR.unsigned-iC"></span><em class="property">template </em>&lt;<em class="property">typename</em> Archive&gt;<br /><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__policy_1a710fa8afe6320d352db9d3933e384722"></span>void <code class="descname">serialize</code><span class="sig-paren">(</span>Archive &amp;<em>ar</em>, <em class="property">const</em> unsigned int <em>version</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution15parallel_policy9serializeER7ArchiveKj" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Members</p>
<dl class="member">
<dt id="_CPPv3N3hpx8parallel9execution15parallel_policy5exec_E">
<span id="_CPPv2N3hpx8parallel9execution15parallel_policy5exec_E"></span><span id="hpx::parallel::execution::parallel_policy::exec___executor_type"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__policy_1a6210864f97472f8c6a6e41dd477cb605"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel9execution15parallel_policy13executor_typeE" title="hpx::parallel::execution::parallel_policy::executor_type">executor_type</a> <code class="descname">exec_</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution15parallel_policy5exec_E" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv3N3hpx8parallel9execution15parallel_policy7params_E">
<span id="_CPPv2N3hpx8parallel9execution15parallel_policy7params_E"></span><span id="hpx::parallel::execution::parallel_policy::params___executor_parameters_type"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__policy_1a2af14e0631e6ecf07cc4e0dd07b87128"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel9execution15parallel_policy24executor_parameters_typeE" title="hpx::parallel::execution::parallel_policy::executor_parameters_type">executor_parameters_type</a> <code class="descname">params_</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution15parallel_policy7params_E" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Friends</p>
<dl class="function">
<dt>
<span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__policy_1add50dcae00a1300662d4d2f8c52c804f"></span><em class="property">friend </em><code class="descname">hpx::parallel::execution::parallel_policy::hpx::serialization::access</code></dt>
<dd></dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx8parallel9execution24parallel_policy_executorE">
<span id="_CPPv2N3hpx8parallel9execution24parallel_policy_executorE"></span><span id="hpx::parallel::execution::parallel_policy_executor"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__policy__executor"></span><em class="property">template </em>&lt;<em class="property">typename</em> Policy&gt;<br /><em class="property">struct </em><code class="descname">parallel_policy_executor</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution24parallel_policy_executorE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;parallel_executor.hpp&gt;</em><p>A <em>parallel_executor</em> creates groups of parallel execution agents which execute in threads implicitly created by the executor. This executor prefers continuing with the creating thread first before executing newly created threads.</p>
<p>This executor conforms to the concepts of a TwoWayExecutor, and a BulkTwoWayExecutor </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="type">
<dt id="_CPPv3N3hpx8parallel9execution24parallel_policy_executor18execution_categoryE">
<span id="_CPPv2N3hpx8parallel9execution24parallel_policy_executor18execution_categoryE"></span><span id="hpx::parallel::execution::parallel_policy_executor::execution_category"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__policy__executor_1a8de8e041bdfef63e5a0b41e58eec88dd"></span><em class="property">typedef </em><a class="reference internal" href="#_CPPv3N3hpx8parallel9execution22parallel_execution_tagE" title="hpx::parallel::execution::parallel_execution_tag">parallel_execution_tag</a> <code class="descname">execution_category</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution24parallel_policy_executor18execution_categoryE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Associate the <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1parallel__execution__tag"><span class="std std-ref">parallel_execution_tag</span></a> executor tag type as a default with this executor. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx8parallel9execution24parallel_policy_executor24executor_parameters_typeE">
<span id="_CPPv2N3hpx8parallel9execution24parallel_policy_executor24executor_parameters_typeE"></span><span id="hpx::parallel::execution::parallel_policy_executor::executor_parameters_type"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__policy__executor_1a4853e21889c7df310a9566c629d37493"></span><em class="property">typedef </em><a class="reference internal" href="#_CPPv3N3hpx8parallel9execution17static_chunk_sizeE" title="hpx::parallel::execution::static_chunk_size">static_chunk_size</a> <code class="descname">executor_parameters_type</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution24parallel_policy_executor24executor_parameters_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Associate the <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1static__chunk__size"><span class="std std-ref">static_chunk_size</span></a> executor parameters type as a default with this executor. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel9execution24parallel_policy_executor24parallel_policy_executorE6PolicyNSt6size_tENSt6size_tE">
<span id="_CPPv2N3hpx8parallel9execution24parallel_policy_executor24parallel_policy_executorE6PolicyNSt6size_tENSt6size_tE"></span><span id="hpx::parallel::execution::parallel_policy_executor::parallel_policy_executor__Policy.std::s.std::s"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__policy__executor_1adc938640f426a571da7ae35314be0d5b"></span><code class="descname">parallel_policy_executor</code><span class="sig-paren">(</span>Policy <em>l</em> = detail::get_default_policy&lt;Policy&gt;::call(), std::size_t <em>spread</em> = 4, std::size_t <em>tasks</em> = std::size_t(-1)<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution24parallel_policy_executor24parallel_policy_executorE6PolicyNSt6size_tENSt6size_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a new parallel executor. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx8parallel9execution20parallel_policy_shimE">
<span id="_CPPv2N3hpx8parallel9execution20parallel_policy_shimE"></span><span id="hpx::parallel::execution::parallel_policy_shim"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__policy__shim"></span><em class="property">template </em>&lt;<em class="property">typename</em> Executor, <em class="property">typename</em> Parameters&gt;<br /><em class="property">struct </em><code class="descname">parallel_policy_shim</code> : <em class="property">public</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx8parallelE" title="hpx::parallel">parallel</a>::<a class="reference internal" href="#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution15parallel_policyE" title="hpx::parallel::execution::parallel_policy">parallel_policy</a><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution20parallel_policy_shimE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;execution_policy.hpp&gt;</em><p>The class <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1parallel__policy__shim"><span class="std std-ref">parallel_policy_shim</span></a> is an execution policy type used as a unique type to disambiguate parallel algorithm overloading and indicate that a parallel algorithm’s execution may be parallelized. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="type">
<dt id="_CPPv3N3hpx8parallel9execution20parallel_policy_shim13executor_typeE">
<span id="_CPPv2N3hpx8parallel9execution20parallel_policy_shim13executor_typeE"></span><span id="hpx::parallel::execution::parallel_policy_shim::executor_type"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__policy__shim_1a701c83fdd6bd40f8a767088a0187d02e"></span><em class="property">typedef </em>Executor <code class="descname">executor_type</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution20parallel_policy_shim13executor_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The type of the executor associated with this execution policy. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx8parallel9execution20parallel_policy_shim24executor_parameters_typeE">
<span id="_CPPv2N3hpx8parallel9execution20parallel_policy_shim24executor_parameters_typeE"></span><span id="hpx::parallel::execution::parallel_policy_shim::executor_parameters_type"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__policy__shim_1afb7cf15ebec84874ec767b3f205dd4ba"></span><em class="property">typedef </em>Parameters <code class="descname">executor_parameters_type</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution20parallel_policy_shim24executor_parameters_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The type of the associated executor parameters object which is associated with this execution policy </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx8parallel9execution20parallel_policy_shim18execution_categoryE">
<span id="_CPPv2N3hpx8parallel9execution20parallel_policy_shim18execution_categoryE"></span><span id="hpx::parallel::execution::parallel_policy_shim::execution_category"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__policy__shim_1a662d093e1588987a35508a9c2a470df3"></span><em class="property">typedef </em><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::executor_execution_category&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution20parallel_policy_shim13executor_typeE" title="hpx::parallel::execution::parallel_policy_shim::executor_type">executor_type</a>&gt;::type <code class="descname">execution_category</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution20parallel_policy_shim18execution_categoryE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The category of the execution agents created by this execution policy. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv3NK3hpx8parallel9execution20parallel_policy_shimclE15task_policy_tag">
<span id="_CPPv2NK3hpx8parallel9execution20parallel_policy_shimclE15task_policy_tag"></span><span id="hpx::parallel::execution::parallel_policy_shim::call-operator__task_policy_tagC"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__policy__shim_1a3b7db9afe9d42b131e662174a9bc6cfe"></span>parallel_task_policy_shim&lt;Executor, Parameters&gt; <code class="descname">operator()</code><span class="sig-paren">(</span>task_policy_tag <em>tag</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8parallel9execution20parallel_policy_shimclE15task_policy_tag" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a new <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1parallel__policy"><span class="std std-ref">parallel_policy</span></a> referencing a chunk size.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The new <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1parallel__policy"><span class="std std-ref">parallel_policy</span></a> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tag</span></code>: [in] Specify that the corresponding asynchronous execution policy should be used</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx8parallel9execution20parallel_policy_shim2onERR9Executor_">
<span id="_CPPv2NK3hpx8parallel9execution20parallel_policy_shim2onERR9Executor_"></span><span id="hpx::parallel::execution::parallel_policy_shim::on__Executor_RRC"></span><em class="property">template </em>&lt;<em class="property">typename</em> Executor_&gt;<br /><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__policy__shim_1a2dac3993838f19d501ab00fa44f790f9"></span>rebind_executor&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution20parallel_policy_shimE" title="hpx::parallel::execution::parallel_policy_shim">parallel_policy_shim</a>, Executor_, <a class="reference internal" href="#_CPPv3N3hpx8parallel9execution20parallel_policy_shim24executor_parameters_typeE" title="hpx::parallel::execution::parallel_policy_shim::executor_parameters_type">executor_parameters_type</a>&gt;::type <code class="descname">on</code><span class="sig-paren">(</span>Executor_ &amp;&amp;<em>exec</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8parallel9execution20parallel_policy_shim2onERR9Executor_" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a new <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1parallel__policy"><span class="std std-ref">parallel_policy</span></a> from the given executor</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Requires: is_executor&lt;Executor&gt;::value is true</dd>
<dt><strong>Return</strong></dt>
<dd>The new <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1parallel__policy"><span class="std std-ref">parallel_policy</span></a> </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">Executor</span></code>: The type of the executor to associate with this execution policy.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">exec</span></code>: [in] The executor to use for the execution of the parallel algorithm the returned execution policy is used with.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx8parallel9execution20parallel_policy_shim4withEDpRR11Parameters_">
<span id="_CPPv2NK3hpx8parallel9execution20parallel_policy_shim4withEDpRR11Parameters_"></span><span id="hpx::parallel::execution::parallel_policy_shim::with__Parameters_RRDpC"></span><em class="property">template </em>&lt;typename... <em>Parameters_</em>, <em class="property">typename</em> ParametersType = typename executor_parameters_join&lt;Parameters_...&gt;::type&gt;<br /><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__policy__shim_1aacb6e2701701b6cd36fb733df058a903"></span>rebind_executor&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution20parallel_policy_shimE" title="hpx::parallel::execution::parallel_policy_shim">parallel_policy_shim</a>, <a class="reference internal" href="#_CPPv3N3hpx8parallel9execution20parallel_policy_shim13executor_typeE" title="hpx::parallel::execution::parallel_policy_shim::executor_type">executor_type</a>, ParametersType&gt;::type <code class="descname">with</code><span class="sig-paren">(</span>Parameters_&amp;&amp;... <em>params</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8parallel9execution20parallel_policy_shim4withEDpRR11Parameters_" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a new <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1parallel__policy__shim"><span class="std std-ref">parallel_policy_shim</span></a> from the given execution parameters</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Requires: is_executor_parameters&lt;Parameters&gt;::value is true</dd>
<dt><strong>Return</strong></dt>
<dd>The new <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1parallel__policy__shim"><span class="std std-ref">parallel_policy_shim</span></a> </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">Parameters</span></code>: The type of the executor parameters to associate with this execution policy.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">params</span></code>: [in] The executor parameters to use for the execution of the parallel algorithm the returned execution policy is used with.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel9execution20parallel_policy_shim8executorEv">
<span id="_CPPv2N3hpx8parallel9execution20parallel_policy_shim8executorEv"></span><span id="hpx::parallel::execution::parallel_policy_shim::executor"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__policy__shim_1aa8c344a9417f65f8e92f7c85bd8fe7b2"></span>Executor &amp;<code class="descname">executor</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution20parallel_policy_shim8executorEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the associated executor object. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx8parallel9execution20parallel_policy_shim8executorEv">
<span id="_CPPv2NK3hpx8parallel9execution20parallel_policy_shim8executorEv"></span><span id="hpx::parallel::execution::parallel_policy_shim::executorC"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__policy__shim_1a45116988ab7e65c405b88951a10d1361"></span>Executor <em class="property">const</em> &amp;<code class="descname">executor</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8parallel9execution20parallel_policy_shim8executorEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the associated executor object. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel9execution20parallel_policy_shim10parametersEv">
<span id="_CPPv2N3hpx8parallel9execution20parallel_policy_shim10parametersEv"></span><span id="hpx::parallel::execution::parallel_policy_shim::parameters"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__policy__shim_1a26145c923d468fae4413488d1f111090"></span>Parameters &amp;<code class="descname">parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution20parallel_policy_shim10parametersEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the associated executor parameters object. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx8parallel9execution20parallel_policy_shim10parametersEv">
<span id="_CPPv2NK3hpx8parallel9execution20parallel_policy_shim10parametersEv"></span><span id="hpx::parallel::execution::parallel_policy_shim::parametersC"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__policy__shim_1abbe0621435fb6a55d476cce533f06b5c"></span>Parameters <em class="property">const</em> &amp;<code class="descname">parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8parallel9execution20parallel_policy_shim10parametersEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the associated executor parameters object. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx8parallel9execution20parallel_task_policyE">
<span id="_CPPv2N3hpx8parallel9execution20parallel_task_policyE"></span><span id="hpx::parallel::execution::parallel_task_policy"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__task__policy"></span><em class="property">struct </em><code class="descname">parallel_task_policy</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution20parallel_task_policyE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;execution_policy.hpp&gt;</em><p>Extension: The class <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1parallel__task__policy"><span class="std std-ref">parallel_task_policy</span></a> is an execution policy type used as a unique type to disambiguate parallel algorithm overloading and indicate that a parallel algorithm’s execution may be parallelized.</p>
<p>The algorithm returns a future representing the result of the corresponding algorithm when invoked with the <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1parallel__policy"><span class="std std-ref">parallel_policy</span></a>. </p>
<p>Subclassed by <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1parallel__task__policy__shim"><span class="std std-ref">hpx::parallel::execution::parallel_task_policy_shim&lt; Executor, Parameters &gt;</span></a></p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="type">
<dt id="_CPPv3N3hpx8parallel9execution20parallel_task_policy13executor_typeE">
<span id="_CPPv2N3hpx8parallel9execution20parallel_task_policy13executor_typeE"></span><span id="hpx::parallel::execution::parallel_task_policy::executor_type"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__task__policy_1a90a8f363f5525953e01265259f44cfc8"></span><em class="property">typedef </em>parallel_executor <code class="descname">executor_type</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution20parallel_task_policy13executor_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The type of the executor associated with this execution policy. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx8parallel9execution20parallel_task_policy24executor_parameters_typeE">
<span id="_CPPv2N3hpx8parallel9execution20parallel_task_policy24executor_parameters_typeE"></span><span id="hpx::parallel::execution::parallel_task_policy::executor_parameters_type"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__task__policy_1a400679ed2f2a71816e6830353c984893"></span><em class="property">typedef </em><a class="reference internal" href="#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::extract_executor_parameters&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution20parallel_task_policy13executor_typeE" title="hpx::parallel::execution::parallel_task_policy::executor_type">executor_type</a>&gt;::type <code class="descname">executor_parameters_type</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution20parallel_task_policy24executor_parameters_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The type of the associated executor parameters object which is associated with this execution policy </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx8parallel9execution20parallel_task_policy18execution_categoryE">
<span id="_CPPv2N3hpx8parallel9execution20parallel_task_policy18execution_categoryE"></span><span id="hpx::parallel::execution::parallel_task_policy::execution_category"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__task__policy_1a070a4b7d80ef286409fd8e8660e50e77"></span><em class="property">typedef </em><a class="reference internal" href="#_CPPv3N3hpx8parallel9execution22parallel_execution_tagE" title="hpx::parallel::execution::parallel_execution_tag">parallel_execution_tag</a> <code class="descname">execution_category</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution20parallel_task_policy18execution_categoryE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The category of the execution agents created by this execution policy. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv3NK3hpx8parallel9execution20parallel_task_policyclE15task_policy_tag">
<span id="_CPPv2NK3hpx8parallel9execution20parallel_task_policyclE15task_policy_tag"></span><span id="hpx::parallel::execution::parallel_task_policy::call-operator__task_policy_tagC"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__task__policy_1af7a3416616c98e17b7722f792b3ab5e9"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel9execution20parallel_task_policyE" title="hpx::parallel::execution::parallel_task_policy">parallel_task_policy</a> <code class="descname">operator()</code><span class="sig-paren">(</span>task_policy_tag<span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8parallel9execution20parallel_task_policyclE15task_policy_tag" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a new <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1parallel__task__policy"><span class="std std-ref">parallel_task_policy</span></a> from itself</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The new <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1parallel__task__policy"><span class="std std-ref">parallel_task_policy</span></a> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tag</span></code>: [in] Specify that the corresponding asynchronous execution policy should be used</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx8parallel9execution20parallel_task_policy2onERR8Executor">
<span id="_CPPv2NK3hpx8parallel9execution20parallel_task_policy2onERR8Executor"></span><span id="hpx::parallel::execution::parallel_task_policy::on__ExecutorRRC"></span><em class="property">template </em>&lt;<em class="property">typename</em> Executor&gt;<br /><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__task__policy_1a0cb10e7de3382338815d253e4fec1171"></span>rebind_executor&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution20parallel_task_policyE" title="hpx::parallel::execution::parallel_task_policy">parallel_task_policy</a>, Executor, <a class="reference internal" href="#_CPPv3N3hpx8parallel9execution20parallel_task_policy24executor_parameters_typeE" title="hpx::parallel::execution::parallel_task_policy::executor_parameters_type">executor_parameters_type</a>&gt;::type <code class="descname">on</code><span class="sig-paren">(</span>Executor &amp;&amp;<em>exec</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8parallel9execution20parallel_task_policy2onERR8Executor" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a new <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1parallel__task__policy"><span class="std std-ref">parallel_task_policy</span></a> from given executor</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Requires: is_executor&lt;Executor&gt;::value is true</dd>
<dt><strong>Return</strong></dt>
<dd>The new <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1parallel__task__policy"><span class="std std-ref">parallel_task_policy</span></a> </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">Executor</span></code>: The type of the executor to associate with this execution policy.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">exec</span></code>: [in] The executor to use for the execution of the parallel algorithm the returned execution policy is used with.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx8parallel9execution20parallel_task_policy4withEDpRR10Parameters">
<span id="_CPPv2NK3hpx8parallel9execution20parallel_task_policy4withEDpRR10Parameters"></span><span id="hpx::parallel::execution::parallel_task_policy::with__ParametersRRDpC"></span><em class="property">template </em>&lt;typename... <em>Parameters</em>, <em class="property">typename</em> ParametersType = typename executor_parameters_join&lt;Parameters...&gt;::type&gt;<br /><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__task__policy_1ad70edb446851d421e09f3bda6cea2a44"></span>rebind_executor&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution20parallel_task_policyE" title="hpx::parallel::execution::parallel_task_policy">parallel_task_policy</a>, <a class="reference internal" href="#_CPPv3N3hpx8parallel9execution20parallel_task_policy13executor_typeE" title="hpx::parallel::execution::parallel_task_policy::executor_type">executor_type</a>, ParametersType&gt;::type <code class="descname">with</code><span class="sig-paren">(</span>Parameters&amp;&amp;... <em>params</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8parallel9execution20parallel_task_policy4withEDpRR10Parameters" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a new <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1parallel__policy__shim"><span class="std std-ref">parallel_policy_shim</span></a> from the given execution parameters</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Requires: all parameters are executor_parameters, different parameter types can’t be duplicated</dd>
<dt><strong>Return</strong></dt>
<dd>The new <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1parallel__policy__shim"><span class="std std-ref">parallel_policy_shim</span></a> </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">Parameters</span></code>: The type of the executor parameters to associate with this execution policy.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">params</span></code>: [in] The executor parameters to use for the execution of the parallel algorithm the returned execution policy is used with.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel9execution20parallel_task_policy8executorEv">
<span id="_CPPv2N3hpx8parallel9execution20parallel_task_policy8executorEv"></span><span id="hpx::parallel::execution::parallel_task_policy::executor"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__task__policy_1ab2fa7e8f12eb1cf3cf72c4140f7b3f81"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel9execution20parallel_task_policy13executor_typeE" title="hpx::parallel::execution::parallel_task_policy::executor_type">executor_type</a> &amp;<code class="descname">executor</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution20parallel_task_policy8executorEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the associated executor object. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx8parallel9execution20parallel_task_policy8executorEv">
<span id="_CPPv2NK3hpx8parallel9execution20parallel_task_policy8executorEv"></span><span id="hpx::parallel::execution::parallel_task_policy::executorC"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__task__policy_1acb665040c7b290f7a89f9812dca8d170"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel9execution20parallel_task_policy13executor_typeE" title="hpx::parallel::execution::parallel_task_policy::executor_type">executor_type</a> <em class="property">const</em> &amp;<code class="descname">executor</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8parallel9execution20parallel_task_policy8executorEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the associated executor object. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel9execution20parallel_task_policy10parametersEv">
<span id="_CPPv2N3hpx8parallel9execution20parallel_task_policy10parametersEv"></span><span id="hpx::parallel::execution::parallel_task_policy::parameters"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__task__policy_1a78c7f25d5f65dd76b4656ff3ebf25135"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel9execution20parallel_task_policy24executor_parameters_typeE" title="hpx::parallel::execution::parallel_task_policy::executor_parameters_type">executor_parameters_type</a> &amp;<code class="descname">parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution20parallel_task_policy10parametersEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the associated executor parameters object. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx8parallel9execution20parallel_task_policy10parametersEv">
<span id="_CPPv2NK3hpx8parallel9execution20parallel_task_policy10parametersEv"></span><span id="hpx::parallel::execution::parallel_task_policy::parametersC"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__task__policy_1a816eafc81e922f1920b0c11ad0cebfa5"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel9execution20parallel_task_policy24executor_parameters_typeE" title="hpx::parallel::execution::parallel_task_policy::executor_parameters_type">executor_parameters_type</a> <em class="property">const</em> &amp;<code class="descname">parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8parallel9execution20parallel_task_policy10parametersEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the associated executor parameters object. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel9execution20parallel_task_policy9serializeER7ArchiveKj">
<span id="_CPPv2N3hpx8parallel9execution20parallel_task_policy9serializeER7ArchiveKj"></span><span id="hpx::parallel::execution::parallel_task_policy::serialize__ArchiveR.unsigned-iC"></span><em class="property">template </em>&lt;<em class="property">typename</em> Archive&gt;<br /><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__task__policy_1ac07aa4f080f8a3723b541042f5cf3e9f"></span>void <code class="descname">serialize</code><span class="sig-paren">(</span>Archive &amp;<em>ar</em>, <em class="property">const</em> unsigned int <em>version</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution20parallel_task_policy9serializeER7ArchiveKj" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Members</p>
<dl class="member">
<dt id="_CPPv3N3hpx8parallel9execution20parallel_task_policy5exec_E">
<span id="_CPPv2N3hpx8parallel9execution20parallel_task_policy5exec_E"></span><span id="hpx::parallel::execution::parallel_task_policy::exec___executor_type"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__task__policy_1a951743c13bccc30151719f93c8fb235a"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel9execution20parallel_task_policy13executor_typeE" title="hpx::parallel::execution::parallel_task_policy::executor_type">executor_type</a> <code class="descname">exec_</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution20parallel_task_policy5exec_E" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv3N3hpx8parallel9execution20parallel_task_policy7params_E">
<span id="_CPPv2N3hpx8parallel9execution20parallel_task_policy7params_E"></span><span id="hpx::parallel::execution::parallel_task_policy::params___executor_parameters_type"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__task__policy_1afceb87f22b3b4ef9d0cdbc8664ca1eca"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel9execution20parallel_task_policy24executor_parameters_typeE" title="hpx::parallel::execution::parallel_task_policy::executor_parameters_type">executor_parameters_type</a> <code class="descname">params_</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution20parallel_task_policy7params_E" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Friends</p>
<dl class="function">
<dt>
<span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__task__policy_1add50dcae00a1300662d4d2f8c52c804f"></span><em class="property">friend </em><code class="descname">hpx::parallel::execution::parallel_task_policy::hpx::serialization::access</code></dt>
<dd></dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx8parallel9execution25parallel_task_policy_shimE">
<span id="_CPPv2N3hpx8parallel9execution25parallel_task_policy_shimE"></span><span id="hpx::parallel::execution::parallel_task_policy_shim"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__task__policy__shim"></span><em class="property">template </em>&lt;typename <em>Executor</em>, typename <em>Parameters</em>&gt;<br /><em class="property">struct </em><code class="descname">parallel_task_policy_shim</code> : <em class="property">public</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx8parallelE" title="hpx::parallel">parallel</a>::<a class="reference internal" href="#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution20parallel_task_policyE" title="hpx::parallel::execution::parallel_task_policy">parallel_task_policy</a><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution25parallel_task_policy_shimE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;execution_policy.hpp&gt;</em><p>Extension: The class <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1parallel__task__policy__shim"><span class="std std-ref">parallel_task_policy_shim</span></a> is an execution policy type used as a unique type to disambiguate parallel algorithm overloading based on combining a underlying <em><a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1parallel__task__policy"><span class="std std-ref">parallel_task_policy</span></a></em> and an executor and indicate that a parallel algorithm’s execution may be parallelized. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="type">
<dt id="_CPPv3N3hpx8parallel9execution25parallel_task_policy_shim13executor_typeE">
<span id="_CPPv2N3hpx8parallel9execution25parallel_task_policy_shim13executor_typeE"></span><span id="hpx::parallel::execution::parallel_task_policy_shim::executor_type"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__task__policy__shim_1affd09ea98cdb9db36df7c32090b29ecc"></span><em class="property">typedef </em>Executor <code class="descname">executor_type</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution25parallel_task_policy_shim13executor_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The type of the executor associated with this execution policy. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx8parallel9execution25parallel_task_policy_shim24executor_parameters_typeE">
<span id="_CPPv2N3hpx8parallel9execution25parallel_task_policy_shim24executor_parameters_typeE"></span><span id="hpx::parallel::execution::parallel_task_policy_shim::executor_parameters_type"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__task__policy__shim_1acbe35501b08c6d67eb1810d1ed8c7ed3"></span><em class="property">typedef </em>Parameters <code class="descname">executor_parameters_type</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution25parallel_task_policy_shim24executor_parameters_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The type of the associated executor parameters object which is associated with this execution policy </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx8parallel9execution25parallel_task_policy_shim18execution_categoryE">
<span id="_CPPv2N3hpx8parallel9execution25parallel_task_policy_shim18execution_categoryE"></span><span id="hpx::parallel::execution::parallel_task_policy_shim::execution_category"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__task__policy__shim_1a71e4e6dae2ff35e2bcc6f4d092d7ef70"></span><em class="property">typedef </em><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::executor_execution_category&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution25parallel_task_policy_shim13executor_typeE" title="hpx::parallel::execution::parallel_task_policy_shim::executor_type">executor_type</a>&gt;::type <code class="descname">execution_category</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution25parallel_task_policy_shim18execution_categoryE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The category of the execution agents created by this execution policy. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv3NK3hpx8parallel9execution25parallel_task_policy_shimclE15task_policy_tag">
<span id="_CPPv2NK3hpx8parallel9execution25parallel_task_policy_shimclE15task_policy_tag"></span><span id="hpx::parallel::execution::parallel_task_policy_shim::call-operator__task_policy_tagC"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__task__policy__shim_1a3d8a353599d91c8555770cdee7f3a1ec"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel9execution25parallel_task_policy_shimE" title="hpx::parallel::execution::parallel_task_policy_shim">parallel_task_policy_shim</a> <code class="descname">operator()</code><span class="sig-paren">(</span>task_policy_tag <em>tag</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8parallel9execution25parallel_task_policy_shimclE15task_policy_tag" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a new <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1parallel__task__policy__shim"><span class="std std-ref">parallel_task_policy_shim</span></a> from itself</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The new <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy"><span class="std std-ref">sequenced_task_policy</span></a> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tag</span></code>: [in] Specify that the corresponding asynchronous execution policy should be used</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx8parallel9execution25parallel_task_policy_shim2onERR9Executor_">
<span id="_CPPv2NK3hpx8parallel9execution25parallel_task_policy_shim2onERR9Executor_"></span><span id="hpx::parallel::execution::parallel_task_policy_shim::on__Executor_RRC"></span><em class="property">template </em>&lt;<em class="property">typename</em> Executor_&gt;<br /><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__task__policy__shim_1ac37a909bbf3f4b436b760d66284ece59"></span>rebind_executor&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution25parallel_task_policy_shimE" title="hpx::parallel::execution::parallel_task_policy_shim">parallel_task_policy_shim</a>, Executor_, <a class="reference internal" href="#_CPPv3N3hpx8parallel9execution25parallel_task_policy_shim24executor_parameters_typeE" title="hpx::parallel::execution::parallel_task_policy_shim::executor_parameters_type">executor_parameters_type</a>&gt;::type <code class="descname">on</code><span class="sig-paren">(</span>Executor_ &amp;&amp;<em>exec</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8parallel9execution25parallel_task_policy_shim2onERR9Executor_" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a new <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1parallel__task__policy"><span class="std std-ref">parallel_task_policy</span></a> from the given executor</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Requires: is_executor&lt;Executor&gt;::value is true</dd>
<dt><strong>Return</strong></dt>
<dd>The new <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1parallel__task__policy"><span class="std std-ref">parallel_task_policy</span></a> </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">Executor</span></code>: The type of the executor to associate with this execution policy.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">exec</span></code>: [in] The executor to use for the execution of the parallel algorithm the returned execution policy is used with.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx8parallel9execution25parallel_task_policy_shim4withEDpRR11Parameters_">
<span id="_CPPv2NK3hpx8parallel9execution25parallel_task_policy_shim4withEDpRR11Parameters_"></span><span id="hpx::parallel::execution::parallel_task_policy_shim::with__Parameters_RRDpC"></span><em class="property">template </em>&lt;typename... <em>Parameters_</em>, <em class="property">typename</em> ParametersType = typename executor_parameters_join&lt;Parameters_...&gt;::type&gt;<br /><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__task__policy__shim_1a22c0ba38c949757c635b9b7b727e785a"></span>rebind_executor&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution25parallel_task_policy_shimE" title="hpx::parallel::execution::parallel_task_policy_shim">parallel_task_policy_shim</a>, <a class="reference internal" href="#_CPPv3N3hpx8parallel9execution25parallel_task_policy_shim13executor_typeE" title="hpx::parallel::execution::parallel_task_policy_shim::executor_type">executor_type</a>, ParametersType&gt;::type <code class="descname">with</code><span class="sig-paren">(</span>Parameters_&amp;&amp;... <em>params</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8parallel9execution25parallel_task_policy_shim4withEDpRR11Parameters_" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a new <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1parallel__policy__shim"><span class="std std-ref">parallel_policy_shim</span></a> from the given execution parameters</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Requires: all parameters are executor_parameters, different parameter types can’t be duplicated</dd>
<dt><strong>Return</strong></dt>
<dd>The new <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1parallel__policy__shim"><span class="std std-ref">parallel_policy_shim</span></a> </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">Parameters</span></code>: The type of the executor parameters to associate with this execution policy.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">params</span></code>: [in] The executor parameters to use for the execution of the parallel algorithm the returned execution policy is used with.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel9execution25parallel_task_policy_shim8executorEv">
<span id="_CPPv2N3hpx8parallel9execution25parallel_task_policy_shim8executorEv"></span><span id="hpx::parallel::execution::parallel_task_policy_shim::executor"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__task__policy__shim_1aa99735d7c9cf874b3c22f9d83c39b4ea"></span>Executor &amp;<code class="descname">executor</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution25parallel_task_policy_shim8executorEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the associated executor object. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx8parallel9execution25parallel_task_policy_shim8executorEv">
<span id="_CPPv2NK3hpx8parallel9execution25parallel_task_policy_shim8executorEv"></span><span id="hpx::parallel::execution::parallel_task_policy_shim::executorC"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__task__policy__shim_1a89a4b57719105aaee84d344e846c12fe"></span>Executor <em class="property">const</em> &amp;<code class="descname">executor</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8parallel9execution25parallel_task_policy_shim8executorEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the associated executor object. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel9execution25parallel_task_policy_shim10parametersEv">
<span id="_CPPv2N3hpx8parallel9execution25parallel_task_policy_shim10parametersEv"></span><span id="hpx::parallel::execution::parallel_task_policy_shim::parameters"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__task__policy__shim_1a29c6ed93d5e2149603b618d5e1ed76ff"></span>Parameters &amp;<code class="descname">parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution25parallel_task_policy_shim10parametersEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the associated executor parameters object. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx8parallel9execution25parallel_task_policy_shim10parametersEv">
<span id="_CPPv2NK3hpx8parallel9execution25parallel_task_policy_shim10parametersEv"></span><span id="hpx::parallel::execution::parallel_task_policy_shim::parametersC"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__task__policy__shim_1a32ee4a0274ce141c93656b3ccaef0c48"></span>Parameters <em class="property">const</em> &amp;<code class="descname">parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8parallel9execution25parallel_task_policy_shim10parametersEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the associated executor parameters object. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx8parallel9execution27parallel_unsequenced_policyE">
<span id="_CPPv2N3hpx8parallel9execution27parallel_unsequenced_policyE"></span><span id="hpx::parallel::execution::parallel_unsequenced_policy"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__unsequenced__policy"></span><em class="property">struct </em><code class="descname">parallel_unsequenced_policy</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution27parallel_unsequenced_policyE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;execution_policy.hpp&gt;</em><p>The class <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1parallel__unsequenced__policy"><span class="std std-ref">parallel_unsequenced_policy</span></a> is an execution policy type used as a unique type to disambiguate parallel algorithm overloading and indicate that a parallel algorithm’s execution may be vectorized. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="type">
<dt id="_CPPv3N3hpx8parallel9execution27parallel_unsequenced_policy13executor_typeE">
<span id="_CPPv2N3hpx8parallel9execution27parallel_unsequenced_policy13executor_typeE"></span><span id="hpx::parallel::execution::parallel_unsequenced_policy::executor_type"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__unsequenced__policy_1aa15af9504780fd48d441859ebc7dc9e4"></span><em class="property">typedef </em>parallel_executor <code class="descname">executor_type</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution27parallel_unsequenced_policy13executor_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The type of the executor associated with this execution policy. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx8parallel9execution27parallel_unsequenced_policy24executor_parameters_typeE">
<span id="_CPPv2N3hpx8parallel9execution27parallel_unsequenced_policy24executor_parameters_typeE"></span><span id="hpx::parallel::execution::parallel_unsequenced_policy::executor_parameters_type"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__unsequenced__policy_1a85cef287a4961013a15722a37722a1af"></span><em class="property">typedef </em><a class="reference internal" href="#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::extract_executor_parameters&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution27parallel_unsequenced_policy13executor_typeE" title="hpx::parallel::execution::parallel_unsequenced_policy::executor_type">executor_type</a>&gt;::type <code class="descname">executor_parameters_type</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution27parallel_unsequenced_policy24executor_parameters_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The type of the associated executor parameters object which is associated with this execution policy </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx8parallel9execution27parallel_unsequenced_policy18execution_categoryE">
<span id="_CPPv2N3hpx8parallel9execution27parallel_unsequenced_policy18execution_categoryE"></span><span id="hpx::parallel::execution::parallel_unsequenced_policy::execution_category"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__unsequenced__policy_1a6889e83333c46f04009b1e5dcd1a73ed"></span><em class="property">typedef </em><a class="reference internal" href="#_CPPv3N3hpx8parallel9execution22parallel_execution_tagE" title="hpx::parallel::execution::parallel_execution_tag">parallel_execution_tag</a> <code class="descname">execution_category</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution27parallel_unsequenced_policy18execution_categoryE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The category of the execution agents created by this execution policy. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv3NK3hpx8parallel9execution27parallel_unsequenced_policyclE15task_policy_tag">
<span id="_CPPv2NK3hpx8parallel9execution27parallel_unsequenced_policyclE15task_policy_tag"></span><span id="hpx::parallel::execution::parallel_unsequenced_policy::call-operator__task_policy_tagC"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__unsequenced__policy_1a066897c8902814fd7cfd43dd46b082ff"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel9execution27parallel_unsequenced_policyE" title="hpx::parallel::execution::parallel_unsequenced_policy">parallel_unsequenced_policy</a> <code class="descname">operator()</code><span class="sig-paren">(</span>task_policy_tag<span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8parallel9execution27parallel_unsequenced_policyclE15task_policy_tag" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a new <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1parallel__unsequenced__policy"><span class="std std-ref">parallel_unsequenced_policy</span></a> from itself</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The new <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1parallel__unsequenced__policy"><span class="std std-ref">parallel_unsequenced_policy</span></a> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tag</span></code>: [in] Specify that the corresponding asynchronous execution policy should be used</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel9execution27parallel_unsequenced_policy8executorEv">
<span id="_CPPv2N3hpx8parallel9execution27parallel_unsequenced_policy8executorEv"></span><span id="hpx::parallel::execution::parallel_unsequenced_policy::executor"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__unsequenced__policy_1aef4a7e977e2c5e9e633fdb40a24a4b2c"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel9execution27parallel_unsequenced_policy13executor_typeE" title="hpx::parallel::execution::parallel_unsequenced_policy::executor_type">executor_type</a> &amp;<code class="descname">executor</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution27parallel_unsequenced_policy8executorEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the associated executor object. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx8parallel9execution27parallel_unsequenced_policy8executorEv">
<span id="_CPPv2NK3hpx8parallel9execution27parallel_unsequenced_policy8executorEv"></span><span id="hpx::parallel::execution::parallel_unsequenced_policy::executorC"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__unsequenced__policy_1ae0bf3359016c341eed3572f374bd7dbe"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel9execution27parallel_unsequenced_policy13executor_typeE" title="hpx::parallel::execution::parallel_unsequenced_policy::executor_type">executor_type</a> <em class="property">const</em> &amp;<code class="descname">executor</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8parallel9execution27parallel_unsequenced_policy8executorEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the associated executor object. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel9execution27parallel_unsequenced_policy10parametersEv">
<span id="_CPPv2N3hpx8parallel9execution27parallel_unsequenced_policy10parametersEv"></span><span id="hpx::parallel::execution::parallel_unsequenced_policy::parameters"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__unsequenced__policy_1ab176ba3cc211bde7b7b3f95e5a90f13f"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel9execution27parallel_unsequenced_policy24executor_parameters_typeE" title="hpx::parallel::execution::parallel_unsequenced_policy::executor_parameters_type">executor_parameters_type</a> &amp;<code class="descname">parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution27parallel_unsequenced_policy10parametersEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the associated executor parameters object. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx8parallel9execution27parallel_unsequenced_policy10parametersEv">
<span id="_CPPv2NK3hpx8parallel9execution27parallel_unsequenced_policy10parametersEv"></span><span id="hpx::parallel::execution::parallel_unsequenced_policy::parametersC"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__unsequenced__policy_1a2b5ee4635d860a848424551133e057be"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel9execution27parallel_unsequenced_policy24executor_parameters_typeE" title="hpx::parallel::execution::parallel_unsequenced_policy::executor_parameters_type">executor_parameters_type</a> <em class="property">const</em> &amp;<code class="descname">parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8parallel9execution27parallel_unsequenced_policy10parametersEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the associated executor parameters object. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel9execution27parallel_unsequenced_policy9serializeER7ArchiveKj">
<span id="_CPPv2N3hpx8parallel9execution27parallel_unsequenced_policy9serializeER7ArchiveKj"></span><span id="hpx::parallel::execution::parallel_unsequenced_policy::serialize__ArchiveR.unsigned-iC"></span><em class="property">template </em>&lt;<em class="property">typename</em> Archive&gt;<br /><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__unsequenced__policy_1a69b5e563d3d2a9d874da8ec8f47ae30f"></span>void <code class="descname">serialize</code><span class="sig-paren">(</span>Archive &amp;<em>ar</em>, <em class="property">const</em> unsigned int <em>version</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution27parallel_unsequenced_policy9serializeER7ArchiveKj" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Members</p>
<dl class="member">
<dt id="_CPPv3N3hpx8parallel9execution27parallel_unsequenced_policy5exec_E">
<span id="_CPPv2N3hpx8parallel9execution27parallel_unsequenced_policy5exec_E"></span><span id="hpx::parallel::execution::parallel_unsequenced_policy::exec___executor_type"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__unsequenced__policy_1a472c33af216688944c67f109085520d1"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel9execution27parallel_unsequenced_policy13executor_typeE" title="hpx::parallel::execution::parallel_unsequenced_policy::executor_type">executor_type</a> <code class="descname">exec_</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution27parallel_unsequenced_policy5exec_E" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv3N3hpx8parallel9execution27parallel_unsequenced_policy7params_E">
<span id="_CPPv2N3hpx8parallel9execution27parallel_unsequenced_policy7params_E"></span><span id="hpx::parallel::execution::parallel_unsequenced_policy::params___executor_parameters_type"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__unsequenced__policy_1aa0ebb5d2d05222fe867f9ef252cb4317"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel9execution27parallel_unsequenced_policy24executor_parameters_typeE" title="hpx::parallel::execution::parallel_unsequenced_policy::executor_parameters_type">executor_parameters_type</a> <code class="descname">params_</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution27parallel_unsequenced_policy7params_E" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Friends</p>
<dl class="function">
<dt>
<span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__unsequenced__policy_1add50dcae00a1300662d4d2f8c52c804f"></span><em class="property">friend </em><code class="descname">hpx::parallel::execution::parallel_unsequenced_policy::hpx::serialization::access</code></dt>
<dd></dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx8resource11partitionerE">
<span id="_CPPv2N3hpx8resource11partitionerE"></span><span id="hpx::resource::partitioner"></span><span class="target" id="classhpx_1_1resource_1_1partitioner"></span><em class="property">class </em><code class="descname">partitioner</code><a class="headerlink" href="#_CPPv3N3hpx8resource11partitionerE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;partitioner.hpp&gt;</em><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8resource11partitioner11partitionerERN4util15function_nonserIFiRN5boost15program_options13variables_mapEEEERN5boost15program_options19options_descriptionEiPPcNSt6vectorINSt6stringEEEN8resource16partitioner_modeE12runtime_mode">
<span id="_CPPv2N3hpx8resource11partitioner11partitionerERN4util15function_nonserIFiRN5boost15program_options13variables_mapEEEERN5boost15program_options19options_descriptionEiPPcNSt6vectorINSt6stringEEEN8resource16partitioner_modeE12runtime_mode"></span><span class="target" id="classhpx_1_1resource_1_1partitioner_1af576b48f537583c3d2956e3b1a6b30e4"></span><code class="descname">partitioner</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::function_nonser&lt;int<span class="sig-paren">(</span>boost::program_options::variables_map &amp;vm<span class="sig-paren">)</span>&gt; <em class="property">const</em> &amp;<em>f</em>, boost::program_options::options_description <em class="property">const</em> &amp;<em>desc_cmdline</em>, int <em>argc</em>, char **<em>argv</em>, std::vector&lt;std::string&gt; <em>ini_config</em>, <a class="reference internal" href="#_CPPv3N3hpx8resourceE" title="hpx::resource">resource</a>::<a class="reference internal" href="#_CPPv3N3hpx8resource16partitioner_modeE" title="hpx::resource::partitioner_mode">partitioner_mode</a> <em>rpmode</em> = <a class="reference internal" href="#_CPPv3N3hpx8resourceE" title="hpx::resource">resource</a>::<a class="reference internal" href="#_CPPv3N3hpx8resource12mode_defaultE" title="hpx::resource::mode_default">mode_default</a>, <a class="reference internal" href="#_CPPv3N3hpx12runtime_modeE" title="hpx::runtime_mode">runtime_mode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv3N3hpx20runtime_mode_defaultE" title="hpx::runtime_mode_default">runtime_mode_default</a>, <span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8resource11partitioner11partitionerERN4util15function_nonserIFiRN5boost15program_options13variables_mapEEEERN5boost15program_options19options_descriptionEiPPcNSt6vectorINSt6stringEEEN8resource16partitioner_modeE12runtime_mode" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8resource11partitioner11partitionerERN4util15function_nonserIFiiPPcEEEiPPcN8resource16partitioner_modeEN3hpx12runtime_modeE">
<span id="_CPPv2N3hpx8resource11partitioner11partitionerERN4util15function_nonserIFiiPPcEEEiPPcN8resource16partitioner_modeEN3hpx12runtime_modeE"></span><span class="target" id="classhpx_1_1resource_1_1partitioner_1a4bba6633f3ccaecd918dbd48e8f060e5"></span><code class="descname">partitioner</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::function_nonser&lt;int<span class="sig-paren">(</span>int, char **<span class="sig-paren">)</span>&gt; <em class="property">const</em> &amp;<em>f</em>, int <em>argc</em>, char **<em>argv</em>, <a class="reference internal" href="#_CPPv3N3hpx8resourceE" title="hpx::resource">resource</a>::<a class="reference internal" href="#_CPPv3N3hpx8resource16partitioner_modeE" title="hpx::resource::partitioner_mode">partitioner_mode</a> <em>rpmode</em> = <a class="reference internal" href="#_CPPv3N3hpx8resourceE" title="hpx::resource">resource</a>::<a class="reference internal" href="#_CPPv3N3hpx8resource12mode_defaultE" title="hpx::resource::mode_default">mode_default</a>, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx12runtime_modeE" title="hpx::runtime_mode">runtime_mode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx20runtime_mode_defaultE" title="hpx::runtime_mode_default">runtime_mode_default</a>, <span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8resource11partitioner11partitionerERN4util15function_nonserIFiiPPcEEEiPPcN8resource16partitioner_modeEN3hpx12runtime_modeE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8resource11partitioner11partitionerERN4util15function_nonserIFiiPPcEEEiPPcRNSt6vectorINSt6stringEEEN8resource16partitioner_modeEN3hpx12runtime_modeE">
<span id="_CPPv2N3hpx8resource11partitioner11partitionerERN4util15function_nonserIFiiPPcEEEiPPcRNSt6vectorINSt6stringEEEN8resource16partitioner_modeEN3hpx12runtime_modeE"></span><span class="target" id="classhpx_1_1resource_1_1partitioner_1af9ca64e26b029246a4de28fe255eac53"></span><code class="descname">partitioner</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::function_nonser&lt;int<span class="sig-paren">(</span>int, char **<span class="sig-paren">)</span>&gt; <em class="property">const</em> &amp;<em>f</em>, int <em>argc</em>, char **<em>argv</em>, std::vector&lt;std::string&gt; <em class="property">const</em> &amp;<em>cfg</em>, <a class="reference internal" href="#_CPPv3N3hpx8resourceE" title="hpx::resource">resource</a>::<a class="reference internal" href="#_CPPv3N3hpx8resource16partitioner_modeE" title="hpx::resource::partitioner_mode">partitioner_mode</a> <em>rpmode</em> = <a class="reference internal" href="#_CPPv3N3hpx8resourceE" title="hpx::resource">resource</a>::<a class="reference internal" href="#_CPPv3N3hpx8resource12mode_defaultE" title="hpx::resource::mode_default">mode_default</a>, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx12runtime_modeE" title="hpx::runtime_mode">runtime_mode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx20runtime_mode_defaultE" title="hpx::runtime_mode_default">runtime_mode_default</a>, <span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8resource11partitioner11partitionerERN4util15function_nonserIFiiPPcEEEiPPcRNSt6vectorINSt6stringEEEN8resource16partitioner_modeEN3hpx12runtime_modeE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8resource11partitioner11partitionerEiPPcN8resource16partitioner_modeE12runtime_mode">
<span id="_CPPv2N3hpx8resource11partitioner11partitionerEiPPcN8resource16partitioner_modeE12runtime_mode"></span><span id="hpx::resource::partitioner::partitioner__i.cPP.resource::partitioner_mode.runtime_mode"></span><span class="target" id="classhpx_1_1resource_1_1partitioner_1af11403a34747e93d4a78daf21436398f"></span><code class="descname">partitioner</code><span class="sig-paren">(</span>int <em>argc</em>, char **<em>argv</em>, <a class="reference internal" href="#_CPPv3N3hpx8resourceE" title="hpx::resource">resource</a>::<a class="reference internal" href="#_CPPv3N3hpx8resource16partitioner_modeE" title="hpx::resource::partitioner_mode">partitioner_mode</a> <em>rpmode</em> = <a class="reference internal" href="#_CPPv3N3hpx8resourceE" title="hpx::resource">resource</a>::<a class="reference internal" href="#_CPPv3N3hpx8resource12mode_defaultE" title="hpx::resource::mode_default">mode_default</a>, <a class="reference internal" href="#_CPPv3N3hpx12runtime_modeE" title="hpx::runtime_mode">runtime_mode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv3N3hpx20runtime_mode_defaultE" title="hpx::runtime_mode_default">runtime_mode_default</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8resource11partitioner11partitionerEiPPcN8resource16partitioner_modeE12runtime_mode" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8resource11partitioner11partitionerEiPPcNSt6vectorINSt6stringEEEN8resource16partitioner_modeE12runtime_mode">
<span id="_CPPv2N3hpx8resource11partitioner11partitionerEiPPcNSt6vectorINSt6stringEEEN8resource16partitioner_modeE12runtime_mode"></span><span id="hpx::resource::partitioner::partitioner__i.cPP.std::vector:ss:.resource::partitioner_mode.runtime_mode"></span><span class="target" id="classhpx_1_1resource_1_1partitioner_1aacf20a9cc6b352458c0c663984e34cbe"></span><code class="descname">partitioner</code><span class="sig-paren">(</span>int <em>argc</em>, char **<em>argv</em>, std::vector&lt;std::string&gt; <em>ini_config</em>, <a class="reference internal" href="#_CPPv3N3hpx8resourceE" title="hpx::resource">resource</a>::<a class="reference internal" href="#_CPPv3N3hpx8resource16partitioner_modeE" title="hpx::resource::partitioner_mode">partitioner_mode</a> <em>rpmode</em> = <a class="reference internal" href="#_CPPv3N3hpx8resourceE" title="hpx::resource">resource</a>::<a class="reference internal" href="#_CPPv3N3hpx8resource12mode_defaultE" title="hpx::resource::mode_default">mode_default</a>, <a class="reference internal" href="#_CPPv3N3hpx12runtime_modeE" title="hpx::runtime_mode">runtime_mode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv3N3hpx20runtime_mode_defaultE" title="hpx::runtime_mode_default">runtime_mode_default</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8resource11partitioner11partitionerEiPPcNSt6vectorINSt6stringEEEN8resource16partitioner_modeE12runtime_mode" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8resource11partitioner11partitionerERN5boost15program_options19options_descriptionEiPPcN8resource16partitioner_modeE12runtime_mode">
<span id="_CPPv2N3hpx8resource11partitioner11partitionerERN5boost15program_options19options_descriptionEiPPcN8resource16partitioner_modeE12runtime_mode"></span><span id="hpx::resource::partitioner::partitioner__boost::program_options::options_descriptionCR.i.cPP.resource::partitioner_mode.runtime_mode"></span><span class="target" id="classhpx_1_1resource_1_1partitioner_1ab2ee775eb176063396031d0f035aa284"></span><code class="descname">partitioner</code><span class="sig-paren">(</span>boost::program_options::options_description <em class="property">const</em> &amp;<em>desc_cmdline</em>, int <em>argc</em>, char **<em>argv</em>, <a class="reference internal" href="#_CPPv3N3hpx8resourceE" title="hpx::resource">resource</a>::<a class="reference internal" href="#_CPPv3N3hpx8resource16partitioner_modeE" title="hpx::resource::partitioner_mode">partitioner_mode</a> <em>rpmode</em> = <a class="reference internal" href="#_CPPv3N3hpx8resourceE" title="hpx::resource">resource</a>::<a class="reference internal" href="#_CPPv3N3hpx8resource12mode_defaultE" title="hpx::resource::mode_default">mode_default</a>, <a class="reference internal" href="#_CPPv3N3hpx12runtime_modeE" title="hpx::runtime_mode">runtime_mode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv3N3hpx20runtime_mode_defaultE" title="hpx::runtime_mode_default">runtime_mode_default</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8resource11partitioner11partitionerERN5boost15program_options19options_descriptionEiPPcN8resource16partitioner_modeE12runtime_mode" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8resource11partitioner11partitionerERN5boost15program_options19options_descriptionEiPPcNSt6vectorINSt6stringEEEN8resource16partitioner_modeE12runtime_mode">
<span id="_CPPv2N3hpx8resource11partitioner11partitionerERN5boost15program_options19options_descriptionEiPPcNSt6vectorINSt6stringEEEN8resource16partitioner_modeE12runtime_mode"></span><span id="hpx::resource::partitioner::partitioner__boost::program_options::options_descriptionCR.i.cPP.std::vector:ss:.resource::partitioner_mode.runtime_mode"></span><span class="target" id="classhpx_1_1resource_1_1partitioner_1a3bb45385b691b0526aca4336467970cd"></span><code class="descname">partitioner</code><span class="sig-paren">(</span>boost::program_options::options_description <em class="property">const</em> &amp;<em>desc_cmdline</em>, int <em>argc</em>, char **<em>argv</em>, std::vector&lt;std::string&gt; <em>ini_config</em>, <a class="reference internal" href="#_CPPv3N3hpx8resourceE" title="hpx::resource">resource</a>::<a class="reference internal" href="#_CPPv3N3hpx8resource16partitioner_modeE" title="hpx::resource::partitioner_mode">partitioner_mode</a> <em>rpmode</em> = <a class="reference internal" href="#_CPPv3N3hpx8resourceE" title="hpx::resource">resource</a>::<a class="reference internal" href="#_CPPv3N3hpx8resource12mode_defaultE" title="hpx::resource::mode_default">mode_default</a>, <a class="reference internal" href="#_CPPv3N3hpx12runtime_modeE" title="hpx::runtime_mode">runtime_mode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv3N3hpx20runtime_mode_defaultE" title="hpx::runtime_mode_default">runtime_mode_default</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8resource11partitioner11partitionerERN5boost15program_options19options_descriptionEiPPcNSt6vectorINSt6stringEEEN8resource16partitioner_modeE12runtime_mode" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8resource11partitioner11partitionerENSt9nullptr_tEiPPcN8resource16partitioner_modeEN3hpx12runtime_modeE">
<span id="_CPPv2N3hpx8resource11partitioner11partitionerENSt9nullptr_tEiPPcN8resource16partitioner_modeEN3hpx12runtime_modeE"></span><span id="hpx::resource::partitioner::partitioner__std::nullptr_t.i.cPP.resource::partitioner_mode.hpx::runtime_mode"></span><span class="target" id="classhpx_1_1resource_1_1partitioner_1a26d9487a4e3a1d09a1e31f6b52371852"></span><code class="descname">partitioner</code><span class="sig-paren">(</span>std::nullptr_t <em>f</em>, int <em>argc</em>, char **<em>argv</em>, <a class="reference internal" href="#_CPPv3N3hpx8resourceE" title="hpx::resource">resource</a>::<a class="reference internal" href="#_CPPv3N3hpx8resource16partitioner_modeE" title="hpx::resource::partitioner_mode">partitioner_mode</a> <em>rpmode</em> = <a class="reference internal" href="#_CPPv3N3hpx8resourceE" title="hpx::resource">resource</a>::<a class="reference internal" href="#_CPPv3N3hpx8resource12mode_defaultE" title="hpx::resource::mode_default">mode_default</a>, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx12runtime_modeE" title="hpx::runtime_mode">runtime_mode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx20runtime_mode_defaultE" title="hpx::runtime_mode_default">runtime_mode_default</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8resource11partitioner11partitionerENSt9nullptr_tEiPPcN8resource16partitioner_modeEN3hpx12runtime_modeE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8resource11partitioner11partitionerENSt9nullptr_tEiPPcRNSt6vectorINSt6stringEEEN8resource16partitioner_modeEN3hpx12runtime_modeE">
<span id="_CPPv2N3hpx8resource11partitioner11partitionerENSt9nullptr_tEiPPcRNSt6vectorINSt6stringEEEN8resource16partitioner_modeEN3hpx12runtime_modeE"></span><span id="hpx::resource::partitioner::partitioner__std::nullptr_t.i.cPP.std::vector:ss:CR.resource::partitioner_mode.hpx::runtime_mode"></span><span class="target" id="classhpx_1_1resource_1_1partitioner_1ada5cb4e70ee5a55bd8e5a395f8933bf6"></span><code class="descname">partitioner</code><span class="sig-paren">(</span>std::nullptr_t <em>f</em>, int <em>argc</em>, char **<em>argv</em>, std::vector&lt;std::string&gt; <em class="property">const</em> &amp;<em>cfg</em>, <a class="reference internal" href="#_CPPv3N3hpx8resourceE" title="hpx::resource">resource</a>::<a class="reference internal" href="#_CPPv3N3hpx8resource16partitioner_modeE" title="hpx::resource::partitioner_mode">partitioner_mode</a> <em>rpmode</em> = <a class="reference internal" href="#_CPPv3N3hpx8resourceE" title="hpx::resource">resource</a>::<a class="reference internal" href="#_CPPv3N3hpx8resource12mode_defaultE" title="hpx::resource::mode_default">mode_default</a>, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx12runtime_modeE" title="hpx::runtime_mode">runtime_mode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx20runtime_mode_defaultE" title="hpx::runtime_mode_default">runtime_mode_default</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8resource11partitioner11partitionerENSt9nullptr_tEiPPcRNSt6vectorINSt6stringEEEN8resource16partitioner_modeEN3hpx12runtime_modeE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8resource11partitioner11partitionerENSt9nullptr_tERN5boost15program_options19options_descriptionEiPPcNSt6vectorINSt6stringEEEN8resource16partitioner_modeE12runtime_mode">
<span id="_CPPv2N3hpx8resource11partitioner11partitionerENSt9nullptr_tERN5boost15program_options19options_descriptionEiPPcNSt6vectorINSt6stringEEEN8resource16partitioner_modeE12runtime_mode"></span><span id="hpx::resource::partitioner::partitioner__std::nullptr_t.boost::program_options::options_descriptionCR.i.cPP.std::vector:ss:.resource::partitioner_mode.runtime_mode"></span><span class="target" id="classhpx_1_1resource_1_1partitioner_1aa18142356aa1b248b4f13f1327a34822"></span><code class="descname">partitioner</code><span class="sig-paren">(</span>std::nullptr_t <em>f</em>, boost::program_options::options_description <em class="property">const</em> &amp;<em>desc_cmdline</em>, int <em>argc</em>, char **<em>argv</em>, std::vector&lt;std::string&gt; <em>ini_config</em>, <a class="reference internal" href="#_CPPv3N3hpx8resourceE" title="hpx::resource">resource</a>::<a class="reference internal" href="#_CPPv3N3hpx8resource16partitioner_modeE" title="hpx::resource::partitioner_mode">partitioner_mode</a> <em>rpmode</em> = <a class="reference internal" href="#_CPPv3N3hpx8resourceE" title="hpx::resource">resource</a>::<a class="reference internal" href="#_CPPv3N3hpx8resource12mode_defaultE" title="hpx::resource::mode_default">mode_default</a>, <a class="reference internal" href="#_CPPv3N3hpx12runtime_modeE" title="hpx::runtime_mode">runtime_mode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv3N3hpx20runtime_mode_defaultE" title="hpx::runtime_mode_default">runtime_mode_default</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8resource11partitioner11partitionerENSt9nullptr_tERN5boost15program_options19options_descriptionEiPPcNSt6vectorINSt6stringEEEN8resource16partitioner_modeE12runtime_mode" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8resource11partitioner18create_thread_poolERNSt6stringE17scheduling_policyN3hpx7threads8policies14scheduler_modeE">
<span id="_CPPv2N3hpx8resource11partitioner18create_thread_poolERNSt6stringE17scheduling_policyN3hpx7threads8policies14scheduler_modeE"></span><span id="hpx::resource::partitioner::create_thread_pool__ssCR.scheduling_policy.hpx::threads::policies::scheduler_mode"></span><span class="target" id="classhpx_1_1resource_1_1partitioner_1a4497d2cbafa68fb886ba2045e3cbd6d3"></span>void <code class="descname">create_thread_pool</code><span class="sig-paren">(</span>std::string <em class="property">const</em> &amp;<em>name</em>, <a class="reference internal" href="#_CPPv3N3hpx8resource17scheduling_policyE" title="hpx::resource::scheduling_policy">scheduling_policy</a> <em>sched</em> = <a class="reference internal" href="#_CPPv3N3hpx8resource17scheduling_policyE" title="hpx::resource::scheduling_policy">scheduling_policy</a>::unspecified, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx7threadsE" title="hpx::threads">threads</a>::<a class="reference internal" href="#_CPPv3N3hpx7threads8policiesE" title="hpx::threads::policies">policies</a>::<a class="reference internal" href="#_CPPv3N3hpx7threads8policies14scheduler_modeE" title="hpx::threads::policies::scheduler_mode">scheduler_mode</a> = <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx7threadsE" title="hpx::threads">threads</a>::<a class="reference internal" href="#_CPPv3N3hpx7threads8policiesE" title="hpx::threads::policies">policies</a>::<a class="reference internal" href="#_CPPv3N3hpx7threads8policies14scheduler_modeE" title="hpx::threads::policies::scheduler_mode">scheduler_mode</a>::default_mode<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8resource11partitioner18create_thread_poolERNSt6stringE17scheduling_policyN3hpx7threads8policies14scheduler_modeE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8resource11partitioner18create_thread_poolERNSt6stringE18scheduler_function">
<span id="_CPPv2N3hpx8resource11partitioner18create_thread_poolERNSt6stringE18scheduler_function"></span><span id="hpx::resource::partitioner::create_thread_pool__ssCR.scheduler_function"></span><span class="target" id="classhpx_1_1resource_1_1partitioner_1ad559caef93ea53bdf561ef5b0893c578"></span>void <code class="descname">create_thread_pool</code><span class="sig-paren">(</span>std::string <em class="property">const</em> &amp;<em>name</em>, scheduler_function <em>scheduler_creation</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8resource11partitioner18create_thread_poolERNSt6stringE18scheduler_function" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8resource11partitioner21set_default_pool_nameERNSt6stringE">
<span id="_CPPv2N3hpx8resource11partitioner21set_default_pool_nameERNSt6stringE"></span><span id="hpx::resource::partitioner::set_default_pool_name__ssCR"></span><span class="target" id="classhpx_1_1resource_1_1partitioner_1a3a44f4397fd710a74b1ab29ace8b12bc"></span>void <code class="descname">set_default_pool_name</code><span class="sig-paren">(</span>std::string <em class="property">const</em> &amp;<em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8resource11partitioner21set_default_pool_nameERNSt6stringE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx8resource11partitioner21get_default_pool_nameEv">
<span id="_CPPv2NK3hpx8resource11partitioner21get_default_pool_nameEv"></span><span id="hpx::resource::partitioner::get_default_pool_nameC"></span><span class="target" id="classhpx_1_1resource_1_1partitioner_1a4724e82f36f222fe5a4967b765e4d9b4"></span><em class="property">const</em> std::string &amp;<code class="descname">get_default_pool_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8resource11partitioner21get_default_pool_nameEv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8resource11partitioner12add_resourceERN3hpx8resource2puERNSt6stringENSt6size_tE">
<span id="_CPPv2N3hpx8resource11partitioner12add_resourceERN3hpx8resource2puERNSt6stringENSt6size_tE"></span><span id="hpx::resource::partitioner::add_resource__hpx::resource::puCR.ssCR.std::s"></span><span class="target" id="classhpx_1_1resource_1_1partitioner_1ae994b2afde4fe9414c8e0b158615387b"></span>void <code class="descname">add_resource</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx8resourceE" title="hpx::resource">resource</a>::<a class="reference internal" href="#_CPPv3N3hpx8resource2puE" title="hpx::resource::pu">pu</a> <em class="property">const</em> &amp;<em>p</em>, std::string <em class="property">const</em> &amp;<em>pool_name</em>, std::size_t <em>num_threads</em> = 1<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8resource11partitioner12add_resourceERN3hpx8resource2puERNSt6stringENSt6size_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8resource11partitioner12add_resourceERN3hpx8resource2puERNSt6stringEbNSt6size_tE">
<span id="_CPPv2N3hpx8resource11partitioner12add_resourceERN3hpx8resource2puERNSt6stringEbNSt6size_tE"></span><span id="hpx::resource::partitioner::add_resource__hpx::resource::puCR.ssCR.b.std::s"></span><span class="target" id="classhpx_1_1resource_1_1partitioner_1a869f50bc0b69968d465cb77248d7e174"></span>void <code class="descname">add_resource</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx8resourceE" title="hpx::resource">resource</a>::<a class="reference internal" href="#_CPPv3N3hpx8resource2puE" title="hpx::resource::pu">pu</a> <em class="property">const</em> &amp;<em>p</em>, std::string <em class="property">const</em> &amp;<em>pool_name</em>, bool <em>exclusive</em>, std::size_t <em>num_threads</em> = 1<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8resource11partitioner12add_resourceERN3hpx8resource2puERNSt6stringEbNSt6size_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8resource11partitioner12add_resourceERNSt6vectorIN3hpx8resource2puEEERNSt6stringEb">
<span id="_CPPv2N3hpx8resource11partitioner12add_resourceERNSt6vectorIN3hpx8resource2puEEERNSt6stringEb"></span><span id="hpx::resource::partitioner::add_resource__std::vector:hpx::resource::pu:CR.ssCR.b"></span><span class="target" id="classhpx_1_1resource_1_1partitioner_1a05ba911a49ab6864ceb0a9d0b38cf866"></span>void <code class="descname">add_resource</code><span class="sig-paren">(</span>std::vector&lt;<a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx8resourceE" title="hpx::resource">resource</a>::<a class="reference internal" href="#_CPPv3N3hpx8resource2puE" title="hpx::resource::pu">pu</a>&gt; <em class="property">const</em> &amp;<em>pv</em>, std::string <em class="property">const</em> &amp;<em>pool_name</em>, bool <em>exclusive</em> = true<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8resource11partitioner12add_resourceERNSt6vectorIN3hpx8resource2puEEERNSt6stringEb" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8resource11partitioner12add_resourceERN3hpx8resource4coreERNSt6stringEb">
<span id="_CPPv2N3hpx8resource11partitioner12add_resourceERN3hpx8resource4coreERNSt6stringEb"></span><span id="hpx::resource::partitioner::add_resource__hpx::resource::coreCR.ssCR.b"></span><span class="target" id="classhpx_1_1resource_1_1partitioner_1a73ca88b3e2be88f01b41b5729a04ec9f"></span>void <code class="descname">add_resource</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx8resourceE" title="hpx::resource">resource</a>::<a class="reference internal" href="#_CPPv3N3hpx8resource4coreE" title="hpx::resource::core">core</a> <em class="property">const</em> &amp;<em>c</em>, std::string <em class="property">const</em> &amp;<em>pool_name</em>, bool <em>exclusive</em> = true<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8resource11partitioner12add_resourceERN3hpx8resource4coreERNSt6stringEb" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8resource11partitioner12add_resourceERNSt6vectorIN3hpx8resource4coreEEERNSt6stringEb">
<span id="_CPPv2N3hpx8resource11partitioner12add_resourceERNSt6vectorIN3hpx8resource4coreEEERNSt6stringEb"></span><span id="hpx::resource::partitioner::add_resource__std::vector:hpx::resource::core:R.ssCR.b"></span><span class="target" id="classhpx_1_1resource_1_1partitioner_1a7938d8bb4d31c1ca8886c83f23c3121c"></span>void <code class="descname">add_resource</code><span class="sig-paren">(</span>std::vector&lt;<a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx8resourceE" title="hpx::resource">resource</a>::<a class="reference internal" href="#_CPPv3N3hpx8resource4coreE" title="hpx::resource::core">core</a>&gt; &amp;<em>cv</em>, std::string <em class="property">const</em> &amp;<em>pool_name</em>, bool <em>exclusive</em> = true<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8resource11partitioner12add_resourceERNSt6vectorIN3hpx8resource4coreEEERNSt6stringEb" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8resource11partitioner12add_resourceERN3hpx8resource11numa_domainERNSt6stringEb">
<span id="_CPPv2N3hpx8resource11partitioner12add_resourceERN3hpx8resource11numa_domainERNSt6stringEb"></span><span id="hpx::resource::partitioner::add_resource__hpx::resource::numa_domainCR.ssCR.b"></span><span class="target" id="classhpx_1_1resource_1_1partitioner_1a59e1cb220f7a395a7863c48091b08036"></span>void <code class="descname">add_resource</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx8resourceE" title="hpx::resource">resource</a>::<a class="reference internal" href="#_CPPv3N3hpx8resource11numa_domainE" title="hpx::resource::numa_domain">numa_domain</a> <em class="property">const</em> &amp;<em>nd</em>, std::string <em class="property">const</em> &amp;<em>pool_name</em>, bool <em>exclusive</em> = true<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8resource11partitioner12add_resourceERN3hpx8resource11numa_domainERNSt6stringEb" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8resource11partitioner12add_resourceERNSt6vectorIN3hpx8resource11numa_domainEEERNSt6stringEb">
<span id="_CPPv2N3hpx8resource11partitioner12add_resourceERNSt6vectorIN3hpx8resource11numa_domainEEERNSt6stringEb"></span><span id="hpx::resource::partitioner::add_resource__std::vector:hpx::resource::numa_domain:CR.ssCR.b"></span><span class="target" id="classhpx_1_1resource_1_1partitioner_1a539605633e7c948c737da90438642f2a"></span>void <code class="descname">add_resource</code><span class="sig-paren">(</span>std::vector&lt;<a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx8resourceE" title="hpx::resource">resource</a>::<a class="reference internal" href="#_CPPv3N3hpx8resource11numa_domainE" title="hpx::resource::numa_domain">numa_domain</a>&gt; <em class="property">const</em> &amp;<em>ndv</em>, std::string <em class="property">const</em> &amp;<em>pool_name</em>, bool <em>exclusive</em> = true<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8resource11partitioner12add_resourceERNSt6vectorIN3hpx8resource11numa_domainEEERNSt6stringEb" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx8resource11partitioner12numa_domainsEv">
<span id="_CPPv2NK3hpx8resource11partitioner12numa_domainsEv"></span><span id="hpx::resource::partitioner::numa_domainsC"></span><span class="target" id="classhpx_1_1resource_1_1partitioner_1ac6c0f5620c6f45f3a9a811d0113997e0"></span>std::vector&lt;<a class="reference internal" href="#_CPPv3N3hpx8resource11numa_domainE" title="hpx::resource::numa_domain">numa_domain</a>&gt; <em class="property">const</em> &amp;<code class="descname">numa_domains</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8resource11partitioner12numa_domainsEv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Members</p>
<dl class="member">
<dt id="_CPPv3N3hpx8resource11partitioner12partitioner_E">
<span id="_CPPv2N3hpx8resource11partitioner12partitioner_E"></span><span id="hpx::resource::partitioner::partitioner___detail::partitionerR"></span><span class="target" id="classhpx_1_1resource_1_1partitioner_1a66bbd4414489502a29b959f602dbb6ae"></span>detail::partitioner &amp;<code class="descname">partitioner_</code><a class="headerlink" href="#_CPPv3N3hpx8resource11partitioner12partitioner_E" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx8parallel9execution26persistent_auto_chunk_sizeE">
<span id="_CPPv2N3hpx8parallel9execution26persistent_auto_chunk_sizeE"></span><span id="hpx::parallel::execution::persistent_auto_chunk_size"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1persistent__auto__chunk__size"></span><em class="property">struct </em><code class="descname">persistent_auto_chunk_size</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution26persistent_auto_chunk_sizeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;persistent_auto_chunk_size.hpp&gt;</em><p>Loop iterations are divided into pieces and then assigned to threads. The number of loop iterations combined is determined based on measurements of how long the execution of 1% of the overall number of iterations takes. This executor parameters type makes sure that as many loop iterations are combined as necessary to run for the amount of time specified. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel9execution26persistent_auto_chunk_size26persistent_auto_chunk_sizeEv">
<span id="_CPPv2N3hpx8parallel9execution26persistent_auto_chunk_size26persistent_auto_chunk_sizeEv"></span><span id="hpx::parallel::execution::persistent_auto_chunk_size::persistent_auto_chunk_size"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1persistent__auto__chunk__size_1ad88b81cde01f05f9693c2f4a823e2fbc"></span><code class="descname">persistent_auto_chunk_size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution26persistent_auto_chunk_size26persistent_auto_chunk_sizeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct an <em><a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1persistent__auto__chunk__size"><span class="std std-ref">persistent_auto_chunk_size</span></a></em> executor parameters object</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Default constructed <em><a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1persistent__auto__chunk__size"><span class="std std-ref">persistent_auto_chunk_size</span></a></em> executor parameter types will use 0 microseconds as the execution time for each chunk and 80 microseconds as the minimal time for which any of the scheduled chunks should run. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel9execution26persistent_auto_chunk_size26persistent_auto_chunk_sizeERN3hpx4util15steady_durationE">
<span id="_CPPv2N3hpx8parallel9execution26persistent_auto_chunk_size26persistent_auto_chunk_sizeERN3hpx4util15steady_durationE"></span><span id="hpx::parallel::execution::persistent_auto_chunk_size::persistent_auto_chunk_size__hpx::util::steady_durationCR"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1persistent__auto__chunk__size_1a7e04ecbaae686b23a6fa735dfba7a554"></span><code class="descname">persistent_auto_chunk_size</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::steady_duration <em class="property">const</em> &amp;<em>time_cs</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution26persistent_auto_chunk_size26persistent_auto_chunk_sizeERN3hpx4util15steady_durationE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct an <em><a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1persistent__auto__chunk__size"><span class="std std-ref">persistent_auto_chunk_size</span></a></em> executor parameters object</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">time_cs</span></code>: The execution time for each chunk. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel9execution26persistent_auto_chunk_size26persistent_auto_chunk_sizeERN3hpx4util15steady_durationERN3hpx4util15steady_durationE">
<span id="_CPPv2N3hpx8parallel9execution26persistent_auto_chunk_size26persistent_auto_chunk_sizeERN3hpx4util15steady_durationERN3hpx4util15steady_durationE"></span><span id="hpx::parallel::execution::persistent_auto_chunk_size::persistent_auto_chunk_size__hpx::util::steady_durationCR.hpx::util::steady_durationCR"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1persistent__auto__chunk__size_1a3849ce5597b9a8be5a70389bb1935aeb"></span><code class="descname">persistent_auto_chunk_size</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::steady_duration <em class="property">const</em> &amp;<em>time_cs</em>, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::steady_duration <em class="property">const</em> &amp;<em>rel_time</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution26persistent_auto_chunk_size26persistent_auto_chunk_sizeERN3hpx4util15steady_durationERN3hpx4util15steady_durationE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct an <em><a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1persistent__auto__chunk__size"><span class="std std-ref">persistent_auto_chunk_size</span></a></em> executor parameters object</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">rel_time</span></code>: [in] The time duration to use as the minimum to decide how many loop iterations should be combined. </li>
<li><code class="docutils literal notranslate"><span class="pre">time_cs</span></code>: The execution time for each chunk. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx8resource2puE">
<span id="_CPPv2N3hpx8resource2puE"></span><span id="hpx::resource::pu"></span><span class="target" id="classhpx_1_1resource_1_1pu"></span><em class="property">class </em><code class="descname">pu</code><a class="headerlink" href="#_CPPv3N3hpx8resource2puE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;partitioner.hpp&gt;</em><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8resource2pu2puENSt6size_tEP4coreNSt6size_tE">
<span id="_CPPv2N3hpx8resource2pu2puENSt6size_tEP4coreNSt6size_tE"></span><span id="hpx::resource::pu::pu__std::s.coreP.std::s"></span><span class="target" id="classhpx_1_1resource_1_1pu_1a537ffb359aa977fbdb2f42f3515fc8bf"></span><code class="descname">pu</code><span class="sig-paren">(</span>std::size_t <em>id</em> = <a class="reference internal" href="#_CPPv3N3hpx8resource2pu13invalid_pu_idE" title="hpx::resource::pu::invalid_pu_id">invalid_pu_id</a>, <a class="reference internal" href="#_CPPv3N3hpx8resource2pu2puENSt6size_tEP4coreNSt6size_tE" title="hpx::resource::pu::pu::core">core</a> *<em>core</em> = nullptr, std::size_t <em>thread_occupancy</em> = 0<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8resource2pu2puENSt6size_tEP4coreNSt6size_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx8resource2pu2idEv">
<span id="_CPPv2NK3hpx8resource2pu2idEv"></span><span id="hpx::resource::pu::idC"></span><span class="target" id="classhpx_1_1resource_1_1pu_1a2e55d79cc3b4e94e3295e9590197a6bf"></span>std::size_t <code class="descname">id</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8resource2pu2idEv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8resource2pu16pus_sharing_coreEv">
<span id="_CPPv2N3hpx8resource2pu16pus_sharing_coreEv"></span><span id="hpx::resource::pu::pus_sharing_core"></span><span class="target" id="classhpx_1_1resource_1_1pu_1a65a6facef703935b9f73b467ff50ad3c"></span>std::vector&lt;<a class="reference internal" href="#_CPPv3N3hpx8resource2puE" title="hpx::resource::pu">pu</a>&gt; <code class="descname">pus_sharing_core</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8resource2pu16pus_sharing_coreEv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8resource2pu23pus_sharing_numa_domainEv">
<span id="_CPPv2N3hpx8resource2pu23pus_sharing_numa_domainEv"></span><span id="hpx::resource::pu::pus_sharing_numa_domain"></span><span class="target" id="classhpx_1_1resource_1_1pu_1a4151c464568440e038fa3ae5fb020f36"></span>std::vector&lt;<a class="reference internal" href="#_CPPv3N3hpx8resource2puE" title="hpx::resource::pu">pu</a>&gt; <code class="descname">pus_sharing_numa_domain</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8resource2pu23pus_sharing_numa_domainEv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Members</p>
<dl class="member">
<dt id="_CPPv3N3hpx8resource2pu3id_E">
<span id="_CPPv2N3hpx8resource2pu3id_E"></span><span id="hpx::resource::pu::id___std::s"></span><span class="target" id="classhpx_1_1resource_1_1pu_1aef608faedbbedb5363ce8b2fa3459902"></span>std::size_t <code class="descname">id_</code><a class="headerlink" href="#_CPPv3N3hpx8resource2pu3id_E" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv3N3hpx8resource2pu5core_E">
<span id="_CPPv2N3hpx8resource2pu5core_E"></span><span id="hpx::resource::pu::core___coreP"></span><span class="target" id="classhpx_1_1resource_1_1pu_1a60cce22f6aa567e2b4a5ed0be8fe4595"></span><a class="reference internal" href="#_CPPv3N3hpx8resource4coreE" title="hpx::resource::core">core</a> *<code class="descname">core_</code><a class="headerlink" href="#_CPPv3N3hpx8resource2pu5core_E" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv3N3hpx8resource2pu17thread_occupancy_E">
<span id="_CPPv2N3hpx8resource2pu17thread_occupancy_E"></span><span id="hpx::resource::pu::thread_occupancy___std::s"></span><span class="target" id="classhpx_1_1resource_1_1pu_1ab803fb8ed0c174879646f06d4150e0f1"></span>std::size_t <code class="descname">thread_occupancy_</code><a class="headerlink" href="#_CPPv3N3hpx8resource2pu17thread_occupancy_E" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv3N3hpx8resource2pu23thread_occupancy_count_E">
<span id="_CPPv2N3hpx8resource2pu23thread_occupancy_count_E"></span><span id="hpx::resource::pu::thread_occupancy_count___std::s"></span><span class="target" id="classhpx_1_1resource_1_1pu_1a857b41b2c93d17256d46632ba31362ea"></span>std::size_t <code class="descname">thread_occupancy_count_</code><a class="headerlink" href="#_CPPv3N3hpx8resource2pu23thread_occupancy_count_E" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Static Attributes</p>
<dl class="member">
<dt id="_CPPv3N3hpx8resource2pu13invalid_pu_idE">
<span id="_CPPv2N3hpx8resource2pu13invalid_pu_idE"></span><span id="hpx::resource::pu::invalid_pu_id__std::sC"></span><span class="target" id="classhpx_1_1resource_1_1pu_1aea1c75ef951ef3603fb488d78f23d19a"></span><em class="property">const</em> std::size_t <code class="descname">invalid_pu_id</code> = std::size_t(-1)<a class="headerlink" href="#_CPPv3N3hpx8resource2pu13invalid_pu_idE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Friends</p>
<dl class="function">
<dt>
<span class="target" id="classhpx_1_1resource_1_1pu_1af764561c544bacc1b90b526ee8d3c708"></span><em class="property">friend </em><code class="descname">hpx::resource::pu::core</code></dt>
<dd></dd></dl>

<dl class="function">
<dt>
<span class="target" id="classhpx_1_1resource_1_1pu_1a2cd848189ba1a47ca3c3150ad45e974c"></span><em class="property">friend </em><code class="descname">hpx::resource::pu::numa_domain</code></dt>
<dd></dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx8parallel9execution25parallel_task_policy_shim6rebindE">
<span id="_CPPv2N3hpx8parallel9execution25parallel_task_policy_shim6rebindE"></span><span id="hpx::parallel::execution::parallel_task_policy_shim::rebind"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__task__policy__shim_1_1rebind"></span><em class="property">template </em>&lt;<em class="property">typename</em> Executor_, <em class="property">typename</em> Parameters_&gt;<br /><em class="property">struct </em><code class="descname">rebind</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution25parallel_task_policy_shim6rebindE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;execution_policy.hpp&gt;</em><p>Rebind the type of executor used by this execution policy. The execution category of Executor shall not be weaker than that of this execution policy </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="type">
<dt id="_CPPv3IEN3hpx8parallel9execution25parallel_task_policy_shimI8Executor10ParametersE6rebind4typeE">
<span id="_CPPv2IEN3hpx8parallel9execution25parallel_task_policy_shimI8Executor10ParametersE6rebind4typeE"></span>template&lt;&gt;<br /><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__task__policy__shim_1_1rebind_1ad2d1fb4a3c14040dfe9c61c1b120402e"></span><em class="property">typedef </em>parallel_task_policy_shim&lt;Executor_, Parameters_&gt; <code class="descname">type</code><a class="headerlink" href="#_CPPv3IEN3hpx8parallel9execution25parallel_task_policy_shimI8Executor10ParametersE6rebind4typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The type of the rebound execution policy. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx8parallel9execution26sequenced_task_policy_shim6rebindE">
<span id="_CPPv2N3hpx8parallel9execution26sequenced_task_policy_shim6rebindE"></span><span id="hpx::parallel::execution::sequenced_task_policy_shim::rebind"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy__shim_1_1rebind"></span><em class="property">template </em>&lt;<em class="property">typename</em> Executor_, <em class="property">typename</em> Parameters_&gt;<br /><em class="property">struct </em><code class="descname">rebind</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution26sequenced_task_policy_shim6rebindE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;execution_policy.hpp&gt;</em><p>Rebind the type of executor used by this execution policy. The execution category of Executor shall not be weaker than that of this execution policy </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="type">
<dt id="_CPPv3IEN3hpx8parallel9execution26sequenced_task_policy_shimI8Executor10ParametersE6rebind4typeE">
<span id="_CPPv2IEN3hpx8parallel9execution26sequenced_task_policy_shimI8Executor10ParametersE6rebind4typeE"></span>template&lt;&gt;<br /><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy__shim_1_1rebind_1aad5c8daa9ef34c39c478f35d00c5920d"></span><em class="property">typedef </em>sequenced_task_policy_shim&lt;Executor_, Parameters_&gt; <code class="descname">type</code><a class="headerlink" href="#_CPPv3IEN3hpx8parallel9execution26sequenced_task_policy_shimI8Executor10ParametersE6rebind4typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The type of the rebound execution policy. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx8parallel9execution15parallel_policy6rebindE">
<span id="_CPPv2N3hpx8parallel9execution15parallel_policy6rebindE"></span><span id="hpx::parallel::execution::parallel_policy::rebind"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__policy_1_1rebind"></span><em class="property">template </em>&lt;<em class="property">typename</em> Executor_, <em class="property">typename</em> Parameters_&gt;<br /><em class="property">struct </em><code class="descname">rebind</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution15parallel_policy6rebindE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;execution_policy.hpp&gt;</em><p>Rebind the type of executor used by this execution policy. The execution category of Executor shall not be weaker than that of this execution policy </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="type">
<dt id="_CPPv3N3hpx8parallel9execution15parallel_policy6rebind4typeE">
<span id="_CPPv2N3hpx8parallel9execution15parallel_policy6rebind4typeE"></span><span id="hpx::parallel::execution::parallel_policy::rebind::type"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__policy_1_1rebind_1a45ad3989c4ebdd21068858201bebf835"></span><em class="property">typedef </em><a class="reference internal" href="#_CPPv3N3hpx8parallel9execution20parallel_policy_shimE" title="hpx::parallel::execution::parallel_policy_shim">parallel_policy_shim</a>&lt;Executor_, Parameters_&gt; <code class="descname">type</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution15parallel_policy6rebind4typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The type of the rebound execution policy. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx8parallel9execution21sequenced_task_policy6rebindE">
<span id="_CPPv2N3hpx8parallel9execution21sequenced_task_policy6rebindE"></span><span id="hpx::parallel::execution::sequenced_task_policy::rebind"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy_1_1rebind"></span><em class="property">template </em>&lt;<em class="property">typename</em> Executor_, <em class="property">typename</em> Parameters_&gt;<br /><em class="property">struct </em><code class="descname">rebind</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution21sequenced_task_policy6rebindE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;execution_policy.hpp&gt;</em><p>Rebind the type of executor used by this execution policy. The execution category of Executor shall not be weaker than that of this execution policy </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="type">
<dt id="_CPPv3N3hpx8parallel9execution21sequenced_task_policy6rebind4typeE">
<span id="_CPPv2N3hpx8parallel9execution21sequenced_task_policy6rebind4typeE"></span><span id="hpx::parallel::execution::sequenced_task_policy::rebind::type"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy_1_1rebind_1ae38a7d1c965443a006a07128e792424b"></span><em class="property">typedef </em><a class="reference internal" href="#_CPPv3N3hpx8parallel9execution26sequenced_task_policy_shimE" title="hpx::parallel::execution::sequenced_task_policy_shim">sequenced_task_policy_shim</a>&lt;Executor_, Parameters_&gt; <code class="descname">type</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution21sequenced_task_policy6rebind4typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The type of the rebound execution policy. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx8parallel9execution16sequenced_policy6rebindE">
<span id="_CPPv2N3hpx8parallel9execution16sequenced_policy6rebindE"></span><span id="hpx::parallel::execution::sequenced_policy::rebind"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__policy_1_1rebind"></span><em class="property">template </em>&lt;<em class="property">typename</em> Executor_, <em class="property">typename</em> Parameters_&gt;<br /><em class="property">struct </em><code class="descname">rebind</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution16sequenced_policy6rebindE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;execution_policy.hpp&gt;</em><p>Rebind the type of executor used by this execution policy. The execution category of Executor shall not be weaker than that of this execution policy </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="type">
<dt id="_CPPv3N3hpx8parallel9execution16sequenced_policy6rebind4typeE">
<span id="_CPPv2N3hpx8parallel9execution16sequenced_policy6rebind4typeE"></span><span id="hpx::parallel::execution::sequenced_policy::rebind::type"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__policy_1_1rebind_1adb06f638bac0fd85682b0053ff7c9b81"></span><em class="property">typedef </em><a class="reference internal" href="#_CPPv3N3hpx8parallel9execution21sequenced_policy_shimE" title="hpx::parallel::execution::sequenced_policy_shim">sequenced_policy_shim</a>&lt;Executor_, Parameters_&gt; <code class="descname">type</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution16sequenced_policy6rebind4typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The type of the rebound execution policy. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx8parallel9execution20parallel_policy_shim6rebindE">
<span id="_CPPv2N3hpx8parallel9execution20parallel_policy_shim6rebindE"></span><span id="hpx::parallel::execution::parallel_policy_shim::rebind"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__policy__shim_1_1rebind"></span><em class="property">template </em>&lt;<em class="property">typename</em> Executor_, <em class="property">typename</em> Parameters_&gt;<br /><em class="property">struct </em><code class="descname">rebind</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution20parallel_policy_shim6rebindE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;execution_policy.hpp&gt;</em><p>Rebind the type of executor used by this execution policy. The execution category of Executor shall not be weaker than that of this execution policy </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="type">
<dt id="_CPPv3IEN3hpx8parallel9execution20parallel_policy_shimI8Executor10ParametersE6rebind4typeE">
<span id="_CPPv2IEN3hpx8parallel9execution20parallel_policy_shimI8Executor10ParametersE6rebind4typeE"></span>template&lt;&gt;<br /><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__policy__shim_1_1rebind_1a5cdb4def65f97ff3c167507612cc08ed"></span><em class="property">typedef </em>parallel_policy_shim&lt;Executor_, Parameters_&gt; <code class="descname">type</code><a class="headerlink" href="#_CPPv3IEN3hpx8parallel9execution20parallel_policy_shimI8Executor10ParametersE6rebind4typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The type of the rebound execution policy. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx8parallel9execution21sequenced_policy_shim6rebindE">
<span id="_CPPv2N3hpx8parallel9execution21sequenced_policy_shim6rebindE"></span><span id="hpx::parallel::execution::sequenced_policy_shim::rebind"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__policy__shim_1_1rebind"></span><em class="property">template </em>&lt;<em class="property">typename</em> Executor_, <em class="property">typename</em> Parameters_&gt;<br /><em class="property">struct </em><code class="descname">rebind</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution21sequenced_policy_shim6rebindE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;execution_policy.hpp&gt;</em><p>Rebind the type of executor used by this execution policy. The execution category of Executor shall not be weaker than that of this execution policy </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="type">
<dt id="_CPPv3IEN3hpx8parallel9execution21sequenced_policy_shimI8Executor10ParametersE6rebind4typeE">
<span id="_CPPv2IEN3hpx8parallel9execution21sequenced_policy_shimI8Executor10ParametersE6rebind4typeE"></span>template&lt;&gt;<br /><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__policy__shim_1_1rebind_1ae1fa86ae0c08c8d3d1944d0728924b4a"></span><em class="property">typedef </em>sequenced_policy_shim&lt;Executor_, Parameters_&gt; <code class="descname">type</code><a class="headerlink" href="#_CPPv3IEN3hpx8parallel9execution21sequenced_policy_shimI8Executor10ParametersE6rebind4typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The type of the rebound execution policy. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx8parallel9execution20parallel_task_policy6rebindE">
<span id="_CPPv2N3hpx8parallel9execution20parallel_task_policy6rebindE"></span><span id="hpx::parallel::execution::parallel_task_policy::rebind"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__task__policy_1_1rebind"></span><em class="property">template </em>&lt;<em class="property">typename</em> Executor_, <em class="property">typename</em> Parameters_&gt;<br /><em class="property">struct </em><code class="descname">rebind</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution20parallel_task_policy6rebindE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;execution_policy.hpp&gt;</em><p>Rebind the type of executor used by this execution policy. The execution category of Executor shall not be weaker than that of this execution policy </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="type">
<dt id="_CPPv3N3hpx8parallel9execution20parallel_task_policy6rebind4typeE">
<span id="_CPPv2N3hpx8parallel9execution20parallel_task_policy6rebind4typeE"></span><span id="hpx::parallel::execution::parallel_task_policy::rebind::type"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1parallel__task__policy_1_1rebind_1aae8cf7208a506ec31738118267a5cf61"></span><em class="property">typedef </em><a class="reference internal" href="#_CPPv3N3hpx8parallel9execution25parallel_task_policy_shimE" title="hpx::parallel::execution::parallel_task_policy_shim">parallel_task_policy_shim</a>&lt;Executor_, Parameters_&gt; <code class="descname">type</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution20parallel_task_policy6rebind4typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The type of the rebound execution policy. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx8parallel9execution23sequenced_execution_tagE">
<span id="_CPPv2N3hpx8parallel9execution23sequenced_execution_tagE"></span><span id="hpx::parallel::execution::sequenced_execution_tag"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__execution__tag"></span><em class="property">struct </em><code class="descname">sequenced_execution_tag</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution23sequenced_execution_tagE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;execution_fwd.hpp&gt;</em><p>Function invocations executed by a group of sequential execution agents execute in sequential order. </p>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx8parallel9execution18sequenced_executorE">
<span id="_CPPv2N3hpx8parallel9execution18sequenced_executorE"></span><span id="hpx::parallel::execution::sequenced_executor"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__executor"></span><em class="property">struct </em><code class="descname">sequenced_executor</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution18sequenced_executorE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;sequenced_executor.hpp&gt;</em><p>A <em>sequential_executor</em> creates groups of sequential execution agents which execute in the calling thread. The sequential order is given by the lexicographical order of indices in the index space. </p>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx8parallel9execution16sequenced_policyE">
<span id="_CPPv2N3hpx8parallel9execution16sequenced_policyE"></span><span id="hpx::parallel::execution::sequenced_policy"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__policy"></span><em class="property">struct </em><code class="descname">sequenced_policy</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution16sequenced_policyE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;execution_policy.hpp&gt;</em><p>The class <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1sequenced__policy"><span class="std std-ref">sequenced_policy</span></a> is an execution policy type used as a unique type to disambiguate parallel algorithm overloading and require that a parallel algorithm’s execution may not be parallelized. </p>
<p>Subclassed by <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1sequenced__policy__shim"><span class="std std-ref">hpx::parallel::execution::sequenced_policy_shim&lt; Executor, Parameters &gt;</span></a></p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="type">
<dt id="_CPPv3N3hpx8parallel9execution16sequenced_policy13executor_typeE">
<span id="_CPPv2N3hpx8parallel9execution16sequenced_policy13executor_typeE"></span><span id="hpx::parallel::execution::sequenced_policy::executor_type"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__policy_1a119d176dce6ced21219e59c31ecfa3c7"></span><em class="property">typedef </em><a class="reference internal" href="#_CPPv3N3hpx8parallel9execution18sequenced_executorE" title="hpx::parallel::execution::sequenced_executor">sequenced_executor</a> <code class="descname">executor_type</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution16sequenced_policy13executor_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The type of the executor associated with this execution policy. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx8parallel9execution16sequenced_policy24executor_parameters_typeE">
<span id="_CPPv2N3hpx8parallel9execution16sequenced_policy24executor_parameters_typeE"></span><span id="hpx::parallel::execution::sequenced_policy::executor_parameters_type"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__policy_1ad809d856011c8f0f00626fdd8231a011"></span><em class="property">typedef </em><a class="reference internal" href="#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::extract_executor_parameters&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution16sequenced_policy13executor_typeE" title="hpx::parallel::execution::sequenced_policy::executor_type">executor_type</a>&gt;::type <code class="descname">executor_parameters_type</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution16sequenced_policy24executor_parameters_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The type of the associated executor parameters object which is associated with this execution policy </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx8parallel9execution16sequenced_policy18execution_categoryE">
<span id="_CPPv2N3hpx8parallel9execution16sequenced_policy18execution_categoryE"></span><span id="hpx::parallel::execution::sequenced_policy::execution_category"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__policy_1a9a9599ee66ea4bc6df6714ff7e6c6eae"></span><em class="property">typedef </em><a class="reference internal" href="#_CPPv3N3hpx8parallel9execution23sequenced_execution_tagE" title="hpx::parallel::execution::sequenced_execution_tag">sequenced_execution_tag</a> <code class="descname">execution_category</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution16sequenced_policy18execution_categoryE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The category of the execution agents created by this execution policy. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv3NK3hpx8parallel9execution16sequenced_policyclE15task_policy_tag">
<span id="_CPPv2NK3hpx8parallel9execution16sequenced_policyclE15task_policy_tag"></span><span id="hpx::parallel::execution::sequenced_policy::call-operator__task_policy_tagC"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__policy_1ae3d73e3711dabf231962da6aafd208e1"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel9execution21sequenced_task_policyE" title="hpx::parallel::execution::sequenced_task_policy">sequenced_task_policy</a> <code class="descname">operator()</code><span class="sig-paren">(</span>task_policy_tag<span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8parallel9execution16sequenced_policyclE15task_policy_tag" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a new <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy"><span class="std std-ref">sequenced_task_policy</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The new <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy"><span class="std std-ref">sequenced_task_policy</span></a> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tag</span></code>: [in] Specify that the corresponding asynchronous execution policy should be used</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx8parallel9execution16sequenced_policy2onERR8Executor">
<span id="_CPPv2NK3hpx8parallel9execution16sequenced_policy2onERR8Executor"></span><span id="hpx::parallel::execution::sequenced_policy::on__ExecutorRRC"></span><em class="property">template </em>&lt;<em class="property">typename</em> Executor&gt;<br /><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__policy_1a03a6b90870b964ae3209f26b5e57e00c"></span>rebind_executor&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution16sequenced_policyE" title="hpx::parallel::execution::sequenced_policy">sequenced_policy</a>, Executor, <a class="reference internal" href="#_CPPv3N3hpx8parallel9execution16sequenced_policy24executor_parameters_typeE" title="hpx::parallel::execution::sequenced_policy::executor_parameters_type">executor_parameters_type</a>&gt;::type <code class="descname">on</code><span class="sig-paren">(</span>Executor &amp;&amp;<em>exec</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8parallel9execution16sequenced_policy2onERR8Executor" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a new <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1sequenced__policy"><span class="std std-ref">sequenced_policy</span></a> from the given executor</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Requires: is_executor&lt;Executor&gt;::value is true</dd>
<dt><strong>Return</strong></dt>
<dd>The new <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1sequenced__policy"><span class="std std-ref">sequenced_policy</span></a> </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">Executor</span></code>: The type of the executor to associate with this execution policy.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">exec</span></code>: [in] The executor to use for the execution of the parallel algorithm the returned execution policy is used with.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx8parallel9execution16sequenced_policy4withEDpRR10Parameters">
<span id="_CPPv2NK3hpx8parallel9execution16sequenced_policy4withEDpRR10Parameters"></span><span id="hpx::parallel::execution::sequenced_policy::with__ParametersRRDpC"></span><em class="property">template </em>&lt;typename... <em>Parameters</em>, <em class="property">typename</em> ParametersType = typename executor_parameters_join&lt;Parameters...&gt;::type&gt;<br /><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__policy_1a8f1a1f143a0855c657bbbc6f041008f2"></span>rebind_executor&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution16sequenced_policyE" title="hpx::parallel::execution::sequenced_policy">sequenced_policy</a>, <a class="reference internal" href="#_CPPv3N3hpx8parallel9execution16sequenced_policy13executor_typeE" title="hpx::parallel::execution::sequenced_policy::executor_type">executor_type</a>, ParametersType&gt;::type <code class="descname">with</code><span class="sig-paren">(</span>Parameters&amp;&amp;... <em>params</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8parallel9execution16sequenced_policy4withEDpRR10Parameters" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a new <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1sequenced__policy"><span class="std std-ref">sequenced_policy</span></a> from the given execution parameters</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Requires: all parameters are executor_parameters, different parameter types can’t be duplicated</dd>
<dt><strong>Return</strong></dt>
<dd>The new <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1sequenced__policy"><span class="std std-ref">sequenced_policy</span></a> </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">Parameters</span></code>: The type of the executor parameters to associate with this execution policy.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">params</span></code>: [in] The executor parameters to use for the execution of the parallel algorithm the returned execution policy is used with.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel9execution16sequenced_policy8executorEv">
<span id="_CPPv2N3hpx8parallel9execution16sequenced_policy8executorEv"></span><span id="hpx::parallel::execution::sequenced_policy::executor"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__policy_1aa39fe19012fb464df68cf6368e2929c5"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel9execution16sequenced_policy13executor_typeE" title="hpx::parallel::execution::sequenced_policy::executor_type">executor_type</a> &amp;<code class="descname">executor</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution16sequenced_policy8executorEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the associated executor object. Return the associated executor object. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx8parallel9execution16sequenced_policy8executorEv">
<span id="_CPPv2NK3hpx8parallel9execution16sequenced_policy8executorEv"></span><span id="hpx::parallel::execution::sequenced_policy::executorC"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__policy_1a292d9405fae1b39b7fe6f6d005224108"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel9execution16sequenced_policy13executor_typeE" title="hpx::parallel::execution::sequenced_policy::executor_type">executor_type</a> <em class="property">const</em> &amp;<code class="descname">executor</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8parallel9execution16sequenced_policy8executorEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the associated executor object. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel9execution16sequenced_policy10parametersEv">
<span id="_CPPv2N3hpx8parallel9execution16sequenced_policy10parametersEv"></span><span id="hpx::parallel::execution::sequenced_policy::parameters"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__policy_1a6f59c38560d90048fd396c8297ec2522"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel9execution16sequenced_policy24executor_parameters_typeE" title="hpx::parallel::execution::sequenced_policy::executor_parameters_type">executor_parameters_type</a> &amp;<code class="descname">parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution16sequenced_policy10parametersEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the associated executor parameters object. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx8parallel9execution16sequenced_policy10parametersEv">
<span id="_CPPv2NK3hpx8parallel9execution16sequenced_policy10parametersEv"></span><span id="hpx::parallel::execution::sequenced_policy::parametersC"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__policy_1aab52f0ee896a6d2f98854fb440c4b62d"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel9execution16sequenced_policy24executor_parameters_typeE" title="hpx::parallel::execution::sequenced_policy::executor_parameters_type">executor_parameters_type</a> <em class="property">const</em> &amp;<code class="descname">parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8parallel9execution16sequenced_policy10parametersEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the associated executor parameters object. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel9execution16sequenced_policy9serializeER7ArchiveKj">
<span id="_CPPv2N3hpx8parallel9execution16sequenced_policy9serializeER7ArchiveKj"></span><span id="hpx::parallel::execution::sequenced_policy::serialize__ArchiveR.unsigned-iC"></span><em class="property">template </em>&lt;<em class="property">typename</em> Archive&gt;<br /><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__policy_1a11b394b982ae0d8766bdd7a7c8882479"></span>void <code class="descname">serialize</code><span class="sig-paren">(</span>Archive &amp;<em>ar</em>, <em class="property">const</em> unsigned int <em>version</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution16sequenced_policy9serializeER7ArchiveKj" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Members</p>
<dl class="member">
<dt id="_CPPv3N3hpx8parallel9execution16sequenced_policy5exec_E">
<span id="_CPPv2N3hpx8parallel9execution16sequenced_policy5exec_E"></span><span id="hpx::parallel::execution::sequenced_policy::exec___executor_type"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__policy_1a4d7ffbc88cbf1861615e92fa6bc7a397"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel9execution16sequenced_policy13executor_typeE" title="hpx::parallel::execution::sequenced_policy::executor_type">executor_type</a> <code class="descname">exec_</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution16sequenced_policy5exec_E" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv3N3hpx8parallel9execution16sequenced_policy7params_E">
<span id="_CPPv2N3hpx8parallel9execution16sequenced_policy7params_E"></span><span id="hpx::parallel::execution::sequenced_policy::params___executor_parameters_type"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__policy_1a42698a58b7df40117eee592a43701550"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel9execution16sequenced_policy24executor_parameters_typeE" title="hpx::parallel::execution::sequenced_policy::executor_parameters_type">executor_parameters_type</a> <code class="descname">params_</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution16sequenced_policy7params_E" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Friends</p>
<dl class="function">
<dt>
<span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__policy_1add50dcae00a1300662d4d2f8c52c804f"></span><em class="property">friend </em><code class="descname">hpx::parallel::execution::sequenced_policy::hpx::serialization::access</code></dt>
<dd></dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx8parallel9execution21sequenced_policy_shimE">
<span id="_CPPv2N3hpx8parallel9execution21sequenced_policy_shimE"></span><span id="hpx::parallel::execution::sequenced_policy_shim"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__policy__shim"></span><em class="property">template </em>&lt;<em class="property">typename</em> Executor, <em class="property">typename</em> Parameters&gt;<br /><em class="property">struct </em><code class="descname">sequenced_policy_shim</code> : <em class="property">public</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx8parallelE" title="hpx::parallel">parallel</a>::<a class="reference internal" href="#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution16sequenced_policyE" title="hpx::parallel::execution::sequenced_policy">sequenced_policy</a><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution21sequenced_policy_shimE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;execution_policy.hpp&gt;</em><p>The class <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1sequenced__policy"><span class="std std-ref">sequenced_policy</span></a> is an execution policy type used as a unique type to disambiguate parallel algorithm overloading and require that a parallel algorithm’s execution may not be parallelized. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="type">
<dt id="_CPPv3N3hpx8parallel9execution21sequenced_policy_shim13executor_typeE">
<span id="_CPPv2N3hpx8parallel9execution21sequenced_policy_shim13executor_typeE"></span><span id="hpx::parallel::execution::sequenced_policy_shim::executor_type"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__policy__shim_1a861d51d32cb7854d0a5e4fadb1823fd4"></span><em class="property">typedef </em>Executor <code class="descname">executor_type</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution21sequenced_policy_shim13executor_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The type of the executor associated with this execution policy. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx8parallel9execution21sequenced_policy_shim24executor_parameters_typeE">
<span id="_CPPv2N3hpx8parallel9execution21sequenced_policy_shim24executor_parameters_typeE"></span><span id="hpx::parallel::execution::sequenced_policy_shim::executor_parameters_type"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__policy__shim_1a547c95857a28085e380c5f3e5d9f735f"></span><em class="property">typedef </em>Parameters <code class="descname">executor_parameters_type</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution21sequenced_policy_shim24executor_parameters_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The type of the associated executor parameters object which is associated with this execution policy </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx8parallel9execution21sequenced_policy_shim18execution_categoryE">
<span id="_CPPv2N3hpx8parallel9execution21sequenced_policy_shim18execution_categoryE"></span><span id="hpx::parallel::execution::sequenced_policy_shim::execution_category"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__policy__shim_1a505796bd3e265a320a79466c4f180bd2"></span><em class="property">typedef </em><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::executor_execution_category&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution21sequenced_policy_shim13executor_typeE" title="hpx::parallel::execution::sequenced_policy_shim::executor_type">executor_type</a>&gt;::type <code class="descname">execution_category</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution21sequenced_policy_shim18execution_categoryE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The category of the execution agents created by this execution policy. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv3NK3hpx8parallel9execution21sequenced_policy_shimclE15task_policy_tag">
<span id="_CPPv2NK3hpx8parallel9execution21sequenced_policy_shimclE15task_policy_tag"></span><span id="hpx::parallel::execution::sequenced_policy_shim::call-operator__task_policy_tagC"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__policy__shim_1ac9bfd6085c9432f2c6733ebd668e320d"></span>sequenced_task_policy_shim&lt;Executor, Parameters&gt; <code class="descname">operator()</code><span class="sig-paren">(</span>task_policy_tag <em>tag</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8parallel9execution21sequenced_policy_shimclE15task_policy_tag" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a new <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy"><span class="std std-ref">sequenced_task_policy</span></a>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The new <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy__shim"><span class="std std-ref">sequenced_task_policy_shim</span></a> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tag</span></code>: [in] Specify that the corresponding asynchronous execution policy should be used</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx8parallel9execution21sequenced_policy_shim2onERR9Executor_">
<span id="_CPPv2NK3hpx8parallel9execution21sequenced_policy_shim2onERR9Executor_"></span><span id="hpx::parallel::execution::sequenced_policy_shim::on__Executor_RRC"></span><em class="property">template </em>&lt;<em class="property">typename</em> Executor_&gt;<br /><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__policy__shim_1ab905d5f96bfbd7d6940d0b5bf32f26ae"></span>rebind_executor&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution21sequenced_policy_shimE" title="hpx::parallel::execution::sequenced_policy_shim">sequenced_policy_shim</a>, Executor_, <a class="reference internal" href="#_CPPv3N3hpx8parallel9execution21sequenced_policy_shim24executor_parameters_typeE" title="hpx::parallel::execution::sequenced_policy_shim::executor_parameters_type">executor_parameters_type</a>&gt;::type <code class="descname">on</code><span class="sig-paren">(</span>Executor_ &amp;&amp;<em>exec</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8parallel9execution21sequenced_policy_shim2onERR9Executor_" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a new <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1sequenced__policy"><span class="std std-ref">sequenced_policy</span></a> from the given executor</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Requires: is_executor&lt;Executor&gt;::value is true</dd>
<dt><strong>Return</strong></dt>
<dd>The new <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1sequenced__policy"><span class="std std-ref">sequenced_policy</span></a> </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">Executor</span></code>: The type of the executor to associate with this execution policy.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">exec</span></code>: [in] The executor to use for the execution of the parallel algorithm the returned execution policy is used with.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx8parallel9execution21sequenced_policy_shim4withEDpRR11Parameters_">
<span id="_CPPv2NK3hpx8parallel9execution21sequenced_policy_shim4withEDpRR11Parameters_"></span><span id="hpx::parallel::execution::sequenced_policy_shim::with__Parameters_RRDpC"></span><em class="property">template </em>&lt;typename... <em>Parameters_</em>, <em class="property">typename</em> ParametersType = typename executor_parameters_join&lt;Parameters_...&gt;::type&gt;<br /><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__policy__shim_1a4ec3e9790a6b5bc17fbd66cda9357d3d"></span>rebind_executor&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution21sequenced_policy_shimE" title="hpx::parallel::execution::sequenced_policy_shim">sequenced_policy_shim</a>, <a class="reference internal" href="#_CPPv3N3hpx8parallel9execution21sequenced_policy_shim13executor_typeE" title="hpx::parallel::execution::sequenced_policy_shim::executor_type">executor_type</a>, ParametersType&gt;::type <code class="descname">with</code><span class="sig-paren">(</span>Parameters_&amp;&amp;... <em>params</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8parallel9execution21sequenced_policy_shim4withEDpRR11Parameters_" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a new <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1sequenced__policy__shim"><span class="std std-ref">sequenced_policy_shim</span></a> from the given execution parameters</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Requires: all parameters are executor_parameters, different parameter types can’t be duplicated</dd>
<dt><strong>Return</strong></dt>
<dd>The new <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1sequenced__policy__shim"><span class="std std-ref">sequenced_policy_shim</span></a> </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">Parameters</span></code>: The type of the executor parameters to associate with this execution policy.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">params</span></code>: [in] The executor parameters to use for the execution of the parallel algorithm the returned execution policy is used with.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel9execution21sequenced_policy_shim8executorEv">
<span id="_CPPv2N3hpx8parallel9execution21sequenced_policy_shim8executorEv"></span><span id="hpx::parallel::execution::sequenced_policy_shim::executor"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__policy__shim_1ac7a0132f31b340bedcd8882d61c81e82"></span>Executor &amp;<code class="descname">executor</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution21sequenced_policy_shim8executorEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the associated executor object. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx8parallel9execution21sequenced_policy_shim8executorEv">
<span id="_CPPv2NK3hpx8parallel9execution21sequenced_policy_shim8executorEv"></span><span id="hpx::parallel::execution::sequenced_policy_shim::executorC"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__policy__shim_1ab079c9913b5c619e3d0eda6e8957a029"></span>Executor <em class="property">const</em> &amp;<code class="descname">executor</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8parallel9execution21sequenced_policy_shim8executorEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the associated executor object. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel9execution21sequenced_policy_shim10parametersEv">
<span id="_CPPv2N3hpx8parallel9execution21sequenced_policy_shim10parametersEv"></span><span id="hpx::parallel::execution::sequenced_policy_shim::parameters"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__policy__shim_1a604447ae38f322fdb4e4b2f0db01b948"></span>Parameters &amp;<code class="descname">parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution21sequenced_policy_shim10parametersEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the associated executor parameters object. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx8parallel9execution21sequenced_policy_shim10parametersEv">
<span id="_CPPv2NK3hpx8parallel9execution21sequenced_policy_shim10parametersEv"></span><span id="hpx::parallel::execution::sequenced_policy_shim::parametersC"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__policy__shim_1a2b5145a492b2d6333050a9f5ff23472d"></span>Parameters <em class="property">const</em> &amp;<code class="descname">parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8parallel9execution21sequenced_policy_shim10parametersEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the associated executor parameters object. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx8parallel9execution21sequenced_task_policyE">
<span id="_CPPv2N3hpx8parallel9execution21sequenced_task_policyE"></span><span id="hpx::parallel::execution::sequenced_task_policy"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy"></span><em class="property">struct </em><code class="descname">sequenced_task_policy</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution21sequenced_task_policyE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;execution_policy.hpp&gt;</em><p>Extension: The class <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy"><span class="std std-ref">sequenced_task_policy</span></a> is an execution policy type used as a unique type to disambiguate parallel algorithm overloading and indicate that a parallel algorithm’s execution may not be parallelized (has to run sequentially).</p>
<p>The algorithm returns a future representing the result of the corresponding algorithm when invoked with the <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1sequenced__policy"><span class="std std-ref">sequenced_policy</span></a>. </p>
<p>Subclassed by <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy__shim"><span class="std std-ref">hpx::parallel::execution::sequenced_task_policy_shim&lt; Executor, Parameters &gt;</span></a></p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="type">
<dt id="_CPPv3N3hpx8parallel9execution21sequenced_task_policy13executor_typeE">
<span id="_CPPv2N3hpx8parallel9execution21sequenced_task_policy13executor_typeE"></span><span id="hpx::parallel::execution::sequenced_task_policy::executor_type"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy_1a6a68c363631ef4ab977a5bd62b25e4bb"></span><em class="property">typedef </em><a class="reference internal" href="#_CPPv3N3hpx8parallel9execution18sequenced_executorE" title="hpx::parallel::execution::sequenced_executor">sequenced_executor</a> <code class="descname">executor_type</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution21sequenced_task_policy13executor_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The type of the executor associated with this execution policy. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx8parallel9execution21sequenced_task_policy24executor_parameters_typeE">
<span id="_CPPv2N3hpx8parallel9execution21sequenced_task_policy24executor_parameters_typeE"></span><span id="hpx::parallel::execution::sequenced_task_policy::executor_parameters_type"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy_1af31ef5129fd4fae716ffd3b7c11e9b1b"></span><em class="property">typedef </em><a class="reference internal" href="#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::extract_executor_parameters&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution21sequenced_task_policy13executor_typeE" title="hpx::parallel::execution::sequenced_task_policy::executor_type">executor_type</a>&gt;::type <code class="descname">executor_parameters_type</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution21sequenced_task_policy24executor_parameters_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The type of the associated executor parameters object which is associated with this execution policy </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx8parallel9execution21sequenced_task_policy18execution_categoryE">
<span id="_CPPv2N3hpx8parallel9execution21sequenced_task_policy18execution_categoryE"></span><span id="hpx::parallel::execution::sequenced_task_policy::execution_category"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy_1a628093f2b17d553bf87cdb1e116c2e57"></span><em class="property">typedef </em><a class="reference internal" href="#_CPPv3N3hpx8parallel9execution23sequenced_execution_tagE" title="hpx::parallel::execution::sequenced_execution_tag">sequenced_execution_tag</a> <code class="descname">execution_category</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution21sequenced_task_policy18execution_categoryE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The category of the execution agents created by this execution policy. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv3NK3hpx8parallel9execution21sequenced_task_policyclE15task_policy_tag">
<span id="_CPPv2NK3hpx8parallel9execution21sequenced_task_policyclE15task_policy_tag"></span><span id="hpx::parallel::execution::sequenced_task_policy::call-operator__task_policy_tagC"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy_1a81a3fe18a9605219644dfc5e42ad391a"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel9execution21sequenced_task_policyE" title="hpx::parallel::execution::sequenced_task_policy">sequenced_task_policy</a> <code class="descname">operator()</code><span class="sig-paren">(</span>task_policy_tag<span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8parallel9execution21sequenced_task_policyclE15task_policy_tag" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a new <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy"><span class="std std-ref">sequenced_task_policy</span></a> from itself</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The new <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy"><span class="std std-ref">sequenced_task_policy</span></a> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tag</span></code>: [in] Specify that the corresponding asynchronous execution policy should be used</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx8parallel9execution21sequenced_task_policy2onERR8Executor">
<span id="_CPPv2NK3hpx8parallel9execution21sequenced_task_policy2onERR8Executor"></span><span id="hpx::parallel::execution::sequenced_task_policy::on__ExecutorRRC"></span><em class="property">template </em>&lt;<em class="property">typename</em> Executor&gt;<br /><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy_1a78110383396d55281a65ce9a1059ebb4"></span>rebind_executor&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution21sequenced_task_policyE" title="hpx::parallel::execution::sequenced_task_policy">sequenced_task_policy</a>, Executor, <a class="reference internal" href="#_CPPv3N3hpx8parallel9execution21sequenced_task_policy24executor_parameters_typeE" title="hpx::parallel::execution::sequenced_task_policy::executor_parameters_type">executor_parameters_type</a>&gt;::type <code class="descname">on</code><span class="sig-paren">(</span>Executor &amp;&amp;<em>exec</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8parallel9execution21sequenced_task_policy2onERR8Executor" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a new <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy"><span class="std std-ref">sequenced_task_policy</span></a> from the given executor</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Requires: is_executor&lt;Executor&gt;::value is true</dd>
<dt><strong>Return</strong></dt>
<dd>The new <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy"><span class="std std-ref">sequenced_task_policy</span></a> </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">Executor</span></code>: The type of the executor to associate with this execution policy.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">exec</span></code>: [in] The executor to use for the execution of the parallel algorithm the returned execution policy is used with.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx8parallel9execution21sequenced_task_policy4withEDpRR10Parameters">
<span id="_CPPv2NK3hpx8parallel9execution21sequenced_task_policy4withEDpRR10Parameters"></span><span id="hpx::parallel::execution::sequenced_task_policy::with__ParametersRRDpC"></span><em class="property">template </em>&lt;typename... <em>Parameters</em>, <em class="property">typename</em> ParametersType = typename executor_parameters_join&lt;Parameters...&gt;::type&gt;<br /><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy_1a80f16f9cfef907f5dc2f9660dc872876"></span>rebind_executor&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution21sequenced_task_policyE" title="hpx::parallel::execution::sequenced_task_policy">sequenced_task_policy</a>, <a class="reference internal" href="#_CPPv3N3hpx8parallel9execution21sequenced_task_policy13executor_typeE" title="hpx::parallel::execution::sequenced_task_policy::executor_type">executor_type</a>, ParametersType&gt;::type <code class="descname">with</code><span class="sig-paren">(</span>Parameters&amp;&amp;... <em>params</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8parallel9execution21sequenced_task_policy4withEDpRR10Parameters" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a new <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy"><span class="std std-ref">sequenced_task_policy</span></a> from the given execution parameters</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Requires: all parameters are executor_parameters, different parameter types can’t be duplicated</dd>
<dt><strong>Return</strong></dt>
<dd>The new <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy"><span class="std std-ref">sequenced_task_policy</span></a> </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">Parameters</span></code>: The type of the executor parameters to associate with this execution policy.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">params</span></code>: [in] The executor parameters to use for the execution of the parallel algorithm the returned execution policy is used with.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel9execution21sequenced_task_policy8executorEv">
<span id="_CPPv2N3hpx8parallel9execution21sequenced_task_policy8executorEv"></span><span id="hpx::parallel::execution::sequenced_task_policy::executor"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy_1a4bfca8a6fd294a6e8178131483c73846"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel9execution21sequenced_task_policy13executor_typeE" title="hpx::parallel::execution::sequenced_task_policy::executor_type">executor_type</a> &amp;<code class="descname">executor</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution21sequenced_task_policy8executorEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the associated executor object. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx8parallel9execution21sequenced_task_policy8executorEv">
<span id="_CPPv2NK3hpx8parallel9execution21sequenced_task_policy8executorEv"></span><span id="hpx::parallel::execution::sequenced_task_policy::executorC"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy_1aa4601be81943e600d2edbbe302ec98fc"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel9execution21sequenced_task_policy13executor_typeE" title="hpx::parallel::execution::sequenced_task_policy::executor_type">executor_type</a> <em class="property">const</em> &amp;<code class="descname">executor</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8parallel9execution21sequenced_task_policy8executorEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the associated executor object. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel9execution21sequenced_task_policy10parametersEv">
<span id="_CPPv2N3hpx8parallel9execution21sequenced_task_policy10parametersEv"></span><span id="hpx::parallel::execution::sequenced_task_policy::parameters"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy_1a9f94a35b705ff48867e24a1e3f527c08"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel9execution21sequenced_task_policy24executor_parameters_typeE" title="hpx::parallel::execution::sequenced_task_policy::executor_parameters_type">executor_parameters_type</a> &amp;<code class="descname">parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution21sequenced_task_policy10parametersEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the associated executor parameters object. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx8parallel9execution21sequenced_task_policy10parametersEv">
<span id="_CPPv2NK3hpx8parallel9execution21sequenced_task_policy10parametersEv"></span><span id="hpx::parallel::execution::sequenced_task_policy::parametersC"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy_1ac707aa4e3bf86c90120dc7c215c58897"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel9execution21sequenced_task_policy24executor_parameters_typeE" title="hpx::parallel::execution::sequenced_task_policy::executor_parameters_type">executor_parameters_type</a> <em class="property">const</em> &amp;<code class="descname">parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8parallel9execution21sequenced_task_policy10parametersEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the associated executor parameters object. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel9execution21sequenced_task_policy9serializeER7ArchiveKj">
<span id="_CPPv2N3hpx8parallel9execution21sequenced_task_policy9serializeER7ArchiveKj"></span><span id="hpx::parallel::execution::sequenced_task_policy::serialize__ArchiveR.unsigned-iC"></span><em class="property">template </em>&lt;<em class="property">typename</em> Archive&gt;<br /><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy_1a2e5f40087bdb2e5ff7ce3252c4118519"></span>void <code class="descname">serialize</code><span class="sig-paren">(</span>Archive &amp;<em>ar</em>, <em class="property">const</em> unsigned int <em>version</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution21sequenced_task_policy9serializeER7ArchiveKj" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Members</p>
<dl class="member">
<dt id="_CPPv3N3hpx8parallel9execution21sequenced_task_policy5exec_E">
<span id="_CPPv2N3hpx8parallel9execution21sequenced_task_policy5exec_E"></span><span id="hpx::parallel::execution::sequenced_task_policy::exec___executor_type"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy_1acd5dc34f77ffcf33801b8c876f730dff"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel9execution21sequenced_task_policy13executor_typeE" title="hpx::parallel::execution::sequenced_task_policy::executor_type">executor_type</a> <code class="descname">exec_</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution21sequenced_task_policy5exec_E" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv3N3hpx8parallel9execution21sequenced_task_policy7params_E">
<span id="_CPPv2N3hpx8parallel9execution21sequenced_task_policy7params_E"></span><span id="hpx::parallel::execution::sequenced_task_policy::params___executor_parameters_type"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy_1a52a89caa3dc493ff328f9cac8021fc9b"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel9execution21sequenced_task_policy24executor_parameters_typeE" title="hpx::parallel::execution::sequenced_task_policy::executor_parameters_type">executor_parameters_type</a> <code class="descname">params_</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution21sequenced_task_policy7params_E" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Friends</p>
<dl class="function">
<dt>
<span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy_1add50dcae00a1300662d4d2f8c52c804f"></span><em class="property">friend </em><code class="descname">hpx::parallel::execution::sequenced_task_policy::hpx::serialization::access</code></dt>
<dd></dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx8parallel9execution26sequenced_task_policy_shimE">
<span id="_CPPv2N3hpx8parallel9execution26sequenced_task_policy_shimE"></span><span id="hpx::parallel::execution::sequenced_task_policy_shim"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy__shim"></span><em class="property">template </em>&lt;<em class="property">typename</em> Executor, <em class="property">typename</em> Parameters&gt;<br /><em class="property">struct </em><code class="descname">sequenced_task_policy_shim</code> : <em class="property">public</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx8parallelE" title="hpx::parallel">parallel</a>::<a class="reference internal" href="#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution21sequenced_task_policyE" title="hpx::parallel::execution::sequenced_task_policy">sequenced_task_policy</a><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution26sequenced_task_policy_shimE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;execution_policy.hpp&gt;</em><p>Extension: The class <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy__shim"><span class="std std-ref">sequenced_task_policy_shim</span></a> is an execution policy type used as a unique type to disambiguate parallel algorithm overloading based on combining a underlying <em><a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy"><span class="std std-ref">sequenced_task_policy</span></a></em> and an executor and indicate that a parallel algorithm’s execution may not be parallelized (has to run sequentially).</p>
<p>The algorithm returns a future representing the result of the corresponding algorithm when invoked with the <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1sequenced__policy"><span class="std std-ref">sequenced_policy</span></a>. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="type">
<dt id="_CPPv3N3hpx8parallel9execution26sequenced_task_policy_shim13executor_typeE">
<span id="_CPPv2N3hpx8parallel9execution26sequenced_task_policy_shim13executor_typeE"></span><span id="hpx::parallel::execution::sequenced_task_policy_shim::executor_type"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy__shim_1a8266a091bab953435f91dd581ebefe6f"></span><em class="property">typedef </em>Executor <code class="descname">executor_type</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution26sequenced_task_policy_shim13executor_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The type of the executor associated with this execution policy. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx8parallel9execution26sequenced_task_policy_shim24executor_parameters_typeE">
<span id="_CPPv2N3hpx8parallel9execution26sequenced_task_policy_shim24executor_parameters_typeE"></span><span id="hpx::parallel::execution::sequenced_task_policy_shim::executor_parameters_type"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy__shim_1a491f80046c2b447302d82ee8581ea852"></span><em class="property">typedef </em>Parameters <code class="descname">executor_parameters_type</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution26sequenced_task_policy_shim24executor_parameters_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The type of the associated executor parameters object which is associated with this execution policy </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx8parallel9execution26sequenced_task_policy_shim18execution_categoryE">
<span id="_CPPv2N3hpx8parallel9execution26sequenced_task_policy_shim18execution_categoryE"></span><span id="hpx::parallel::execution::sequenced_task_policy_shim::execution_category"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy__shim_1aff2f1e3c8099e7bfd9f52af6b4d5bcfc"></span><em class="property">typedef </em><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::executor_execution_category&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution26sequenced_task_policy_shim13executor_typeE" title="hpx::parallel::execution::sequenced_task_policy_shim::executor_type">executor_type</a>&gt;::type <code class="descname">execution_category</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution26sequenced_task_policy_shim18execution_categoryE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The category of the execution agents created by this execution policy. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv3NK3hpx8parallel9execution26sequenced_task_policy_shimclE15task_policy_tag">
<span id="_CPPv2NK3hpx8parallel9execution26sequenced_task_policy_shimclE15task_policy_tag"></span><span id="hpx::parallel::execution::sequenced_task_policy_shim::call-operator__task_policy_tagC"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy__shim_1a6105db1818b56affe5efbcdc20157e89"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel9execution26sequenced_task_policy_shimE" title="hpx::parallel::execution::sequenced_task_policy_shim">sequenced_task_policy_shim</a> <em class="property">const</em> &amp;<code class="descname">operator()</code><span class="sig-paren">(</span>task_policy_tag <em>tag</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8parallel9execution26sequenced_task_policy_shimclE15task_policy_tag" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a new <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy"><span class="std std-ref">sequenced_task_policy</span></a> from itself</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The new <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy"><span class="std std-ref">sequenced_task_policy</span></a> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">tag</span></code>: [in] Specify that the corresponding asynchronous execution policy should be used</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx8parallel9execution26sequenced_task_policy_shim2onERR9Executor_">
<span id="_CPPv2NK3hpx8parallel9execution26sequenced_task_policy_shim2onERR9Executor_"></span><span id="hpx::parallel::execution::sequenced_task_policy_shim::on__Executor_RRC"></span><em class="property">template </em>&lt;<em class="property">typename</em> Executor_&gt;<br /><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy__shim_1aa89fb1f432bf0593eb786874cf72dda8"></span>rebind_executor&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution26sequenced_task_policy_shimE" title="hpx::parallel::execution::sequenced_task_policy_shim">sequenced_task_policy_shim</a>, Executor_, <a class="reference internal" href="#_CPPv3N3hpx8parallel9execution26sequenced_task_policy_shim24executor_parameters_typeE" title="hpx::parallel::execution::sequenced_task_policy_shim::executor_parameters_type">executor_parameters_type</a>&gt;::type <code class="descname">on</code><span class="sig-paren">(</span>Executor_ &amp;&amp;<em>exec</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8parallel9execution26sequenced_task_policy_shim2onERR9Executor_" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a new <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy"><span class="std std-ref">sequenced_task_policy</span></a> from the given executor</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Requires: is_executor&lt;Executor&gt;::value is true</dd>
<dt><strong>Return</strong></dt>
<dd>The new <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy"><span class="std std-ref">sequenced_task_policy</span></a> </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">Executor</span></code>: The type of the executor to associate with this execution policy.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">exec</span></code>: [in] The executor to use for the execution of the parallel algorithm the returned execution policy is used with.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx8parallel9execution26sequenced_task_policy_shim4withEDpRR11Parameters_">
<span id="_CPPv2NK3hpx8parallel9execution26sequenced_task_policy_shim4withEDpRR11Parameters_"></span><span id="hpx::parallel::execution::sequenced_task_policy_shim::with__Parameters_RRDpC"></span><em class="property">template </em>&lt;typename... <em>Parameters_</em>, <em class="property">typename</em> ParametersType = typename executor_parameters_join&lt;Parameters_...&gt;::type&gt;<br /><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy__shim_1ae37922ef6cf58cf12338d72d6879c40a"></span>rebind_executor&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution26sequenced_task_policy_shimE" title="hpx::parallel::execution::sequenced_task_policy_shim">sequenced_task_policy_shim</a>, <a class="reference internal" href="#_CPPv3N3hpx8parallel9execution26sequenced_task_policy_shim13executor_typeE" title="hpx::parallel::execution::sequenced_task_policy_shim::executor_type">executor_type</a>, ParametersType&gt;::type <code class="descname">with</code><span class="sig-paren">(</span>Parameters_&amp;&amp;... <em>params</em><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8parallel9execution26sequenced_task_policy_shim4withEDpRR11Parameters_" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create a new <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy__shim"><span class="std std-ref">sequenced_task_policy_shim</span></a> from the given execution parameters</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Requires: all parameters are executor_parameters, different parameter types can’t be duplicated</dd>
<dt><strong>Return</strong></dt>
<dd>The new <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy__shim"><span class="std std-ref">sequenced_task_policy_shim</span></a> </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">Parameters</span></code>: The type of the executor parameters to associate with this execution policy.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">params</span></code>: [in] The executor parameters to use for the execution of the parallel algorithm the returned execution policy is used with.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel9execution26sequenced_task_policy_shim8executorEv">
<span id="_CPPv2N3hpx8parallel9execution26sequenced_task_policy_shim8executorEv"></span><span id="hpx::parallel::execution::sequenced_task_policy_shim::executor"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy__shim_1a93a5b36cb1d7c7b45841617a2d2263bb"></span>Executor &amp;<code class="descname">executor</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution26sequenced_task_policy_shim8executorEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the associated executor object. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx8parallel9execution26sequenced_task_policy_shim8executorEv">
<span id="_CPPv2NK3hpx8parallel9execution26sequenced_task_policy_shim8executorEv"></span><span id="hpx::parallel::execution::sequenced_task_policy_shim::executorC"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy__shim_1a422728c3949bf740fe544d4dc4437d43"></span>Executor <em class="property">const</em> &amp;<code class="descname">executor</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8parallel9execution26sequenced_task_policy_shim8executorEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the associated executor object. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel9execution26sequenced_task_policy_shim10parametersEv">
<span id="_CPPv2N3hpx8parallel9execution26sequenced_task_policy_shim10parametersEv"></span><span id="hpx::parallel::execution::sequenced_task_policy_shim::parameters"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy__shim_1a87256185a79187e4cdb6ef0de5a3a077"></span>Parameters &amp;<code class="descname">parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution26sequenced_task_policy_shim10parametersEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the associated executor parameters object. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx8parallel9execution26sequenced_task_policy_shim10parametersEv">
<span id="_CPPv2NK3hpx8parallel9execution26sequenced_task_policy_shim10parametersEv"></span><span id="hpx::parallel::execution::sequenced_task_policy_shim::parametersC"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1sequenced__task__policy__shim_1a000e646b337a5e711b33a5758c1edfea"></span>Parameters <em class="property">const</em> &amp;<code class="descname">parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8parallel9execution26sequenced_task_policy_shim10parametersEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the associated executor parameters object. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx8parallel9execution17static_chunk_sizeE">
<span id="_CPPv2N3hpx8parallel9execution17static_chunk_sizeE"></span><span id="hpx::parallel::execution::static_chunk_size"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1static__chunk__size"></span><em class="property">struct </em><code class="descname">static_chunk_size</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution17static_chunk_sizeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;static_chunk_size.hpp&gt;</em><p>Loop iterations are divided into pieces of size <em>chunk_size</em> and then assigned to threads. If <em>chunk_size</em> is not specified, the iterations are evenly (if possible) divided contiguously among the threads.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This executor parameters type is equivalent to OpenMP’s STATIC scheduling directive. </dd>
</dl>
</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel9execution17static_chunk_size17static_chunk_sizeEv">
<span id="_CPPv2N3hpx8parallel9execution17static_chunk_size17static_chunk_sizeEv"></span><span id="hpx::parallel::execution::static_chunk_size::static_chunk_size"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1static__chunk__size_1a6085fd5c9a53450f1f4b21ad1db647f0"></span><code class="descname">static_chunk_size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution17static_chunk_size17static_chunk_sizeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct a <em><a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1static__chunk__size"><span class="std std-ref">static_chunk_size</span></a></em> executor parameters object</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>By default the number of loop iterations is determined from the number of available cores and the overall number of loop iterations to schedule. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel9execution17static_chunk_size17static_chunk_sizeENSt6size_tE">
<span id="_CPPv2N3hpx8parallel9execution17static_chunk_size17static_chunk_sizeENSt6size_tE"></span><span id="hpx::parallel::execution::static_chunk_size::static_chunk_size__std::s"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1static__chunk__size_1ab0fba8aba6f1e0ef843406434b8c9c7e"></span><code class="descname">static_chunk_size</code><span class="sig-paren">(</span>std::size_t <em>chunk_size</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution17static_chunk_size17static_chunk_sizeENSt6size_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Construct a <em><a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1static__chunk__size"><span class="std std-ref">static_chunk_size</span></a></em> executor parameters object</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">chunk_size</span></code>: [in] The optional chunk size to use as the number of loop iterations to run on a single thread. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx8parallel2v210task_blockE">
<span id="_CPPv2N3hpx8parallel2v210task_blockE"></span><span id="hpx::parallel::v2::task_block"></span><span class="target" id="classhpx_1_1parallel_1_1v2_1_1task__block"></span><em class="property">template </em>&lt;typename <em>ExPolicy</em> = <a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1parallel__policy"><span class="std std-ref">parallel::execution::parallel_policy</span></a>&gt;<br /><em class="property">class </em><code class="descname">task_block</code><a class="headerlink" href="#_CPPv3N3hpx8parallel2v210task_blockE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;task_block.hpp&gt;</em><p>The class <a class="reference internal" href="#classhpx_1_1parallel_1_1v2_1_1task__block"><span class="std std-ref">task_block</span></a> defines an interface for forking and joining parallel tasks. The <em>define_task_block</em> and <em>define_task_block_restore_thread</em> function templates create an object of type <a class="reference internal" href="#classhpx_1_1parallel_1_1v2_1_1task__block"><span class="std std-ref">task_block</span></a> and pass a reference to that object to a user-provided callable object.</p>
<p>An object of class <em><a class="reference internal" href="#classhpx_1_1parallel_1_1v2_1_1task__block"><span class="std std-ref">task_block</span></a></em> cannot be constructed, destroyed, copied, or moved except by the implementation of the task region library. Taking the address of a <a class="reference internal" href="#classhpx_1_1parallel_1_1v2_1_1task__block"><span class="std std-ref">task_block</span></a> object via operator&amp; or addressof is ill formed. The result of obtaining its address by any other means is unspecified.</p>
<p>A <em><a class="reference internal" href="#classhpx_1_1parallel_1_1v2_1_1task__block"><span class="std std-ref">task_block</span></a></em><p> is active if it was created by the nearest enclosing task block, where “task block” refers to an invocation of define_task_block or define_task_block_restore_thread and “nearest</p>
<p>enclosing” means the most recent invocation that has not yet completed. Code designated for execution in another thread by means other than the facilities in this section (e.g., using thread or async) are not enclosed in the task region and a </p>
<a class="reference internal" href="#classhpx_1_1parallel_1_1v2_1_1task__block"><span class="std std-ref">task_block</span></a> passed to (or captured by) such code is not active within that code. Performing any operation on a <a class="reference internal" href="#classhpx_1_1parallel_1_1v2_1_1task__block"><span class="std std-ref">task_block</span></a> that is not active results in undefined behavior.</p>
<p>The <em><a class="reference internal" href="#classhpx_1_1parallel_1_1v2_1_1task__block"><span class="std std-ref">task_block</span></a></em> that is active before a specific call to the run member function is not active within the asynchronous function that invoked run. (The invoked function should not, therefore, capture the <em><a class="reference internal" href="#classhpx_1_1parallel_1_1v2_1_1task__block"><span class="std std-ref">task_block</span></a></em> from the surrounding block.)</p>
<p><div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="nl">Example</span><span class="p">:</span>
    <span class="n">define_task_block</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">tr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tr</span><span class="p">.</span><span class="n">run</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]</span> <span class="p">{</span>
            <span class="n">tr</span><span class="p">.</span><span class="n">run</span><span class="p">([]</span> <span class="p">{</span> <span class="n">f</span><span class="p">();</span> <span class="p">});</span>                <span class="c1">// Error: tr is not active</span>
            <span class="n">define_task_block</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">tr</span><span class="p">)</span> <span class="p">{</span>   <span class="c1">// Nested task block</span>
                <span class="n">tr</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>                      <span class="c1">// OK: inner tr is active</span>
                <span class="c1">/// ...</span>
            <span class="p">});</span>
        <span class="p">});</span>
        <span class="c1">/// ...</span>
    <span class="p">});</span>
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The execution policy an instance of a <em><a class="reference internal" href="#classhpx_1_1parallel_1_1v2_1_1task__block"><span class="std std-ref">task_block</span></a></em> was created with. This defaults to <em>parallel_policy</em>. </li>
</ul>
</dd>
</dl>
</p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="type">
<dt id="_CPPv3N3hpx8parallel2v210task_block16execution_policyE">
<span id="_CPPv2N3hpx8parallel2v210task_block16execution_policyE"></span><span id="hpx::parallel::v2::task_block::execution_policy"></span><span class="target" id="classhpx_1_1parallel_1_1v2_1_1task__block_1aab56ea8bdf25594112ccab9889c3e294"></span><em class="property">typedef </em>ExPolicy <code class="descname">execution_policy</code><a class="headerlink" href="#_CPPv3N3hpx8parallel2v210task_block16execution_policyE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Refers to the type of the execution policy used to create the <em><a class="reference internal" href="#classhpx_1_1parallel_1_1v2_1_1task__block"><span class="std std-ref">task_block</span></a></em>. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv3NK3hpx8parallel2v210task_block20get_execution_policyEv">
<span id="_CPPv2NK3hpx8parallel2v210task_block20get_execution_policyEv"></span><span id="hpx::parallel::v2::task_block::get_execution_policyC"></span><span class="target" id="classhpx_1_1parallel_1_1v2_1_1task__block_1ac6a81aa62ea26bd2b790b573af04bac6"></span><a class="reference internal" href="#_CPPv3N3hpx8parallel2v210task_block16execution_policyE" title="hpx::parallel::v2::task_block::execution_policy">execution_policy</a> <em class="property">const</em> &amp;<code class="descname">get_execution_policy</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8parallel2v210task_block20get_execution_policyEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the execution policy instance used to create this <em><a class="reference internal" href="#classhpx_1_1parallel_1_1v2_1_1task__block"><span class="std std-ref">task_block</span></a></em> </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v210task_block3runERR1FDpRR2Ts">
<span id="_CPPv2N3hpx8parallel2v210task_block3runERR1FDpRR2Ts"></span><span id="hpx::parallel::v2::task_block::run__FRR.TsRRDp"></span><em class="property">template </em>&lt;<em class="property">typename</em> F, <em class="property">typename</em> ... <em>Ts</em>&gt;<br /><span class="target" id="classhpx_1_1parallel_1_1v2_1_1task__block_1a942ef260b49d3bd93b3f63df973b577b"></span>void <code class="descname">run</code><span class="sig-paren">(</span>F &amp;&amp;<em>f</em>, Ts&amp;&amp;... <em>ts</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v210task_block3runERR1FDpRR2Ts" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Causes the expression f() to be invoked asynchronously. The invocation of f is permitted to run on an unspecified thread in an unordered fashion relative to the sequence of operations following the call to run(f) (the continuation), or indeterminately sequenced within the same thread as the continuation.</p>
<p>The call to <em>run</em> synchronizes with the invocation of f. The completion of f() synchronizes with the next invocation of wait on the same <a class="reference internal" href="#classhpx_1_1parallel_1_1v2_1_1task__block"><span class="std std-ref">task_block</span></a> or completion of the nearest enclosing task block (i.e., the <em>define_task_block</em> or <em>define_task_block_restore_thread</em> that created this task block).</p>
<p>Requires: F shall be MoveConstructible. The expression, (void)f(), shall be well-formed.</p>
<p>Precondition: this shall be the active <a class="reference internal" href="#classhpx_1_1parallel_1_1v2_1_1task__block"><span class="std std-ref">task_block</span></a>.</p>
<p>Postconditions: A call to run may return on a different thread than that on which it was called.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The call to <em>run</em> is sequenced before the continuation as if <em>run</em> returns on the same thread. The invocation of the user-supplied callable object f may be immediate or may be delayed until compute resources are available. <em>run</em> might or might not return before invocation of f completes.</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">This</span></code>: function may throw <em><a class="reference internal" href="#classhpx_1_1parallel_1_1v2_1_1task__canceled__exception"><span class="std std-ref">task_canceled_exception</span></a></em>, as described in Exception Handling. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v210task_block3runER8ExecutorRR1FDpRR2Ts">
<span id="_CPPv2N3hpx8parallel2v210task_block3runER8ExecutorRR1FDpRR2Ts"></span><span id="hpx::parallel::v2::task_block::run__ExecutorR.FRR.TsRRDp"></span><em class="property">template </em>&lt;<em class="property">typename</em> Executor, <em class="property">typename</em> F, <em class="property">typename</em> ... <em>Ts</em>&gt;<br /><span class="target" id="classhpx_1_1parallel_1_1v2_1_1task__block_1ad19e4cb24036c2adbd421cec62926821"></span>void <code class="descname">run</code><span class="sig-paren">(</span>Executor &amp;<em>exec</em>, F &amp;&amp;<em>f</em>, Ts&amp;&amp;... <em>ts</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v210task_block3runER8ExecutorRR1FDpRR2Ts" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Causes the expression f() to be invoked asynchronously using the given executor. The invocation of f is permitted to run on an unspecified thread associated with the given executor and in an unordered fashion relative to the sequence of operations following the call to run(exec, f) (the continuation), or indeterminately sequenced within the same thread as the continuation.</p>
<p>The call to <em>run</em> synchronizes with the invocation of f. The completion of f() synchronizes with the next invocation of wait on the same <a class="reference internal" href="#classhpx_1_1parallel_1_1v2_1_1task__block"><span class="std std-ref">task_block</span></a> or completion of the nearest enclosing task block (i.e., the <em>define_task_block</em> or <em>define_task_block_restore_thread</em> that created this task block).</p>
<p>Requires: Executor shall be a type modeling the Executor concept. F shall be MoveConstructible. The expression, (void)f(), shall be well-formed.</p>
<p>Precondition: this shall be the active <a class="reference internal" href="#classhpx_1_1parallel_1_1v2_1_1task__block"><span class="std std-ref">task_block</span></a>.</p>
<p>Postconditions: A call to run may return on a different thread than that on which it was called.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The call to <em>run</em> is sequenced before the continuation as if <em>run</em> returns on the same thread. The invocation of the user-supplied callable object f may be immediate or may be delayed until compute resources are available. <em>run</em> might or might not return before invocation of f completes.</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">This</span></code>: function may throw <em><a class="reference internal" href="#classhpx_1_1parallel_1_1v2_1_1task__canceled__exception"><span class="std std-ref">task_canceled_exception</span></a></em>, as described in Exception Handling. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v210task_block4waitEv">
<span id="_CPPv2N3hpx8parallel2v210task_block4waitEv"></span><span id="hpx::parallel::v2::task_block::wait"></span><span class="target" id="classhpx_1_1parallel_1_1v2_1_1task__block_1a409b3ac4d95c5f22eaf49a1012d26200"></span>void <code class="descname">wait</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v210task_block4waitEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Blocks until the tasks spawned using this <a class="reference internal" href="#classhpx_1_1parallel_1_1v2_1_1task__block"><span class="std std-ref">task_block</span></a> have finished.</p>
<p>Precondition: this shall be the active <a class="reference internal" href="#classhpx_1_1parallel_1_1v2_1_1task__block"><span class="std std-ref">task_block</span></a>.</p>
<p>Postcondition: All tasks spawned by the nearest enclosing task region have finished. A call to wait may return on a different thread than that on which it was called.</p>
<p><div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="nl">Example</span><span class="p">:</span>
    <span class="n">define_task_block</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">tr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tr</span><span class="p">.</span><span class="n">run</span><span class="p">([</span><span class="o">&amp;</span><span class="p">]{</span> <span class="n">process</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span> <span class="p">});</span> <span class="c1">// Process a[w] through a[x]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">)</span> <span class="n">tr</span><span class="p">.</span><span class="n">wait</span><span class="p">();</span>   <span class="c1">// Wait if overlap between [w, x) and [y, z)</span>
        <span class="n">process</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>       <span class="c1">// Process a[y] through a[z]</span>
    <span class="p">});</span>
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The call to <em>wait</em> is sequenced before the continuation as if <em>wait</em> returns on the same thread.</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">This</span></code>: function may throw <em><a class="reference internal" href="#classhpx_1_1parallel_1_1v2_1_1task__canceled__exception"><span class="std std-ref">task_canceled_exception</span></a></em>, as described in Exception Handling.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v210task_block6policyEv">
<span id="_CPPv2N3hpx8parallel2v210task_block6policyEv"></span><span id="hpx::parallel::v2::task_block::policy"></span><span class="target" id="classhpx_1_1parallel_1_1v2_1_1task__block_1a1e54dbb3c28c991b928548366f500455"></span>ExPolicy &amp;<code class="descname">policy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v210task_block6policyEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns a reference to the execution policy used to construct this object.</p>
<p>Precondition: this shall be the active <a class="reference internal" href="#classhpx_1_1parallel_1_1v2_1_1task__block"><span class="std std-ref">task_block</span></a>. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3NK3hpx8parallel2v210task_block6policyEv">
<span id="_CPPv2NK3hpx8parallel2v210task_block6policyEv"></span><span id="hpx::parallel::v2::task_block::policyC"></span><span class="target" id="classhpx_1_1parallel_1_1v2_1_1task__block_1a3a481461d7f33eff0c9b6df4bb093593"></span>ExPolicy <em class="property">const</em> &amp;<code class="descname">policy</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">const</em><a class="headerlink" href="#_CPPv3NK3hpx8parallel2v210task_block6policyEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns a reference to the execution policy used to construct this object.</p>
<p>Precondition: this shall be the active <a class="reference internal" href="#classhpx_1_1parallel_1_1v2_1_1task__block"><span class="std std-ref">task_block</span></a>. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Private Members</p>
<dl class="member">
<dt id="_CPPv3N3hpx8parallel2v210task_block4mtx_E">
<span id="_CPPv2N3hpx8parallel2v210task_block4mtx_E"></span><span id="hpx::parallel::v2::task_block::mtx___mutex_type"></span><span class="target" id="classhpx_1_1parallel_1_1v2_1_1task__block_1a7b2dc2eea923d591eb814e432ec597b2"></span>mutex_type <code class="descname">mtx_</code><a class="headerlink" href="#_CPPv3N3hpx8parallel2v210task_block4mtx_E" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv3N3hpx8parallel2v210task_block6tasks_E">
<span id="_CPPv2N3hpx8parallel2v210task_block6tasks_E"></span><span id="hpx::parallel::v2::task_block::tasks___std::vector:hpx::future:void::"></span><span class="target" id="classhpx_1_1parallel_1_1v2_1_1task__block_1acf5200a8cf8e8866fcd5885c2de4cfe6"></span>std::vector&lt;<a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::future&lt;void&gt;&gt; <code class="descname">tasks_</code><a class="headerlink" href="#_CPPv3N3hpx8parallel2v210task_block6tasks_E" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv3N3hpx8parallel2v210task_block7errors_E">
<span id="_CPPv2N3hpx8parallel2v210task_block7errors_E"></span><span id="hpx::parallel::v2::task_block::errors___parallel::exception_list"></span><span class="target" id="classhpx_1_1parallel_1_1v2_1_1task__block_1a01521453dc95bf19d361bd99e2d0c4aa"></span><a class="reference internal" href="#_CPPv3N3hpx8parallelE" title="hpx::parallel">parallel</a>::exception_list <code class="descname">errors_</code><a class="headerlink" href="#_CPPv3N3hpx8parallel2v210task_block7errors_E" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv3N3hpx8parallel2v210task_block3id_E">
<span id="_CPPv2N3hpx8parallel2v210task_block3id_E"></span><span id="hpx::parallel::v2::task_block::id___threads::thread_id_type"></span><span class="target" id="classhpx_1_1parallel_1_1v2_1_1task__block_1a3ac0cb819cb10fa1847d8207228b81ba"></span><a class="reference internal" href="#_CPPv3N3hpx7threadsE" title="hpx::threads">threads</a>::thread_id_type <code class="descname">id_</code><a class="headerlink" href="#_CPPv3N3hpx8parallel2v210task_block3id_E" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv3N3hpx8parallel2v210task_block7policy_E">
<span id="_CPPv2N3hpx8parallel2v210task_block7policy_E"></span><span id="hpx::parallel::v2::task_block::policy___ExPolicy"></span><span class="target" id="classhpx_1_1parallel_1_1v2_1_1task__block_1a4cbbea8135c1507e713de14d0e8be80b"></span>ExPolicy <code class="descname">policy_</code><a class="headerlink" href="#_CPPv3N3hpx8parallel2v210task_block7policy_E" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx8parallel2v223task_canceled_exceptionE">
<span id="_CPPv2N3hpx8parallel2v223task_canceled_exceptionE"></span><span id="hpx::parallel::v2::task_canceled_exception"></span><span class="target" id="classhpx_1_1parallel_1_1v2_1_1task__canceled__exception"></span><em class="property">class </em><code class="descname">task_canceled_exception</code> : <em class="property">public</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx9exceptionE" title="hpx::exception">exception</a><a class="headerlink" href="#_CPPv3N3hpx8parallel2v223task_canceled_exceptionE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;task_block.hpp&gt;</em><p>The class <em><a class="reference internal" href="#classhpx_1_1parallel_1_1v2_1_1task__canceled__exception"><span class="std std-ref">task_canceled_exception</span></a></em> defines the type of objects thrown by <a class="reference internal" href="#classhpx_1_1parallel_1_1v2_1_1task__block_1a942ef260b49d3bd93b3f63df973b577b"><span class="std std-ref">task_block::run</span></a> or <a class="reference internal" href="#classhpx_1_1parallel_1_1v2_1_1task__block_1a409b3ac4d95c5f22eaf49a1012d26200"><span class="std std-ref">task_block::wait</span></a> if they detect that an exception is pending within the current parallel region. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v223task_canceled_exception23task_canceled_exceptionEv">
<span id="_CPPv2N3hpx8parallel2v223task_canceled_exception23task_canceled_exceptionEv"></span><span id="hpx::parallel::v2::task_canceled_exception::task_canceled_exception"></span><span class="target" id="classhpx_1_1parallel_1_1v2_1_1task__canceled__exception_1a43819a01d060a4fec05b558537a30db0"></span><code class="descname">task_canceled_exception</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v223task_canceled_exception23task_canceled_exceptionEv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx18thread_interruptedE">
<span id="_CPPv2N3hpx18thread_interruptedE"></span><span id="hpx::thread_interrupted"></span><span class="target" id="structhpx_1_1thread__interrupted"></span><em class="property">struct </em><code class="descname">thread_interrupted</code> : <em class="property">public</em> <a class="reference internal" href="#_CPPv3N3hpx9exceptionE" title="hpx::exception">exception</a><a class="headerlink" href="#_CPPv3N3hpx18thread_interruptedE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;exception.hpp&gt;</em><p>A <a class="reference internal" href="#structhpx_1_1thread__interrupted"><span class="std std-ref">hpx::thread_interrupted</span></a> is the exception type used by HPX to interrupt a running HPX thread. </p>
<p>The <em><a class="reference internal" href="#structhpx_1_1thread__interrupted"><span class="std std-ref">hpx::thread_interrupted</span></a></em> type is the exception type used by HPX to interrupt a running thread.</p>
<p>A running thread can be interrupted by invoking the interrupt() member function of the corresponding hpx::thread object. When the interrupted thread next executes one of the specified interruption points (or if it is currently blocked whilst executing one) with interruption enabled, then a <a class="reference internal" href="#structhpx_1_1thread__interrupted"><span class="std std-ref">hpx::thread_interrupted</span></a> exception will be thrown in the interrupted thread. If not caught, this will cause the execution of the interrupted thread to terminate. As with any other exception, the stack will be unwound, and destructors for objects of automatic storage duration will be executed.</p>
<p>If a thread wishes to avoid being interrupted, it can create an instance of <em>hpx::this_thread::disable_interruption</em>. Objects of this class disable interruption for the thread that created them on construction, and restore the interruption state to whatever it was before on destruction.</p>
<p><div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// interruption enabled here</span>
    <span class="p">{</span>
        <span class="n">hpx</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">disable_interruption</span> <span class="n">di</span><span class="p">;</span>
        <span class="c1">// interruption disabled</span>
        <span class="p">{</span>
            <span class="n">hpx</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">disable_interruption</span> <span class="n">di2</span><span class="p">;</span>
            <span class="c1">// interruption still disabled</span>
        <span class="p">}</span> <span class="c1">// di2 destroyed, interruption state restored</span>
        <span class="c1">// interruption still disabled</span>
    <span class="p">}</span> <span class="c1">// di destroyed, interruption state restored</span>
    <span class="c1">// interruption now enabled</span>
<span class="p">}</span>
</pre></div>
</div>
</p>
<p>The effects of an instance of <em>hpx::this_thread::disable_interruption</em> can be temporarily reversed by constructing an instance of <em>hpx::this_thread::restore_interruption</em>, passing in the <em>hpx::this_thread::disable_interruption</em> object in question. This will restore the interruption state to what it was when the <em>hpx::this_thread::disable_interruption</em> object was constructed, and then disable interruption again when the <em>hpx::this_thread::restore_interruption</em> object is destroyed.</p>
<p><div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">g</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// interruption enabled here</span>
    <span class="p">{</span>
        <span class="n">hpx</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">disable_interruption</span> <span class="n">di</span><span class="p">;</span>
        <span class="c1">// interruption disabled</span>
        <span class="p">{</span>
            <span class="n">hpx</span><span class="o">::</span><span class="n">this_thread</span><span class="o">::</span><span class="n">restore_interruption</span> <span class="n">ri</span><span class="p">(</span><span class="n">di</span><span class="p">);</span>
            <span class="c1">// interruption now enabled</span>
        <span class="p">}</span> <span class="c1">// ri destroyed, interruption disable again</span>
    <span class="p">}</span> <span class="c1">// di destroyed, interruption state restored</span>
    <span class="c1">// interruption now enabled</span>
<span class="p">}</span>
</pre></div>
</div>
</p>
<p>At any point, the interruption state for the current thread can be queried by calling <em>hpx::this_thread::interruption_enabled()</em>. </p>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx7threads16thread_pool_baseE">
<span id="_CPPv2N3hpx7threads16thread_pool_baseE"></span><span id="hpx::threads::thread_pool_base"></span><span class="target" id="classhpx_1_1threads_1_1thread__pool__base"></span><em class="property">class </em><code class="descname">thread_pool_base</code> : <em class="property">public</em> manage_executor<a class="headerlink" href="#_CPPv3N3hpx7threads16thread_pool_baseE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;thread_pool_base.hpp&gt;</em><p>The base class used to manage a pool of OS threads. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx7threads16thread_pool_base6resumeEv">
<span id="_CPPv2N3hpx7threads16thread_pool_base6resumeEv"></span><span id="hpx::threads::thread_pool_base::resume"></span><span class="target" id="classhpx_1_1threads_1_1thread__pool__base_1a4fa782673f76257704e67b9a7b0f9e30"></span><em class="property">virtual</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::future&lt;void&gt; <code class="descname">resume</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv3N3hpx7threads16thread_pool_base6resumeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Resumes the thread pool. When the all OS threads on the thread pool have been resumed the returned future will be ready.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can only be called from an HPX thread. Use resume_cb or resume_direct to suspend the pool from outside HPX.</dd>
<dt><strong>Return</strong></dt>
<dd>A <code class="docutils literal notranslate"><span class="pre">future&lt;void&gt;</span></code> which is ready when the thread pool has been resumed.</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref"><span class="pre">hpx::exception</span></span></a></code>: if called from outside the HPX runtime. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7threads16thread_pool_base9resume_cbENSt8functionIFvvEEER10error_code">
<span id="_CPPv2N3hpx7threads16thread_pool_base9resume_cbENSt8functionIFvvEEER10error_code"></span><span class="target" id="classhpx_1_1threads_1_1thread__pool__base_1a8e98492a4f4ceb0149468dcba8977ae2"></span><em class="property">virtual</em> void <code class="descname">resume_cb</code><span class="sig-paren">(</span>std::function&lt;void<span class="sig-paren">(</span>void<span class="sig-paren">)</span>&gt; <em>callback</em>, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a>, <span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv3N3hpx7threads16thread_pool_base9resume_cbENSt8functionIFvvEEER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Resumes the thread pool. Takes a callback as a parameter which will be called when all OS threads on the thread pool have been resumed.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">callback</span></code>: [in] called when the thread pool has been resumed. </li>
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7threads16thread_pool_base13resume_directER10error_code">
<span id="_CPPv2N3hpx7threads16thread_pool_base13resume_directER10error_code"></span><span id="hpx::threads::thread_pool_base::resume_direct__error_codeR"></span><span class="target" id="classhpx_1_1threads_1_1thread__pool__base_1a3f1472693c67bf8f57ef57dcc048c42e"></span><em class="property">virtual</em> void <code class="descname">resume_direct</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv3N3hpx7threads16thread_pool_base13resume_directER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Resumes the thread pool. Blocks until all OS threads on the thread pool have been resumed.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7threads16thread_pool_base7suspendEv">
<span id="_CPPv2N3hpx7threads16thread_pool_base7suspendEv"></span><span id="hpx::threads::thread_pool_base::suspend"></span><span class="target" id="classhpx_1_1threads_1_1thread__pool__base_1a339a0e4bb761b9b09f55ade74a6c712e"></span><em class="property">virtual</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::future&lt;void&gt; <code class="descname">suspend</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv3N3hpx7threads16thread_pool_base7suspendEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Suspends the thread pool. When the all OS threads on the thread pool have been suspended the returned future will be ready.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can only be called from an HPX thread. Use suspend_cb or suspend_direct to suspend the pool from outside HPX. A thread pool cannot be suspended from an HPX thread running on the pool itself.</dd>
<dt><strong>Return</strong></dt>
<dd>A <code class="docutils literal notranslate"><span class="pre">future&lt;void&gt;</span></code> which is ready when the thread pool has been suspended.</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref"><span class="pre">hpx::exception</span></span></a></code>: if called from outside the HPX runtime. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7threads16thread_pool_base10suspend_cbENSt8functionIFvvEEER10error_code">
<span id="_CPPv2N3hpx7threads16thread_pool_base10suspend_cbENSt8functionIFvvEEER10error_code"></span><span class="target" id="classhpx_1_1threads_1_1thread__pool__base_1a52360b972a0d1f530201e3007a136f4b"></span><em class="property">virtual</em> void <code class="descname">suspend_cb</code><span class="sig-paren">(</span>std::function&lt;void<span class="sig-paren">(</span>void<span class="sig-paren">)</span>&gt; <em>callback</em>, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a>, <span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv3N3hpx7threads16thread_pool_base10suspend_cbENSt8functionIFvvEEER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Suspends the thread pool. Takes a callback as a parameter which will be called when all OS threads on the thread pool have been suspended.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>A thread pool cannot be suspended from an HPX thread running on the pool itself.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">callback</span></code>: [in] called when the thread pool has been suspended. </li>
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref"><span class="pre">hpx::exception</span></span></a></code>: if called from an HPX thread which is running on the pool itself. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7threads16thread_pool_base14suspend_directER10error_code">
<span id="_CPPv2N3hpx7threads16thread_pool_base14suspend_directER10error_code"></span><span id="hpx::threads::thread_pool_base::suspend_direct__error_codeR"></span><span class="target" id="classhpx_1_1threads_1_1thread__pool__base_1a19fe3f5cfbe6e5257873b53936c03b98"></span><em class="property">virtual</em> void <code class="descname">suspend_direct</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv3N3hpx7threads16thread_pool_base14suspend_directER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Suspends the thread pool. Blocks until all OS threads on the thread pool have been suspended.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>A thread pool cannot be suspended from an HPX thread running on the pool itself.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref"><span class="pre">hpx::exception</span></span></a></code>: if called from an HPX thread which is running on the pool itself. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7threads16thread_pool_base23suspend_processing_unitENSt6size_tE">
<span id="_CPPv2N3hpx7threads16thread_pool_base23suspend_processing_unitENSt6size_tE"></span><span id="hpx::threads::thread_pool_base::suspend_processing_unit__std::s"></span><span class="target" id="classhpx_1_1threads_1_1thread__pool__base_1a7bbb4345b56474b066f985a7fb18377b"></span><em class="property">virtual</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::future&lt;void&gt; <code class="descname">suspend_processing_unit</code><span class="sig-paren">(</span>std::size_t <em>virt_core</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv3N3hpx7threads16thread_pool_base23suspend_processing_unitENSt6size_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Suspends the given processing unit. When the processing unit has been suspended the returned future will be ready.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can only be called from an HPX thread. Use suspend_processing_unit_cb or to suspend the processing unit from outside HPX. Requires that the pool has <a class="reference internal" href="#namespacehpx_1_1threads_1_1policies_1a69bdc4ea03e29d7326c155278b0fc386a4f494c1a6b130fa4d79673a0fe753208"><span class="std std-ref">threads::policies::enable_elasticity</span></a> set.</dd>
<dt><strong>Return</strong></dt>
<dd>A <code class="docutils literal notranslate"><span class="pre">future&lt;void&gt;</span></code> which is ready when the given processing unit has been suspended.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">virt_core</span></code>: [in] The processing unit on the the pool to be suspended. The processing units are indexed starting from 0.</li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref"><span class="pre">hpx::exception</span></span></a></code>: if called from outside the HPX runtime. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7threads16thread_pool_base26suspend_processing_unit_cbENSt8functionIFvvEEENSt6size_tER10error_code">
<span id="_CPPv2N3hpx7threads16thread_pool_base26suspend_processing_unit_cbENSt8functionIFvvEEENSt6size_tER10error_code"></span><span class="target" id="classhpx_1_1threads_1_1thread__pool__base_1aa0a0b203ae00420b1bdfc52f2d16932f"></span><em class="property">virtual</em> void <code class="descname">suspend_processing_unit_cb</code><span class="sig-paren">(</span>std::function&lt;void<span class="sig-paren">(</span>void<span class="sig-paren">)</span>&gt; <em>callback</em>, std::size_t <em>virt_core</em>, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a>, <span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv3N3hpx7threads16thread_pool_base26suspend_processing_unit_cbENSt8functionIFvvEEENSt6size_tER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Suspends the given processing unit. Takes a callback as a parameter which will be called when the processing unit has been suspended.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Requires that the pool has <a class="reference internal" href="#namespacehpx_1_1threads_1_1policies_1a69bdc4ea03e29d7326c155278b0fc386a4f494c1a6b130fa4d79673a0fe753208"><span class="std std-ref">threads::policies::enable_elasticity</span></a> set.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">callback</span></code>: [in] Callback which is called when the processing unit has been suspended. </li>
<li><code class="docutils literal notranslate"><span class="pre">virt_core</span></code>: [in] The processing unit to suspend. </li>
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7threads16thread_pool_base22resume_processing_unitENSt6size_tE">
<span id="_CPPv2N3hpx7threads16thread_pool_base22resume_processing_unitENSt6size_tE"></span><span id="hpx::threads::thread_pool_base::resume_processing_unit__std::s"></span><span class="target" id="classhpx_1_1threads_1_1thread__pool__base_1af436f4083abaf7463913e2c2672f0dac"></span><em class="property">virtual</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::future&lt;void&gt; <code class="descname">resume_processing_unit</code><span class="sig-paren">(</span>std::size_t <em>virt_core</em><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv3N3hpx7threads16thread_pool_base22resume_processing_unitENSt6size_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Resumes the given processing unit. When the processing unit has been resumed the returned future will be ready.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Can only be called from an HPX thread. Use resume_processing_unit_cb or to resume the processing unit from outside HPX. Requires that the pool has <a class="reference internal" href="#namespacehpx_1_1threads_1_1policies_1a69bdc4ea03e29d7326c155278b0fc386a4f494c1a6b130fa4d79673a0fe753208"><span class="std std-ref">threads::policies::enable_elasticity</span></a> set.</dd>
<dt><strong>Return</strong></dt>
<dd>A <code class="docutils literal notranslate"><span class="pre">future&lt;void&gt;</span></code> which is ready when the given processing unit has been resumed. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">virt_core</span></code>: [in] The processing unit on the the pool to be resumed. The processing units are indexed starting from 0.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7threads16thread_pool_base25resume_processing_unit_cbENSt8functionIFvvEEENSt6size_tER10error_code">
<span id="_CPPv2N3hpx7threads16thread_pool_base25resume_processing_unit_cbENSt8functionIFvvEEENSt6size_tER10error_code"></span><span class="target" id="classhpx_1_1threads_1_1thread__pool__base_1aa3173e3f709284a6c7df2cc010d7ae10"></span><em class="property">virtual</em> void <code class="descname">resume_processing_unit_cb</code><span class="sig-paren">(</span>std::function&lt;void<span class="sig-paren">(</span>void<span class="sig-paren">)</span>&gt; <em>callback</em>, std::size_t <em>virt_core</em>, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a>, <span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv3N3hpx7threads16thread_pool_base25resume_processing_unit_cbENSt8functionIFvvEEENSt6size_tER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Resumes the given processing unit. Takes a callback as a parameter which will be called when the processing unit has been resumed.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Requires that the pool has <a class="reference internal" href="#namespacehpx_1_1threads_1_1policies_1a69bdc4ea03e29d7326c155278b0fc386a4f494c1a6b130fa4d79673a0fe753208"><span class="std std-ref">threads::policies::enable_elasticity</span></a> set.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">callback</span></code>: [in] Callback which is called when the processing unit has been suspended. </li>
<li><code class="docutils literal notranslate"><span class="pre">virt_core</span></code>: [in] The processing unit to resume. </li>
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx7threads20thread_schedule_hintE">
<span id="_CPPv2N3hpx7threads20thread_schedule_hintE"></span><span id="hpx::threads::thread_schedule_hint"></span><span class="target" id="structhpx_1_1threads_1_1thread__schedule__hint"></span><em class="property">struct </em><code class="descname">thread_schedule_hint</code><a class="headerlink" href="#_CPPv3N3hpx7threads20thread_schedule_hintE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;thread_enums.hpp&gt;</em><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx7threads20thread_schedule_hint20thread_schedule_hintEv">
<span id="_CPPv2N3hpx7threads20thread_schedule_hint20thread_schedule_hintEv"></span><span id="hpx::threads::thread_schedule_hint::thread_schedule_hint"></span><span class="target" id="structhpx_1_1threads_1_1thread__schedule__hint_1a62a25d092755ec8b1fc3f2570e342c94"></span><code class="descname">thread_schedule_hint</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx7threads20thread_schedule_hint20thread_schedule_hintEv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7threads20thread_schedule_hint20thread_schedule_hintENSt7int16_tE">
<span id="_CPPv2N3hpx7threads20thread_schedule_hint20thread_schedule_hintENSt7int16_tE"></span><span id="hpx::threads::thread_schedule_hint::thread_schedule_hint__std::int16_t"></span><span class="target" id="structhpx_1_1threads_1_1thread__schedule__hint_1a3061741bc7a205932c5df42d41a4ae26"></span><code class="descname">thread_schedule_hint</code><span class="sig-paren">(</span>std::int16_t <em>thread_hint</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx7threads20thread_schedule_hint20thread_schedule_hintENSt7int16_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7threads20thread_schedule_hint20thread_schedule_hintE25thread_schedule_hint_modeNSt7int16_tE">
<span id="_CPPv2N3hpx7threads20thread_schedule_hint20thread_schedule_hintE25thread_schedule_hint_modeNSt7int16_tE"></span><span id="hpx::threads::thread_schedule_hint::thread_schedule_hint__thread_schedule_hint_mode.std::int16_t"></span><span class="target" id="structhpx_1_1threads_1_1thread__schedule__hint_1a86a52584d9b969a682a01bb18d85e087"></span><code class="descname">thread_schedule_hint</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx7threads25thread_schedule_hint_modeE" title="hpx::threads::thread_schedule_hint_mode">thread_schedule_hint_mode</a> <em>mode</em>, std::int16_t <em>hint</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx7threads20thread_schedule_hint20thread_schedule_hintE25thread_schedule_hint_modeNSt7int16_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Members</p>
<dl class="member">
<dt id="_CPPv3N3hpx7threads20thread_schedule_hint4modeE">
<span id="_CPPv2N3hpx7threads20thread_schedule_hint4modeE"></span><span id="hpx::threads::thread_schedule_hint::mode__thread_schedule_hint_mode"></span><span class="target" id="structhpx_1_1threads_1_1thread__schedule__hint_1a7e362378c52f387824151f5ff4e97503"></span><a class="reference internal" href="#_CPPv3N3hpx7threads25thread_schedule_hint_modeE" title="hpx::threads::thread_schedule_hint_mode">thread_schedule_hint_mode</a> <code class="descname">mode</code><a class="headerlink" href="#_CPPv3N3hpx7threads20thread_schedule_hint4modeE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv3N3hpx7threads20thread_schedule_hint4hintE">
<span id="_CPPv2N3hpx7threads20thread_schedule_hint4hintE"></span><span id="hpx::threads::thread_schedule_hint::hint__std::int16_t"></span><span class="target" id="structhpx_1_1threads_1_1thread__schedule__hint_1abd8195cf6b0f718c1aab2214fdecfdf6"></span>std::int16_t <code class="descname">hint</code><a class="headerlink" href="#_CPPv3N3hpx7threads20thread_schedule_hint4hintE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx8parallel9execution25unsequenced_execution_tagE">
<span id="_CPPv2N3hpx8parallel9execution25unsequenced_execution_tagE"></span><span id="hpx::parallel::execution::unsequenced_execution_tag"></span><span class="target" id="structhpx_1_1parallel_1_1execution_1_1unsequenced__execution__tag"></span><em class="property">struct </em><code class="descname">unsequenced_execution_tag</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9execution25unsequenced_execution_tagE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;execution_fwd.hpp&gt;</em><p>Function invocations executed by a group of vector execution agents are permitted to execute in unordered fashion when executed in different threads, and un-sequenced with respect to one another when executed in the same thread.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd><em><a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1unsequenced__execution__tag"><span class="std std-ref">unsequenced_execution_tag</span></a></em> is weaker than <em><a class="reference internal" href="#structhpx_1_1parallel_1_1execution_1_1parallel__execution__tag"><span class="std std-ref">parallel_execution_tag</span></a></em>. </dd>
</dl>
</p>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx4util10functional6unwrapE">
<span id="_CPPv2N3hpx4util10functional6unwrapE"></span><span id="hpx::util::functional::unwrap"></span><span class="target" id="structhpx_1_1util_1_1functional_1_1unwrap"></span><em class="property">struct </em><code class="descname">unwrap</code><a class="headerlink" href="#_CPPv3N3hpx4util10functional6unwrapE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;unwrap.hpp&gt;</em><p>A helper function object for functionally invoking <code class="docutils literal notranslate"><a class="reference internal" href="#namespacehpx_1_1util_1a687bc9b163ccbdaaa82764b171b7f0c0"><span class="std std-ref"><span class="pre">hpx::util::unwrap</span></span></a></code>. For more information please refer to its documentation. </p>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx4util10functional10unwrap_allE">
<span id="_CPPv2N3hpx4util10functional10unwrap_allE"></span><span id="hpx::util::functional::unwrap_all"></span><span class="target" id="structhpx_1_1util_1_1functional_1_1unwrap__all"></span><em class="property">struct </em><code class="descname">unwrap_all</code><a class="headerlink" href="#_CPPv3N3hpx4util10functional10unwrap_allE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;unwrap.hpp&gt;</em><p>A helper function object for functionally invoking <code class="docutils literal notranslate"><a class="reference internal" href="#namespacehpx_1_1util_1a72dc824c1b2fe406b75984d0f3c131d5"><span class="std std-ref"><span class="pre">hpx::util::unwrap_all</span></span></a></code>. For more information please refer to its documentation. </p>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx4util10functional8unwrap_nE">
<span id="_CPPv2N3hpx4util10functional8unwrap_nE"></span><span id="hpx::util::functional::unwrap_n"></span><span class="target" id="structhpx_1_1util_1_1functional_1_1unwrap__n"></span><em class="property">template </em>&lt;std::size_t <em>Depth</em>&gt;<br /><em class="property">struct </em><code class="descname">unwrap_n</code><a class="headerlink" href="#_CPPv3N3hpx4util10functional8unwrap_nE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;unwrap.hpp&gt;</em><p>A helper function object for functionally invoking <code class="docutils literal notranslate"><a class="reference internal" href="#namespacehpx_1_1util_1a916ca91b9993c4f1e77feeed738631bb"><span class="std std-ref"><span class="pre">hpx::util::unwrap_n</span></span></a></code>. For more information please refer to its documentation. </p>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx15when_any_resultE">
<span id="_CPPv2N3hpx15when_any_resultE"></span><span id="hpx::when_any_result"></span><span class="target" id="structhpx_1_1when__any__result"></span><em class="property">template </em>&lt;typename <em>Sequence</em>&gt;<br /><em class="property">struct </em><code class="descname">when_any_result</code><a class="headerlink" href="#_CPPv3N3hpx15when_any_resultE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;when_any.hpp&gt;</em><p>Result type for <em>when_any</em>, contains a sequence of futures and an index pointing to a ready future. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Members</p>
<dl class="member">
<dt id="_CPPv3N3hpx15when_any_result5indexE">
<span id="_CPPv2N3hpx15when_any_result5indexE"></span><span id="hpx::when_any_result::index__std::s"></span><span class="target" id="structhpx_1_1when__any__result_1a972c8f8603fe26be77f8e3807b1e4ba0"></span>std::size_t <code class="descname">index</code><a class="headerlink" href="#_CPPv3N3hpx15when_any_result5indexE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The index of a future which has become ready. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv3N3hpx15when_any_result7futuresE">
<span id="_CPPv2N3hpx15when_any_result7futuresE"></span><span id="hpx::when_any_result::futures__Sequence"></span><span class="target" id="structhpx_1_1when__any__result_1ae93c233daa7b0a2ea3156c7fb841efd4"></span>Sequence <code class="descname">futures</code><a class="headerlink" href="#_CPPv3N3hpx15when_any_result7futuresE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The sequence of futures as passed to <em><a class="reference internal" href="#namespacehpx_1a39262d7122af673a49fe039cd8f860d9"><span class="std std-ref">hpx::when_any</span></a></em>. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="class">
<dt id="_CPPv3N3hpx16when_some_resultE">
<span id="_CPPv2N3hpx16when_some_resultE"></span><span id="hpx::when_some_result"></span><span class="target" id="structhpx_1_1when__some__result"></span><em class="property">template </em>&lt;typename <em>Sequence</em>&gt;<br /><em class="property">struct </em><code class="descname">when_some_result</code><a class="headerlink" href="#_CPPv3N3hpx16when_some_resultE" title="Permalink to this definition">¶</a><br /></dt>
<dd><em>#include &lt;when_some.hpp&gt;</em><p>Result type for <em>when_some</em>, contains a sequence of futures and indices pointing to ready futures. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Members</p>
<dl class="member">
<dt id="_CPPv3N3hpx16when_some_result7indicesE">
<span id="_CPPv2N3hpx16when_some_result7indicesE"></span><span id="hpx::when_some_result::indices__std::vector:std::s:"></span><span class="target" id="structhpx_1_1when__some__result_1a07fc76821e9aa559feb559bdfe1f89ac"></span>std::vector&lt;std::size_t&gt; <code class="descname">indices</code><a class="headerlink" href="#_CPPv3N3hpx16when_some_result7indicesE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>List of indices of futures which became ready. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv3N3hpx16when_some_result7futuresE">
<span id="_CPPv2N3hpx16when_some_result7futuresE"></span><span id="hpx::when_some_result::futures__Sequence"></span><span class="target" id="structhpx_1_1when__some__result_1a3ee7c853fdc2aa8760c9f1a07656ba15"></span>Sequence <code class="descname">futures</code><a class="headerlink" href="#_CPPv3N3hpx16when_some_result7futuresE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The sequence of futures as passed to <em><a class="reference internal" href="#namespacehpx_1a4bd1040a6422fc4653e90cdbb56ac8a7"><span class="std std-ref">hpx::when_some</span></a></em>. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="type">
<dt id="_CPPv37applier">
<span id="_CPPv27applier"></span><span id="applier"></span><span class="target" id="namespaceapplier"></span><em class="property">namespace </em><code class="descname">applier</code><a class="headerlink" href="#_CPPv37applier" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The namespace <em>applier</em> contains all definitions needed for the class <em>hpx::applier::applier</em> and its related functionality. This namespace is part of the HPX core module. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv33hpx">
<span id="_CPPv23hpx"></span><span id="hpx"></span><span class="target" id="namespacehpx"></span><em class="property">namespace </em><code class="descname">hpx</code><a class="headerlink" href="#_CPPv33hpx" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Unnamed Group</p>
<dl class="function">
<dt id="_CPPv3N3hpx15make_error_codeE5error9throwmode">
<span id="_CPPv2N3hpx15make_error_codeE5error9throwmode"></span><span id="hpx::make_error_code__error.throwmode"></span><span class="target" id="namespacehpx_1a154bc03d8bffebc41d36767f98aea4b0"></span><a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> <code class="descname">make_error_code</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx5errorE" title="hpx::error">error</a> <em>e</em>, <a class="reference internal" href="#_CPPv3N3hpx9throwmodeE" title="hpx::throwmode">throwmode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv3N3hpx5plainE" title="hpx::plain">plain</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx15make_error_codeE5error9throwmode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns a new <a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">error_code</span></a> constructed from the given parameters. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx15make_error_codeE5errorPcPcl9throwmode">
<span id="_CPPv2N3hpx15make_error_codeE5errorPcPcl9throwmode"></span><span id="hpx::make_error_code__error.cCP.cCP.l.throwmode"></span><span class="target" id="namespacehpx_1a61fb06ff5a3f5947e3880b4b1a3e61cd"></span><a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> <code class="descname">make_error_code</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx5errorE" title="hpx::error">error</a> <em>e</em>, char <em class="property">const</em> *<em>func</em>, char <em class="property">const</em> *<em>file</em>, long <em>line</em>, <a class="reference internal" href="#_CPPv3N3hpx9throwmodeE" title="hpx::throwmode">throwmode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv3N3hpx5plainE" title="hpx::plain">plain</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx15make_error_codeE5errorPcPcl9throwmode" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx15make_error_codeE5errorPc9throwmode">
<span id="_CPPv2N3hpx15make_error_codeE5errorPc9throwmode"></span><span id="hpx::make_error_code__error.cCP.throwmode"></span><span class="target" id="namespacehpx_1a1e7c6cb205e954cff6a0f5ebc16910dd"></span><a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> <code class="descname">make_error_code</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx5errorE" title="hpx::error">error</a> <em>e</em>, char <em class="property">const</em> *<em>msg</em>, <a class="reference internal" href="#_CPPv3N3hpx9throwmodeE" title="hpx::throwmode">throwmode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv3N3hpx5plainE" title="hpx::plain">plain</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx15make_error_codeE5errorPc9throwmode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns error_code(e, msg, mode). </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx15make_error_codeE5errorPcPcPcl9throwmode">
<span id="_CPPv2N3hpx15make_error_codeE5errorPcPcPcl9throwmode"></span><span id="hpx::make_error_code__error.cCP.cCP.cCP.l.throwmode"></span><span class="target" id="namespacehpx_1a9a429ed3e3c4c2caa9318db4e3aa59f9"></span><a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> <code class="descname">make_error_code</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx5errorE" title="hpx::error">error</a> <em>e</em>, char <em class="property">const</em> *<em>msg</em>, char <em class="property">const</em> *<em>func</em>, char <em class="property">const</em> *<em>file</em>, long <em>line</em>, <a class="reference internal" href="#_CPPv3N3hpx9throwmodeE" title="hpx::throwmode">throwmode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv3N3hpx5plainE" title="hpx::plain">plain</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx15make_error_codeE5errorPcPcPcl9throwmode" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx15make_error_codeE5errorRNSt6stringE9throwmode">
<span id="_CPPv2N3hpx15make_error_codeE5errorRNSt6stringE9throwmode"></span><span id="hpx::make_error_code__error.ssCR.throwmode"></span><span class="target" id="namespacehpx_1a9afcc24e5e65a909548c8c46bae77e55"></span><a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> <code class="descname">make_error_code</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx5errorE" title="hpx::error">error</a> <em>e</em>, std::string <em class="property">const</em> &amp;<em>msg</em>, <a class="reference internal" href="#_CPPv3N3hpx9throwmodeE" title="hpx::throwmode">throwmode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv3N3hpx5plainE" title="hpx::plain">plain</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx15make_error_codeE5errorRNSt6stringE9throwmode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns error_code(e, msg, mode). </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx15make_error_codeE5errorRNSt6stringEPcPcl9throwmode">
<span id="_CPPv2N3hpx15make_error_codeE5errorRNSt6stringEPcPcl9throwmode"></span><span id="hpx::make_error_code__error.ssCR.cCP.cCP.l.throwmode"></span><span class="target" id="namespacehpx_1a9f2d15bb1a55b29529922cc8e38397bc"></span><a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> <code class="descname">make_error_code</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx5errorE" title="hpx::error">error</a> <em>e</em>, std::string <em class="property">const</em> &amp;<em>msg</em>, char <em class="property">const</em> *<em>func</em>, char <em class="property">const</em> *<em>file</em>, long <em>line</em>, <a class="reference internal" href="#_CPPv3N3hpx9throwmodeE" title="hpx::throwmode">throwmode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv3N3hpx5plainE" title="hpx::plain">plain</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx15make_error_codeE5errorRNSt6stringEPcPcl9throwmode" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx15make_error_codeERNSt13exception_ptrE">
<span id="_CPPv2N3hpx15make_error_codeERNSt13exception_ptrE"></span><span id="hpx::make_error_code__std::exception_ptrCR"></span><span class="target" id="namespacehpx_1a51904e4edf3e4e02436cb8cf39f427f7"></span><a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> <code class="descname">make_error_code</code><span class="sig-paren">(</span>std::exception_ptr <em class="property">const</em> &amp;<em>e</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx15make_error_codeERNSt13exception_ptrE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Typedefs</p>
<dl class="type">
<dt id="_CPPv3N3hpx25parcel_write_handler_typeE">
<span id="_CPPv2N3hpx25parcel_write_handler_typeE"></span><span id="hpx::parcel_write_handler_type"></span><span class="target" id="namespacehpx_1ab95e97c81bfae24a79e4d0f2956f0fe1"></span><em class="property">typedef </em><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::function_nonser&lt;void<span class="sig-paren">(</span>boost::system::error_code <em class="property">const</em>&amp;, parcelset::parcel <em class="property">const</em>&amp;<span class="sig-paren">)</span>&gt; <code class="descname">parcel_write_handler_type</code><a class="headerlink" href="#_CPPv3N3hpx25parcel_write_handler_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The type of a function which can be registered as a parcel write handler using the function <em><a class="reference internal" href="#namespacehpx_1aeb594d703895a387b89e4fba621b13f4"><span class="std std-ref">hpx::set_parcel_write_handler</span></a></em>.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>A parcel write handler is a function which is called by the parcel layer whenever a parcel has been sent by the underlying networking library and if no explicit parcel handler function was specified for the parcel. </dd>
</dl>
</p>
</dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx22shutdown_function_typeE">
<span id="_CPPv2N3hpx22shutdown_function_typeE"></span><span id="hpx::shutdown_function_type"></span><span class="target" id="namespacehpx_1a1f43ecb2f7750d274e512fefc25ae059"></span><em class="property">typedef </em><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::unique_function_nonser&lt;void<span class="sig-paren">(</span><span class="sig-paren">)</span>&gt; <code class="descname">shutdown_function_type</code><a class="headerlink" href="#_CPPv3N3hpx22shutdown_function_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The type of a function which is registered to be executed as a shutdown or pre-shutdown function. </p>
</dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx21startup_function_typeE">
<span id="_CPPv2N3hpx21startup_function_typeE"></span><span id="hpx::startup_function_type"></span><span class="target" id="namespacehpx_1a182edb67dcfa1c3aa5fa9c30faaa43d7"></span><em class="property">typedef </em><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::unique_function_nonser&lt;void<span class="sig-paren">(</span><span class="sig-paren">)</span>&gt; <code class="descname">startup_function_type</code><a class="headerlink" href="#_CPPv3N3hpx21startup_function_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The type of a function which is registered to be executed as a startup or pre-startup function. </p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Enums</p>
<dl class="type">
<dt id="_CPPv3N3hpx5errorE">
<span id="_CPPv2N3hpx5errorE"></span><span id="hpx::error"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663"></span><em class="property">enum </em><code class="descname">error</code><a class="headerlink" href="#_CPPv3N3hpx5errorE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Possible error conditions. </p>
<p>This enumeration lists all possible error conditions which can be reported from any of the API functions. </p>
<p><em>Values:</em></p>
<dl class="enumerator">
<dt id="_CPPv3N3hpx7successE">
<span id="_CPPv2N3hpx7successE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663aca008d80aec0aed361d392d4ea09adbb"></span><code class="descname">success</code> = 0<a class="headerlink" href="#_CPPv3N3hpx7successE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The operation was successful. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx10no_successE">
<span id="_CPPv2N3hpx10no_successE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663ae6d4a6406208bade0f1a167020a72042"></span><code class="descname">no_success</code> = 1<a class="headerlink" href="#_CPPv3N3hpx10no_successE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The operation did failed, but not in an unexpected manner. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx15not_implementedE">
<span id="_CPPv2N3hpx15not_implementedE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663ac947ec2d2ab5033a05ac3cfc58d4e80b"></span><code class="descname">not_implemented</code> = 2<a class="headerlink" href="#_CPPv3N3hpx15not_implementedE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The operation is not implemented. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx13out_of_memoryE">
<span id="_CPPv2N3hpx13out_of_memoryE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663a3432e5de5a8148798886115101b4a0bd"></span><code class="descname">out_of_memory</code> = 3<a class="headerlink" href="#_CPPv3N3hpx13out_of_memoryE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The operation caused an out of memory condition. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx15bad_action_codeE">
<span id="_CPPv2N3hpx15bad_action_codeE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663a791124b4f9f2743b5e0007a8db3e6ba2"></span><code class="descname">bad_action_code</code> = 4<a class="headerlink" href="#_CPPv3N3hpx15bad_action_codeE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx18bad_component_typeE">
<span id="_CPPv2N3hpx18bad_component_typeE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663adde80739c949dcda70afc6a19b406a33"></span><code class="descname">bad_component_type</code> = 5<a class="headerlink" href="#_CPPv3N3hpx18bad_component_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The specified component type is not known or otherwise invalid. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx13network_errorE">
<span id="_CPPv2N3hpx13network_errorE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663a44a71ac839ebd0cc0525cd60f23fcc1d"></span><code class="descname">network_error</code> = 6<a class="headerlink" href="#_CPPv3N3hpx13network_errorE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A generic network error occurred. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx15version_too_newE">
<span id="_CPPv2N3hpx15version_too_newE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663af12106c406a20ef351d13a7d42a98edb"></span><code class="descname">version_too_new</code> = 7<a class="headerlink" href="#_CPPv3N3hpx15version_too_newE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The version of the network representation for this object is too new. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx15version_too_oldE">
<span id="_CPPv2N3hpx15version_too_oldE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663a83cbe80f41a52a6ddc505163f458037c"></span><code class="descname">version_too_old</code> = 8<a class="headerlink" href="#_CPPv3N3hpx15version_too_oldE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The version of the network representation for this object is too old. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx15version_unknownE">
<span id="_CPPv2N3hpx15version_unknownE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663ae4195b751066048cc4ce2b3a2b238355"></span><code class="descname">version_unknown</code> = 9<a class="headerlink" href="#_CPPv3N3hpx15version_unknownE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The version of the network representation for this object is unknown. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx25unknown_component_addressE">
<span id="_CPPv2N3hpx25unknown_component_addressE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663add1b40835025fa6eb0c0fec9e9a91dac"></span><code class="descname">unknown_component_address</code> = 10<a class="headerlink" href="#_CPPv3N3hpx25unknown_component_addressE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx27duplicate_component_addressE">
<span id="_CPPv2N3hpx27duplicate_component_addressE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663a82f56d8efc405c3f67ed14f612bdfafa"></span><code class="descname">duplicate_component_address</code> = 11<a class="headerlink" href="#_CPPv3N3hpx27duplicate_component_addressE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The given global id has already been registered. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx14invalid_statusE">
<span id="_CPPv2N3hpx14invalid_statusE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663abfb0c9b0ab71f8bcbe9a40c88b6b6959"></span><code class="descname">invalid_status</code> = 12<a class="headerlink" href="#_CPPv3N3hpx14invalid_statusE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The operation was executed in an invalid status. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx13bad_parameterE">
<span id="_CPPv2N3hpx13bad_parameterE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663ad6980c3ad7fd111b69144dbf5323120f"></span><code class="descname">bad_parameter</code> = 13<a class="headerlink" href="#_CPPv3N3hpx13bad_parameterE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>One of the supplied parameters is invalid. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx21internal_server_errorE">
<span id="_CPPv2N3hpx21internal_server_errorE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663a389551c24ac850d917d405c0d9e0b4e5"></span><code class="descname">internal_server_error</code> = 14<a class="headerlink" href="#_CPPv3N3hpx21internal_server_errorE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx19service_unavailableE">
<span id="_CPPv2N3hpx19service_unavailableE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663a013bf6b18f8179441729db6f5b5b9317"></span><code class="descname">service_unavailable</code> = 15<a class="headerlink" href="#_CPPv3N3hpx19service_unavailableE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx11bad_requestE">
<span id="_CPPv2N3hpx11bad_requestE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663aeabcd8a14f94fb6b91076ea6c36c6d43"></span><code class="descname">bad_request</code> = 16<a class="headerlink" href="#_CPPv3N3hpx11bad_requestE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx16repeated_requestE">
<span id="_CPPv2N3hpx16repeated_requestE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663a582c6d5a63f17052883d0e149c47ffee"></span><code class="descname">repeated_request</code> = 17<a class="headerlink" href="#_CPPv3N3hpx16repeated_requestE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx10lock_errorE">
<span id="_CPPv2N3hpx10lock_errorE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663a9fb3f6eea0cb547385d10424e33efffd"></span><code class="descname">lock_error</code> = 18<a class="headerlink" href="#_CPPv3N3hpx10lock_errorE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx17duplicate_consoleE">
<span id="_CPPv2N3hpx17duplicate_consoleE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663a3316be183b7717bad1c3afa4677a5ad5"></span><code class="descname">duplicate_console</code> = 19<a class="headerlink" href="#_CPPv3N3hpx17duplicate_consoleE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>There is more than one console locality. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx21no_registered_consoleE">
<span id="_CPPv2N3hpx21no_registered_consoleE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663a41c12b0a95b092580485f45bdf1a9012"></span><code class="descname">no_registered_console</code> = 20<a class="headerlink" href="#_CPPv3N3hpx21no_registered_consoleE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>There is no registered console locality available. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx17startup_timed_outE">
<span id="_CPPv2N3hpx17startup_timed_outE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663a3ce19b6a4402ac3d097da32d37c05e13"></span><code class="descname">startup_timed_out</code> = 21<a class="headerlink" href="#_CPPv3N3hpx17startup_timed_outE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx19uninitialized_valueE">
<span id="_CPPv2N3hpx19uninitialized_valueE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663a87684aa8b82891e4e0df7497d8f66e0c"></span><code class="descname">uninitialized_value</code> = 22<a class="headerlink" href="#_CPPv3N3hpx19uninitialized_valueE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx17bad_response_typeE">
<span id="_CPPv2N3hpx17bad_response_typeE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663a578be2bb16a0f9a494103414a392c971"></span><code class="descname">bad_response_type</code> = 23<a class="headerlink" href="#_CPPv3N3hpx17bad_response_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx8deadlockE">
<span id="_CPPv2N3hpx8deadlockE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663ab657307ce228d99a4bc8fb7f88bdbca5"></span><code class="descname">deadlock</code> = 24<a class="headerlink" href="#_CPPv3N3hpx8deadlockE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx17assertion_failureE">
<span id="_CPPv2N3hpx17assertion_failureE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663a1487984adb75f03a51df61d2dc796d93"></span><code class="descname">assertion_failure</code> = 25<a class="headerlink" href="#_CPPv3N3hpx17assertion_failureE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx14null_thread_idE">
<span id="_CPPv2N3hpx14null_thread_idE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663a05ec9382bba0a20ecfa536cc11e52288"></span><code class="descname">null_thread_id</code> = 26<a class="headerlink" href="#_CPPv3N3hpx14null_thread_idE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Attempt to invoke a API function from a non-HPX thread. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx12invalid_dataE">
<span id="_CPPv2N3hpx12invalid_dataE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663a05a10a9917188ab9c90efc2580e10b86"></span><code class="descname">invalid_data</code> = 27<a class="headerlink" href="#_CPPv3N3hpx12invalid_dataE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx13yield_abortedE">
<span id="_CPPv2N3hpx13yield_abortedE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663adaabe7896fcf922ad9d1b1dd252bdb8c"></span><code class="descname">yield_aborted</code> = 28<a class="headerlink" href="#_CPPv3N3hpx13yield_abortedE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The yield operation was aborted. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx20dynamic_link_failureE">
<span id="_CPPv2N3hpx20dynamic_link_failureE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663a6a380e09b4eab4586edef3c477306f1d"></span><code class="descname">dynamic_link_failure</code> = 29<a class="headerlink" href="#_CPPv3N3hpx20dynamic_link_failureE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx24commandline_option_errorE">
<span id="_CPPv2N3hpx24commandline_option_errorE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663a650fdd8b181791c2d413f36c52df57e7"></span><code class="descname">commandline_option_error</code> = 30<a class="headerlink" href="#_CPPv3N3hpx24commandline_option_errorE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>One of the options given on the command line is erroneous. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx19serialization_errorE">
<span id="_CPPv2N3hpx19serialization_errorE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663a9cbfcd0d11f67e98346743910f0a8734"></span><code class="descname">serialization_error</code> = 31<a class="headerlink" href="#_CPPv3N3hpx19serialization_errorE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>There was an error during serialization of this object. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx19unhandled_exceptionE">
<span id="_CPPv2N3hpx19unhandled_exceptionE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663a15fc69ad2726ae44d726b46ca099495f"></span><code class="descname">unhandled_exception</code> = 32<a class="headerlink" href="#_CPPv3N3hpx19unhandled_exceptionE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>An unhandled exception has been caught. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx12kernel_errorE">
<span id="_CPPv2N3hpx12kernel_errorE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663af84f866007602480dcdabf76d0edb7e9"></span><code class="descname">kernel_error</code> = 33<a class="headerlink" href="#_CPPv3N3hpx12kernel_errorE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The OS kernel reported an error. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx11broken_taskE">
<span id="_CPPv2N3hpx11broken_taskE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663a268f1aa1007bf6d19185750eb7dd4cb6"></span><code class="descname">broken_task</code> = 34<a class="headerlink" href="#_CPPv3N3hpx11broken_taskE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The task associated with this future object is not available anymore. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx10task_movedE">
<span id="_CPPv2N3hpx10task_movedE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663af8c8661032ad0b13d664a5d0da9f2897"></span><code class="descname">task_moved</code> = 35<a class="headerlink" href="#_CPPv3N3hpx10task_movedE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The task associated with this future object has been moved. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx20task_already_startedE">
<span id="_CPPv2N3hpx20task_already_startedE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663ab2f9767e63f460403a4d04c2653f116f"></span><code class="descname">task_already_started</code> = 36<a class="headerlink" href="#_CPPv3N3hpx20task_already_startedE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The task associated with this future object has already been started. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx24future_already_retrievedE">
<span id="_CPPv2N3hpx24future_already_retrievedE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663a1888d3cf3b448da0638359fb4b6f7389"></span><code class="descname">future_already_retrieved</code> = 37<a class="headerlink" href="#_CPPv3N3hpx24future_already_retrievedE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The future object has already been retrieved. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx25promise_already_satisfiedE">
<span id="_CPPv2N3hpx25promise_already_satisfiedE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663af33732f3591315ee4f5afc7690e9ff7a"></span><code class="descname">promise_already_satisfied</code> = 38<a class="headerlink" href="#_CPPv3N3hpx25promise_already_satisfiedE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The value for this future object has already been set. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx36future_does_not_support_cancellationE">
<span id="_CPPv2N3hpx36future_does_not_support_cancellationE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663af347ea8bc644c07f8598afa1125ed223"></span><code class="descname">future_does_not_support_cancellation</code> = 39<a class="headerlink" href="#_CPPv3N3hpx36future_does_not_support_cancellationE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The future object does not support cancellation. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx27future_can_not_be_cancelledE">
<span id="_CPPv2N3hpx27future_can_not_be_cancelledE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663a8542d0646324b0101ce30772ed37dbf2"></span><code class="descname">future_can_not_be_cancelled</code> = 40<a class="headerlink" href="#_CPPv3N3hpx27future_can_not_be_cancelledE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The future can’t be canceled at this time. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx8no_stateE">
<span id="_CPPv2N3hpx8no_stateE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663a2e101d20d9d18d59763eeab48c2fc737"></span><code class="descname">no_state</code> = 41<a class="headerlink" href="#_CPPv3N3hpx8no_stateE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The future object has no valid shared state. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx14broken_promiseE">
<span id="_CPPv2N3hpx14broken_promiseE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663ace0718584183efa14be4d43cfbd4bc36"></span><code class="descname">broken_promise</code> = 42<a class="headerlink" href="#_CPPv3N3hpx14broken_promiseE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The promise has been deleted. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx21thread_resource_errorE">
<span id="_CPPv2N3hpx21thread_resource_errorE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663a2a3bd9cf347766209afc71ed6894da7e"></span><code class="descname">thread_resource_error</code> = 43<a class="headerlink" href="#_CPPv3N3hpx21thread_resource_errorE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx16future_cancelledE">
<span id="_CPPv2N3hpx16future_cancelledE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663a1679da0b8f7b8f1d17ada849fb63e76d"></span><code class="descname">future_cancelled</code> = 44<a class="headerlink" href="#_CPPv3N3hpx16future_cancelledE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx16thread_cancelledE">
<span id="_CPPv2N3hpx16thread_cancelledE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663ab1d1486a2e56a88c0d4b487206e01271"></span><code class="descname">thread_cancelled</code> = 45<a class="headerlink" href="#_CPPv3N3hpx16thread_cancelledE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx24thread_not_interruptableE">
<span id="_CPPv2N3hpx24thread_not_interruptableE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663a1f481a109086007b837ce394cc6add80"></span><code class="descname">thread_not_interruptable</code> = 46<a class="headerlink" href="#_CPPv3N3hpx24thread_not_interruptableE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx22duplicate_component_idE">
<span id="_CPPv2N3hpx22duplicate_component_idE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663a7dcb6be2702321cc7dd3e3d04043879c"></span><code class="descname">duplicate_component_id</code> = 47<a class="headerlink" href="#_CPPv3N3hpx22duplicate_component_idE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The component type has already been registered. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx13unknown_errorE">
<span id="_CPPv2N3hpx13unknown_errorE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663a5ecb4cecdedd9f2cdce3c78461731e97"></span><code class="descname">unknown_error</code> = 48<a class="headerlink" href="#_CPPv3N3hpx13unknown_errorE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>An unknown error occurred. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx15bad_plugin_typeE">
<span id="_CPPv2N3hpx15bad_plugin_typeE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663a64c656cad0d9eb35e006015d1c0e3b90"></span><code class="descname">bad_plugin_type</code> = 49<a class="headerlink" href="#_CPPv3N3hpx15bad_plugin_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The specified plugin type is not known or otherwise invalid. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx16filesystem_errorE">
<span id="_CPPv2N3hpx16filesystem_errorE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663aee903226fce36e7aff2be519526c3f5d"></span><code class="descname">filesystem_error</code> = 50<a class="headerlink" href="#_CPPv3N3hpx16filesystem_errorE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The specified file does not exist or other filesystem related error. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx17bad_function_callE">
<span id="_CPPv2N3hpx17bad_function_callE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663a7f789101d6c061aa2188b5ff27c49c6f"></span><code class="descname">bad_function_call</code> = 51<a class="headerlink" href="#_CPPv3N3hpx17bad_function_callE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>equivalent of std::bad_function_call </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx23task_canceled_exceptionE">
<span id="_CPPv2N3hpx23task_canceled_exceptionE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663a244739d91451aca2344a5a40969a26e5"></span><code class="descname">task_canceled_exception</code> = 52<a class="headerlink" href="#_CPPv3N3hpx23task_canceled_exceptionE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p><a class="reference internal" href="#classhpx_1_1parallel_1_1v2_1_1task__canceled__exception"><span class="std std-ref">parallel::v2::task_canceled_exception</span></a> </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx21task_block_not_activeE">
<span id="_CPPv2N3hpx21task_block_not_activeE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663a135cea481091b4abd24d544aba811058"></span><code class="descname">task_block_not_active</code> = 53<a class="headerlink" href="#_CPPv3N3hpx21task_block_not_activeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>task_region is not active </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx12out_of_rangeE">
<span id="_CPPv2N3hpx12out_of_rangeE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663af12e8a467ec1a58e3717b8c71d4de7ad"></span><code class="descname">out_of_range</code> = 54<a class="headerlink" href="#_CPPv3N3hpx12out_of_rangeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Equivalent to std::out_of_range. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx12length_errorE">
<span id="_CPPv2N3hpx12length_errorE"></span><span class="target" id="namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663a7aa5cac3ef81e8beb69c5a2f19621a96"></span><code class="descname">length_error</code> = 55<a class="headerlink" href="#_CPPv3N3hpx12length_errorE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Equivalent to std::length_error. </p>
</dd></dl>

</dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx9throwmodeE">
<span id="_CPPv2N3hpx9throwmodeE"></span><span id="hpx::throwmode"></span><span class="target" id="namespacehpx_1afe4f36b1e296ae734bcfa9f552b4af94"></span><em class="property">enum </em><code class="descname">throwmode</code><a class="headerlink" href="#_CPPv3N3hpx9throwmodeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Encode error category for new <a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">error_code</span></a>. </p>
<p><em>Values:</em></p>
<dl class="enumerator">
<dt id="_CPPv3N3hpx5plainE">
<span id="_CPPv2N3hpx5plainE"></span><span class="target" id="namespacehpx_1afe4f36b1e296ae734bcfa9f552b4af94a4bb503f987a72e31443aa44bf9a9714c"></span><code class="descname">plain</code> = 0<a class="headerlink" href="#_CPPv3N3hpx5plainE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx7rethrowE">
<span id="_CPPv2N3hpx7rethrowE"></span><span class="target" id="namespacehpx_1afe4f36b1e296ae734bcfa9f552b4af94ab5f8a596fef817e576a4d1277466544c"></span><code class="descname">rethrow</code> = 1<a class="headerlink" href="#_CPPv3N3hpx7rethrowE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx11lightweightE">
<span id="_CPPv2N3hpx11lightweightE"></span><span class="target" id="namespacehpx_1afe4f36b1e296ae734bcfa9f552b4af94a056bfaf2e600091151e27eb7a0809eb9"></span><code class="descname">lightweight</code> = 0x80<a class="headerlink" href="#_CPPv3N3hpx11lightweightE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx12runtime_modeE">
<span id="_CPPv2N3hpx12runtime_modeE"></span><span id="hpx::runtime_mode"></span><span class="target" id="namespacehpx_1a380cead581c9f4b6ec569a355f9440bf"></span><em class="property">enum </em><code class="descname">runtime_mode</code><a class="headerlink" href="#_CPPv3N3hpx12runtime_modeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A HPX runtime can be executed in two different modes: console mode and worker mode. </p>
<p><em>Values:</em></p>
<dl class="enumerator">
<dt id="_CPPv3N3hpx20runtime_mode_invalidE">
<span id="_CPPv2N3hpx20runtime_mode_invalidE"></span><span class="target" id="namespacehpx_1a380cead581c9f4b6ec569a355f9440bfa0f1143f7bb8e783a8efde8201b65bf79"></span><code class="descname">runtime_mode_invalid</code> = -1<a class="headerlink" href="#_CPPv3N3hpx20runtime_mode_invalidE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx20runtime_mode_consoleE">
<span id="_CPPv2N3hpx20runtime_mode_consoleE"></span><span class="target" id="namespacehpx_1a380cead581c9f4b6ec569a355f9440bfae8af6c45f53e2f3a938617540899092b"></span><code class="descname">runtime_mode_console</code> = 0<a class="headerlink" href="#_CPPv3N3hpx20runtime_mode_consoleE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The runtime is the console locality. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx19runtime_mode_workerE">
<span id="_CPPv2N3hpx19runtime_mode_workerE"></span><span class="target" id="namespacehpx_1a380cead581c9f4b6ec569a355f9440bfaba432e1dc9ba9d51594a7480e1a22a1e"></span><code class="descname">runtime_mode_worker</code> = 1<a class="headerlink" href="#_CPPv3N3hpx19runtime_mode_workerE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The runtime is a worker locality. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx20runtime_mode_connectE">
<span id="_CPPv2N3hpx20runtime_mode_connectE"></span><span class="target" id="namespacehpx_1a380cead581c9f4b6ec569a355f9440bfaf09a99c3187af6c1ae86efe086b90bd6"></span><code class="descname">runtime_mode_connect</code> = 2<a class="headerlink" href="#_CPPv3N3hpx20runtime_mode_connectE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The runtime is a worker locality connecting late </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx20runtime_mode_defaultE">
<span id="_CPPv2N3hpx20runtime_mode_defaultE"></span><span class="target" id="namespacehpx_1a380cead581c9f4b6ec569a355f9440bfabdc3faac1dd0c8df0fbb2937792aa895"></span><code class="descname">runtime_mode_default</code> = 3<a class="headerlink" href="#_CPPv3N3hpx20runtime_mode_defaultE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The runtime mode will be determined based on the command line arguments </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx17runtime_mode_lastE">
<span id="_CPPv2N3hpx17runtime_mode_lastE"></span><span class="target" id="namespacehpx_1a380cead581c9f4b6ec569a355f9440bfaabb25708024e48b832b635adfa552f37"></span><code class="descname">runtime_mode_last</code><a class="headerlink" href="#_CPPv3N3hpx17runtime_mode_lastE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx4initERN4util15function_nonserIFiRN5boost15program_options13variables_mapEEEERN5boost15program_options19options_descriptionEiPPcRNSt6vectorINSt6stringEEE21startup_function_type22shutdown_function_typeN3hpx12runtime_modeE">
<span id="_CPPv2N3hpx4initERN4util15function_nonserIFiRN5boost15program_options13variables_mapEEEERN5boost15program_options19options_descriptionEiPPcRNSt6vectorINSt6stringEEE21startup_function_type22shutdown_function_typeN3hpx12runtime_modeE"></span><span class="target" id="namespacehpx_1a3c694ea960b47c56b33351ba16e3d76b"></span>int <code class="descname">init</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::function_nonser&lt;int<span class="sig-paren">(</span>boost::program_options::variables_map &amp;vm<span class="sig-paren">)</span>&gt; <em class="property">const</em> &amp;<em>f</em>, boost::program_options::options_description <em class="property">const</em> &amp;<em>desc_cmdline</em>, int <em>argc</em>, char **<em>argv</em>, std::vector&lt;std::string&gt; <em class="property">const</em> &amp;<em>cfg</em>, <a class="reference internal" href="#_CPPv3N3hpx21startup_function_typeE" title="hpx::startup_function_type">startup_function_type</a> <em>startup</em> = <a class="reference internal" href="#_CPPv3N3hpx21startup_function_typeE" title="hpx::startup_function_type">startup_function_type</a>(), <a class="reference internal" href="#_CPPv3N3hpx22shutdown_function_typeE" title="hpx::shutdown_function_type">shutdown_function_type</a> <em>shutdown</em> = <a class="reference internal" href="#_CPPv3N3hpx22shutdown_function_typeE" title="hpx::shutdown_function_type">shutdown_function_type</a>(), <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx12runtime_modeE" title="hpx::runtime_mode">runtime_mode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx20runtime_mode_defaultE" title="hpx::runtime_mode_default">runtime_mode_default</a>, <span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4initERN4util15function_nonserIFiRN5boost15program_options13variables_mapEEEERN5boost15program_options19options_descriptionEiPPcRNSt6vectorINSt6stringEEE21startup_function_type22shutdown_function_typeN3hpx12runtime_modeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Main entry point for launching the HPX runtime system. </p>
<p>This is the main entry point for any HPX application. This function (or one of its overloads below) should be called from the users <code class="docutils literal notranslate"><span class="pre">main()</span></code> function. It will set up the HPX runtime environment and schedule the function given by <code class="docutils literal notranslate"><span class="pre">f</span></code> as a HPX thread. This overload will not call <code class="docutils literal notranslate"><span class="pre">hpx_main</span></code>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The function returns the value, which has been returned from the user supplied <code class="docutils literal notranslate"><span class="pre">f</span></code>.</dd>
<dt><strong>Note</strong></dt>
<dd>If the parameter <code class="docutils literal notranslate"><span class="pre">mode</span></code> is not given (defaulted), the created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argc</span></code>/<code class="docutils literal notranslate"><span class="pre">argv</span></code>. Otherwise it will be executed as specified by the parameter<code class="docutils literal notranslate"><span class="pre">mode</span></code>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: [in] The function to be scheduled as an HPX thread. Usually this function represents the main entry point of any HPX application. If <code class="docutils literal notranslate"><span class="pre">f</span></code> is <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> the HPX runtime environment will be started without invoking <code class="docutils literal notranslate"><span class="pre">f</span></code>. </li>
<li><code class="docutils literal notranslate"><span class="pre">desc_cmdline</span></code>: [in] This parameter may hold the description of additional command line arguments understood by the application. These options will be prepended to the default command line options understood by <em><a class="reference internal" href="#namespacehpx_1a3c694ea960b47c56b33351ba16e3d76b"><span class="std std-ref">hpx::init</span></a></em> (see description below). </li>
<li><code class="docutils literal notranslate"><span class="pre">argc</span></code>: [in] The number of command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argv</span></code>. This is usually the unchanged value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">argv</span></code>: [in] The command line arguments for this application, usually that is the value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">cfg</span></code>: A list of configuration settings which will be added to the system configuration before the runtime instance is run. Each of the entries in this list must have the format of a fully defined key/value pair from an ini-file (for instance ‘hpx.component.enabled=1’) </li>
<li><code class="docutils literal notranslate"><span class="pre">startup</span></code>: [in] A function to be executed inside a HPX thread before <code class="docutils literal notranslate"><span class="pre">f</span></code> is called. If this parameter is not given no function will be executed. </li>
<li><code class="docutils literal notranslate"><span class="pre">shutdown</span></code>: [in] A function to be executed inside an HPX thread while <a class="reference internal" href="#namespacehpx_1ab7eb159cb77997b366b5d79e65f04cd0"><span class="std std-ref">hpx::finalize</span></a> is executed. If this parameter is not given no function will be executed. </li>
<li><code class="docutils literal notranslate"><span class="pre">mode</span></code>: [in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfae8af6c45f53e2f3a938617540899092b"><span class="std std-ref">hpx::runtime_mode_console</span></a></em>), all other localities have to be run in worker mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfaba432e1dc9ba9d51594a7480e1a22a1e"><span class="std std-ref">hpx::runtime_mode_worker</span></a></em>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4initEPFiRN5boost15program_options13variables_mapEERN5boost15program_options19options_descriptionEiPPc21startup_function_type22shutdown_function_typeN3hpx12runtime_modeE">
<span id="_CPPv2N3hpx4initEPFiRN5boost15program_options13variables_mapEERN5boost15program_options19options_descriptionEiPPc21startup_function_type22shutdown_function_typeN3hpx12runtime_modeE"></span><span class="target" id="namespacehpx_1a43066707e7aa0921fe229834c1c46a0d"></span>int <code class="descname">init</code><span class="sig-paren">(</span>int (*<em>f</em>)<span class="sig-paren">(</span>boost::program_options::variables_map &amp;vm<span class="sig-paren">)</span>, boost::program_options::options_description <em class="property">const</em> &amp;<em>desc_cmdline</em>, int <em>argc</em>, char **<em>argv</em>, <a class="reference internal" href="#_CPPv3N3hpx21startup_function_typeE" title="hpx::startup_function_type">startup_function_type</a> <em>startup</em> = <a class="reference internal" href="#_CPPv3N3hpx21startup_function_typeE" title="hpx::startup_function_type">startup_function_type</a>(), <a class="reference internal" href="#_CPPv3N3hpx22shutdown_function_typeE" title="hpx::shutdown_function_type">shutdown_function_type</a> <em>shutdown</em> = <a class="reference internal" href="#_CPPv3N3hpx22shutdown_function_typeE" title="hpx::shutdown_function_type">shutdown_function_type</a>(), <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx12runtime_modeE" title="hpx::runtime_mode">runtime_mode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx20runtime_mode_defaultE" title="hpx::runtime_mode_default">runtime_mode_default</a>, <span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4initEPFiRN5boost15program_options13variables_mapEERN5boost15program_options19options_descriptionEiPPc21startup_function_type22shutdown_function_typeN3hpx12runtime_modeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Main entry point for launching the HPX runtime system. </p>
<p>This is the main entry point for any HPX application. This function (or one of its overloads below) should be called from the users <code class="docutils literal notranslate"><span class="pre">main()</span></code> function. It will set up the HPX runtime environment and schedule the function given by <code class="docutils literal notranslate"><span class="pre">f</span></code> as a HPX thread. This overload will not call <code class="docutils literal notranslate"><span class="pre">hpx_main</span></code>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The function returns the value, which has been returned from the user supplied <code class="docutils literal notranslate"><span class="pre">f</span></code>.</dd>
<dt><strong>Note</strong></dt>
<dd>If the parameter <code class="docutils literal notranslate"><span class="pre">mode</span></code> is not given (defaulted), the created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argc</span></code>/<code class="docutils literal notranslate"><span class="pre">argv</span></code>. Otherwise it will be executed as specified by the parameter<code class="docutils literal notranslate"><span class="pre">mode</span></code>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: [in] The function to be scheduled as an HPX thread. Usually this function represents the main entry point of any HPX application. If <code class="docutils literal notranslate"><span class="pre">f</span></code> is <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> the HPX runtime environment will be started without invoking <code class="docutils literal notranslate"><span class="pre">f</span></code>. </li>
<li><code class="docutils literal notranslate"><span class="pre">desc_cmdline</span></code>: [in] This parameter may hold the description of additional command line arguments understood by the application. These options will be prepended to the default command line options understood by <em><a class="reference internal" href="#namespacehpx_1a3c694ea960b47c56b33351ba16e3d76b"><span class="std std-ref">hpx::init</span></a></em> (see description below). </li>
<li><code class="docutils literal notranslate"><span class="pre">argc</span></code>: [in] The number of command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argv</span></code>. This is usually the unchanged value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">argv</span></code>: [in] The command line arguments for this application, usually that is the value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">startup</span></code>: [in] A function to be executed inside a HPX thread before <code class="docutils literal notranslate"><span class="pre">f</span></code> is called. If this parameter is not given no function will be executed. </li>
<li><code class="docutils literal notranslate"><span class="pre">shutdown</span></code>: [in] A function to be executed inside an HPX thread while <a class="reference internal" href="#namespacehpx_1ab7eb159cb77997b366b5d79e65f04cd0"><span class="std std-ref">hpx::finalize</span></a> is executed. If this parameter is not given no function will be executed. </li>
<li><code class="docutils literal notranslate"><span class="pre">mode</span></code>: [in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfae8af6c45f53e2f3a938617540899092b"><span class="std std-ref">hpx::runtime_mode_console</span></a></em>), all other localities have to be run in worker mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfaba432e1dc9ba9d51594a7480e1a22a1e"><span class="std std-ref">hpx::runtime_mode_worker</span></a></em>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4initERN5boost15program_options19options_descriptionEiPPc21startup_function_type22shutdown_function_typeN3hpx12runtime_modeE">
<span id="_CPPv2N3hpx4initERN5boost15program_options19options_descriptionEiPPc21startup_function_type22shutdown_function_typeN3hpx12runtime_modeE"></span><span id="hpx::init__boost::program_options::options_descriptionCR.i.cPP.startup_function_type.shutdown_function_type.hpx::runtime_mode"></span><span class="target" id="namespacehpx_1a55bc265fef195480c372a9cd84ba7507"></span>int <code class="descname">init</code><span class="sig-paren">(</span>boost::program_options::options_description <em class="property">const</em> &amp;<em>desc_cmdline</em>, int <em>argc</em>, char **<em>argv</em>, <a class="reference internal" href="#_CPPv3N3hpx21startup_function_typeE" title="hpx::startup_function_type">startup_function_type</a> <em>startup</em> = <a class="reference internal" href="#_CPPv3N3hpx21startup_function_typeE" title="hpx::startup_function_type">startup_function_type</a>(), <a class="reference internal" href="#_CPPv3N3hpx22shutdown_function_typeE" title="hpx::shutdown_function_type">shutdown_function_type</a> <em>shutdown</em> = <a class="reference internal" href="#_CPPv3N3hpx22shutdown_function_typeE" title="hpx::shutdown_function_type">shutdown_function_type</a>(), <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx12runtime_modeE" title="hpx::runtime_mode">runtime_mode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx20runtime_mode_defaultE" title="hpx::runtime_mode_default">runtime_mode_default</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4initERN5boost15program_options19options_descriptionEiPPc21startup_function_type22shutdown_function_typeN3hpx12runtime_modeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Main entry point for launching the HPX runtime system. </p>
<p>This is a simplified main entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings).</p>
<p>In console mode it will execute the user supplied function <code class="docutils literal notranslate"><span class="pre">hpx_main</span></code>, in worker mode it will execute an empty <code class="docutils literal notranslate"><span class="pre">hpx_main</span></code>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The function returns the value, which has been returned from <code class="docutils literal notranslate"><span class="pre">hpx_main</span></code> (or 0 when executed in worker mode).</dd>
<dt><strong>Note</strong></dt>
<dd>If the parameter <code class="docutils literal notranslate"><span class="pre">mode</span></code> is not given (defaulted), the created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argc</span></code>/<code class="docutils literal notranslate"><span class="pre">argv</span></code>. Otherwise it will be executed as specified by the parameter<code class="docutils literal notranslate"><span class="pre">mode</span></code>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">desc_cmdline</span></code>: [in] This parameter may hold the description of additional command line arguments understood by the application. These options will be prepended to the default command line options understood by <em><a class="reference internal" href="#namespacehpx_1a3c694ea960b47c56b33351ba16e3d76b"><span class="std std-ref">hpx::init</span></a></em> (see description below). </li>
<li><code class="docutils literal notranslate"><span class="pre">argc</span></code>: [in] The number of command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argv</span></code>. This is usually the unchanged value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">argv</span></code>: [in] The command line arguments for this application, usually that is the value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">startup</span></code>: [in] A function to be executed inside a HPX thread before <code class="docutils literal notranslate"><span class="pre">f</span></code> is called. If this parameter is not given no function will be executed. </li>
<li><code class="docutils literal notranslate"><span class="pre">shutdown</span></code>: [in] A function to be executed inside an HPX thread while <a class="reference internal" href="#namespacehpx_1ab7eb159cb77997b366b5d79e65f04cd0"><span class="std std-ref">hpx::finalize</span></a> is executed. If this parameter is not given no function will be executed. </li>
<li><code class="docutils literal notranslate"><span class="pre">mode</span></code>: [in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfae8af6c45f53e2f3a938617540899092b"><span class="std std-ref">hpx::runtime_mode_console</span></a></em>), all other localities have to be run in worker mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfaba432e1dc9ba9d51594a7480e1a22a1e"><span class="std std-ref">hpx::runtime_mode_worker</span></a></em>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4initERN5boost15program_options19options_descriptionEiPPcRNSt6vectorINSt6stringEEE21startup_function_type22shutdown_function_typeN3hpx12runtime_modeE">
<span id="_CPPv2N3hpx4initERN5boost15program_options19options_descriptionEiPPcRNSt6vectorINSt6stringEEE21startup_function_type22shutdown_function_typeN3hpx12runtime_modeE"></span><span id="hpx::init__boost::program_options::options_descriptionCR.i.cPP.std::vector:ss:CR.startup_function_type.shutdown_function_type.hpx::runtime_mode"></span><span class="target" id="namespacehpx_1ac44506146ed6ce364027d20bde1d85f4"></span>int <code class="descname">init</code><span class="sig-paren">(</span>boost::program_options::options_description <em class="property">const</em> &amp;<em>desc_cmdline</em>, int <em>argc</em>, char **<em>argv</em>, std::vector&lt;std::string&gt; <em class="property">const</em> &amp;<em>cfg</em>, <a class="reference internal" href="#_CPPv3N3hpx21startup_function_typeE" title="hpx::startup_function_type">startup_function_type</a> <em>startup</em> = <a class="reference internal" href="#_CPPv3N3hpx21startup_function_typeE" title="hpx::startup_function_type">startup_function_type</a>(), <a class="reference internal" href="#_CPPv3N3hpx22shutdown_function_typeE" title="hpx::shutdown_function_type">shutdown_function_type</a> <em>shutdown</em> = <a class="reference internal" href="#_CPPv3N3hpx22shutdown_function_typeE" title="hpx::shutdown_function_type">shutdown_function_type</a>(), <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx12runtime_modeE" title="hpx::runtime_mode">runtime_mode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx20runtime_mode_defaultE" title="hpx::runtime_mode_default">runtime_mode_default</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4initERN5boost15program_options19options_descriptionEiPPcRNSt6vectorINSt6stringEEE21startup_function_type22shutdown_function_typeN3hpx12runtime_modeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Main entry point for launching the HPX runtime system. </p>
<p>This is a simplified main entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings).</p>
<p>In console mode it will execute the user supplied function <code class="docutils literal notranslate"><span class="pre">hpx_main</span></code>, in worker mode it will execute an empty <code class="docutils literal notranslate"><span class="pre">hpx_main</span></code>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The function returns the value, which has been returned from <code class="docutils literal notranslate"><span class="pre">hpx_main</span></code> (or 0 when executed in worker mode).</dd>
<dt><strong>Note</strong></dt>
<dd>If the parameter <code class="docutils literal notranslate"><span class="pre">mode</span></code> is not given (defaulted), the created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argc</span></code>/<code class="docutils literal notranslate"><span class="pre">argv</span></code>. Otherwise it will be executed as specified by the parameter<code class="docutils literal notranslate"><span class="pre">mode</span></code>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">desc_cmdline</span></code>: [in] This parameter may hold the description of additional command line arguments understood by the application. These options will be prepended to the default command line options understood by <em><a class="reference internal" href="#namespacehpx_1a3c694ea960b47c56b33351ba16e3d76b"><span class="std std-ref">hpx::init</span></a></em> (see description below). </li>
<li><code class="docutils literal notranslate"><span class="pre">argc</span></code>: [in] The number of command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argv</span></code>. This is usually the unchanged value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">argv</span></code>: [in] The command line arguments for this application, usually that is the value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">cfg</span></code>: A list of configuration settings which will be added to the system configuration before the runtime instance is run. Each of the entries in this list must have the format of a fully defined key/value pair from an ini-file (for instance ‘hpx.component.enabled=1’) </li>
<li><code class="docutils literal notranslate"><span class="pre">startup</span></code>: [in] A function to be executed inside a HPX thread before <code class="docutils literal notranslate"><span class="pre">f</span></code> is called. If this parameter is not given no function will be executed. </li>
<li><code class="docutils literal notranslate"><span class="pre">shutdown</span></code>: [in] A function to be executed inside an HPX thread while <a class="reference internal" href="#namespacehpx_1ab7eb159cb77997b366b5d79e65f04cd0"><span class="std std-ref">hpx::finalize</span></a> is executed. If this parameter is not given no function will be executed. </li>
<li><code class="docutils literal notranslate"><span class="pre">mode</span></code>: [in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfae8af6c45f53e2f3a938617540899092b"><span class="std std-ref">hpx::runtime_mode_console</span></a></em>), all other localities have to be run in worker mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfaba432e1dc9ba9d51594a7480e1a22a1e"><span class="std std-ref">hpx::runtime_mode_worker</span></a></em>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4initEiPPcRNSt6vectorINSt6stringEEEN3hpx12runtime_modeE">
<span id="_CPPv2N3hpx4initEiPPcRNSt6vectorINSt6stringEEEN3hpx12runtime_modeE"></span><span id="hpx::init__i.cPP.std::vector:ss:CR.hpx::runtime_mode"></span><span class="target" id="namespacehpx_1abda8ebec19e8632bb987536ceab59ce7"></span>int <code class="descname">init</code><span class="sig-paren">(</span>int <em>argc</em>, char **<em>argv</em>, std::vector&lt;std::string&gt; <em class="property">const</em> &amp;<em>cfg</em>, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx12runtime_modeE" title="hpx::runtime_mode">runtime_mode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx20runtime_mode_defaultE" title="hpx::runtime_mode_default">runtime_mode_default</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4initEiPPcRNSt6vectorINSt6stringEEEN3hpx12runtime_modeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Main entry point for launching the HPX runtime system. </p>
<p>This is a simplified main entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings).</p>
<p>In console mode it will execute the user supplied function <code class="docutils literal notranslate"><span class="pre">hpx_main</span></code>, in worker mode it will execute an empty <code class="docutils literal notranslate"><span class="pre">hpx_main</span></code>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The function returns the value, which has been returned from <code class="docutils literal notranslate"><span class="pre">hpx_main</span></code> (or 0 when executed in worker mode).</dd>
<dt><strong>Note</strong></dt>
<dd>The created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argc</span></code>/<code class="docutils literal notranslate"><span class="pre">argv</span></code>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">argc</span></code>: [in] The number of command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argv</span></code>. This is usually the unchanged value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">argv</span></code>: [in] The command line arguments for this application, usually that is the value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">cfg</span></code>: A list of configuration settings which will be added to the system configuration before the runtime instance is run. Each of the entries in this list must have the format of a fully defined key/value pair from an ini-file (for instance ‘hpx.component.enabled=1’) </li>
<li><code class="docutils literal notranslate"><span class="pre">mode</span></code>: [in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfae8af6c45f53e2f3a938617540899092b"><span class="std std-ref">hpx::runtime_mode_console</span></a></em>), all other localities have to be run in worker mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfaba432e1dc9ba9d51594a7480e1a22a1e"><span class="std std-ref">hpx::runtime_mode_worker</span></a></em>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4initERN5boost15program_options19options_descriptionEiPPcN3hpx12runtime_modeE">
<span id="_CPPv2N3hpx4initERN5boost15program_options19options_descriptionEiPPcN3hpx12runtime_modeE"></span><span id="hpx::init__boost::program_options::options_descriptionCR.i.cPP.hpx::runtime_mode"></span><span class="target" id="namespacehpx_1aea4fafc550cb1b1c7eebe8884d988b50"></span>int <code class="descname">init</code><span class="sig-paren">(</span>boost::program_options::options_description <em class="property">const</em> &amp;<em>desc_cmdline</em>, int <em>argc</em>, char **<em>argv</em>, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx12runtime_modeE" title="hpx::runtime_mode">runtime_mode</a> <em>mode</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4initERN5boost15program_options19options_descriptionEiPPcN3hpx12runtime_modeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Main entry point for launching the HPX runtime system. </p>
<p>This is a simplified main entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings).</p>
<p>In console mode it will execute the user supplied function <code class="docutils literal notranslate"><span class="pre">hpx_main</span></code>, in worker mode it will execute an empty <code class="docutils literal notranslate"><span class="pre">hpx_main</span></code>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The function returns the value, which has been returned from <code class="docutils literal notranslate"><span class="pre">hpx_main</span></code> (or 0 when executed in worker mode).</dd>
<dt><strong>Note</strong></dt>
<dd>If the parameter <code class="docutils literal notranslate"><span class="pre">mode</span></code> is runtime_mode_default, the created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argc</span></code>/<code class="docutils literal notranslate"><span class="pre">argv</span></code>. Otherwise it will be executed as specified by the parameter<code class="docutils literal notranslate"><span class="pre">mode</span></code>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">desc_cmdline</span></code>: [in] This parameter may hold the description of additional command line arguments understood by the application. These options will be prepended to the default command line options understood by <em><a class="reference internal" href="#namespacehpx_1a3c694ea960b47c56b33351ba16e3d76b"><span class="std std-ref">hpx::init</span></a></em> (see description below). </li>
<li><code class="docutils literal notranslate"><span class="pre">argc</span></code>: [in] The number of command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argv</span></code>. This is usually the unchanged value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">argv</span></code>: [in] The command line arguments for this application, usually that is the value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">mode</span></code>: [in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfae8af6c45f53e2f3a938617540899092b"><span class="std std-ref">hpx::runtime_mode_console</span></a></em>), all other localities have to be run in worker mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfaba432e1dc9ba9d51594a7480e1a22a1e"><span class="std std-ref">hpx::runtime_mode_worker</span></a></em>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4initERN5boost15program_options19options_descriptionEiPPcRNSt6vectorINSt6stringEEEN3hpx12runtime_modeE">
<span id="_CPPv2N3hpx4initERN5boost15program_options19options_descriptionEiPPcRNSt6vectorINSt6stringEEEN3hpx12runtime_modeE"></span><span id="hpx::init__boost::program_options::options_descriptionCR.i.cPP.std::vector:ss:CR.hpx::runtime_mode"></span><span class="target" id="namespacehpx_1ab4fbc1a606bae92b06bfe86182d12d47"></span>int <code class="descname">init</code><span class="sig-paren">(</span>boost::program_options::options_description <em class="property">const</em> &amp;<em>desc_cmdline</em>, int <em>argc</em>, char **<em>argv</em>, std::vector&lt;std::string&gt; <em class="property">const</em> &amp;<em>cfg</em>, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx12runtime_modeE" title="hpx::runtime_mode">runtime_mode</a> <em>mode</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4initERN5boost15program_options19options_descriptionEiPPcRNSt6vectorINSt6stringEEEN3hpx12runtime_modeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Main entry point for launching the HPX runtime system. </p>
<p>This is a simplified main entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings).</p>
<p>In console mode it will execute the user supplied function <code class="docutils literal notranslate"><span class="pre">hpx_main</span></code>, in worker mode it will execute an empty <code class="docutils literal notranslate"><span class="pre">hpx_main</span></code>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The function returns the value, which has been returned from <code class="docutils literal notranslate"><span class="pre">hpx_main</span></code> (or 0 when executed in worker mode).</dd>
<dt><strong>Note</strong></dt>
<dd>If the parameter <code class="docutils literal notranslate"><span class="pre">mode</span></code> is runtime_mode_default, the created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argc</span></code>/<code class="docutils literal notranslate"><span class="pre">argv</span></code>. Otherwise it will be executed as specified by the parameter<code class="docutils literal notranslate"><span class="pre">mode</span></code>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">desc_cmdline</span></code>: [in] This parameter may hold the description of additional command line arguments understood by the application. These options will be prepended to the default command line options understood by <em><a class="reference internal" href="#namespacehpx_1a3c694ea960b47c56b33351ba16e3d76b"><span class="std std-ref">hpx::init</span></a></em> (see description below). </li>
<li><code class="docutils literal notranslate"><span class="pre">argc</span></code>: [in] The number of command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argv</span></code>. This is usually the unchanged value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">argv</span></code>: [in] The command line arguments for this application, usually that is the value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">cfg</span></code>: A list of configuration settings which will be added to the system configuration before the runtime instance is run. Each of the entries in this list must have the format of a fully defined key/value pair from an ini-file (for instance ‘hpx.component.enabled=1’) </li>
<li><code class="docutils literal notranslate"><span class="pre">mode</span></code>: [in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfae8af6c45f53e2f3a938617540899092b"><span class="std std-ref">hpx::runtime_mode_console</span></a></em>), all other localities have to be run in worker mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfaba432e1dc9ba9d51594a7480e1a22a1e"><span class="std std-ref">hpx::runtime_mode_worker</span></a></em>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4initERNSt6stringEiPPcN3hpx12runtime_modeE">
<span id="_CPPv2N3hpx4initERNSt6stringEiPPcN3hpx12runtime_modeE"></span><span id="hpx::init__ssCR.i.cPP.hpx::runtime_mode"></span><span class="target" id="namespacehpx_1adebf2eae88a87022dbc5bacf619e22a3"></span>int <code class="descname">init</code><span class="sig-paren">(</span>std::string <em class="property">const</em> &amp;<em>app_name</em>, int <em>argc</em> = 0, char **<em>argv</em> = nullptr, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx12runtime_modeE" title="hpx::runtime_mode">runtime_mode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx20runtime_mode_defaultE" title="hpx::runtime_mode_default">runtime_mode_default</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4initERNSt6stringEiPPcN3hpx12runtime_modeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Main entry point for launching the HPX runtime system. </p>
<p>This is a simplified main entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings).</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The function returns the value, which has been returned from <code class="docutils literal notranslate"><span class="pre">hpx_main</span></code> (or 0 when executed in worker mode).</dd>
<dt><strong>Note</strong></dt>
<dd>The created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argc</span></code>/<code class="docutils literal notranslate"><span class="pre">argv</span></code>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">app_name</span></code>: [in] The name of the application. </li>
<li><code class="docutils literal notranslate"><span class="pre">argc</span></code>: [in] The number of command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argv</span></code>. This is usually the unchanged value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">argv</span></code>: [in] The command line arguments for this application, usually that is the value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">mode</span></code>: [in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfae8af6c45f53e2f3a938617540899092b"><span class="std std-ref">hpx::runtime_mode_console</span></a></em>), all other localities have to be run in worker mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfaba432e1dc9ba9d51594a7480e1a22a1e"><span class="std std-ref">hpx::runtime_mode_worker</span></a></em>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4initEiPPcN3hpx12runtime_modeE">
<span id="_CPPv2N3hpx4initEiPPcN3hpx12runtime_modeE"></span><span id="hpx::init__i.cPP.hpx::runtime_mode"></span><span class="target" id="namespacehpx_1a13cd8a7a3209ffbc5a237f121a46eb49"></span>int <code class="descname">init</code><span class="sig-paren">(</span>int <em>argc</em> = 0, char **<em>argv</em> = nullptr, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx12runtime_modeE" title="hpx::runtime_mode">runtime_mode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx20runtime_mode_defaultE" title="hpx::runtime_mode_default">runtime_mode_default</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4initEiPPcN3hpx12runtime_modeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Main entry point for launching the HPX runtime system. </p>
<p>This is a simplified main entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings).</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The function returns the value, which has been returned from <code class="docutils literal notranslate"><span class="pre">hpx_main</span></code> (or 0 when executed in worker mode).</dd>
<dt><strong>Note</strong></dt>
<dd>The created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argc</span></code>/<code class="docutils literal notranslate"><span class="pre">argv</span></code>. If not command line arguments are passed, console mode is assumed.</dd>
<dt><strong>Note</strong></dt>
<dd>If no command line arguments are passed the HPX runtime system will not support any of the default command line options as described in the section ‘HPX Command Line Options’. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">argc</span></code>: [in] The number of command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argv</span></code>. This is usually the unchanged value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">argv</span></code>: [in] The command line arguments for this application, usually that is the value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">mode</span></code>: [in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfae8af6c45f53e2f3a938617540899092b"><span class="std std-ref">hpx::runtime_mode_console</span></a></em>), all other localities have to be run in worker mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfaba432e1dc9ba9d51594a7480e1a22a1e"><span class="std std-ref">hpx::runtime_mode_worker</span></a></em>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4initERNSt6vectorINSt6stringEEEN3hpx12runtime_modeE">
<span id="_CPPv2N3hpx4initERNSt6vectorINSt6stringEEEN3hpx12runtime_modeE"></span><span id="hpx::init__std::vector:ss:CR.hpx::runtime_mode"></span><span class="target" id="namespacehpx_1a462c73b02f8f393597d7149b6d2a6390"></span>int <code class="descname">init</code><span class="sig-paren">(</span>std::vector&lt;std::string&gt; <em class="property">const</em> &amp;<em>cfg</em>, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx12runtime_modeE" title="hpx::runtime_mode">runtime_mode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx20runtime_mode_defaultE" title="hpx::runtime_mode_default">runtime_mode_default</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4initERNSt6vectorINSt6stringEEEN3hpx12runtime_modeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Main entry point for launching the HPX runtime system. </p>
<p>This is a simplified main entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings).</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The function returns the value, which has been returned from <code class="docutils literal notranslate"><span class="pre">hpx_main</span></code> (or 0 when executed in worker mode).</dd>
<dt><strong>Note</strong></dt>
<dd>The created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argc</span></code>/<code class="docutils literal notranslate"><span class="pre">argv</span></code>. If not command line arguments are passed, console mode is assumed.</dd>
<dt><strong>Note</strong></dt>
<dd>If no command line arguments are passed the HPX runtime system will not support any of the default command line options as described in the section ‘HPX Command Line Options’. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">cfg</span></code>: A list of configuration settings which will be added to the system configuration before the runtime instance is run. Each of the entries in this list must have the format of a fully defined key/value pair from an ini-file (for instance ‘hpx.component.enabled=1’) </li>
<li><code class="docutils literal notranslate"><span class="pre">mode</span></code>: [in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfae8af6c45f53e2f3a938617540899092b"><span class="std std-ref">hpx::runtime_mode_console</span></a></em>), all other localities have to be run in worker mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfaba432e1dc9ba9d51594a7480e1a22a1e"><span class="std std-ref">hpx::runtime_mode_worker</span></a></em>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4initEPFiRN5boost15program_options13variables_mapEERNSt6stringEiPPcN3hpx12runtime_modeE">
<span id="_CPPv2N3hpx4initEPFiRN5boost15program_options13variables_mapEERNSt6stringEiPPcN3hpx12runtime_modeE"></span><span class="target" id="namespacehpx_1ae41deed58e7cb834e1eb9cb15c0c27d7"></span>int <code class="descname">init</code><span class="sig-paren">(</span>int (*<em>f</em>)<span class="sig-paren">(</span>boost::program_options::variables_map &amp;vm<span class="sig-paren">)</span>, std::string <em class="property">const</em> &amp;<em>app_name</em>, int <em>argc</em>, char **<em>argv</em>, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx12runtime_modeE" title="hpx::runtime_mode">runtime_mode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx20runtime_mode_defaultE" title="hpx::runtime_mode_default">runtime_mode_default</a>, <span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4initEPFiRN5boost15program_options13variables_mapEERNSt6stringEiPPcN3hpx12runtime_modeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Main entry point for launching the HPX runtime system. </p>
<p>This is a simplified main entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings). It will schedule the function given by <code class="docutils literal notranslate"><span class="pre">f</span></code> as a HPX thread. This overload will not call <code class="docutils literal notranslate"><span class="pre">hpx_main</span></code>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The function returns the value, which has been returned from the user supplied function <code class="docutils literal notranslate"><span class="pre">f</span></code>.</dd>
<dt><strong>Note</strong></dt>
<dd>The created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argc</span></code>/<code class="docutils literal notranslate"><span class="pre">argv</span></code>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: [in] The function to be scheduled as an HPX thread. Usually this function represents the main entry point of any HPX application. If <code class="docutils literal notranslate"><span class="pre">f</span></code> is <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> the HPX runtime environment will be started without invoking <code class="docutils literal notranslate"><span class="pre">f</span></code>. </li>
<li><code class="docutils literal notranslate"><span class="pre">app_name</span></code>: [in] The name of the application. </li>
<li><code class="docutils literal notranslate"><span class="pre">argc</span></code>: [in] The number of command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argv</span></code>. This is usually the unchanged value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">argv</span></code>: [in] The command line arguments for this application, usually that is the value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">mode</span></code>: [in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfae8af6c45f53e2f3a938617540899092b"><span class="std std-ref">hpx::runtime_mode_console</span></a></em>), all other localities have to be run in worker mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfaba432e1dc9ba9d51594a7480e1a22a1e"><span class="std std-ref">hpx::runtime_mode_worker</span></a></em>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4initEPFiRN5boost15program_options13variables_mapEEiPPcN3hpx12runtime_modeE">
<span id="_CPPv2N3hpx4initEPFiRN5boost15program_options13variables_mapEEiPPcN3hpx12runtime_modeE"></span><span class="target" id="namespacehpx_1ae18d07b03c60c4b05ada65049cbf94f6"></span>int <code class="descname">init</code><span class="sig-paren">(</span>int (*<em>f</em>)<span class="sig-paren">(</span>boost::program_options::variables_map &amp;vm<span class="sig-paren">)</span>, int <em>argc</em>, char **<em>argv</em>, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx12runtime_modeE" title="hpx::runtime_mode">runtime_mode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx20runtime_mode_defaultE" title="hpx::runtime_mode_default">runtime_mode_default</a>, <span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4initEPFiRN5boost15program_options13variables_mapEEiPPcN3hpx12runtime_modeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Main entry point for launching the HPX runtime system. </p>
<p>This is a simplified main entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings). It will schedule the function given by <code class="docutils literal notranslate"><span class="pre">f</span></code> as a HPX thread. This overload will not call <code class="docutils literal notranslate"><span class="pre">hpx_main</span></code>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The function returns the value, which has been returned from the user supplied function <code class="docutils literal notranslate"><span class="pre">f</span></code>.</dd>
<dt><strong>Note</strong></dt>
<dd>The created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argc</span></code>/<code class="docutils literal notranslate"><span class="pre">argv</span></code>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: [in] The function to be scheduled as an HPX thread. Usually this function represents the main entry point of any HPX application. If <code class="docutils literal notranslate"><span class="pre">f</span></code> is <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> the HPX runtime environment will be started without invoking <code class="docutils literal notranslate"><span class="pre">f</span></code>. </li>
<li><code class="docutils literal notranslate"><span class="pre">argc</span></code>: [in] The number of command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argv</span></code>. This is usually the unchanged value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">argv</span></code>: [in] The command line arguments for this application, usually that is the value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">mode</span></code>: [in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfae8af6c45f53e2f3a938617540899092b"><span class="std std-ref">hpx::runtime_mode_console</span></a></em>), all other localities have to be run in worker mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfaba432e1dc9ba9d51594a7480e1a22a1e"><span class="std std-ref">hpx::runtime_mode_worker</span></a></em>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4initERN4util15function_nonserIFiiPPcEEERNSt6stringEiPPcN3hpx12runtime_modeE">
<span id="_CPPv2N3hpx4initERN4util15function_nonserIFiiPPcEEERNSt6stringEiPPcN3hpx12runtime_modeE"></span><span class="target" id="namespacehpx_1a7dbf92ae7898899431df5fff333c4240"></span>int <code class="descname">init</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::function_nonser&lt;int<span class="sig-paren">(</span>int, char **<span class="sig-paren">)</span>&gt; <em class="property">const</em> &amp;<em>f</em>, std::string <em class="property">const</em> &amp;<em>app_name</em>, int <em>argc</em>, char **<em>argv</em>, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx12runtime_modeE" title="hpx::runtime_mode">runtime_mode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx20runtime_mode_defaultE" title="hpx::runtime_mode_default">runtime_mode_default</a>, <span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4initERN4util15function_nonserIFiiPPcEEERNSt6stringEiPPcN3hpx12runtime_modeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Main entry point for launching the HPX runtime system. </p>
<p>This is a simplified main entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings). It will schedule the function given by <code class="docutils literal notranslate"><span class="pre">f</span></code> as a HPX thread. This overload will not call <code class="docutils literal notranslate"><span class="pre">hpx_main</span></code>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The function returns the value, which has been returned from the user supplied function <code class="docutils literal notranslate"><span class="pre">f</span></code>.</dd>
<dt><strong>Note</strong></dt>
<dd>The created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argc</span></code>/<code class="docutils literal notranslate"><span class="pre">argv</span></code>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: [in] The function to be scheduled as an HPX thread. Usually this function represents the main entry point of any HPX application. If <code class="docutils literal notranslate"><span class="pre">f</span></code> is <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> the HPX runtime environment will be started without invoking <code class="docutils literal notranslate"><span class="pre">f</span></code>. </li>
<li><code class="docutils literal notranslate"><span class="pre">app_name</span></code>: [in] The name of the application. </li>
<li><code class="docutils literal notranslate"><span class="pre">argc</span></code>: [in] The number of command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argv</span></code>. This is usually the unchanged value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">argv</span></code>: [in] The command line arguments for this application, usually that is the value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">mode</span></code>: [in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfae8af6c45f53e2f3a938617540899092b"><span class="std std-ref">hpx::runtime_mode_console</span></a></em>), all other localities have to be run in worker mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfaba432e1dc9ba9d51594a7480e1a22a1e"><span class="std std-ref">hpx::runtime_mode_worker</span></a></em>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4initERN4util15function_nonserIFiiPPcEEEiPPcN3hpx12runtime_modeE">
<span id="_CPPv2N3hpx4initERN4util15function_nonserIFiiPPcEEEiPPcN3hpx12runtime_modeE"></span><span class="target" id="namespacehpx_1a30828fd4ee776cd069196712c5719434"></span>int <code class="descname">init</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::function_nonser&lt;int<span class="sig-paren">(</span>int, char **<span class="sig-paren">)</span>&gt; <em class="property">const</em> &amp;<em>f</em>, int <em>argc</em>, char **<em>argv</em>, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx12runtime_modeE" title="hpx::runtime_mode">runtime_mode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx20runtime_mode_defaultE" title="hpx::runtime_mode_default">runtime_mode_default</a>, <span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4initERN4util15function_nonserIFiiPPcEEEiPPcN3hpx12runtime_modeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Main entry point for launching the HPX runtime system. </p>
<p>This is a simplified main entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings). It will schedule the function given by <code class="docutils literal notranslate"><span class="pre">f</span></code> as a HPX thread. This overload will not call <code class="docutils literal notranslate"><span class="pre">hpx_main</span></code>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The function returns the value, which has been returned from the user supplied function <code class="docutils literal notranslate"><span class="pre">f</span></code>.</dd>
<dt><strong>Note</strong></dt>
<dd>The created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argc</span></code>/<code class="docutils literal notranslate"><span class="pre">argv</span></code>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: [in] The function to be scheduled as an HPX thread. Usually this function represents the main entry point of any HPX application. If <code class="docutils literal notranslate"><span class="pre">f</span></code> is <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> the HPX runtime environment will be started without invoking <code class="docutils literal notranslate"><span class="pre">f</span></code>. </li>
<li><code class="docutils literal notranslate"><span class="pre">argc</span></code>: [in] The number of command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argv</span></code>. This is usually the unchanged value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">argv</span></code>: [in] The command line arguments for this application, usually that is the value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">mode</span></code>: [in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfae8af6c45f53e2f3a938617540899092b"><span class="std std-ref">hpx::runtime_mode_console</span></a></em>), all other localities have to be run in worker mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfaba432e1dc9ba9d51594a7480e1a22a1e"><span class="std std-ref">hpx::runtime_mode_worker</span></a></em>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4initERN4util15function_nonserIFiiPPcEEEiPPcRNSt6vectorINSt6stringEEEN3hpx12runtime_modeE">
<span id="_CPPv2N3hpx4initERN4util15function_nonserIFiiPPcEEEiPPcRNSt6vectorINSt6stringEEEN3hpx12runtime_modeE"></span><span class="target" id="namespacehpx_1ac5c94e7a4250674e36082626aa34f3fc"></span>int <code class="descname">init</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::function_nonser&lt;int<span class="sig-paren">(</span>int, char **<span class="sig-paren">)</span>&gt; <em class="property">const</em> &amp;<em>f</em>, int <em>argc</em>, char **<em>argv</em>, std::vector&lt;std::string&gt; <em class="property">const</em> &amp;<em>cfg</em>, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx12runtime_modeE" title="hpx::runtime_mode">runtime_mode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx20runtime_mode_defaultE" title="hpx::runtime_mode_default">runtime_mode_default</a>, <span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4initERN4util15function_nonserIFiiPPcEEEiPPcRNSt6vectorINSt6stringEEEN3hpx12runtime_modeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Main entry point for launching the HPX runtime system. </p>
<p>This is a simplified main entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings). It will schedule the function given by <code class="docutils literal notranslate"><span class="pre">f</span></code> as a HPX thread. This overload will not call <code class="docutils literal notranslate"><span class="pre">hpx_main</span></code>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The function returns the value, which has been returned from the user supplied function <code class="docutils literal notranslate"><span class="pre">f</span></code>.</dd>
<dt><strong>Note</strong></dt>
<dd>The created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argc</span></code>/<code class="docutils literal notranslate"><span class="pre">argv</span></code>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: [in] The function to be scheduled as an HPX thread. Usually this function represents the main entry point of any HPX application. If <code class="docutils literal notranslate"><span class="pre">f</span></code> is <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> the HPX runtime environment will be started without invoking <code class="docutils literal notranslate"><span class="pre">f</span></code>. </li>
<li><code class="docutils literal notranslate"><span class="pre">argc</span></code>: [in] The number of command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argv</span></code>. This is usually the unchanged value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">argv</span></code>: [in] The command line arguments for this application, usually that is the value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">cfg</span></code>: A list of configuration settings which will be added to the system configuration before the runtime instance is run. Each of the entries in this list must have the format of a fully defined key/value pair from an ini-file (for instance ‘hpx.component.enabled=1’) </li>
<li><code class="docutils literal notranslate"><span class="pre">mode</span></code>: [in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfae8af6c45f53e2f3a938617540899092b"><span class="std std-ref">hpx::runtime_mode_console</span></a></em>), all other localities have to be run in worker mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfaba432e1dc9ba9d51594a7480e1a22a1e"><span class="std std-ref">hpx::runtime_mode_worker</span></a></em>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx5startERN4util15function_nonserIFiRN5boost15program_options13variables_mapEEEERN5boost15program_options19options_descriptionEiPPcRNSt6vectorINSt6stringEEE21startup_function_type22shutdown_function_typeN3hpx12runtime_modeE">
<span id="_CPPv2N3hpx5startERN4util15function_nonserIFiRN5boost15program_options13variables_mapEEEERN5boost15program_options19options_descriptionEiPPcRNSt6vectorINSt6stringEEE21startup_function_type22shutdown_function_typeN3hpx12runtime_modeE"></span><span class="target" id="namespacehpx_1a7e832bd3c4af93a4619dbe97a5b1c3d2"></span>bool <code class="descname">start</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::function_nonser&lt;int<span class="sig-paren">(</span>boost::program_options::variables_map &amp;vm<span class="sig-paren">)</span>&gt; <em class="property">const</em> &amp;<em>f</em>, boost::program_options::options_description <em class="property">const</em> &amp;<em>desc_cmdline</em>, int <em>argc</em>, char **<em>argv</em>, std::vector&lt;std::string&gt; <em class="property">const</em> &amp;<em>cfg</em>, <a class="reference internal" href="#_CPPv3N3hpx21startup_function_typeE" title="hpx::startup_function_type">startup_function_type</a> <em>startup</em> = <a class="reference internal" href="#_CPPv3N3hpx21startup_function_typeE" title="hpx::startup_function_type">startup_function_type</a>(), <a class="reference internal" href="#_CPPv3N3hpx22shutdown_function_typeE" title="hpx::shutdown_function_type">shutdown_function_type</a> <em>shutdown</em> = <a class="reference internal" href="#_CPPv3N3hpx22shutdown_function_typeE" title="hpx::shutdown_function_type">shutdown_function_type</a>(), <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx12runtime_modeE" title="hpx::runtime_mode">runtime_mode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx20runtime_mode_defaultE" title="hpx::runtime_mode_default">runtime_mode_default</a>, <span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx5startERN4util15function_nonserIFiRN5boost15program_options13variables_mapEEEERN5boost15program_options19options_descriptionEiPPcRNSt6vectorINSt6stringEEE21startup_function_type22shutdown_function_typeN3hpx12runtime_modeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Main non-blocking entry point for launching the HPX runtime system. </p>
<p>This is the main, non-blocking entry point for any HPX application. This function (or one of its overloads below) should be called from the users <code class="docutils literal notranslate"><span class="pre">main()</span></code> function. It will set up the HPX runtime environment and schedule the function given by <code class="docutils literal notranslate"><span class="pre">f</span></code> as a HPX thread. It will return immediately after that. Use <code class="docutils literal notranslate"><span class="pre">hpx::wait</span></code> and <code class="docutils literal notranslate"><a class="reference internal" href="#namespacehpx_1a1b4c2c4851fcae7c6c01617b6181d44f"><span class="std std-ref"><span class="pre">hpx::stop</span></span></a></code> to synchronize with the runtime system’s execution. This overload will not call <code class="docutils literal notranslate"><span class="pre">hpx_main</span></code>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The function returns <em>true</em> if command line processing succeeded and the runtime system was started successfully. It will return <em>false</em> otherwise.</dd>
<dt><strong>Note</strong></dt>
<dd>If the parameter <code class="docutils literal notranslate"><span class="pre">mode</span></code> is not given (defaulted), the created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argc</span></code>/<code class="docutils literal notranslate"><span class="pre">argv</span></code>. Otherwise it will be executed as specified by the parameter<code class="docutils literal notranslate"><span class="pre">mode</span></code>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: [in] The function to be scheduled as an HPX thread. Usually this function represents the main entry point of any HPX application. If <code class="docutils literal notranslate"><span class="pre">f</span></code> is <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> the HPX runtime environment will be started without invoking <code class="docutils literal notranslate"><span class="pre">f</span></code>. </li>
<li><code class="docutils literal notranslate"><span class="pre">desc_cmdline</span></code>: [in] This parameter may hold the description of additional command line arguments understood by the application. These options will be prepended to the default command line options understood by <em><a class="reference internal" href="#namespacehpx_1a3c694ea960b47c56b33351ba16e3d76b"><span class="std std-ref">hpx::init</span></a></em> (see description below). </li>
<li><code class="docutils literal notranslate"><span class="pre">argc</span></code>: [in] The number of command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argv</span></code>. This is usually the unchanged value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">argv</span></code>: [in] The command line arguments for this application, usually that is the value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">cfg</span></code>: A list of configuration settings which will be added to the system configuration before the runtime instance is run. Each of the entries in this list must have the format of a fully defined key/value pair from an ini-file (for instance ‘hpx.component.enabled=1’) </li>
<li><code class="docutils literal notranslate"><span class="pre">startup</span></code>: [in] A function to be executed inside a HPX thread before <code class="docutils literal notranslate"><span class="pre">f</span></code> is called. If this parameter is not given no function will be executed. </li>
<li><code class="docutils literal notranslate"><span class="pre">shutdown</span></code>: [in] A function to be executed inside an HPX thread while <a class="reference internal" href="#namespacehpx_1ab7eb159cb77997b366b5d79e65f04cd0"><span class="std std-ref">hpx::finalize</span></a> is executed. If this parameter is not given no function will be executed. </li>
<li><code class="docutils literal notranslate"><span class="pre">mode</span></code>: [in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfae8af6c45f53e2f3a938617540899092b"><span class="std std-ref">hpx::runtime_mode_console</span></a></em>), all other localities have to be run in worker mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfaba432e1dc9ba9d51594a7480e1a22a1e"><span class="std std-ref">hpx::runtime_mode_worker</span></a></em>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx5startEPFiRN5boost15program_options13variables_mapEERN5boost15program_options19options_descriptionEiPPc21startup_function_type22shutdown_function_typeN3hpx12runtime_modeE">
<span id="_CPPv2N3hpx5startEPFiRN5boost15program_options13variables_mapEERN5boost15program_options19options_descriptionEiPPc21startup_function_type22shutdown_function_typeN3hpx12runtime_modeE"></span><span class="target" id="namespacehpx_1a80ae064c776b7fb0f824cc936d7298ab"></span>bool <code class="descname">start</code><span class="sig-paren">(</span>int (*<em>f</em>)<span class="sig-paren">(</span>boost::program_options::variables_map &amp;vm<span class="sig-paren">)</span>, boost::program_options::options_description <em class="property">const</em> &amp;<em>desc_cmdline</em>, int <em>argc</em>, char **<em>argv</em>, <a class="reference internal" href="#_CPPv3N3hpx21startup_function_typeE" title="hpx::startup_function_type">startup_function_type</a> <em>startup</em> = <a class="reference internal" href="#_CPPv3N3hpx21startup_function_typeE" title="hpx::startup_function_type">startup_function_type</a>(), <a class="reference internal" href="#_CPPv3N3hpx22shutdown_function_typeE" title="hpx::shutdown_function_type">shutdown_function_type</a> <em>shutdown</em> = <a class="reference internal" href="#_CPPv3N3hpx22shutdown_function_typeE" title="hpx::shutdown_function_type">shutdown_function_type</a>(), <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx12runtime_modeE" title="hpx::runtime_mode">runtime_mode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx20runtime_mode_defaultE" title="hpx::runtime_mode_default">runtime_mode_default</a>, <span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx5startEPFiRN5boost15program_options13variables_mapEERN5boost15program_options19options_descriptionEiPPc21startup_function_type22shutdown_function_typeN3hpx12runtime_modeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Main non-blocking entry point for launching the HPX runtime system. </p>
<p>This is the main, non-blocking entry point for any HPX application. This function (or one of its overloads below) should be called from the users <code class="docutils literal notranslate"><span class="pre">main()</span></code> function. It will set up the HPX runtime environment and schedule the function given by <code class="docutils literal notranslate"><span class="pre">f</span></code> as a HPX thread. It will return immediately after that. Use <code class="docutils literal notranslate"><span class="pre">hpx::wait</span></code> and <code class="docutils literal notranslate"><a class="reference internal" href="#namespacehpx_1a1b4c2c4851fcae7c6c01617b6181d44f"><span class="std std-ref"><span class="pre">hpx::stop</span></span></a></code> to synchronize with the runtime system’s execution. This overload will not call <code class="docutils literal notranslate"><span class="pre">hpx_main</span></code>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The function returns <em>true</em> if command line processing succeeded and the runtime system was started successfully. It will return <em>false</em> otherwise.</dd>
<dt><strong>Note</strong></dt>
<dd>If the parameter <code class="docutils literal notranslate"><span class="pre">mode</span></code> is not given (defaulted), the created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argc</span></code>/<code class="docutils literal notranslate"><span class="pre">argv</span></code>. Otherwise it will be executed as specified by the parameter<code class="docutils literal notranslate"><span class="pre">mode</span></code>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: [in] The function to be scheduled as an HPX thread. Usually this function represents the main entry point of any HPX application. If <code class="docutils literal notranslate"><span class="pre">f</span></code> is <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> the HPX runtime environment will be started without invoking <code class="docutils literal notranslate"><span class="pre">f</span></code>. </li>
<li><code class="docutils literal notranslate"><span class="pre">desc_cmdline</span></code>: [in] This parameter may hold the description of additional command line arguments understood by the application. These options will be prepended to the default command line options understood by <em><a class="reference internal" href="#namespacehpx_1a3c694ea960b47c56b33351ba16e3d76b"><span class="std std-ref">hpx::init</span></a></em> (see description below). </li>
<li><code class="docutils literal notranslate"><span class="pre">argc</span></code>: [in] The number of command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argv</span></code>. This is usually the unchanged value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">argv</span></code>: [in] The command line arguments for this application, usually that is the value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">startup</span></code>: [in] A function to be executed inside a HPX thread before <code class="docutils literal notranslate"><span class="pre">f</span></code> is called. If this parameter is not given no function will be executed. </li>
<li><code class="docutils literal notranslate"><span class="pre">shutdown</span></code>: [in] A function to be executed inside an HPX thread while <a class="reference internal" href="#namespacehpx_1ab7eb159cb77997b366b5d79e65f04cd0"><span class="std std-ref">hpx::finalize</span></a> is executed. If this parameter is not given no function will be executed. </li>
<li><code class="docutils literal notranslate"><span class="pre">mode</span></code>: [in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfae8af6c45f53e2f3a938617540899092b"><span class="std std-ref">hpx::runtime_mode_console</span></a></em>), all other localities have to be run in worker mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfaba432e1dc9ba9d51594a7480e1a22a1e"><span class="std std-ref">hpx::runtime_mode_worker</span></a></em>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx5startERN5boost15program_options19options_descriptionEiPPc21startup_function_type22shutdown_function_typeN3hpx12runtime_modeE">
<span id="_CPPv2N3hpx5startERN5boost15program_options19options_descriptionEiPPc21startup_function_type22shutdown_function_typeN3hpx12runtime_modeE"></span><span id="hpx::start__boost::program_options::options_descriptionCR.i.cPP.startup_function_type.shutdown_function_type.hpx::runtime_mode"></span><span class="target" id="namespacehpx_1a3abde89aba0290f595742641833c8efe"></span>bool <code class="descname">start</code><span class="sig-paren">(</span>boost::program_options::options_description <em class="property">const</em> &amp;<em>desc_cmdline</em>, int <em>argc</em>, char **<em>argv</em>, <a class="reference internal" href="#_CPPv3N3hpx21startup_function_typeE" title="hpx::startup_function_type">startup_function_type</a> <em>startup</em> = <a class="reference internal" href="#_CPPv3N3hpx21startup_function_typeE" title="hpx::startup_function_type">startup_function_type</a>(), <a class="reference internal" href="#_CPPv3N3hpx22shutdown_function_typeE" title="hpx::shutdown_function_type">shutdown_function_type</a> <em>shutdown</em> = <a class="reference internal" href="#_CPPv3N3hpx22shutdown_function_typeE" title="hpx::shutdown_function_type">shutdown_function_type</a>(), <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx12runtime_modeE" title="hpx::runtime_mode">runtime_mode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx20runtime_mode_defaultE" title="hpx::runtime_mode_default">runtime_mode_default</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx5startERN5boost15program_options19options_descriptionEiPPc21startup_function_type22shutdown_function_typeN3hpx12runtime_modeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Main non-blocking entry point for launching the HPX runtime system. </p>
<p>This is a simplified main, non-blocking entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings). It will return immediately after that. Use <code class="docutils literal notranslate"><span class="pre">hpx::wait</span></code> and <code class="docutils literal notranslate"><a class="reference internal" href="#namespacehpx_1a1b4c2c4851fcae7c6c01617b6181d44f"><span class="std std-ref"><span class="pre">hpx::stop</span></span></a></code> to synchronize with the runtime system’s execution.</p>
<p>In console mode it will execute the user supplied function <code class="docutils literal notranslate"><span class="pre">hpx_main</span></code>, in worker mode it will execute an empty <code class="docutils literal notranslate"><span class="pre">hpx_main</span></code>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The function returns <em>true</em> if command line processing succeeded and the runtime system was started successfully. It will return <em>false</em> otherwise.</dd>
<dt><strong>Note</strong></dt>
<dd>If the parameter <code class="docutils literal notranslate"><span class="pre">mode</span></code> is not given (defaulted), the created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argc</span></code>/<code class="docutils literal notranslate"><span class="pre">argv</span></code>. Otherwise it will be executed as specified by the parameter<code class="docutils literal notranslate"><span class="pre">mode</span></code>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">desc_cmdline</span></code>: [in] This parameter may hold the description of additional command line arguments understood by the application. These options will be prepended to the default command line options understood by <em><a class="reference internal" href="#namespacehpx_1a3c694ea960b47c56b33351ba16e3d76b"><span class="std std-ref">hpx::init</span></a></em> (see description below). </li>
<li><code class="docutils literal notranslate"><span class="pre">argc</span></code>: [in] The number of command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argv</span></code>. This is usually the unchanged value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">argv</span></code>: [in] The command line arguments for this application, usually that is the value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">startup</span></code>: [in] A function to be executed inside a HPX thread before <code class="docutils literal notranslate"><span class="pre">f</span></code> is called. If this parameter is not given no function will be executed. </li>
<li><code class="docutils literal notranslate"><span class="pre">shutdown</span></code>: [in] A function to be executed inside an HPX thread while <a class="reference internal" href="#namespacehpx_1ab7eb159cb77997b366b5d79e65f04cd0"><span class="std std-ref">hpx::finalize</span></a> is executed. If this parameter is not given no function will be executed. </li>
<li><code class="docutils literal notranslate"><span class="pre">mode</span></code>: [in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfae8af6c45f53e2f3a938617540899092b"><span class="std std-ref">hpx::runtime_mode_console</span></a></em>), all other localities have to be run in worker mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfaba432e1dc9ba9d51594a7480e1a22a1e"><span class="std std-ref">hpx::runtime_mode_worker</span></a></em>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx5startERN5boost15program_options19options_descriptionEiPPcRNSt6vectorINSt6stringEEE21startup_function_type22shutdown_function_typeN3hpx12runtime_modeE">
<span id="_CPPv2N3hpx5startERN5boost15program_options19options_descriptionEiPPcRNSt6vectorINSt6stringEEE21startup_function_type22shutdown_function_typeN3hpx12runtime_modeE"></span><span id="hpx::start__boost::program_options::options_descriptionCR.i.cPP.std::vector:ss:CR.startup_function_type.shutdown_function_type.hpx::runtime_mode"></span><span class="target" id="namespacehpx_1ad886245d9e10d5381a7f78685f276cb5"></span>bool <code class="descname">start</code><span class="sig-paren">(</span>boost::program_options::options_description <em class="property">const</em> &amp;<em>desc_cmdline</em>, int <em>argc</em>, char **<em>argv</em>, std::vector&lt;std::string&gt; <em class="property">const</em> &amp;<em>cfg</em>, <a class="reference internal" href="#_CPPv3N3hpx21startup_function_typeE" title="hpx::startup_function_type">startup_function_type</a> <em>startup</em> = <a class="reference internal" href="#_CPPv3N3hpx21startup_function_typeE" title="hpx::startup_function_type">startup_function_type</a>(), <a class="reference internal" href="#_CPPv3N3hpx22shutdown_function_typeE" title="hpx::shutdown_function_type">shutdown_function_type</a> <em>shutdown</em> = <a class="reference internal" href="#_CPPv3N3hpx22shutdown_function_typeE" title="hpx::shutdown_function_type">shutdown_function_type</a>(), <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx12runtime_modeE" title="hpx::runtime_mode">runtime_mode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx20runtime_mode_defaultE" title="hpx::runtime_mode_default">runtime_mode_default</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx5startERN5boost15program_options19options_descriptionEiPPcRNSt6vectorINSt6stringEEE21startup_function_type22shutdown_function_typeN3hpx12runtime_modeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Main non-blocking entry point for launching the HPX runtime system. </p>
<p>This is a simplified main, non-blocking entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings). It will return immediately after that. Use <code class="docutils literal notranslate"><span class="pre">hpx::wait</span></code> and <code class="docutils literal notranslate"><a class="reference internal" href="#namespacehpx_1a1b4c2c4851fcae7c6c01617b6181d44f"><span class="std std-ref"><span class="pre">hpx::stop</span></span></a></code> to synchronize with the runtime system’s execution.</p>
<p>In console mode it will execute the user supplied function <code class="docutils literal notranslate"><span class="pre">hpx_main</span></code>, in worker mode it will execute an empty <code class="docutils literal notranslate"><span class="pre">hpx_main</span></code>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The function returns <em>true</em> if command line processing succeeded and the runtime system was started successfully. It will return <em>false</em> otherwise.</dd>
<dt><strong>Note</strong></dt>
<dd>If the parameter <code class="docutils literal notranslate"><span class="pre">mode</span></code> is not given (defaulted), the created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argc</span></code>/<code class="docutils literal notranslate"><span class="pre">argv</span></code>. Otherwise it will be executed as specified by the parameter<code class="docutils literal notranslate"><span class="pre">mode</span></code>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">desc_cmdline</span></code>: [in] This parameter may hold the description of additional command line arguments understood by the application. These options will be prepended to the default command line options understood by <em><a class="reference internal" href="#namespacehpx_1a3c694ea960b47c56b33351ba16e3d76b"><span class="std std-ref">hpx::init</span></a></em> (see description below). </li>
<li><code class="docutils literal notranslate"><span class="pre">argc</span></code>: [in] The number of command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argv</span></code>. This is usually the unchanged value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">argv</span></code>: [in] The command line arguments for this application, usually that is the value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">cfg</span></code>: A list of configuration settings which will be added to the system configuration before the runtime instance is run. Each of the entries in this list must have the format of a fully defined key/value pair from an ini-file (for instance ‘hpx.component.enabled=1’) </li>
<li><code class="docutils literal notranslate"><span class="pre">startup</span></code>: [in] A function to be executed inside a HPX thread before <code class="docutils literal notranslate"><span class="pre">f</span></code> is called. If this parameter is not given no function will be executed. </li>
<li><code class="docutils literal notranslate"><span class="pre">shutdown</span></code>: [in] A function to be executed inside an HPX thread while <a class="reference internal" href="#namespacehpx_1ab7eb159cb77997b366b5d79e65f04cd0"><span class="std std-ref">hpx::finalize</span></a> is executed. If this parameter is not given no function will be executed. </li>
<li><code class="docutils literal notranslate"><span class="pre">mode</span></code>: [in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfae8af6c45f53e2f3a938617540899092b"><span class="std std-ref">hpx::runtime_mode_console</span></a></em>), all other localities have to be run in worker mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfaba432e1dc9ba9d51594a7480e1a22a1e"><span class="std std-ref">hpx::runtime_mode_worker</span></a></em>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx5startEiPPcRNSt6vectorINSt6stringEEEN3hpx12runtime_modeE">
<span id="_CPPv2N3hpx5startEiPPcRNSt6vectorINSt6stringEEEN3hpx12runtime_modeE"></span><span id="hpx::start__i.cPP.std::vector:ss:CR.hpx::runtime_mode"></span><span class="target" id="namespacehpx_1a61e01ea3c0e0eed0f30ac3eecb58f4f7"></span>bool <code class="descname">start</code><span class="sig-paren">(</span>int <em>argc</em>, char **<em>argv</em>, std::vector&lt;std::string&gt; <em class="property">const</em> &amp;<em>cfg</em>, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx12runtime_modeE" title="hpx::runtime_mode">runtime_mode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx20runtime_mode_defaultE" title="hpx::runtime_mode_default">runtime_mode_default</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx5startEiPPcRNSt6vectorINSt6stringEEEN3hpx12runtime_modeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Main non-blocking entry point for launching the HPX runtime system. </p>
<p>This is a simplified main, non-blocking entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings). It will return immediately after that. Use <code class="docutils literal notranslate"><span class="pre">hpx::wait</span></code> and <code class="docutils literal notranslate"><a class="reference internal" href="#namespacehpx_1a1b4c2c4851fcae7c6c01617b6181d44f"><span class="std std-ref"><span class="pre">hpx::stop</span></span></a></code> to synchronize with the runtime system’s execution.</p>
<p>In console mode it will execute the user supplied function <code class="docutils literal notranslate"><span class="pre">hpx_main</span></code>, in worker mode it will execute an empty <code class="docutils literal notranslate"><span class="pre">hpx_main</span></code>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The function returns <em>true</em> if command line processing succeeded and the runtime system was started successfully. It will return <em>false</em> otherwise.</dd>
<dt><strong>Note</strong></dt>
<dd>If the parameter <code class="docutils literal notranslate"><span class="pre">mode</span></code> is runtime_mode_default, the created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argc</span></code>/<code class="docutils literal notranslate"><span class="pre">argv</span></code>. Otherwise it will be executed as specified by the parameter<code class="docutils literal notranslate"><span class="pre">mode</span></code>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">argc</span></code>: [in] The number of command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argv</span></code>. This is usually the unchanged value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">argv</span></code>: [in] The command line arguments for this application, usually that is the value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">cfg</span></code>: A list of configuration settings which will be added to the system configuration before the runtime instance is run. Each of the entries in this list must have the format of a fully defined key/value pair from an ini-file (for instance ‘hpx.component.enabled=1’) </li>
<li><code class="docutils literal notranslate"><span class="pre">mode</span></code>: [in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfae8af6c45f53e2f3a938617540899092b"><span class="std std-ref">hpx::runtime_mode_console</span></a></em>), all other localities have to be run in worker mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfaba432e1dc9ba9d51594a7480e1a22a1e"><span class="std std-ref">hpx::runtime_mode_worker</span></a></em>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx5startERN5boost15program_options19options_descriptionEiPPcN3hpx12runtime_modeE">
<span id="_CPPv2N3hpx5startERN5boost15program_options19options_descriptionEiPPcN3hpx12runtime_modeE"></span><span id="hpx::start__boost::program_options::options_descriptionCR.i.cPP.hpx::runtime_mode"></span><span class="target" id="namespacehpx_1a8b24cfd34bb3fafdd4b2db966770cfa2"></span>bool <code class="descname">start</code><span class="sig-paren">(</span>boost::program_options::options_description <em class="property">const</em> &amp;<em>desc_cmdline</em>, int <em>argc</em>, char **<em>argv</em>, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx12runtime_modeE" title="hpx::runtime_mode">runtime_mode</a> <em>mode</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx5startERN5boost15program_options19options_descriptionEiPPcN3hpx12runtime_modeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Main non-blocking entry point for launching the HPX runtime system. </p>
<p>This is a simplified main, non-blocking entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings). It will return immediately after that. Use <code class="docutils literal notranslate"><span class="pre">hpx::wait</span></code> and <code class="docutils literal notranslate"><a class="reference internal" href="#namespacehpx_1a1b4c2c4851fcae7c6c01617b6181d44f"><span class="std std-ref"><span class="pre">hpx::stop</span></span></a></code> to synchronize with the runtime system’s execution.</p>
<p>In console mode it will execute the user supplied function <code class="docutils literal notranslate"><span class="pre">hpx_main</span></code>, in worker mode it will execute an empty <code class="docutils literal notranslate"><span class="pre">hpx_main</span></code>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The function returns <em>true</em> if command line processing succeeded and the runtime system was started successfully. It will return <em>false</em> otherwise.</dd>
<dt><strong>Note</strong></dt>
<dd>If the parameter <code class="docutils literal notranslate"><span class="pre">mode</span></code> is runtime_mode_default, the created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argc</span></code>/<code class="docutils literal notranslate"><span class="pre">argv</span></code>. Otherwise it will be executed as specified by the parameter<code class="docutils literal notranslate"><span class="pre">mode</span></code>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">desc_cmdline</span></code>: [in] This parameter may hold the description of additional command line arguments understood by the application. These options will be prepended to the default command line options understood by <em><a class="reference internal" href="#namespacehpx_1a3c694ea960b47c56b33351ba16e3d76b"><span class="std std-ref">hpx::init</span></a></em> (see description below). </li>
<li><code class="docutils literal notranslate"><span class="pre">argc</span></code>: [in] The number of command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argv</span></code>. This is usually the unchanged value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">argv</span></code>: [in] The command line arguments for this application, usually that is the value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">mode</span></code>: [in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfae8af6c45f53e2f3a938617540899092b"><span class="std std-ref">hpx::runtime_mode_console</span></a></em>), all other localities have to be run in worker mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfaba432e1dc9ba9d51594a7480e1a22a1e"><span class="std std-ref">hpx::runtime_mode_worker</span></a></em>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx5startERN5boost15program_options19options_descriptionEiPPcRNSt6vectorINSt6stringEEEN3hpx12runtime_modeE">
<span id="_CPPv2N3hpx5startERN5boost15program_options19options_descriptionEiPPcRNSt6vectorINSt6stringEEEN3hpx12runtime_modeE"></span><span id="hpx::start__boost::program_options::options_descriptionCR.i.cPP.std::vector:ss:CR.hpx::runtime_mode"></span><span class="target" id="namespacehpx_1a8ac3c6022272a4dd1f27ca9de61d09b6"></span>bool <code class="descname">start</code><span class="sig-paren">(</span>boost::program_options::options_description <em class="property">const</em> &amp;<em>desc_cmdline</em>, int <em>argc</em>, char **<em>argv</em>, std::vector&lt;std::string&gt; <em class="property">const</em> &amp;<em>cfg</em>, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx12runtime_modeE" title="hpx::runtime_mode">runtime_mode</a> <em>mode</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx5startERN5boost15program_options19options_descriptionEiPPcRNSt6vectorINSt6stringEEEN3hpx12runtime_modeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Main non-blocking entry point for launching the HPX runtime system. </p>
<p>This is a simplified main, non-blocking entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings). It will return immediately after that. Use <code class="docutils literal notranslate"><span class="pre">hpx::wait</span></code> and <code class="docutils literal notranslate"><a class="reference internal" href="#namespacehpx_1a1b4c2c4851fcae7c6c01617b6181d44f"><span class="std std-ref"><span class="pre">hpx::stop</span></span></a></code> to synchronize with the runtime system’s execution.</p>
<p>In console mode it will execute the user supplied function <code class="docutils literal notranslate"><span class="pre">hpx_main</span></code>, in worker mode it will execute an empty <code class="docutils literal notranslate"><span class="pre">hpx_main</span></code>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The function returns <em>true</em> if command line processing succeeded and the runtime system was started successfully. It will return <em>false</em> otherwise.</dd>
<dt><strong>Note</strong></dt>
<dd>If the parameter <code class="docutils literal notranslate"><span class="pre">mode</span></code> is runtime_mode_default, the created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argc</span></code>/<code class="docutils literal notranslate"><span class="pre">argv</span></code>. Otherwise it will be executed as specified by the parameter<code class="docutils literal notranslate"><span class="pre">mode</span></code>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">desc_cmdline</span></code>: [in] This parameter may hold the description of additional command line arguments understood by the application. These options will be prepended to the default command line options understood by <em><a class="reference internal" href="#namespacehpx_1a3c694ea960b47c56b33351ba16e3d76b"><span class="std std-ref">hpx::init</span></a></em> (see description below). </li>
<li><code class="docutils literal notranslate"><span class="pre">argc</span></code>: [in] The number of command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argv</span></code>. This is usually the unchanged value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">argv</span></code>: [in] The command line arguments for this application, usually that is the value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">cfg</span></code>: A list of configuration settings which will be added to the system configuration before the runtime instance is run. Each of the entries in this list must have the format of a fully defined key/value pair from an ini-file (for instance ‘hpx.component.enabled=1’) </li>
<li><code class="docutils literal notranslate"><span class="pre">mode</span></code>: [in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfae8af6c45f53e2f3a938617540899092b"><span class="std std-ref">hpx::runtime_mode_console</span></a></em>), all other localities have to be run in worker mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfaba432e1dc9ba9d51594a7480e1a22a1e"><span class="std std-ref">hpx::runtime_mode_worker</span></a></em>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx5startERNSt6stringEiPPcN3hpx12runtime_modeE">
<span id="_CPPv2N3hpx5startERNSt6stringEiPPcN3hpx12runtime_modeE"></span><span id="hpx::start__ssCR.i.cPP.hpx::runtime_mode"></span><span class="target" id="namespacehpx_1a9ddc6ea9a1a6faa5aff2a7c723752591"></span>bool <code class="descname">start</code><span class="sig-paren">(</span>std::string <em class="property">const</em> &amp;<em>app_name</em>, int <em>argc</em> = 0, char **<em>argv</em> = nullptr, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx12runtime_modeE" title="hpx::runtime_mode">runtime_mode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx20runtime_mode_defaultE" title="hpx::runtime_mode_default">runtime_mode_default</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx5startERNSt6stringEiPPcN3hpx12runtime_modeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Main non-blocking entry point for launching the HPX runtime system. </p>
<p>This is a simplified main, non-blocking entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings). It will return immediately after that. Use <code class="docutils literal notranslate"><span class="pre">hpx::wait</span></code> and <code class="docutils literal notranslate"><a class="reference internal" href="#namespacehpx_1a1b4c2c4851fcae7c6c01617b6181d44f"><span class="std std-ref"><span class="pre">hpx::stop</span></span></a></code> to synchronize with the runtime system’s execution.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The function returns <em>true</em> if command line processing succeeded and the runtime system was started successfully. It will return <em>false</em> otherwise.</dd>
<dt><strong>Note</strong></dt>
<dd>The created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argc</span></code>/<code class="docutils literal notranslate"><span class="pre">argv</span></code>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">app_name</span></code>: [in] The name of the application. </li>
<li><code class="docutils literal notranslate"><span class="pre">argc</span></code>: [in] The number of command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argv</span></code>. This is usually the unchanged value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">argv</span></code>: [in] The command line arguments for this application, usually that is the value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">mode</span></code>: [in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfae8af6c45f53e2f3a938617540899092b"><span class="std std-ref">hpx::runtime_mode_console</span></a></em>), all other localities have to be run in worker mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfaba432e1dc9ba9d51594a7480e1a22a1e"><span class="std std-ref">hpx::runtime_mode_worker</span></a></em>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx5startEiPPcN3hpx12runtime_modeE">
<span id="_CPPv2N3hpx5startEiPPcN3hpx12runtime_modeE"></span><span id="hpx::start__i.cPP.hpx::runtime_mode"></span><span class="target" id="namespacehpx_1a5ee710f0fe99def75e0ef2f5ee1ab94e"></span>bool <code class="descname">start</code><span class="sig-paren">(</span>int <em>argc</em> = 0, char **<em>argv</em> = nullptr, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx12runtime_modeE" title="hpx::runtime_mode">runtime_mode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx20runtime_mode_defaultE" title="hpx::runtime_mode_default">runtime_mode_default</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx5startEiPPcN3hpx12runtime_modeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Main non-blocking entry point for launching the HPX runtime system. </p>
<p>This is a simplified main, non-blocking entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings). It will return immediately after that. Use <code class="docutils literal notranslate"><span class="pre">hpx::wait</span></code> and <code class="docutils literal notranslate"><a class="reference internal" href="#namespacehpx_1a1b4c2c4851fcae7c6c01617b6181d44f"><span class="std std-ref"><span class="pre">hpx::stop</span></span></a></code> to synchronize with the runtime system’s execution.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The function returns <em>true</em> if command line processing succeeded and the runtime system was started successfully. It will return <em>false</em> otherwise.</dd>
<dt><strong>Note</strong></dt>
<dd>The created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argc</span></code>/<code class="docutils literal notranslate"><span class="pre">argv</span></code>. If not command line arguments are passed, console mode is assumed.</dd>
<dt><strong>Note</strong></dt>
<dd>If no command line arguments are passed the HPX runtime system will not support any of the default command line options as described in the section ‘HPX Command Line Options’. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">argc</span></code>: [in] The number of command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argv</span></code>. This is usually the unchanged value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">argv</span></code>: [in] The command line arguments for this application, usually that is the value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">mode</span></code>: [in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfae8af6c45f53e2f3a938617540899092b"><span class="std std-ref">hpx::runtime_mode_console</span></a></em>), all other localities have to be run in worker mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfaba432e1dc9ba9d51594a7480e1a22a1e"><span class="std std-ref">hpx::runtime_mode_worker</span></a></em>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx5startERNSt6vectorINSt6stringEEEN3hpx12runtime_modeE">
<span id="_CPPv2N3hpx5startERNSt6vectorINSt6stringEEEN3hpx12runtime_modeE"></span><span id="hpx::start__std::vector:ss:CR.hpx::runtime_mode"></span><span class="target" id="namespacehpx_1a6b072b4e453f66c127d9b8108cfc3485"></span>bool <code class="descname">start</code><span class="sig-paren">(</span>std::vector&lt;std::string&gt; <em class="property">const</em> &amp;<em>cfg</em>, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx12runtime_modeE" title="hpx::runtime_mode">runtime_mode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx20runtime_mode_defaultE" title="hpx::runtime_mode_default">runtime_mode_default</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx5startERNSt6vectorINSt6stringEEEN3hpx12runtime_modeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Main non-blocking entry point for launching the HPX runtime system. </p>
<p>This is a simplified main, non-blocking entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings). It will return immediately after that. Use <code class="docutils literal notranslate"><span class="pre">hpx::wait</span></code> and <code class="docutils literal notranslate"><a class="reference internal" href="#namespacehpx_1a1b4c2c4851fcae7c6c01617b6181d44f"><span class="std std-ref"><span class="pre">hpx::stop</span></span></a></code> to synchronize with the runtime system’s execution.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The function returns <em>true</em> if command line processing succeeded and the runtime system was started successfully. It will return <em>false</em> otherwise.</dd>
<dt><strong>Note</strong></dt>
<dd>The created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argc</span></code>/<code class="docutils literal notranslate"><span class="pre">argv</span></code>. If not command line arguments are passed, console mode is assumed.</dd>
<dt><strong>Note</strong></dt>
<dd>If no command line arguments are passed the HPX runtime system will not support any of the default command line options as described in the section ‘HPX Command Line Options’. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">cfg</span></code>: A list of configuration settings which will be added to the system configuration before the runtime instance is run. Each of the entries in this list must have the format of a fully defined key/value pair from an ini-file (for instance ‘hpx.component.enabled=1’) </li>
<li><code class="docutils literal notranslate"><span class="pre">mode</span></code>: [in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfae8af6c45f53e2f3a938617540899092b"><span class="std std-ref">hpx::runtime_mode_console</span></a></em>), all other localities have to be run in worker mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfaba432e1dc9ba9d51594a7480e1a22a1e"><span class="std std-ref">hpx::runtime_mode_worker</span></a></em>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx5startEPFiRN5boost15program_options13variables_mapEERNSt6stringEiPPcN3hpx12runtime_modeE">
<span id="_CPPv2N3hpx5startEPFiRN5boost15program_options13variables_mapEERNSt6stringEiPPcN3hpx12runtime_modeE"></span><span class="target" id="namespacehpx_1a6ef9f2b314afe18536a7edc96de6a964"></span>bool <code class="descname">start</code><span class="sig-paren">(</span>int (*<em>f</em>)<span class="sig-paren">(</span>boost::program_options::variables_map &amp;vm<span class="sig-paren">)</span>, std::string <em class="property">const</em> &amp;<em>app_name</em>, int <em>argc</em>, char **<em>argv</em>, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx12runtime_modeE" title="hpx::runtime_mode">runtime_mode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx20runtime_mode_defaultE" title="hpx::runtime_mode_default">runtime_mode_default</a>, <span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx5startEPFiRN5boost15program_options13variables_mapEERNSt6stringEiPPcN3hpx12runtime_modeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Main non-blocking entry point for launching the HPX runtime system. </p>
<p>This is a simplified main, non-blocking entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings). It will return immediately after that. Use <code class="docutils literal notranslate"><span class="pre">hpx::wait</span></code> and <code class="docutils literal notranslate"><a class="reference internal" href="#namespacehpx_1a1b4c2c4851fcae7c6c01617b6181d44f"><span class="std std-ref"><span class="pre">hpx::stop</span></span></a></code> to synchronize with the runtime system’s execution. This overload will schedule the function given by <code class="docutils literal notranslate"><span class="pre">f</span></code> as a HPX thread. It will not call <code class="docutils literal notranslate"><span class="pre">hpx_main</span></code>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The function returns <em>true</em> if command line processing succeeded and the runtime system was started successfully. It will return <em>false</em> otherwise.</dd>
<dt><strong>Note</strong></dt>
<dd>The created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argc</span></code>/<code class="docutils literal notranslate"><span class="pre">argv</span></code>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: [in] The function to be scheduled as an HPX thread. Usually this function represents the main entry point of any HPX application. </li>
<li><code class="docutils literal notranslate"><span class="pre">app_name</span></code>: [in] The name of the application. </li>
<li><code class="docutils literal notranslate"><span class="pre">argc</span></code>: [in] The number of command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argv</span></code>. This is usually the unchanged value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">argv</span></code>: [in] The command line arguments for this application, usually that is the value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">mode</span></code>: [in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfae8af6c45f53e2f3a938617540899092b"><span class="std std-ref">hpx::runtime_mode_console</span></a></em>), all other localities have to be run in worker mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfaba432e1dc9ba9d51594a7480e1a22a1e"><span class="std std-ref">hpx::runtime_mode_worker</span></a></em>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx5startERN4util15function_nonserIFiiPPcEEERNSt6stringEiPPcN3hpx12runtime_modeE">
<span id="_CPPv2N3hpx5startERN4util15function_nonserIFiiPPcEEERNSt6stringEiPPcN3hpx12runtime_modeE"></span><span class="target" id="namespacehpx_1a7c75886f31b64226b848655fc69bf611"></span>bool <code class="descname">start</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::function_nonser&lt;int<span class="sig-paren">(</span>int, char **<span class="sig-paren">)</span>&gt; <em class="property">const</em> &amp;<em>f</em>, std::string <em class="property">const</em> &amp;<em>app_name</em>, int <em>argc</em>, char **<em>argv</em>, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx12runtime_modeE" title="hpx::runtime_mode">runtime_mode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx20runtime_mode_defaultE" title="hpx::runtime_mode_default">runtime_mode_default</a>, <span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx5startERN4util15function_nonserIFiiPPcEEERNSt6stringEiPPcN3hpx12runtime_modeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Main non-blocking entry point for launching the HPX runtime system. </p>
<p>This is a simplified main, non-blocking entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings). It will return immediately after that. Use <code class="docutils literal notranslate"><span class="pre">hpx::wait</span></code> and <code class="docutils literal notranslate"><a class="reference internal" href="#namespacehpx_1a1b4c2c4851fcae7c6c01617b6181d44f"><span class="std std-ref"><span class="pre">hpx::stop</span></span></a></code> to synchronize with the runtime system’s execution. This overload will schedule the function given by <code class="docutils literal notranslate"><span class="pre">f</span></code> as a HPX thread. It will not call <code class="docutils literal notranslate"><span class="pre">hpx_main</span></code>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The function returns <em>true</em> if command line processing succeeded and the runtime system was started successfully. It will return <em>false</em> otherwise.</dd>
<dt><strong>Note</strong></dt>
<dd>The created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argc</span></code>/<code class="docutils literal notranslate"><span class="pre">argv</span></code>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: [in] The function to be scheduled as an HPX thread. Usually this function represents the main entry point of any HPX application. If <code class="docutils literal notranslate"><span class="pre">f</span></code> is <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> the HPX runtime environment will be started without invoking <code class="docutils literal notranslate"><span class="pre">f</span></code>. </li>
<li><code class="docutils literal notranslate"><span class="pre">app_name</span></code>: [in] The name of the application. </li>
<li><code class="docutils literal notranslate"><span class="pre">argc</span></code>: [in] The number of command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argv</span></code>. This is usually the unchanged value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">argv</span></code>: [in] The command line arguments for this application, usually that is the value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">mode</span></code>: [in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfae8af6c45f53e2f3a938617540899092b"><span class="std std-ref">hpx::runtime_mode_console</span></a></em>), all other localities have to be run in worker mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfaba432e1dc9ba9d51594a7480e1a22a1e"><span class="std std-ref">hpx::runtime_mode_worker</span></a></em>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx5startEPFiRN5boost15program_options13variables_mapEEiPPcN3hpx12runtime_modeE">
<span id="_CPPv2N3hpx5startEPFiRN5boost15program_options13variables_mapEEiPPcN3hpx12runtime_modeE"></span><span class="target" id="namespacehpx_1af9d23a05615e4bb15bc3ee24c0150358"></span>bool <code class="descname">start</code><span class="sig-paren">(</span>int (*<em>f</em>)<span class="sig-paren">(</span>boost::program_options::variables_map &amp;vm<span class="sig-paren">)</span>, int <em>argc</em>, char **<em>argv</em>, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx12runtime_modeE" title="hpx::runtime_mode">runtime_mode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx20runtime_mode_defaultE" title="hpx::runtime_mode_default">runtime_mode_default</a>, <span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx5startEPFiRN5boost15program_options13variables_mapEEiPPcN3hpx12runtime_modeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Main non-blocking entry point for launching the HPX runtime system. </p>
<p>This is a simplified main, non-blocking entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings). It will return immediately after that. Use <code class="docutils literal notranslate"><span class="pre">hpx::wait</span></code> and <code class="docutils literal notranslate"><a class="reference internal" href="#namespacehpx_1a1b4c2c4851fcae7c6c01617b6181d44f"><span class="std std-ref"><span class="pre">hpx::stop</span></span></a></code> to synchronize with the runtime system’s execution. This overload will schedule the function given by <code class="docutils literal notranslate"><span class="pre">f</span></code> as a HPX thread. It will not call <code class="docutils literal notranslate"><span class="pre">hpx_main</span></code>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The function returns <em>true</em> if command line processing succeeded and the runtime system was started successfully. It will return <em>false</em> otherwise.</dd>
<dt><strong>Note</strong></dt>
<dd>The created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argc</span></code>/<code class="docutils literal notranslate"><span class="pre">argv</span></code>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: [in] The function to be scheduled as an HPX thread. Usually this function represents the main entry point of any HPX application. If <code class="docutils literal notranslate"><span class="pre">f</span></code> is <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> the HPX runtime environment will be started without invoking <code class="docutils literal notranslate"><span class="pre">f</span></code>. </li>
<li><code class="docutils literal notranslate"><span class="pre">argc</span></code>: [in] The number of command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argv</span></code>. This is usually the unchanged value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">argv</span></code>: [in] The command line arguments for this application, usually that is the value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">mode</span></code>: [in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfae8af6c45f53e2f3a938617540899092b"><span class="std std-ref">hpx::runtime_mode_console</span></a></em>), all other localities have to be run in worker mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfaba432e1dc9ba9d51594a7480e1a22a1e"><span class="std std-ref">hpx::runtime_mode_worker</span></a></em>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx5startERN4util15function_nonserIFiiPPcEEEiPPcN3hpx12runtime_modeE">
<span id="_CPPv2N3hpx5startERN4util15function_nonserIFiiPPcEEEiPPcN3hpx12runtime_modeE"></span><span class="target" id="namespacehpx_1a8d56659a465baf2303c2b88936e7cf0e"></span>bool <code class="descname">start</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::function_nonser&lt;int<span class="sig-paren">(</span>int, char **<span class="sig-paren">)</span>&gt; <em class="property">const</em> &amp;<em>f</em>, int <em>argc</em>, char **<em>argv</em>, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx12runtime_modeE" title="hpx::runtime_mode">runtime_mode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx20runtime_mode_defaultE" title="hpx::runtime_mode_default">runtime_mode_default</a>, <span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx5startERN4util15function_nonserIFiiPPcEEEiPPcN3hpx12runtime_modeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Main non-blocking entry point for launching the HPX runtime system. </p>
<p>This is a simplified main, non-blocking entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings). It will return immediately after that. Use <code class="docutils literal notranslate"><span class="pre">hpx::wait</span></code> and <code class="docutils literal notranslate"><a class="reference internal" href="#namespacehpx_1a1b4c2c4851fcae7c6c01617b6181d44f"><span class="std std-ref"><span class="pre">hpx::stop</span></span></a></code> to synchronize with the runtime system’s execution. This overload will schedule the function given by <code class="docutils literal notranslate"><span class="pre">f</span></code> as a HPX thread. It will not call <code class="docutils literal notranslate"><span class="pre">hpx_main</span></code>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The function returns <em>true</em> if command line processing succeeded and the runtime system was started successfully. It will return <em>false</em> otherwise.</dd>
<dt><strong>Note</strong></dt>
<dd>The created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argc</span></code>/<code class="docutils literal notranslate"><span class="pre">argv</span></code>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: [in] The function to be scheduled as an HPX thread. Usually this function represents the main entry point of any HPX application. If <code class="docutils literal notranslate"><span class="pre">f</span></code> is <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> the HPX runtime environment will be started without invoking <code class="docutils literal notranslate"><span class="pre">f</span></code>. </li>
<li><code class="docutils literal notranslate"><span class="pre">argc</span></code>: [in] The number of command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argv</span></code>. This is usually the unchanged value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">argv</span></code>: [in] The command line arguments for this application, usually that is the value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">mode</span></code>: [in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfae8af6c45f53e2f3a938617540899092b"><span class="std std-ref">hpx::runtime_mode_console</span></a></em>), all other localities have to be run in worker mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfaba432e1dc9ba9d51594a7480e1a22a1e"><span class="std std-ref">hpx::runtime_mode_worker</span></a></em>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx5startERN4util15function_nonserIFiiPPcEEEiPPcRNSt6vectorINSt6stringEEEN3hpx12runtime_modeE">
<span id="_CPPv2N3hpx5startERN4util15function_nonserIFiiPPcEEEiPPcRNSt6vectorINSt6stringEEEN3hpx12runtime_modeE"></span><span class="target" id="namespacehpx_1ac448add81d30e8932cd3a4ce367de66e"></span>bool <code class="descname">start</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::function_nonser&lt;int<span class="sig-paren">(</span>int, char **<span class="sig-paren">)</span>&gt; <em class="property">const</em> &amp;<em>f</em>, int <em>argc</em>, char **<em>argv</em>, std::vector&lt;std::string&gt; <em class="property">const</em> &amp;<em>cfg</em>, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx12runtime_modeE" title="hpx::runtime_mode">runtime_mode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx20runtime_mode_defaultE" title="hpx::runtime_mode_default">runtime_mode_default</a>, <span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx5startERN4util15function_nonserIFiiPPcEEEiPPcRNSt6vectorINSt6stringEEEN3hpx12runtime_modeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Main non-blocking entry point for launching the HPX runtime system. </p>
<p>This is a simplified main, non-blocking entry point, which can be used to set up the runtime for an HPX application (the runtime system will be set up in console mode or worker mode depending on the command line settings). It will return immediately after that. Use <code class="docutils literal notranslate"><span class="pre">hpx::wait</span></code> and <code class="docutils literal notranslate"><a class="reference internal" href="#namespacehpx_1a1b4c2c4851fcae7c6c01617b6181d44f"><span class="std std-ref"><span class="pre">hpx::stop</span></span></a></code> to synchronize with the runtime system’s execution. This overload will schedule the function given by <code class="docutils literal notranslate"><span class="pre">f</span></code> as a HPX thread. It will not call <code class="docutils literal notranslate"><span class="pre">hpx_main</span></code>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The function returns <em>true</em> if command line processing succeeded and the runtime system was started successfully. It will return <em>false</em> otherwise.</dd>
<dt><strong>Note</strong></dt>
<dd>The created runtime system instance will be executed in console or worker mode depending on the command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argc</span></code>/<code class="docutils literal notranslate"><span class="pre">argv</span></code>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: [in] The function to be scheduled as an HPX thread. Usually this function represents the main entry point of any HPX application. If <code class="docutils literal notranslate"><span class="pre">f</span></code> is <code class="docutils literal notranslate"><span class="pre">nullptr</span></code> the HPX runtime environment will be started without invoking <code class="docutils literal notranslate"><span class="pre">f</span></code>. </li>
<li><code class="docutils literal notranslate"><span class="pre">argc</span></code>: [in] The number of command line arguments passed in <code class="docutils literal notranslate"><span class="pre">argv</span></code>. This is usually the unchanged value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">argv</span></code>: [in] The command line arguments for this application, usually that is the value as passed by the operating system (to <code class="docutils literal notranslate"><span class="pre">main()</span></code>). </li>
<li><code class="docutils literal notranslate"><span class="pre">cfg</span></code>: A list of configuration settings which will be added to the system configuration before the runtime instance is run. Each of the entries in this list must have the format of a fully defined key/value pair from an ini-file (for instance ‘hpx.component.enabled=1’) </li>
<li><code class="docutils literal notranslate"><span class="pre">mode</span></code>: [in] The mode the created runtime environment should be initialized in. There has to be exactly one locality in each HPX application which is executed in console mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfae8af6c45f53e2f3a938617540899092b"><span class="std std-ref">hpx::runtime_mode_console</span></a></em>), all other localities have to be run in worker mode (<em><a class="reference internal" href="#namespacehpx_1a380cead581c9f4b6ec569a355f9440bfaba432e1dc9ba9d51594a7480e1a22a1e"><span class="std std-ref">hpx::runtime_mode_worker</span></a></em>). Normally this is set up automatically, but sometimes it is necessary to explicitly specify the mode.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8finalizeEddR10error_code">
<span id="_CPPv2N3hpx8finalizeEddR10error_code"></span><span id="hpx::finalize__double.double.error_codeR"></span><span class="target" id="namespacehpx_1ab7eb159cb77997b366b5d79e65f04cd0"></span>int <code class="descname">finalize</code><span class="sig-paren">(</span>double <em>shutdown_timeout</em>, double <em>localwait</em> = -1.0, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8finalizeEddR10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Main function to gracefully terminate the HPX runtime system. </p>
<p>The function <em><a class="reference internal" href="#namespacehpx_1ab7eb159cb77997b366b5d79e65f04cd0"><span class="std std-ref">hpx::finalize</span></a></em> is the main way to (gracefully) exit any HPX application. It should be called from one locality only (usually the console) and it will notify all connected localities to finish execution. Only after all other localities have exited this function will return, allowing to exit the console locality as well.</p>
<p>During the execution of this function the runtime system will invoke all registered shutdown functions (see <em><a class="reference internal" href="#namespacehpx_1a3c694ea960b47c56b33351ba16e3d76b"><span class="std std-ref">hpx::init</span></a></em>) on all localities.</p>
<p><p>The default value (</p>
<code class="docutils literal notranslate"><span class="pre">-1.0</span></code>) will try to find a globally set timeout value (can be set as the configuration parameter <code class="docutils literal notranslate"><span class="pre">hpx.shutdown_timeout</span></code>), and if that is not set or <code class="docutils literal notranslate"><span class="pre">-1.0</span></code> as well, it will disable any timeout, each connected locality will wait for all existing HPX-threads to terminate.<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">shutdown_timeout</span></code>: This parameter allows to specify a timeout (in microseconds), specifying how long any of the connected localities should wait for pending tasks to be executed. After this timeout, all suspended HPX-threads will be aborted. Note, that this function will not abort any running HPX-threads. In any case the shutdown will not proceed as long as there is at least one pending/running HPX-thread.</li>
</ul>
</dd>
</dl>
</p>
<p><p>The default value (</p>
<code class="docutils literal notranslate"><span class="pre">-1.0</span></code>) will try to find a globally set wait time value (can be set as the configuration parameter “hpx.finalize_wait_time”), and if this is not set or <code class="docutils literal notranslate"><span class="pre">-1.0</span></code> as well, it will disable any addition local wait time before proceeding.<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">localwait</span></code>: This parameter allows to specify a local wait time (in microseconds) before the connected localities will be notified and the overall shutdown process starts.</li>
</ul>
</dd>
</dl>
</p>
<p><p>This function will block and wait for all connected localities to exit before returning to the caller. It should be the last HPX-function called by any application.</p>
<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>This function will always return zero.</dd>
<dt><strong>Note</strong></dt>
<dd>As long as <em>ec</em> is not pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> this function doesn’t throw but returns the result code using the parameter <em>ec</em>. Otherwise it throws an instance of <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a>.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
<p>Using this function is an alternative to <em><a class="reference internal" href="#namespacehpx_1a33db29f916f1591d6b37c6b6d76886d3"><span class="std std-ref">hpx::disconnect</span></a></em>, these functions do not need to be called both. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8finalizeER10error_code">
<span id="_CPPv2N3hpx8finalizeER10error_code"></span><span id="hpx::finalize__error_codeR"></span><span class="target" id="namespacehpx_1adadfe0973783fa126afca52feda59529"></span>int <code class="descname">finalize</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8finalizeER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Main function to gracefully terminate the HPX runtime system. </p>
<p>The function <em><a class="reference internal" href="#namespacehpx_1ab7eb159cb77997b366b5d79e65f04cd0"><span class="std std-ref">hpx::finalize</span></a></em> is the main way to (gracefully) exit any HPX application. It should be called from one locality only (usually the console) and it will notify all connected localities to finish execution. Only after all other localities have exited this function will return, allowing to exit the console locality as well.</p>
<p>During the execution of this function the runtime system will invoke all registered shutdown functions (see <em><a class="reference internal" href="#namespacehpx_1a3c694ea960b47c56b33351ba16e3d76b"><span class="std std-ref">hpx::init</span></a></em>) on all localities.</p>
<p><p>This function will block and wait for all connected localities to exit before returning to the caller. It should be the last HPX-function called by any application.</p>
<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>This function will always return zero.</dd>
<dt><strong>Note</strong></dt>
<dd>As long as <em>ec</em> is not pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> this function doesn’t throw but returns the result code using the parameter <em>ec</em>. Otherwise it throws an instance of <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a>.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
<p>Using this function is an alternative to <em><a class="reference internal" href="#namespacehpx_1a33db29f916f1591d6b37c6b6d76886d3"><span class="std std-ref">hpx::disconnect</span></a></em>, these functions do not need to be called both. </p>
</dd></dl>

<dl class="function">
<dt>
<span class="target" id="namespacehpx_1a460472f748021ade829cca393930d1a2"></span><code class="descname">HPX_NORETURN void hpx::terminate()</code></dt>
<dd><p>Terminate any application non-gracefully. </p>
<p>The function <em><a class="reference internal" href="#namespacehpx_1a460472f748021ade829cca393930d1a2"><span class="std std-ref">hpx::terminate</span></a></em> is the non-graceful way to exit any application immediately. It can be called from any locality and will terminate all localities currently used by the application.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function will cause HPX to call <code class="docutils literal notranslate"><a class="reference internal" href="#namespacehpx_1a460472f748021ade829cca393930d1a2"><span class="std std-ref"><span class="pre">std::terminate()</span></span></a></code> on all localities associated with this application. If the function is called not from an HPX thread it will fail and return an error using the argument <em>ec</em>. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx10disconnectEddR10error_code">
<span id="_CPPv2N3hpx10disconnectEddR10error_code"></span><span id="hpx::disconnect__double.double.error_codeR"></span><span class="target" id="namespacehpx_1a33db29f916f1591d6b37c6b6d76886d3"></span>int <code class="descname">disconnect</code><span class="sig-paren">(</span>double <em>shutdown_timeout</em>, double <em>localwait</em> = -1.0, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx10disconnectEddR10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Disconnect this locality from the application. </p>
<p>The function <em><a class="reference internal" href="#namespacehpx_1a33db29f916f1591d6b37c6b6d76886d3"><span class="std std-ref">hpx::disconnect</span></a></em> can be used to disconnect a locality from a running HPX application.</p>
<p>During the execution of this function the runtime system will invoke all registered shutdown functions (see <em><a class="reference internal" href="#namespacehpx_1a3c694ea960b47c56b33351ba16e3d76b"><span class="std std-ref">hpx::init</span></a></em>) on this locality. <p>The default value (</p>
<code class="docutils literal notranslate"><span class="pre">-1.0</span></code>) will try to find a globally set timeout value (can be set as the configuration parameter “hpx.shutdown_timeout”), and if that is not set or <code class="docutils literal notranslate"><span class="pre">-1.0</span></code> as well, it will disable any timeout, each connected locality will wait for all existing HPX-threads to terminate.<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">shutdown_timeout</span></code>: This parameter allows to specify a timeout (in microseconds), specifying how long this locality should wait for pending tasks to be executed. After this timeout, all suspended HPX-threads will be aborted. Note, that this function will not abort any running HPX-threads. In any case the shutdown will not proceed as long as there is at least one pending/running HPX-thread.</li>
</ul>
</dd>
</dl>
</p>
<p><p>The default value (</p>
<code class="docutils literal notranslate"><span class="pre">-1.0</span></code>) will try to find a globally set wait time value (can be set as the configuration parameter <code class="docutils literal notranslate"><span class="pre">hpx.finalize_wait_time</span></code>), and if this is not set or <code class="docutils literal notranslate"><span class="pre">-1.0</span></code> as well, it will disable any addition local wait time before proceeding.<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">localwait</span></code>: This parameter allows to specify a local wait time (in microseconds) before the connected localities will be notified and the overall shutdown process starts.</li>
</ul>
</dd>
</dl>
</p>
<p><p>This function will block and wait for this locality to finish executing before returning to the caller. It should be the last HPX-function called by any locality being disconnected. </p>
<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>This function will always return zero.</dd>
<dt><strong>Note</strong></dt>
<dd>As long as <em>ec</em> is not pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> this function doesn’t throw but returns the result code using the parameter <em>ec</em>. Otherwise it throws an instance of <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a>.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx10disconnectER10error_code">
<span id="_CPPv2N3hpx10disconnectER10error_code"></span><span id="hpx::disconnect__error_codeR"></span><span class="target" id="namespacehpx_1ad05607f97e7977530074039d29ca0512"></span>int <code class="descname">disconnect</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx10disconnectER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Disconnect this locality from the application. </p>
<p>The function <em><a class="reference internal" href="#namespacehpx_1a33db29f916f1591d6b37c6b6d76886d3"><span class="std std-ref">hpx::disconnect</span></a></em> can be used to disconnect a locality from a running HPX application.</p>
<p>During the execution of this function the runtime system will invoke all registered shutdown functions (see <em><a class="reference internal" href="#namespacehpx_1a3c694ea960b47c56b33351ba16e3d76b"><span class="std std-ref">hpx::init</span></a></em>) on this locality.</p>
<p><p>This function will block and wait for this locality to finish executing before returning to the caller. It should be the last HPX-function called by any locality being disconnected. </p>
<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>This function will always return zero.</dd>
<dt><strong>Note</strong></dt>
<dd>As long as <em>ec</em> is not pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> this function doesn’t throw but returns the result code using the parameter <em>ec</em>. Otherwise it throws an instance of <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a>.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4stopER10error_code">
<span id="_CPPv2N3hpx4stopER10error_code"></span><span id="hpx::stop__error_codeR"></span><span class="target" id="namespacehpx_1a1b4c2c4851fcae7c6c01617b6181d44f"></span>int <code class="descname">stop</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4stopER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Stop the runtime system. </p>
<p><p>This function will block and wait for this locality to finish executing before returning to the caller. It should be the last HPX-function called on every locality. This function should be used only if the runtime system was started using </p>
<code class="docutils literal notranslate"><a class="reference internal" href="#namespacehpx_1a7e832bd3c4af93a4619dbe97a5b1c3d2"><span class="std std-ref"><span class="pre">hpx::start</span></span></a></code>. <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The function returns the value, which has been returned from the user supplied main HPX function (usually <code class="docutils literal notranslate"><span class="pre">hpx_main</span></code>).</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7suspendER10error_code">
<span id="_CPPv2N3hpx7suspendER10error_code"></span><span id="hpx::suspend__error_codeR"></span><span class="target" id="namespacehpx_1a2c7789229c2d816106262236343586a6"></span>int <code class="descname">suspend</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx7suspendER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Suspend the runtime system. </p>
<p>The function <em><a class="reference internal" href="#namespacehpx_1a2c7789229c2d816106262236343586a6"><span class="std std-ref">hpx::suspend</span></a></em> is used to suspend the HPX runtime system. It can only be used when running HPX on a single locality. It will block waiting for all thread pools to be empty. This function only be called when the runtime is running, or already suspended in which case this function will do nothing.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>This function will always return zero.</dd>
<dt><strong>Note</strong></dt>
<dd>As long as <em>ec</em> is not pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> this function doesn’t throw but returns the result code using the parameter <em>ec</em>. Otherwise it throws an instance of <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx6resumeER10error_code">
<span id="_CPPv2N3hpx6resumeER10error_code"></span><span id="hpx::resume__error_codeR"></span><span class="target" id="namespacehpx_1a2705fd1033c1d6a011ba0c42ff39a7ca"></span>int <code class="descname">resume</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx6resumeER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Resume the HPX runtime system. </p>
<p>The function <em><a class="reference internal" href="#namespacehpx_1a2705fd1033c1d6a011ba0c42ff39a7ca"><span class="std std-ref">hpx::resume</span></a></em> is used to resume the HPX runtime system. It can only be used when running HPX on a single locality. It will block waiting for all thread pools to be resumed. This function only be called when the runtime suspended, or already running in which case this function will do nothing.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>This function will always return zero.</dd>
<dt><strong>Note</strong></dt>
<dd>As long as <em>ec</em> is not pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> this function doesn’t throw but returns the result code using the parameter <em>ec</em>. Otherwise it throws an instance of <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx16get_hpx_categoryEv">
<span id="_CPPv2N3hpx16get_hpx_categoryEv"></span><span id="hpx::get_hpx_category"></span><span class="target" id="namespacehpx_1ae1b41e445d214ad2cf30f6e1ebd4e3bf"></span>boost::system::error_category <em class="property">const</em> &amp;<code class="descname">get_hpx_category</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx16get_hpx_categoryEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns generic HPX error category used for new errors. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx24get_hpx_rethrow_categoryEv">
<span id="_CPPv2N3hpx24get_hpx_rethrow_categoryEv"></span><span id="hpx::get_hpx_rethrow_category"></span><span class="target" id="namespacehpx_1afff1a46978ac0e1d2439456547643ed9"></span>boost::system::error_category <em class="property">const</em> &amp;<code class="descname">get_hpx_rethrow_category</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx24get_hpx_rethrow_categoryEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns generic HPX error category used for errors re-thrown after the exception has been de-serialized. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx17make_success_codeE9throwmode">
<span id="_CPPv2N3hpx17make_success_codeE9throwmode"></span><span id="hpx::make_success_code__throwmode"></span><span class="target" id="namespacehpx_1a0e8512a8f49e2a6c8185061181419d8f"></span><a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> <code class="descname">make_success_code</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx9throwmodeE" title="hpx::throwmode">throwmode</a> <em>mode</em> = <a class="reference internal" href="#_CPPv3N3hpx5plainE" title="hpx::plain">plain</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx17make_success_codeE9throwmode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns <a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">error_code</span></a>(<a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663aca008d80aec0aed361d392d4ea09adbb"><span class="std std-ref">hpx::success</span></a>, “success”, mode). </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx22diagnostic_informationER14exception_info">
<span id="_CPPv2N3hpx22diagnostic_informationER14exception_info"></span><span id="hpx::diagnostic_information__exception_infoCR"></span><span class="target" id="namespacehpx_1af59d165ab289edc23121bae716d73b81"></span>std::string <code class="descname">diagnostic_information</code><span class="sig-paren">(</span>exception_info <em class="property">const</em> &amp;<em>xi</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx22diagnostic_informationER14exception_info" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Extract the diagnostic information embedded in the given exception and return a string holding a formatted message. </p>
<p>The function <em><a class="reference internal" href="#namespacehpx_1af59d165ab289edc23121bae716d73b81"><span class="std std-ref">hpx::diagnostic_information</span></a></em> can be used to extract all diagnostic information stored in the given exception instance as a formatted string. This simplifies debug output as it composes the diagnostics into one, easy to use function call. This includes the name of the source file and line number, the sequence number of the OS-thread and the HPX-thread id, the locality id and the stack backtrace of the point where the original exception was thrown.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The formatted string holding all of the available diagnostic information stored in the given exception instance.</dd>
<dt><strong>See</strong></dt>
<dd><em><a class="reference internal" href="#namespacehpx_1ae0aad4b593578699a9f5ac58d2a11288"><span class="std std-ref">hpx::get_error_locality_id()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a7ebe8e69e08d364ec86cbdcb9c5aa199"><span class="std std-ref">hpx::get_error_host_name()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a0c21f4e95548d80fb941b4138d0e4d24"><span class="std std-ref">hpx::get_error_process_id()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a754d205ce3b220a254c65f3d124ac405"><span class="std std-ref">hpx::get_error_function_name()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a0af92c8ff70bbc40c078ef06a2ff4647"><span class="std std-ref">hpx::get_error_file_name()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ae0112fceccd5a51798ed81d88906468e"><span class="std std-ref">hpx::get_error_line_number()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a5fae8dd048ba1ba0b9a3f098335c4ab7"><span class="std std-ref">hpx::get_error_os_thread()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a56922a8181da8b3ca25a2f495bec15bf"><span class="std std-ref">hpx::get_error_thread_id()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a7d794dce67e3d4923547d0e045c7f307"><span class="std std-ref">hpx::get_error_thread_description()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1af6349dbd4e6dd99a3dfd5ff6e4e74c21"><span class="std std-ref">hpx::get_error()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a6832a96f6792773df7403722ca42ea1c"><span class="std std-ref">hpx::get_error_backtrace()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ab74d4e93ce592c61fa3d107701ef9284"><span class="std std-ref">hpx::get_error_env()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ad28bf0e2a07a99c4d3eedaf1339af32c"><span class="std std-ref">hpx::get_error_what()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ae307e091b0dea3494eaf2afd72a82d15"><span class="std std-ref">hpx::get_error_config()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ae534c0adea0fd5b928a05f133d5c817d"><span class="std std-ref">hpx::get_error_state()</span></a></em> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xi</span></code>: The parameter <code class="docutils literal notranslate"><span class="pre">e</span></code> will be inspected for all diagnostic information elements which have been stored at the point where the exception was thrown. This parameter can be one of the following types: <em>hpx::exception_info</em>, <em><a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">hpx::error_code</span></a></em>, <em>std::exception</em>, or <em>std::exception_ptr</em>.</li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">std::bad_alloc</span></code>: (if any of the required allocation operations fail)</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx14get_error_whatER14exception_info">
<span id="_CPPv2N3hpx14get_error_whatER14exception_info"></span><span id="hpx::get_error_what__exception_infoCR"></span><span class="target" id="namespacehpx_1ad28bf0e2a07a99c4d3eedaf1339af32c"></span>std::string <code class="descname">get_error_what</code><span class="sig-paren">(</span>exception_info <em class="property">const</em> &amp;<em>xi</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx14get_error_whatER14exception_info" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the error message of the thrown exception. </p>
<p>The function <em><a class="reference internal" href="#namespacehpx_1ad28bf0e2a07a99c4d3eedaf1339af32c"><span class="std std-ref">hpx::get_error_what</span></a></em> can be used to extract the diagnostic information element representing the error message as stored in the given exception instance.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The error message stored in the exception If the exception instance does not hold this information, the function will return an empty string.</dd>
<dt><strong>See</strong></dt>
<dd><em><a class="reference internal" href="#namespacehpx_1af59d165ab289edc23121bae716d73b81"><span class="std std-ref">hpx::diagnostic_information()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a7ebe8e69e08d364ec86cbdcb9c5aa199"><span class="std std-ref">hpx::get_error_host_name()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a0c21f4e95548d80fb941b4138d0e4d24"><span class="std std-ref">hpx::get_error_process_id()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a754d205ce3b220a254c65f3d124ac405"><span class="std std-ref">hpx::get_error_function_name()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a0af92c8ff70bbc40c078ef06a2ff4647"><span class="std std-ref">hpx::get_error_file_name()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ae0112fceccd5a51798ed81d88906468e"><span class="std std-ref">hpx::get_error_line_number()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a5fae8dd048ba1ba0b9a3f098335c4ab7"><span class="std std-ref">hpx::get_error_os_thread()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a56922a8181da8b3ca25a2f495bec15bf"><span class="std std-ref">hpx::get_error_thread_id()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a7d794dce67e3d4923547d0e045c7f307"><span class="std std-ref">hpx::get_error_thread_description()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1af6349dbd4e6dd99a3dfd5ff6e4e74c21"><span class="std std-ref">hpx::get_error()</span></a></em> <em><a class="reference internal" href="#namespacehpx_1a6832a96f6792773df7403722ca42ea1c"><span class="std std-ref">hpx::get_error_backtrace()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ab74d4e93ce592c61fa3d107701ef9284"><span class="std std-ref">hpx::get_error_env()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ae307e091b0dea3494eaf2afd72a82d15"><span class="std std-ref">hpx::get_error_config()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ae534c0adea0fd5b928a05f133d5c817d"><span class="std std-ref">hpx::get_error_state()</span></a></em> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xi</span></code>: The parameter <code class="docutils literal notranslate"><span class="pre">e</span></code> will be inspected for the requested diagnostic information elements which have been stored at the point where the exception was thrown. This parameter can be one of the following types: <em>hpx::exception_info</em>, <em><a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">hpx::error_code</span></a></em>, <em>std::exception</em>, or <em>std::exception_ptr</em>.</li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">std::bad_alloc</span></code>: (if one of the required allocations fails)</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx21get_error_locality_idERN3hpx14exception_infoE">
<span id="_CPPv2N3hpx21get_error_locality_idERN3hpx14exception_infoE"></span><span id="hpx::get_error_locality_id__hpx::exception_infoCR"></span><span class="target" id="namespacehpx_1ae0aad4b593578699a9f5ac58d2a11288"></span>std::uint32_t <code class="descname">get_error_locality_id</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::exception_info <em class="property">const</em> &amp;<em>xi</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx21get_error_locality_idERN3hpx14exception_infoE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the locality id where the exception was thrown. </p>
<p>The function <em><a class="reference internal" href="#namespacehpx_1ae0aad4b593578699a9f5ac58d2a11288"><span class="std std-ref">hpx::get_error_locality_id</span></a></em> can be used to extract the diagnostic information element representing the locality id as stored in the given exception instance.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The locality id of the locality where the exception was thrown. If the exception instance does not hold this information, the function will return <em>hpx::naming::invalid_locality_id</em>.</dd>
<dt><strong>See</strong></dt>
<dd><em><a class="reference internal" href="#namespacehpx_1af59d165ab289edc23121bae716d73b81"><span class="std std-ref">hpx::diagnostic_information()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a7ebe8e69e08d364ec86cbdcb9c5aa199"><span class="std std-ref">hpx::get_error_host_name()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a0c21f4e95548d80fb941b4138d0e4d24"><span class="std std-ref">hpx::get_error_process_id()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a754d205ce3b220a254c65f3d124ac405"><span class="std std-ref">hpx::get_error_function_name()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a0af92c8ff70bbc40c078ef06a2ff4647"><span class="std std-ref">hpx::get_error_file_name()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ae0112fceccd5a51798ed81d88906468e"><span class="std std-ref">hpx::get_error_line_number()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a5fae8dd048ba1ba0b9a3f098335c4ab7"><span class="std std-ref">hpx::get_error_os_thread()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a56922a8181da8b3ca25a2f495bec15bf"><span class="std std-ref">hpx::get_error_thread_id()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a7d794dce67e3d4923547d0e045c7f307"><span class="std std-ref">hpx::get_error_thread_description()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1af6349dbd4e6dd99a3dfd5ff6e4e74c21"><span class="std std-ref">hpx::get_error()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a6832a96f6792773df7403722ca42ea1c"><span class="std std-ref">hpx::get_error_backtrace()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ab74d4e93ce592c61fa3d107701ef9284"><span class="std std-ref">hpx::get_error_env()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ad28bf0e2a07a99c4d3eedaf1339af32c"><span class="std std-ref">hpx::get_error_what()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ae307e091b0dea3494eaf2afd72a82d15"><span class="std std-ref">hpx::get_error_config()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ae534c0adea0fd5b928a05f133d5c817d"><span class="std std-ref">hpx::get_error_state()</span></a></em> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xi</span></code>: The parameter <code class="docutils literal notranslate"><span class="pre">e</span></code> will be inspected for the requested diagnostic information elements which have been stored at the point where the exception was thrown. This parameter can be one of the following types: <em>hpx::exception_info</em>, <em><a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">hpx::error_code</span></a></em>, <em>std::exception</em>, or <em>std::exception_ptr</em>.</li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">nothing</span></code>: </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx9get_errorERN3hpx9exceptionE">
<span id="_CPPv2N3hpx9get_errorERN3hpx9exceptionE"></span><span id="hpx::get_error__hpx::exceptionCR"></span><span class="target" id="namespacehpx_1af6349dbd4e6dd99a3dfd5ff6e4e74c21"></span><a class="reference internal" href="#_CPPv3N3hpx5errorE" title="hpx::error">error</a> <code class="descname">get_error</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx9exceptionE" title="hpx::exception">exception</a> <em class="property">const</em> &amp;<em>e</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx9get_errorERN3hpx9exceptionE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the locality id where the exception was thrown. </p>
<p>The function <em><a class="reference internal" href="#namespacehpx_1af6349dbd4e6dd99a3dfd5ff6e4e74c21"><span class="std std-ref">hpx::get_error</span></a></em> can be used to extract the diagnostic information element representing the error value code as stored in the given exception instance.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The error value code of the locality where the exception was thrown. If the exception instance does not hold this information, the function will return <em>hpx::naming::invalid_locality_id</em>.</dd>
<dt><strong>See</strong></dt>
<dd><em><a class="reference internal" href="#namespacehpx_1af59d165ab289edc23121bae716d73b81"><span class="std std-ref">hpx::diagnostic_information()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a7ebe8e69e08d364ec86cbdcb9c5aa199"><span class="std std-ref">hpx::get_error_host_name()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a0c21f4e95548d80fb941b4138d0e4d24"><span class="std std-ref">hpx::get_error_process_id()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a754d205ce3b220a254c65f3d124ac405"><span class="std std-ref">hpx::get_error_function_name()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a0af92c8ff70bbc40c078ef06a2ff4647"><span class="std std-ref">hpx::get_error_file_name()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ae0112fceccd5a51798ed81d88906468e"><span class="std std-ref">hpx::get_error_line_number()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a5fae8dd048ba1ba0b9a3f098335c4ab7"><span class="std std-ref">hpx::get_error_os_thread()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a56922a8181da8b3ca25a2f495bec15bf"><span class="std std-ref">hpx::get_error_thread_id()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a7d794dce67e3d4923547d0e045c7f307"><span class="std std-ref">hpx::get_error_thread_description()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a6832a96f6792773df7403722ca42ea1c"><span class="std std-ref">hpx::get_error_backtrace()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ab74d4e93ce592c61fa3d107701ef9284"><span class="std std-ref">hpx::get_error_env()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ad28bf0e2a07a99c4d3eedaf1339af32c"><span class="std std-ref">hpx::get_error_what()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ae307e091b0dea3494eaf2afd72a82d15"><span class="std std-ref">hpx::get_error_config()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ae534c0adea0fd5b928a05f133d5c817d"><span class="std std-ref">hpx::get_error_state()</span></a></em> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">e</span></code>: The parameter <code class="docutils literal notranslate"><span class="pre">e</span></code> will be inspected for the requested diagnostic information elements which have been stored at the point where the exception was thrown. This parameter can be one of the following types: <em><a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a></em>, <em><a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">hpx::error_code</span></a></em>, or <em>std::exception_ptr</em>.</li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">nothing</span></code>: </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx9get_errorERN3hpx10error_codeE">
<span id="_CPPv2N3hpx9get_errorERN3hpx10error_codeE"></span><span id="hpx::get_error__hpx::error_codeCR"></span><span class="target" id="namespacehpx_1a68dd22b15b787540208e0977a2e4b53d"></span><a class="reference internal" href="#_CPPv3N3hpx5errorE" title="hpx::error">error</a> <code class="descname">get_error</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> <em class="property">const</em> &amp;<em>e</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx9get_errorERN3hpx10error_codeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the locality id where the exception was thrown. </p>
<p>The function <em><a class="reference internal" href="#namespacehpx_1af6349dbd4e6dd99a3dfd5ff6e4e74c21"><span class="std std-ref">hpx::get_error</span></a></em> can be used to extract the diagnostic information element representing the error value code as stored in the given exception instance.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The error value code of the locality where the exception was thrown. If the exception instance does not hold this information, the function will return <em>hpx::naming::invalid_locality_id</em>.</dd>
<dt><strong>See</strong></dt>
<dd><em><a class="reference internal" href="#namespacehpx_1af59d165ab289edc23121bae716d73b81"><span class="std std-ref">hpx::diagnostic_information()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a7ebe8e69e08d364ec86cbdcb9c5aa199"><span class="std std-ref">hpx::get_error_host_name()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a0c21f4e95548d80fb941b4138d0e4d24"><span class="std std-ref">hpx::get_error_process_id()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a754d205ce3b220a254c65f3d124ac405"><span class="std std-ref">hpx::get_error_function_name()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a0af92c8ff70bbc40c078ef06a2ff4647"><span class="std std-ref">hpx::get_error_file_name()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ae0112fceccd5a51798ed81d88906468e"><span class="std std-ref">hpx::get_error_line_number()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a5fae8dd048ba1ba0b9a3f098335c4ab7"><span class="std std-ref">hpx::get_error_os_thread()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a56922a8181da8b3ca25a2f495bec15bf"><span class="std std-ref">hpx::get_error_thread_id()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a7d794dce67e3d4923547d0e045c7f307"><span class="std std-ref">hpx::get_error_thread_description()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a6832a96f6792773df7403722ca42ea1c"><span class="std std-ref">hpx::get_error_backtrace()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ab74d4e93ce592c61fa3d107701ef9284"><span class="std std-ref">hpx::get_error_env()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ad28bf0e2a07a99c4d3eedaf1339af32c"><span class="std std-ref">hpx::get_error_what()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ae307e091b0dea3494eaf2afd72a82d15"><span class="std std-ref">hpx::get_error_config()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ae534c0adea0fd5b928a05f133d5c817d"><span class="std std-ref">hpx::get_error_state()</span></a></em> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">e</span></code>: The parameter <code class="docutils literal notranslate"><span class="pre">e</span></code> will be inspected for the requested diagnostic information elements which have been stored at the point where the exception was thrown. This parameter can be one of the following types: <em><a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a></em>, <em><a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">hpx::error_code</span></a></em>, or <em>std::exception_ptr</em>.</li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">nothing</span></code>: </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx19get_error_host_nameERN3hpx14exception_infoE">
<span id="_CPPv2N3hpx19get_error_host_nameERN3hpx14exception_infoE"></span><span id="hpx::get_error_host_name__hpx::exception_infoCR"></span><span class="target" id="namespacehpx_1a7ebe8e69e08d364ec86cbdcb9c5aa199"></span>std::string <code class="descname">get_error_host_name</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::exception_info <em class="property">const</em> &amp;<em>xi</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx19get_error_host_nameERN3hpx14exception_infoE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the hostname of the locality where the exception was thrown. </p>
<p>The function <em><a class="reference internal" href="#namespacehpx_1a7ebe8e69e08d364ec86cbdcb9c5aa199"><span class="std std-ref">hpx::get_error_host_name</span></a></em> can be used to extract the diagnostic information element representing the host name as stored in the given exception instance.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The hostname of the locality where the exception was thrown. If the exception instance does not hold this information, the function will return and empty string.</dd>
<dt><strong>See</strong></dt>
<dd><em><a class="reference internal" href="#namespacehpx_1af59d165ab289edc23121bae716d73b81"><span class="std std-ref">hpx::diagnostic_information()</span></a></em> <em><a class="reference internal" href="#namespacehpx_1a0c21f4e95548d80fb941b4138d0e4d24"><span class="std std-ref">hpx::get_error_process_id()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a754d205ce3b220a254c65f3d124ac405"><span class="std std-ref">hpx::get_error_function_name()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a0af92c8ff70bbc40c078ef06a2ff4647"><span class="std std-ref">hpx::get_error_file_name()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ae0112fceccd5a51798ed81d88906468e"><span class="std std-ref">hpx::get_error_line_number()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a5fae8dd048ba1ba0b9a3f098335c4ab7"><span class="std std-ref">hpx::get_error_os_thread()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a56922a8181da8b3ca25a2f495bec15bf"><span class="std std-ref">hpx::get_error_thread_id()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a7d794dce67e3d4923547d0e045c7f307"><span class="std std-ref">hpx::get_error_thread_description()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1af6349dbd4e6dd99a3dfd5ff6e4e74c21"><span class="std std-ref">hpx::get_error()</span></a></em> <em><a class="reference internal" href="#namespacehpx_1a6832a96f6792773df7403722ca42ea1c"><span class="std std-ref">hpx::get_error_backtrace()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ab74d4e93ce592c61fa3d107701ef9284"><span class="std std-ref">hpx::get_error_env()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ad28bf0e2a07a99c4d3eedaf1339af32c"><span class="std std-ref">hpx::get_error_what()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ae307e091b0dea3494eaf2afd72a82d15"><span class="std std-ref">hpx::get_error_config()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ae534c0adea0fd5b928a05f133d5c817d"><span class="std std-ref">hpx::get_error_state()</span></a></em> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xi</span></code>: The parameter <code class="docutils literal notranslate"><span class="pre">e</span></code> will be inspected for the requested diagnostic information elements which have been stored at the point where the exception was thrown. This parameter can be one of the following types: <em>hpx::exception_info</em>, <em><a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">hpx::error_code</span></a></em>, <em>std::exception</em>, or <em>std::exception_ptr</em>.</li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">std::bad_alloc</span></code>: (if one of the required allocations fails)</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx20get_error_process_idERN3hpx14exception_infoE">
<span id="_CPPv2N3hpx20get_error_process_idERN3hpx14exception_infoE"></span><span id="hpx::get_error_process_id__hpx::exception_infoCR"></span><span class="target" id="namespacehpx_1a0c21f4e95548d80fb941b4138d0e4d24"></span>std::int64_t <code class="descname">get_error_process_id</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::exception_info <em class="property">const</em> &amp;<em>xi</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx20get_error_process_idERN3hpx14exception_infoE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the (operating system) process id of the locality where the exception was thrown. </p>
<p>The function <em><a class="reference internal" href="#namespacehpx_1a0c21f4e95548d80fb941b4138d0e4d24"><span class="std std-ref">hpx::get_error_process_id</span></a></em> can be used to extract the diagnostic information element representing the process id as stored in the given exception instance.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The process id of the OS-process which threw the exception If the exception instance does not hold this information, the function will return 0.</dd>
<dt><strong>See</strong></dt>
<dd><em><a class="reference internal" href="#namespacehpx_1af59d165ab289edc23121bae716d73b81"><span class="std std-ref">hpx::diagnostic_information()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a7ebe8e69e08d364ec86cbdcb9c5aa199"><span class="std std-ref">hpx::get_error_host_name()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a754d205ce3b220a254c65f3d124ac405"><span class="std std-ref">hpx::get_error_function_name()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a0af92c8ff70bbc40c078ef06a2ff4647"><span class="std std-ref">hpx::get_error_file_name()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ae0112fceccd5a51798ed81d88906468e"><span class="std std-ref">hpx::get_error_line_number()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a5fae8dd048ba1ba0b9a3f098335c4ab7"><span class="std std-ref">hpx::get_error_os_thread()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a56922a8181da8b3ca25a2f495bec15bf"><span class="std std-ref">hpx::get_error_thread_id()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a7d794dce67e3d4923547d0e045c7f307"><span class="std std-ref">hpx::get_error_thread_description()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1af6349dbd4e6dd99a3dfd5ff6e4e74c21"><span class="std std-ref">hpx::get_error()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a6832a96f6792773df7403722ca42ea1c"><span class="std std-ref">hpx::get_error_backtrace()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ab74d4e93ce592c61fa3d107701ef9284"><span class="std std-ref">hpx::get_error_env()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ad28bf0e2a07a99c4d3eedaf1339af32c"><span class="std std-ref">hpx::get_error_what()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ae307e091b0dea3494eaf2afd72a82d15"><span class="std std-ref">hpx::get_error_config()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ae534c0adea0fd5b928a05f133d5c817d"><span class="std std-ref">hpx::get_error_state()</span></a></em> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xi</span></code>: The parameter <code class="docutils literal notranslate"><span class="pre">e</span></code> will be inspected for the requested diagnostic information elements which have been stored at the point where the exception was thrown. This parameter can be one of the following types: <em>hpx::exception_info</em>, <em><a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">hpx::error_code</span></a></em>, <em>std::exception</em>, or <em>std::exception_ptr</em>.</li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">nothing</span></code>: </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx13get_error_envERN3hpx14exception_infoE">
<span id="_CPPv2N3hpx13get_error_envERN3hpx14exception_infoE"></span><span id="hpx::get_error_env__hpx::exception_infoCR"></span><span class="target" id="namespacehpx_1ab74d4e93ce592c61fa3d107701ef9284"></span>std::string <code class="descname">get_error_env</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::exception_info <em class="property">const</em> &amp;<em>xi</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx13get_error_envERN3hpx14exception_infoE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the environment of the OS-process at the point the exception was thrown. </p>
<p>The function <em><a class="reference internal" href="#namespacehpx_1ab74d4e93ce592c61fa3d107701ef9284"><span class="std std-ref">hpx::get_error_env</span></a></em> can be used to extract the diagnostic information element representing the environment of the OS-process collected at the point the exception was thrown.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The environment from the point the exception was thrown. If the exception instance does not hold this information, the function will return an empty string.</dd>
<dt><strong>See</strong></dt>
<dd><em><a class="reference internal" href="#namespacehpx_1af59d165ab289edc23121bae716d73b81"><span class="std std-ref">hpx::diagnostic_information()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a7ebe8e69e08d364ec86cbdcb9c5aa199"><span class="std std-ref">hpx::get_error_host_name()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a0c21f4e95548d80fb941b4138d0e4d24"><span class="std std-ref">hpx::get_error_process_id()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a754d205ce3b220a254c65f3d124ac405"><span class="std std-ref">hpx::get_error_function_name()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a0af92c8ff70bbc40c078ef06a2ff4647"><span class="std std-ref">hpx::get_error_file_name()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ae0112fceccd5a51798ed81d88906468e"><span class="std std-ref">hpx::get_error_line_number()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a5fae8dd048ba1ba0b9a3f098335c4ab7"><span class="std std-ref">hpx::get_error_os_thread()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a56922a8181da8b3ca25a2f495bec15bf"><span class="std std-ref">hpx::get_error_thread_id()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a7d794dce67e3d4923547d0e045c7f307"><span class="std std-ref">hpx::get_error_thread_description()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1af6349dbd4e6dd99a3dfd5ff6e4e74c21"><span class="std std-ref">hpx::get_error()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a6832a96f6792773df7403722ca42ea1c"><span class="std std-ref">hpx::get_error_backtrace()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ad28bf0e2a07a99c4d3eedaf1339af32c"><span class="std std-ref">hpx::get_error_what()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ae307e091b0dea3494eaf2afd72a82d15"><span class="std std-ref">hpx::get_error_config()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ae534c0adea0fd5b928a05f133d5c817d"><span class="std std-ref">hpx::get_error_state()</span></a></em> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xi</span></code>: The parameter <code class="docutils literal notranslate"><span class="pre">e</span></code> will be inspected for the requested diagnostic information elements which have been stored at the point where the exception was thrown. This parameter can be one of the following types: <em>hpx::exception_info</em>, <em><a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">hpx::error_code</span></a></em>, <em>std::exception</em>, or <em>std::exception_ptr</em>.</li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">std::bad_alloc</span></code>: (if one of the required allocations fails)</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx23get_error_function_nameERN3hpx14exception_infoE">
<span id="_CPPv2N3hpx23get_error_function_nameERN3hpx14exception_infoE"></span><span id="hpx::get_error_function_name__hpx::exception_infoCR"></span><span class="target" id="namespacehpx_1a754d205ce3b220a254c65f3d124ac405"></span>std::string <code class="descname">get_error_function_name</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::exception_info <em class="property">const</em> &amp;<em>xi</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx23get_error_function_nameERN3hpx14exception_infoE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the function name from which the exception was thrown. </p>
<p>The function <em><a class="reference internal" href="#namespacehpx_1a754d205ce3b220a254c65f3d124ac405"><span class="std std-ref">hpx::get_error_function_name</span></a></em> can be used to extract the diagnostic information element representing the name of the function as stored in the given exception instance.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The name of the function from which the exception was thrown. If the exception instance does not hold this information, the function will return an empty string.</dd>
<dt><strong>See</strong></dt>
<dd><em><a class="reference internal" href="#namespacehpx_1af59d165ab289edc23121bae716d73b81"><span class="std std-ref">hpx::diagnostic_information()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a7ebe8e69e08d364ec86cbdcb9c5aa199"><span class="std std-ref">hpx::get_error_host_name()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a0c21f4e95548d80fb941b4138d0e4d24"><span class="std std-ref">hpx::get_error_process_id()</span></a></em> <em><a class="reference internal" href="#namespacehpx_1a0af92c8ff70bbc40c078ef06a2ff4647"><span class="std std-ref">hpx::get_error_file_name()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ae0112fceccd5a51798ed81d88906468e"><span class="std std-ref">hpx::get_error_line_number()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a5fae8dd048ba1ba0b9a3f098335c4ab7"><span class="std std-ref">hpx::get_error_os_thread()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a56922a8181da8b3ca25a2f495bec15bf"><span class="std std-ref">hpx::get_error_thread_id()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a7d794dce67e3d4923547d0e045c7f307"><span class="std std-ref">hpx::get_error_thread_description()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1af6349dbd4e6dd99a3dfd5ff6e4e74c21"><span class="std std-ref">hpx::get_error()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a6832a96f6792773df7403722ca42ea1c"><span class="std std-ref">hpx::get_error_backtrace()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ab74d4e93ce592c61fa3d107701ef9284"><span class="std std-ref">hpx::get_error_env()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ad28bf0e2a07a99c4d3eedaf1339af32c"><span class="std std-ref">hpx::get_error_what()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ae307e091b0dea3494eaf2afd72a82d15"><span class="std std-ref">hpx::get_error_config()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ae534c0adea0fd5b928a05f133d5c817d"><span class="std std-ref">hpx::get_error_state()</span></a></em> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xi</span></code>: The parameter <code class="docutils literal notranslate"><span class="pre">e</span></code> will be inspected for the requested diagnostic information elements which have been stored at the point where the exception was thrown. This parameter can be one of the following types: <em>hpx::exception_info</em>, <em><a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">hpx::error_code</span></a></em>, <em>std::exception</em>, or <em>std::exception_ptr</em>.</li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">std::bad_alloc</span></code>: (if one of the required allocations fails)</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx19get_error_backtraceERN3hpx14exception_infoE">
<span id="_CPPv2N3hpx19get_error_backtraceERN3hpx14exception_infoE"></span><span id="hpx::get_error_backtrace__hpx::exception_infoCR"></span><span class="target" id="namespacehpx_1a6832a96f6792773df7403722ca42ea1c"></span>std::string <code class="descname">get_error_backtrace</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::exception_info <em class="property">const</em> &amp;<em>xi</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx19get_error_backtraceERN3hpx14exception_infoE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the stack backtrace from the point the exception was thrown. </p>
<p>The function <em><a class="reference internal" href="#namespacehpx_1a6832a96f6792773df7403722ca42ea1c"><span class="std std-ref">hpx::get_error_backtrace</span></a></em> can be used to extract the diagnostic information element representing the stack backtrace collected at the point the exception was thrown.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The stack back trace from the point the exception was thrown. If the exception instance does not hold this information, the function will return an empty string.</dd>
<dt><strong>See</strong></dt>
<dd><em><a class="reference internal" href="#namespacehpx_1af59d165ab289edc23121bae716d73b81"><span class="std std-ref">hpx::diagnostic_information()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a7ebe8e69e08d364ec86cbdcb9c5aa199"><span class="std std-ref">hpx::get_error_host_name()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a0c21f4e95548d80fb941b4138d0e4d24"><span class="std std-ref">hpx::get_error_process_id()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a754d205ce3b220a254c65f3d124ac405"><span class="std std-ref">hpx::get_error_function_name()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a0af92c8ff70bbc40c078ef06a2ff4647"><span class="std std-ref">hpx::get_error_file_name()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ae0112fceccd5a51798ed81d88906468e"><span class="std std-ref">hpx::get_error_line_number()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a5fae8dd048ba1ba0b9a3f098335c4ab7"><span class="std std-ref">hpx::get_error_os_thread()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a56922a8181da8b3ca25a2f495bec15bf"><span class="std std-ref">hpx::get_error_thread_id()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a7d794dce67e3d4923547d0e045c7f307"><span class="std std-ref">hpx::get_error_thread_description()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1af6349dbd4e6dd99a3dfd5ff6e4e74c21"><span class="std std-ref">hpx::get_error()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ab74d4e93ce592c61fa3d107701ef9284"><span class="std std-ref">hpx::get_error_env()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ad28bf0e2a07a99c4d3eedaf1339af32c"><span class="std std-ref">hpx::get_error_what()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ae307e091b0dea3494eaf2afd72a82d15"><span class="std std-ref">hpx::get_error_config()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ae534c0adea0fd5b928a05f133d5c817d"><span class="std std-ref">hpx::get_error_state()</span></a></em> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xi</span></code>: The parameter <code class="docutils literal notranslate"><span class="pre">e</span></code> will be inspected for the requested diagnostic information elements which have been stored at the point where the exception was thrown. This parameter can be one of the following types: <em>hpx::exception_info</em>, <em><a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">hpx::error_code</span></a></em>, <em>std::exception</em>, or <em>std::exception_ptr</em>.</li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">std::bad_alloc</span></code>: (if one of the required allocations fails)</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx19get_error_file_nameERN3hpx14exception_infoE">
<span id="_CPPv2N3hpx19get_error_file_nameERN3hpx14exception_infoE"></span><span id="hpx::get_error_file_name__hpx::exception_infoCR"></span><span class="target" id="namespacehpx_1a0af92c8ff70bbc40c078ef06a2ff4647"></span>std::string <code class="descname">get_error_file_name</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::exception_info <em class="property">const</em> &amp;<em>xi</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx19get_error_file_nameERN3hpx14exception_infoE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the (source code) file name of the function from which the exception was thrown. </p>
<p>The function <em><a class="reference internal" href="#namespacehpx_1a0af92c8ff70bbc40c078ef06a2ff4647"><span class="std std-ref">hpx::get_error_file_name</span></a></em> can be used to extract the diagnostic information element representing the name of the source file as stored in the given exception instance.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The name of the source file of the function from which the exception was thrown. If the exception instance does not hold this information, the function will return an empty string.</dd>
<dt><strong>See</strong></dt>
<dd><em><a class="reference internal" href="#namespacehpx_1af59d165ab289edc23121bae716d73b81"><span class="std std-ref">hpx::diagnostic_information()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a7ebe8e69e08d364ec86cbdcb9c5aa199"><span class="std std-ref">hpx::get_error_host_name()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a0c21f4e95548d80fb941b4138d0e4d24"><span class="std std-ref">hpx::get_error_process_id()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a754d205ce3b220a254c65f3d124ac405"><span class="std std-ref">hpx::get_error_function_name()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ae0112fceccd5a51798ed81d88906468e"><span class="std std-ref">hpx::get_error_line_number()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a5fae8dd048ba1ba0b9a3f098335c4ab7"><span class="std std-ref">hpx::get_error_os_thread()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a56922a8181da8b3ca25a2f495bec15bf"><span class="std std-ref">hpx::get_error_thread_id()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a7d794dce67e3d4923547d0e045c7f307"><span class="std std-ref">hpx::get_error_thread_description()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1af6349dbd4e6dd99a3dfd5ff6e4e74c21"><span class="std std-ref">hpx::get_error()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a6832a96f6792773df7403722ca42ea1c"><span class="std std-ref">hpx::get_error_backtrace()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ab74d4e93ce592c61fa3d107701ef9284"><span class="std std-ref">hpx::get_error_env()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ad28bf0e2a07a99c4d3eedaf1339af32c"><span class="std std-ref">hpx::get_error_what()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ae307e091b0dea3494eaf2afd72a82d15"><span class="std std-ref">hpx::get_error_config()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ae534c0adea0fd5b928a05f133d5c817d"><span class="std std-ref">hpx::get_error_state()</span></a></em> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xi</span></code>: The parameter <code class="docutils literal notranslate"><span class="pre">e</span></code> will be inspected for the requested diagnostic information elements which have been stored at the point where the exception was thrown. This parameter can be one of the following types: <em>hpx::exception_info</em>, <em><a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">hpx::error_code</span></a></em>, <em>std::exception</em>, or <em>std::exception_ptr</em>.</li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">std::bad_alloc</span></code>: (if one of the required allocations fails)</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx21get_error_line_numberERN3hpx14exception_infoE">
<span id="_CPPv2N3hpx21get_error_line_numberERN3hpx14exception_infoE"></span><span id="hpx::get_error_line_number__hpx::exception_infoCR"></span><span class="target" id="namespacehpx_1ae0112fceccd5a51798ed81d88906468e"></span>long <code class="descname">get_error_line_number</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::exception_info <em class="property">const</em> &amp;<em>xi</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx21get_error_line_numberERN3hpx14exception_infoE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the line number in the (source code) file of the function from which the exception was thrown. </p>
<p>The function <em><a class="reference internal" href="#namespacehpx_1ae0112fceccd5a51798ed81d88906468e"><span class="std std-ref">hpx::get_error_line_number</span></a></em> can be used to extract the diagnostic information element representing the line number as stored in the given exception instance.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The line number of the place where the exception was thrown. If the exception instance does not hold this information, the function will return -1.</dd>
<dt><strong>See</strong></dt>
<dd><em><a class="reference internal" href="#namespacehpx_1af59d165ab289edc23121bae716d73b81"><span class="std std-ref">hpx::diagnostic_information()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a7ebe8e69e08d364ec86cbdcb9c5aa199"><span class="std std-ref">hpx::get_error_host_name()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a0c21f4e95548d80fb941b4138d0e4d24"><span class="std std-ref">hpx::get_error_process_id()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a754d205ce3b220a254c65f3d124ac405"><span class="std std-ref">hpx::get_error_function_name()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a0af92c8ff70bbc40c078ef06a2ff4647"><span class="std std-ref">hpx::get_error_file_name()</span></a></em> <em><a class="reference internal" href="#namespacehpx_1a5fae8dd048ba1ba0b9a3f098335c4ab7"><span class="std std-ref">hpx::get_error_os_thread()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a56922a8181da8b3ca25a2f495bec15bf"><span class="std std-ref">hpx::get_error_thread_id()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a7d794dce67e3d4923547d0e045c7f307"><span class="std std-ref">hpx::get_error_thread_description()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1af6349dbd4e6dd99a3dfd5ff6e4e74c21"><span class="std std-ref">hpx::get_error()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a6832a96f6792773df7403722ca42ea1c"><span class="std std-ref">hpx::get_error_backtrace()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ab74d4e93ce592c61fa3d107701ef9284"><span class="std std-ref">hpx::get_error_env()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ad28bf0e2a07a99c4d3eedaf1339af32c"><span class="std std-ref">hpx::get_error_what()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ae307e091b0dea3494eaf2afd72a82d15"><span class="std std-ref">hpx::get_error_config()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ae534c0adea0fd5b928a05f133d5c817d"><span class="std std-ref">hpx::get_error_state()</span></a></em> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xi</span></code>: The parameter <code class="docutils literal notranslate"><span class="pre">e</span></code> will be inspected for the requested diagnostic information elements which have been stored at the point where the exception was thrown. This parameter can be one of the following types: <em>hpx::exception_info</em>, <em><a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">hpx::error_code</span></a></em>, <em>std::exception</em>, or <em>std::exception_ptr</em>.</li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">nothing</span></code>: </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx19get_error_os_threadERN3hpx14exception_infoE">
<span id="_CPPv2N3hpx19get_error_os_threadERN3hpx14exception_infoE"></span><span id="hpx::get_error_os_thread__hpx::exception_infoCR"></span><span class="target" id="namespacehpx_1a5fae8dd048ba1ba0b9a3f098335c4ab7"></span>std::size_t <code class="descname">get_error_os_thread</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::exception_info <em class="property">const</em> &amp;<em>xi</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx19get_error_os_threadERN3hpx14exception_infoE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the sequence number of the OS-thread used to execute HPX-threads from which the exception was thrown. </p>
<p>The function <em><a class="reference internal" href="#namespacehpx_1a5fae8dd048ba1ba0b9a3f098335c4ab7"><span class="std std-ref">hpx::get_error_os_thread</span></a></em> can be used to extract the diagnostic information element representing the sequence number of the OS-thread as stored in the given exception instance.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The sequence number of the OS-thread used to execute the HPX-thread from which the exception was thrown. If the exception instance does not hold this information, the function will return std::size(-1).</dd>
<dt><strong>See</strong></dt>
<dd><em><a class="reference internal" href="#namespacehpx_1af59d165ab289edc23121bae716d73b81"><span class="std std-ref">hpx::diagnostic_information()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a7ebe8e69e08d364ec86cbdcb9c5aa199"><span class="std std-ref">hpx::get_error_host_name()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a0c21f4e95548d80fb941b4138d0e4d24"><span class="std std-ref">hpx::get_error_process_id()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a754d205ce3b220a254c65f3d124ac405"><span class="std std-ref">hpx::get_error_function_name()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a0af92c8ff70bbc40c078ef06a2ff4647"><span class="std std-ref">hpx::get_error_file_name()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ae0112fceccd5a51798ed81d88906468e"><span class="std std-ref">hpx::get_error_line_number()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a56922a8181da8b3ca25a2f495bec15bf"><span class="std std-ref">hpx::get_error_thread_id()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a7d794dce67e3d4923547d0e045c7f307"><span class="std std-ref">hpx::get_error_thread_description()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1af6349dbd4e6dd99a3dfd5ff6e4e74c21"><span class="std std-ref">hpx::get_error()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a6832a96f6792773df7403722ca42ea1c"><span class="std std-ref">hpx::get_error_backtrace()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ab74d4e93ce592c61fa3d107701ef9284"><span class="std std-ref">hpx::get_error_env()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ad28bf0e2a07a99c4d3eedaf1339af32c"><span class="std std-ref">hpx::get_error_what()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ae307e091b0dea3494eaf2afd72a82d15"><span class="std std-ref">hpx::get_error_config()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ae534c0adea0fd5b928a05f133d5c817d"><span class="std std-ref">hpx::get_error_state()</span></a></em> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xi</span></code>: The parameter <code class="docutils literal notranslate"><span class="pre">e</span></code> will be inspected for the requested diagnostic information elements which have been stored at the point where the exception was thrown. This parameter can be one of the following types: <em>hpx::exception_info</em>, <em><a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">hpx::error_code</span></a></em>, <em>std::exception</em>, or <em>std::exception_ptr</em>.</li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">nothing</span></code>: </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx19get_error_thread_idERN3hpx14exception_infoE">
<span id="_CPPv2N3hpx19get_error_thread_idERN3hpx14exception_infoE"></span><span id="hpx::get_error_thread_id__hpx::exception_infoCR"></span><span class="target" id="namespacehpx_1a56922a8181da8b3ca25a2f495bec15bf"></span>std::size_t <code class="descname">get_error_thread_id</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::exception_info <em class="property">const</em> &amp;<em>xi</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx19get_error_thread_idERN3hpx14exception_infoE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the unique thread id of the HPX-thread from which the exception was thrown. </p>
<p>The function <em><a class="reference internal" href="#namespacehpx_1a56922a8181da8b3ca25a2f495bec15bf"><span class="std std-ref">hpx::get_error_thread_id</span></a></em> can be used to extract the diagnostic information element representing the HPX-thread id as stored in the given exception instance.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The unique thread id of the HPX-thread from which the exception was thrown. If the exception instance does not hold this information, the function will return std::size_t(0).</dd>
<dt><strong>See</strong></dt>
<dd><em><a class="reference internal" href="#namespacehpx_1af59d165ab289edc23121bae716d73b81"><span class="std std-ref">hpx::diagnostic_information()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a7ebe8e69e08d364ec86cbdcb9c5aa199"><span class="std std-ref">hpx::get_error_host_name()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a0c21f4e95548d80fb941b4138d0e4d24"><span class="std std-ref">hpx::get_error_process_id()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a754d205ce3b220a254c65f3d124ac405"><span class="std std-ref">hpx::get_error_function_name()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a0af92c8ff70bbc40c078ef06a2ff4647"><span class="std std-ref">hpx::get_error_file_name()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ae0112fceccd5a51798ed81d88906468e"><span class="std std-ref">hpx::get_error_line_number()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a5fae8dd048ba1ba0b9a3f098335c4ab7"><span class="std std-ref">hpx::get_error_os_thread()</span></a></em> <em><a class="reference internal" href="#namespacehpx_1a7d794dce67e3d4923547d0e045c7f307"><span class="std std-ref">hpx::get_error_thread_description()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1af6349dbd4e6dd99a3dfd5ff6e4e74c21"><span class="std std-ref">hpx::get_error()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a6832a96f6792773df7403722ca42ea1c"><span class="std std-ref">hpx::get_error_backtrace()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ab74d4e93ce592c61fa3d107701ef9284"><span class="std std-ref">hpx::get_error_env()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ad28bf0e2a07a99c4d3eedaf1339af32c"><span class="std std-ref">hpx::get_error_what()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ae307e091b0dea3494eaf2afd72a82d15"><span class="std std-ref">hpx::get_error_config()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ae534c0adea0fd5b928a05f133d5c817d"><span class="std std-ref">hpx::get_error_state()</span></a></em> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xi</span></code>: The parameter <code class="docutils literal notranslate"><span class="pre">e</span></code> will be inspected for the requested diagnostic information elements which have been stored at the point where the exception was thrown. This parameter can be one of the following types: <em>hpx::exception_info</em>, <em><a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">hpx::error_code</span></a></em>, <em>std::exception</em>, or <em>std::exception_ptr</em>.</li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">nothing</span></code>: </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx28get_error_thread_descriptionERN3hpx14exception_infoE">
<span id="_CPPv2N3hpx28get_error_thread_descriptionERN3hpx14exception_infoE"></span><span id="hpx::get_error_thread_description__hpx::exception_infoCR"></span><span class="target" id="namespacehpx_1a7d794dce67e3d4923547d0e045c7f307"></span>std::string <code class="descname">get_error_thread_description</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::exception_info <em class="property">const</em> &amp;<em>xi</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx28get_error_thread_descriptionERN3hpx14exception_infoE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return any additionally available thread description of the HPX-thread from which the exception was thrown. </p>
<p>The function <em><a class="reference internal" href="#namespacehpx_1a7d794dce67e3d4923547d0e045c7f307"><span class="std std-ref">hpx::get_error_thread_description</span></a></em> can be used to extract the diagnostic information element representing the additional thread description as stored in the given exception instance.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Any additionally available thread description of the HPX-thread from which the exception was thrown. If the exception instance does not hold this information, the function will return an empty string.</dd>
<dt><strong>See</strong></dt>
<dd><em><a class="reference internal" href="#namespacehpx_1af59d165ab289edc23121bae716d73b81"><span class="std std-ref">hpx::diagnostic_information()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a7ebe8e69e08d364ec86cbdcb9c5aa199"><span class="std std-ref">hpx::get_error_host_name()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a0c21f4e95548d80fb941b4138d0e4d24"><span class="std std-ref">hpx::get_error_process_id()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a754d205ce3b220a254c65f3d124ac405"><span class="std std-ref">hpx::get_error_function_name()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a0af92c8ff70bbc40c078ef06a2ff4647"><span class="std std-ref">hpx::get_error_file_name()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ae0112fceccd5a51798ed81d88906468e"><span class="std std-ref">hpx::get_error_line_number()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a5fae8dd048ba1ba0b9a3f098335c4ab7"><span class="std std-ref">hpx::get_error_os_thread()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a56922a8181da8b3ca25a2f495bec15bf"><span class="std std-ref">hpx::get_error_thread_id()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a6832a96f6792773df7403722ca42ea1c"><span class="std std-ref">hpx::get_error_backtrace()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ab74d4e93ce592c61fa3d107701ef9284"><span class="std std-ref">hpx::get_error_env()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1af6349dbd4e6dd99a3dfd5ff6e4e74c21"><span class="std std-ref">hpx::get_error()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ae534c0adea0fd5b928a05f133d5c817d"><span class="std std-ref">hpx::get_error_state()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ad28bf0e2a07a99c4d3eedaf1339af32c"><span class="std std-ref">hpx::get_error_what()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ae307e091b0dea3494eaf2afd72a82d15"><span class="std std-ref">hpx::get_error_config()</span></a></em> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xi</span></code>: The parameter <code class="docutils literal notranslate"><span class="pre">e</span></code> will be inspected for the requested diagnostic information elements which have been stored at the point where the exception was thrown. This parameter can be one of the following types: <em>hpx::exception_info</em>, <em><a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">hpx::error_code</span></a></em>, <em>std::exception</em>, or <em>std::exception_ptr</em>.</li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">std::bad_alloc</span></code>: (if one of the required allocations fails)</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx16get_error_configERN3hpx14exception_infoE">
<span id="_CPPv2N3hpx16get_error_configERN3hpx14exception_infoE"></span><span id="hpx::get_error_config__hpx::exception_infoCR"></span><span class="target" id="namespacehpx_1ae307e091b0dea3494eaf2afd72a82d15"></span>std::string <code class="descname">get_error_config</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::exception_info <em class="property">const</em> &amp;<em>xi</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx16get_error_configERN3hpx14exception_infoE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the HPX configuration information point from which the exception was thrown. </p>
<p>The function <em><a class="reference internal" href="#namespacehpx_1ae307e091b0dea3494eaf2afd72a82d15"><span class="std std-ref">hpx::get_error_config</span></a></em> can be used to extract the HPX configuration information element representing the full HPX configuration information as stored in the given exception instance.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Any additionally available HPX configuration information the point from which the exception was thrown. If the exception instance does not hold this information, the function will return an empty string.</dd>
<dt><strong>See</strong></dt>
<dd><em><a class="reference internal" href="#namespacehpx_1af59d165ab289edc23121bae716d73b81"><span class="std std-ref">hpx::diagnostic_information()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a7ebe8e69e08d364ec86cbdcb9c5aa199"><span class="std std-ref">hpx::get_error_host_name()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a0c21f4e95548d80fb941b4138d0e4d24"><span class="std std-ref">hpx::get_error_process_id()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a754d205ce3b220a254c65f3d124ac405"><span class="std std-ref">hpx::get_error_function_name()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a0af92c8ff70bbc40c078ef06a2ff4647"><span class="std std-ref">hpx::get_error_file_name()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ae0112fceccd5a51798ed81d88906468e"><span class="std std-ref">hpx::get_error_line_number()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a5fae8dd048ba1ba0b9a3f098335c4ab7"><span class="std std-ref">hpx::get_error_os_thread()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a56922a8181da8b3ca25a2f495bec15bf"><span class="std std-ref">hpx::get_error_thread_id()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a6832a96f6792773df7403722ca42ea1c"><span class="std std-ref">hpx::get_error_backtrace()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ab74d4e93ce592c61fa3d107701ef9284"><span class="std std-ref">hpx::get_error_env()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1af6349dbd4e6dd99a3dfd5ff6e4e74c21"><span class="std std-ref">hpx::get_error()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ae534c0adea0fd5b928a05f133d5c817d"><span class="std std-ref">hpx::get_error_state()</span></a></em> <em><a class="reference internal" href="#namespacehpx_1ad28bf0e2a07a99c4d3eedaf1339af32c"><span class="std std-ref">hpx::get_error_what()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a7d794dce67e3d4923547d0e045c7f307"><span class="std std-ref">hpx::get_error_thread_description()</span></a></em> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xi</span></code>: The parameter <code class="docutils literal notranslate"><span class="pre">e</span></code> will be inspected for the requested diagnostic information elements which have been stored at the point where the exception was thrown. This parameter can be one of the following types: <em>hpx::exception_info</em>, <em><a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">hpx::error_code</span></a></em>, <em>std::exception</em>, or <em>std::exception_ptr</em>.</li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">std::bad_alloc</span></code>: (if one of the required allocations fails)</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx15get_error_stateERN3hpx14exception_infoE">
<span id="_CPPv2N3hpx15get_error_stateERN3hpx14exception_infoE"></span><span id="hpx::get_error_state__hpx::exception_infoCR"></span><span class="target" id="namespacehpx_1ae534c0adea0fd5b928a05f133d5c817d"></span>std::string <code class="descname">get_error_state</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::exception_info <em class="property">const</em> &amp;<em>xi</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx15get_error_stateERN3hpx14exception_infoE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the HPX runtime state information at which the exception was thrown. </p>
<p>The function <em><a class="reference internal" href="#namespacehpx_1ae534c0adea0fd5b928a05f133d5c817d"><span class="std std-ref">hpx::get_error_state</span></a></em> can be used to extract the HPX runtime state information element representing the state the runtime system is currently in as stored in the given exception instance.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The point runtime state at the point at which the exception was thrown. If the exception instance does not hold this information, the function will return an empty string.</dd>
<dt><strong>See</strong></dt>
<dd><em><a class="reference internal" href="#namespacehpx_1af59d165ab289edc23121bae716d73b81"><span class="std std-ref">hpx::diagnostic_information()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a7ebe8e69e08d364ec86cbdcb9c5aa199"><span class="std std-ref">hpx::get_error_host_name()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a0c21f4e95548d80fb941b4138d0e4d24"><span class="std std-ref">hpx::get_error_process_id()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a754d205ce3b220a254c65f3d124ac405"><span class="std std-ref">hpx::get_error_function_name()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a0af92c8ff70bbc40c078ef06a2ff4647"><span class="std std-ref">hpx::get_error_file_name()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ae0112fceccd5a51798ed81d88906468e"><span class="std std-ref">hpx::get_error_line_number()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a5fae8dd048ba1ba0b9a3f098335c4ab7"><span class="std std-ref">hpx::get_error_os_thread()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a56922a8181da8b3ca25a2f495bec15bf"><span class="std std-ref">hpx::get_error_thread_id()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a6832a96f6792773df7403722ca42ea1c"><span class="std std-ref">hpx::get_error_backtrace()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ab74d4e93ce592c61fa3d107701ef9284"><span class="std std-ref">hpx::get_error_env()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1af6349dbd4e6dd99a3dfd5ff6e4e74c21"><span class="std std-ref">hpx::get_error()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ad28bf0e2a07a99c4d3eedaf1339af32c"><span class="std std-ref">hpx::get_error_what()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a7d794dce67e3d4923547d0e045c7f307"><span class="std std-ref">hpx::get_error_thread_description()</span></a></em> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">xi</span></code>: The parameter <code class="docutils literal notranslate"><span class="pre">e</span></code> will be inspected for the requested diagnostic information elements which have been stored at the point where the exception was thrown. This parameter can be one of the following types: <em>hpx::exception_info</em>, <em><a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">hpx::error_code</span></a></em>, <em>std::exception</em>, or <em>std::exception_ptr</em>.</li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">std::bad_alloc</span></code>: (if one of the required allocations fails)</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx15register_threadEP7runtimePcR10error_code">
<span id="_CPPv2N3hpx15register_threadEP7runtimePcR10error_code"></span><span id="hpx::register_thread__runtimeP.cCP.error_codeR"></span><span class="target" id="namespacehpx_1a0bdf7871dfff58e68ae5eab9af23f2aa"></span>bool <code class="descname">register_thread</code><span class="sig-paren">(</span>runtime *<em>rt</em>, char <em class="property">const</em> *<em>name</em>, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx15register_threadEP7runtimePcR10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Register the current kernel thread with HPX, this should be done once for each external OS-thread intended to invoke HPX functionality. Calling this function more than once will silently fail. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx17unregister_threadEP7runtime">
<span id="_CPPv2N3hpx17unregister_threadEP7runtime"></span><span id="hpx::unregister_thread__runtimeP"></span><span class="target" id="namespacehpx_1ae6fab9f567417d9f1fa0772537b5dc2b"></span>void <code class="descname">unregister_thread</code><span class="sig-paren">(</span>runtime *<em>rt</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx17unregister_threadEP7runtime" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Unregister the thread from HPX, this should be done once in the end before the external thread exists. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx12get_localityEv">
<span id="_CPPv2N3hpx12get_localityEv"></span><span id="hpx::get_locality"></span><span class="target" id="namespacehpx_1a20392fc425de279eb5ef5f0206825d26"></span><a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::gid_type <em class="property">const</em> &amp;<code class="descname">get_locality</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx12get_localityEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>get_locality</em> returns a reference to the locality prefix. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx27get_runtime_instance_numberEv">
<span id="_CPPv2N3hpx27get_runtime_instance_numberEv"></span><span id="hpx::get_runtime_instance_number"></span><span class="target" id="namespacehpx_1a9cd8c96309c6ea084c51856ae6cde7a5"></span>std::size_t <code class="descname">get_runtime_instance_number</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx27get_runtime_instance_numberEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>get_runtime_instance_number</em> returns a unique number associated with the runtime instance the current thread is running in. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx16register_on_exitERN4util15function_nonserIFvvEEE">
<span id="_CPPv2N3hpx16register_on_exitERN4util15function_nonserIFvvEEE"></span><span class="target" id="namespacehpx_1ab6a4104504c101248834fe490c813b08"></span>bool <code class="descname">register_on_exit</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::function_nonser&lt;void<span class="sig-paren">(</span><span class="sig-paren">)</span>&gt; <em class="property">const</em>&amp;<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx16register_on_exitERN4util15function_nonserIFvvEEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Register a function to be called during system shutdown. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx11is_startingEv">
<span id="_CPPv2N3hpx11is_startingEv"></span><span id="hpx::is_starting"></span><span class="target" id="namespacehpx_1ad8fbe89e273b0a5d2f57ea09a971e1af"></span>bool <code class="descname">is_starting</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx11is_startingEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Test whether the runtime system is currently being started. </p>
<p>This function returns whether the runtime system is currently being started or not, e.g. whether the current state of the runtime system is <em>hpx::state_startup</em> </p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function needs to be executed on a HPX-thread. It will return false otherwise. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx20tolerate_node_faultsEv">
<span id="_CPPv2N3hpx20tolerate_node_faultsEv"></span><span id="hpx::tolerate_node_faults"></span><span class="target" id="namespacehpx_1a6a7e3387e6a55d6d7040a142bda044d6"></span>bool <code class="descname">tolerate_node_faults</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx20tolerate_node_faultsEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Test if HPX runs in fault-tolerant mode. </p>
<p>This function returns whether the runtime system is running in fault-tolerant mode </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx10is_runningEv">
<span id="_CPPv2N3hpx10is_runningEv"></span><span id="hpx::is_running"></span><span class="target" id="namespacehpx_1ab20f0913801d5a05d84e4eac0e24f704"></span>bool <code class="descname">is_running</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx10is_runningEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Test whether the runtime system is currently running. </p>
<p>This function returns whether the runtime system is currently running or not, e.g. whether the current state of the runtime system is <em>hpx::state_running</em> </p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function needs to be executed on a HPX-thread. It will return false otherwise. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx10is_stoppedEv">
<span id="_CPPv2N3hpx10is_stoppedEv"></span><span id="hpx::is_stopped"></span><span class="target" id="namespacehpx_1a04f7638724843ab606835ba07816acb4"></span>bool <code class="descname">is_stopped</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx10is_stoppedEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Test whether the runtime system is currently stopped. </p>
<p>This function returns whether the runtime system is currently stopped or not, e.g. whether the current state of the runtime system is <em>hpx::state_stopped</em> </p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function needs to be executed on a HPX-thread. It will return false otherwise. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx27is_stopped_or_shutting_downEv">
<span id="_CPPv2N3hpx27is_stopped_or_shutting_downEv"></span><span id="hpx::is_stopped_or_shutting_down"></span><span class="target" id="namespacehpx_1a6ed14cb2616c96933836462c355f1e13"></span>bool <code class="descname">is_stopped_or_shutting_down</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx27is_stopped_or_shutting_downEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Test whether the runtime system is currently being shut down. </p>
<p>This function returns whether the runtime system is currently being shut down or not, e.g. whether the current state of the runtime system is <em>hpx::state_stopped</em> or <em>hpx::state_shutdown</em> </p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function needs to be executed on a HPX-thread. It will return false otherwise. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx22get_num_worker_threadsEv">
<span id="_CPPv2N3hpx22get_num_worker_threadsEv"></span><span id="hpx::get_num_worker_threads"></span><span class="target" id="namespacehpx_1ae0cb050327ed37e6863061bd1761409e"></span>std::size_t <code class="descname">get_num_worker_threads</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx22get_num_worker_threadsEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the number of worker OS- threads used to execute HPX threads. </p>
<p>This function returns the number of OS-threads used to execute HPX threads. If the function is called while no HPX runtime system is active, it will return zero. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx17get_system_uptimeEv">
<span id="_CPPv2N3hpx17get_system_uptimeEv"></span><span id="hpx::get_system_uptime"></span><span class="target" id="namespacehpx_1a805a6863e2633550de10e42233f6ee0b"></span>std::uint64_t <code class="descname">get_system_uptime</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx17get_system_uptimeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the system uptime measure on the thread executing this call. </p>
<p>This function returns the system uptime measured in nanoseconds for the thread executing this call. If the function is called while no HPX runtime system is active, it will return zero. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx21start_active_countersER10error_code">
<span id="_CPPv2N3hpx21start_active_countersER10error_code"></span><span id="hpx::start_active_counters__error_codeR"></span><span class="target" id="namespacehpx_1a63bda005cda88c7c7e42a29e950176f2"></span>void <code class="descname">start_active_counters</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx21start_active_countersER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Start all active performance counters, optionally naming the section of code. </p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>As long as <em>ec</em> is not pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> this function doesn’t throw but returns the result code using the parameter <em>ec</em>. Otherwise it throws an instance of <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a>.</dd>
<dt><strong>Note</strong></dt>
<dd>The active counters are those which have been specified on the command line while executing the application (see command line option –hpx:print-counter) </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx21reset_active_countersER10error_code">
<span id="_CPPv2N3hpx21reset_active_countersER10error_code"></span><span id="hpx::reset_active_counters__error_codeR"></span><span class="target" id="namespacehpx_1ad3c6bed4bad130ad9b104b7f4a55b4ea"></span>void <code class="descname">reset_active_counters</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx21reset_active_countersER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Resets all active performance counters. </p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>As long as <em>ec</em> is not pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> this function doesn’t throw but returns the result code using the parameter <em>ec</em>. Otherwise it throws an instance of <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a>.</dd>
<dt><strong>Note</strong></dt>
<dd>The active counters are those which have been specified on the command line while executing the application (see command line option –hpx:print-counter) </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx22reinit_active_countersEbR10error_code">
<span id="_CPPv2N3hpx22reinit_active_countersEbR10error_code"></span><span id="hpx::reinit_active_counters__b.error_codeR"></span><span class="target" id="namespacehpx_1a60e4928d4f5e31bed41b45e3d0e61b56"></span>void <code class="descname">reinit_active_counters</code><span class="sig-paren">(</span>bool <em>reset</em> = true, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx22reinit_active_countersEbR10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Re-initialize all active performance counters. </p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>As long as <em>ec</em> is not pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> this function doesn’t throw but returns the result code using the parameter <em>ec</em>. Otherwise it throws an instance of <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a>.</dd>
<dt><strong>Note</strong></dt>
<dd>The active counters are those which have been specified on the command line while executing the application (see command line option –hpx:print-counter) </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">reset</span></code>: [in] Reset the current values before re-initializing counters (default: true) </li>
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx20stop_active_countersER10error_code">
<span id="_CPPv2N3hpx20stop_active_countersER10error_code"></span><span id="hpx::stop_active_counters__error_codeR"></span><span class="target" id="namespacehpx_1a32ecc3b6052e3801ab35b11cdbcdaccd"></span>void <code class="descname">stop_active_counters</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx20stop_active_countersER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Stop all active performance counters. </p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>As long as <em>ec</em> is not pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> this function doesn’t throw but returns the result code using the parameter <em>ec</em>. Otherwise it throws an instance of <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a>.</dd>
<dt><strong>Note</strong></dt>
<dd>The active counters are those which have been specified on the command line while executing the application (see command line option –hpx:print-counter) </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx24evaluate_active_countersEbPcR10error_code">
<span id="_CPPv2N3hpx24evaluate_active_countersEbPcR10error_code"></span><span id="hpx::evaluate_active_counters__b.cCP.error_codeR"></span><span class="target" id="namespacehpx_1a321a5315c52ed45b3d2fc64599c3f898"></span>void <code class="descname">evaluate_active_counters</code><span class="sig-paren">(</span>bool <em>reset</em> = false, char <em class="property">const</em> *<em>description</em> = nullptr, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx24evaluate_active_countersEbPcR10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Evaluate and output all active performance counters, optionally naming the point in code marked by this function. </p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>As long as <em>ec</em> is not pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> this function doesn’t throw but returns the result code using the parameter <em>ec</em>. Otherwise it throws an instance of <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a>.</dd>
<dt><strong>Note</strong></dt>
<dd>The output generated by this function is redirected to the destination specified by the corresponding command line options (see –hpx:print-counter-destination).</dd>
<dt><strong>Note</strong></dt>
<dd>The active counters are those which have been specified on the command line while executing the application (see command line option –hpx:print-counter) </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">reset</span></code>: [in] this is an optional flag allowing to reset the counter value after it has been evaluated. </li>
<li><code class="docutils literal notranslate"><span class="pre">description</span></code>: [in] this is an optional value naming the point in the code marked by the call to this function. </li>
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx20create_binary_filterEPcbPN13serialization13binary_filterER10error_code">
<span id="_CPPv2N3hpx20create_binary_filterEPcbPN13serialization13binary_filterER10error_code"></span><span id="hpx::create_binary_filter__cCP.b.serialization::binary_filterP.error_codeR"></span><span class="target" id="namespacehpx_1a68b368379e3bfb318c7cbe5928dbd4e3"></span>serialization::binary_filter *<code class="descname">create_binary_filter</code><span class="sig-paren">(</span>char <em class="property">const</em> *<em>binary_filter_type</em>, bool <em>compress</em>, serialization::binary_filter *<em>next_filter</em> = nullptr, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx20create_binary_filterEPcbPN13serialization13binary_filterER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Create an instance of a binary filter plugin. </p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>As long as <em>ec</em> is not pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> this function doesn’t throw but returns the result code using the parameter <em>ec</em>. Otherwise it throws an instance of <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">binary_filter_type</span></code>: [in] The type of the binary filter to create </li>
<li><code class="docutils literal notranslate"><span class="pre">compress</span></code>: [in] The created filter should support compression </li>
<li><code class="docutils literal notranslate"><span class="pre">next_filter</span></code>: [in] Use this as the filter to dispatch the invocation into. </li>
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx22find_all_from_basenameENSt6stringENSt6size_tE">
<span id="_CPPv2N3hpx22find_all_from_basenameENSt6stringENSt6size_tE"></span><span id="hpx::find_all_from_basename__ss.std::s"></span><span class="target" id="namespacehpx_1a66926bac762addf6d636fdb2cf148516"></span>std::vector&lt;Client&gt; <code class="descname">find_all_from_basename</code><span class="sig-paren">(</span>std::string <em>base_name</em>, std::size_t <em>num_ids</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx22find_all_from_basenameENSt6stringENSt6size_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return all registered ids from all localities from the given base name.</p>
<p>This function locates all ids which were registered with the given base name. It returns a list of futures representing those ids.</p>
<p><p>Return all registered clients from all localities from the given base name.</p>
<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>A list of futures representing the ids which were registered using the given base name.</dd>
<dt><strong>Note</strong></dt>
<dd>The futures will become ready even if the event (for instance, binding the name to an id) has already happened in the past. This is important in order to reliably retrieve ids from a name, even if the name was already registered.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">base_name</span></code>: [in] The base name for which to retrieve the registered ids. </li>
<li><code class="docutils literal notranslate"><span class="pre">num_ids</span></code>: [in] The number of registered ids to expect.</li>
</ul>
</dd>
</dl>
</p>
<p>This function locates all ids which were registered with the given base name. It returns a list of futures representing those ids.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>A list of futures representing the ids which were registered using the given base name.</dd>
<dt><strong>Note</strong></dt>
<dd>The futures embedded in the returned client objects will become ready even if the event (for instance, binding the name to an id) has already happened in the past. This is important in order to reliably retrieve ids from a name, even if the name was already registered. </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">Client</span></code>: The client type to return</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">base_name</span></code>: [in] The base name for which to retrieve the registered ids. </li>
<li><code class="docutils literal notranslate"><span class="pre">num_ids</span></code>: [in] The number of registered ids to expect.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx18find_from_basenameENSt6stringERNSt6vectorINSt6size_tEEE">
<span id="_CPPv2N3hpx18find_from_basenameENSt6stringERNSt6vectorINSt6size_tEEE"></span><span id="hpx::find_from_basename__ss.std::vector:std::s:CR"></span><span class="target" id="namespacehpx_1aab131e9a24c4a1a9bc04dca4f45d675b"></span>std::vector&lt;Client&gt; <code class="descname">find_from_basename</code><span class="sig-paren">(</span>std::string <em>base_name</em>, std::vector&lt;std::size_t&gt; <em class="property">const</em> &amp;<em>ids</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx18find_from_basenameENSt6stringERNSt6vectorINSt6size_tEEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return registered ids from the given base name and sequence numbers.</p>
<p>This function locates the ids which were registered with the given base name and the given sequence numbers. It returns a list of futures representing those ids.</p>
<p><p>Return registered clients from the given base name and sequence numbers.</p>
<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>A list of futures representing the ids which were registered using the given base name and sequence numbers.</dd>
<dt><strong>Note</strong></dt>
<dd>The futures will become ready even if the event (for instance, binding the name to an id) has already happened in the past. This is important in order to reliably retrieve ids from a name, even if the name was already registered.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">base_name</span></code>: [in] The base name for which to retrieve the registered ids. </li>
<li><code class="docutils literal notranslate"><span class="pre">ids</span></code>: [in] The sequence numbers of the registered ids.</li>
</ul>
</dd>
</dl>
</p>
<p>This function locates the ids which were registered with the given base name and the given sequence numbers. It returns a list of futures representing those ids.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>A list of futures representing the ids which were registered using the given base name and sequence numbers.</dd>
<dt><strong>Note</strong></dt>
<dd>The futures embedded in the returned client objects will become ready even if the event (for instance, binding the name to an id) has already happened in the past. This is important in order to reliably retrieve ids from a name, even if the name was already registered. </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">Client</span></code>: The client type to return</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">base_name</span></code>: [in] The base name for which to retrieve the registered ids. </li>
<li><code class="docutils literal notranslate"><span class="pre">ids</span></code>: [in] The sequence numbers of the registered ids.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx18find_from_basenameENSt6stringENSt6size_tE">
<span id="_CPPv2N3hpx18find_from_basenameENSt6stringENSt6size_tE"></span><span id="hpx::find_from_basename__ss.std::s"></span><span class="target" id="namespacehpx_1adb273a4ba592836bba34943a3674aec5"></span>Client <code class="descname">find_from_basename</code><span class="sig-paren">(</span>std::string <em>base_name</em>, std::size_t <em>sequence_nr</em> = ~0U<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx18find_from_basenameENSt6stringENSt6size_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return registered id from the given base name and sequence number. </p>
<p>This function locates the id which was registered with the given base name and the given sequence number. It returns a future representing those id.</p>
<p><p>This function locates the id which was registered with the given base name and the given sequence number. It returns a future representing those id.</p>
<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>A representing the id which was registered using the given base name and sequence numbers.</dd>
<dt><strong>Note</strong></dt>
<dd>The future will become ready even if the event (for instance, binding the name to an id) has already happened in the past. This is important in order to reliably retrieve ids from a name, even if the name was already registered.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">base_name</span></code>: [in] The base name for which to retrieve the registered ids. </li>
<li><code class="docutils literal notranslate"><span class="pre">sequence_nr</span></code>: [in] The sequence number of the registered id.</li>
</ul>
</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>A representing the id which was registered using the given base name and sequence numbers.</dd>
<dt><strong>Note</strong></dt>
<dd>The future embedded in the returned client object will become ready even if the event (for instance, binding the name to an id) has already happened in the past. This is important in order to reliably retrieve ids from a name, even if the name was already registered. </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">Client</span></code>: The client type to return</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">base_name</span></code>: [in] The base name for which to retrieve the registered ids. </li>
<li><code class="docutils literal notranslate"><span class="pre">sequence_nr</span></code>: [in] The sequence number of the registered id.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx22register_with_basenameENSt6stringEN3hpx7id_typeENSt6size_tE">
<span id="_CPPv2N3hpx22register_with_basenameENSt6stringEN3hpx7id_typeENSt6size_tE"></span><span id="hpx::register_with_basename__ss.hpx::id_type.std::s"></span><span class="target" id="namespacehpx_1ab07858717ce3212089fabddc841239e9"></span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::future&lt;bool&gt; <code class="descname">register_with_basename</code><span class="sig-paren">(</span>std::string <em>base_name</em>, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::id_type <em>id</em>, std::size_t <em>sequence_nr</em> = ~0U<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx22register_with_basenameENSt6stringEN3hpx7id_typeENSt6size_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Register the given id using the given base name. </p>
<p>The function registers the given ids using the provided base name.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>A future representing the result of the registration operation itself.</dd>
<dt><strong>Note</strong></dt>
<dd>The operation will fail if the given sequence number is not unique. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">base_name</span></code>: [in] The base name for which to retrieve the registered ids. </li>
<li><code class="docutils literal notranslate"><span class="pre">id</span></code>: [in] The id to register using the given base name. </li>
<li><code class="docutils literal notranslate"><span class="pre">sequence_nr</span></code>: [in, optional] The sequential number to use for the registration of the id. This number has to be unique system wide for each registration using the same base name. The default is the current locality identifier. Also, the sequence numbers have to be consecutive starting from zero.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx22register_with_basenameENSt6stringEN3hpx6futureIN3hpx7id_typeEEENSt6size_tE">
<span id="_CPPv2N3hpx22register_with_basenameENSt6stringEN3hpx6futureIN3hpx7id_typeEEENSt6size_tE"></span><span id="hpx::register_with_basename__ss.hpx::future:hpx::id_type:.std::s"></span><span class="target" id="namespacehpx_1a5c7e5ae41d3ba06633d53c18c2f92978"></span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::future&lt;bool&gt; <code class="descname">register_with_basename</code><span class="sig-paren">(</span>std::string <em>base_name</em>, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::future&lt;<a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::id_type&gt; <em>f</em>, std::size_t <em>sequence_nr</em> = ~0U<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx22register_with_basenameENSt6stringEN3hpx6futureIN3hpx7id_typeEEENSt6size_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Register the id wrapped in the given future using the given base name.</p>
<p>The function registers the object the given future refers to using the provided base name.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>A future representing the result of the registration operation itself.</dd>
<dt><strong>Note</strong></dt>
<dd>The operation will fail if the given sequence number is not unique. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">base_name</span></code>: [in] The base name for which to retrieve the registered ids. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: [in] The future which should be registered using the given base name. </li>
<li><code class="docutils literal notranslate"><span class="pre">sequence_nr</span></code>: [in, optional] The sequential number to use for the registration of the id. This number has to be unique system wide for each registration using the same base name. The default is the current locality identifier. Also, the sequence numbers have to be consecutive starting from zero.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx22register_with_basenameENSt6stringERN10components11client_baseI6Client4StubEENSt6size_tE">
<span id="_CPPv2N3hpx22register_with_basenameENSt6stringERN10components11client_baseI6Client4StubEENSt6size_tE"></span><span id="hpx::register_with_basename__ss.components::client_base:Client.Stub:R.std::s"></span><em class="property">template </em>&lt;<em class="property">typename</em> Client, <em class="property">typename</em> Stub&gt;<br /><span class="target" id="namespacehpx_1ae5f4da24c521a288098fa6e9f8b7b84e"></span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::future&lt;bool&gt; <code class="descname">register_with_basename</code><span class="sig-paren">(</span>std::string <em>base_name</em>, <a class="reference internal" href="#_CPPv3N3hpx10componentsE" title="hpx::components">components</a>::client_base&lt;Client, Stub&gt; &amp;<em>client</em>, std::size_t <em>sequence_nr</em> = ~0U<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx22register_with_basenameENSt6stringERN10components11client_baseI6Client4StubEENSt6size_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Register the id wrapped in the given client using the given base name.</p>
<p>The function registers the object the given client refers to using the provided base name.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>A future representing the result of the registration operation itself.</dd>
<dt><strong>Note</strong></dt>
<dd>The operation will fail if the given sequence number is not unique. </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">Client</span></code>: The client type to register</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">base_name</span></code>: [in] The base name for which to retrieve the registered ids. </li>
<li><code class="docutils literal notranslate"><span class="pre">client</span></code>: [in] The client which should be registered using the given base name. </li>
<li><code class="docutils literal notranslate"><span class="pre">sequence_nr</span></code>: [in, optional] The sequential number to use for the registration of the id. This number has to be unique system wide for each registration using the same base name. The default is the current locality identifier. Also, the sequence numbers have to be consecutive starting from zero.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx24unregister_with_basenameENSt6stringENSt6size_tE">
<span id="_CPPv2N3hpx24unregister_with_basenameENSt6stringENSt6size_tE"></span><span id="hpx::unregister_with_basename__ss.std::s"></span><span class="target" id="namespacehpx_1a8b74adbaed07646c3eaeb8bc8cbaa55d"></span>Client <code class="descname">unregister_with_basename</code><span class="sig-paren">(</span>std::string <em>base_name</em>, std::size_t <em>sequence_nr</em> = ~0U<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx24unregister_with_basenameENSt6stringENSt6size_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Unregister the given id using the given base name. </p>
<p>The function unregisters the given ids using the provided base name.</p>
<p><p>Unregister the given base name.</p>
<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>A future representing the result of the un-registration operation itself.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">base_name</span></code>: [in] The base name for which to retrieve the registered ids. </li>
<li><code class="docutils literal notranslate"><span class="pre">sequence_nr</span></code>: [in, optional] The sequential number to use for the un-registration. This number has to be the same as has been used with <em>register_with_basename</em> before.</li>
</ul>
</dd>
</dl>
</p>
<p>The function unregisters the given ids using the provided base name.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>A future representing the result of the un-registration operation itself. </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">Client</span></code>: The client type to return</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">base_name</span></code>: [in] The base name for which to retrieve the registered ids. </li>
<li><code class="docutils literal notranslate"><span class="pre">sequence_nr</span></code>: [in, optional] The sequential number to use for the un-registration. This number has to be the same as has been used with <em>register_with_basename</em> before.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx9find_hereER10error_code">
<span id="_CPPv2N3hpx9find_hereER10error_code"></span><span id="hpx::find_here__error_codeR"></span><span class="target" id="namespacehpx_1af07c1b6e26bcdfb1138643a1a2133cf4"></span><a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type <code class="descname">find_here</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx9find_hereER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the global id representing this locality. </p>
<p>The function <em><a class="reference internal" href="#namespacehpx_1af07c1b6e26bcdfb1138643a1a2133cf4"><span class="std std-ref">find_here()</span></a></em> can be used to retrieve the global id usable to refer to the current locality.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Generally, the id of a locality can be used for instance to create new instances of components and to invoke plain actions (global functions).</dd>
<dt><strong>Return</strong></dt>
<dd>The global id representing the locality this function has been called on.</dd>
<dt><strong>Note</strong></dt>
<dd>As long as <em>ec</em> is not pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> this function doesn’t throw but returns the result code using the parameter <em>ec</em>. Otherwise it throws an instance of <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a>.</dd>
<dt><strong>Note</strong></dt>
<dd>This function will return meaningful results only if called from an HPX-thread. It will return <em>hpx::naming::invalid_id</em> otherwise.</dd>
<dt><strong>See</strong></dt>
<dd><em><a class="reference internal" href="#namespacehpx_1ad7e2f65f28022cc809a10034ee8379d2"><span class="std std-ref">hpx::find_all_localities()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1adde1eeefca5bbb4863e54ca81dfb1b6f"><span class="std std-ref">hpx::find_locality()</span></a></em> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx18find_root_localityER10error_code">
<span id="_CPPv2N3hpx18find_root_localityER10error_code"></span><span id="hpx::find_root_locality__error_codeR"></span><span class="target" id="namespacehpx_1a91f701414a6c667c3b58a2e50b93ad0a"></span><a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type <code class="descname">find_root_locality</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx18find_root_localityER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the global id representing the root locality. </p>
<p>The function <em><a class="reference internal" href="#namespacehpx_1a91f701414a6c667c3b58a2e50b93ad0a"><span class="std std-ref">find_root_locality()</span></a></em> can be used to retrieve the global id usable to refer to the root locality. The root locality is the locality where the main AGAS service is hosted.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Generally, the id of a locality can be used for instance to create new instances of components and to invoke plain actions (global functions).</dd>
<dt><strong>Return</strong></dt>
<dd>The global id representing the root locality for this application.</dd>
<dt><strong>Note</strong></dt>
<dd>As long as <em>ec</em> is not pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> this function doesn’t throw but returns the result code using the parameter <em>ec</em>. Otherwise it throws an instance of <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a>.</dd>
<dt><strong>Note</strong></dt>
<dd>This function will return meaningful results only if called from an HPX-thread. It will return <em>hpx::naming::invalid_id</em> otherwise.</dd>
<dt><strong>See</strong></dt>
<dd><em><a class="reference internal" href="#namespacehpx_1ad7e2f65f28022cc809a10034ee8379d2"><span class="std std-ref">hpx::find_all_localities()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1adde1eeefca5bbb4863e54ca81dfb1b6f"><span class="std std-ref">hpx::find_locality()</span></a></em> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx19find_all_localitiesER10error_code">
<span id="_CPPv2N3hpx19find_all_localitiesER10error_code"></span><span id="hpx::find_all_localities__error_codeR"></span><span class="target" id="namespacehpx_1ad7e2f65f28022cc809a10034ee8379d2"></span>std::vector&lt;<a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type&gt; <code class="descname">find_all_localities</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx19find_all_localitiesER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the list of global ids representing all localities available to this application. </p>
<p>The function <em><a class="reference internal" href="#namespacehpx_1ad7e2f65f28022cc809a10034ee8379d2"><span class="std std-ref">find_all_localities()</span></a></em> can be used to retrieve the global ids of all localities currently available to this application.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Generally, the id of a locality can be used for instance to create new instances of components and to invoke plain actions (global functions).</dd>
<dt><strong>Return</strong></dt>
<dd>The global ids representing the localities currently available to this application.</dd>
<dt><strong>Note</strong></dt>
<dd>As long as <em>ec</em> is not pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> this function doesn’t throw but returns the result code using the parameter <em>ec</em>. Otherwise it throws an instance of <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a>.</dd>
<dt><strong>Note</strong></dt>
<dd>This function will return meaningful results only if called from an HPX-thread. It will return an empty vector otherwise.</dd>
<dt><strong>See</strong></dt>
<dd><em><a class="reference internal" href="#namespacehpx_1af07c1b6e26bcdfb1138643a1a2133cf4"><span class="std std-ref">hpx::find_here()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1adde1eeefca5bbb4863e54ca81dfb1b6f"><span class="std std-ref">hpx::find_locality()</span></a></em> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx19find_all_localitiesEN10components14component_typeER10error_code">
<span id="_CPPv2N3hpx19find_all_localitiesEN10components14component_typeER10error_code"></span><span id="hpx::find_all_localities__components::component_type.error_codeR"></span><span class="target" id="namespacehpx_1a0f1424a2b85140c6d6bb4077601760ae"></span>std::vector&lt;<a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type&gt; <code class="descname">find_all_localities</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx10componentsE" title="hpx::components">components</a>::component_type <em>type</em>, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx19find_all_localitiesEN10components14component_typeER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the list of global ids representing all localities available to this application which support the given component type. </p>
<p>The function <em><a class="reference internal" href="#namespacehpx_1ad7e2f65f28022cc809a10034ee8379d2"><span class="std std-ref">find_all_localities()</span></a></em> can be used to retrieve the global ids of all localities currently available to this application which support the creation of instances of the given component type.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Generally, the id of a locality can be used for instance to create new instances of components and to invoke plain actions (global functions).</dd>
<dt><strong>Return</strong></dt>
<dd>The global ids representing the localities currently available to this application which support the creation of instances of the given component type. If no localities supporting the given component type are currently available, this function will return an empty vector.</dd>
<dt><strong>Note</strong></dt>
<dd>As long as <em>ec</em> is not pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> this function doesn’t throw but returns the result code using the parameter <em>ec</em>. Otherwise it throws an instance of <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a>.</dd>
<dt><strong>Note</strong></dt>
<dd>This function will return meaningful results only if called from an HPX-thread. It will return an empty vector otherwise.</dd>
<dt><strong>See</strong></dt>
<dd><em><a class="reference internal" href="#namespacehpx_1af07c1b6e26bcdfb1138643a1a2133cf4"><span class="std std-ref">hpx::find_here()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1adde1eeefca5bbb4863e54ca81dfb1b6f"><span class="std std-ref">hpx::find_locality()</span></a></em> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">type</span></code>: [in] The type of the components for which the function should return the available localities. </li>
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx22find_remote_localitiesER10error_code">
<span id="_CPPv2N3hpx22find_remote_localitiesER10error_code"></span><span id="hpx::find_remote_localities__error_codeR"></span><span class="target" id="namespacehpx_1a9ff320f4efae1cd119f99fb27ddb8393"></span>std::vector&lt;<a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type&gt; <code class="descname">find_remote_localities</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx22find_remote_localitiesER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the list of locality ids of remote localities supporting the given component type. By default this function will return the list of all remote localities (all but the current locality). </p>
<p>The function <em><a class="reference internal" href="#namespacehpx_1a9ff320f4efae1cd119f99fb27ddb8393"><span class="std std-ref">find_remote_localities()</span></a></em> can be used to retrieve the global ids of all remote localities currently available to this application (i.e. all localities except the current one).</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Generally, the id of a locality can be used for instance to create new instances of components and to invoke plain actions (global functions).</dd>
<dt><strong>Return</strong></dt>
<dd>The global ids representing the remote localities currently available to this application.</dd>
<dt><strong>Note</strong></dt>
<dd>As long as <em>ec</em> is not pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> this function doesn’t throw but returns the result code using the parameter <em>ec</em>. Otherwise it throws an instance of <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a>.</dd>
<dt><strong>Note</strong></dt>
<dd>This function will return meaningful results only if called from an HPX-thread. It will return an empty vector otherwise.</dd>
<dt><strong>See</strong></dt>
<dd><em><a class="reference internal" href="#namespacehpx_1af07c1b6e26bcdfb1138643a1a2133cf4"><span class="std std-ref">hpx::find_here()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1adde1eeefca5bbb4863e54ca81dfb1b6f"><span class="std std-ref">hpx::find_locality()</span></a></em> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx22find_remote_localitiesEN10components14component_typeER10error_code">
<span id="_CPPv2N3hpx22find_remote_localitiesEN10components14component_typeER10error_code"></span><span id="hpx::find_remote_localities__components::component_type.error_codeR"></span><span class="target" id="namespacehpx_1a6b6542b41f455b106a8952474a7ff184"></span>std::vector&lt;<a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type&gt; <code class="descname">find_remote_localities</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx10componentsE" title="hpx::components">components</a>::component_type <em>type</em>, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx22find_remote_localitiesEN10components14component_typeER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the list of locality ids of remote localities supporting the given component type. By default this function will return the list of all remote localities (all but the current locality). </p>
<p>The function <em><a class="reference internal" href="#namespacehpx_1a9ff320f4efae1cd119f99fb27ddb8393"><span class="std std-ref">find_remote_localities()</span></a></em> can be used to retrieve the global ids of all remote localities currently available to this application (i.e. all localities except the current one) which support the creation of instances of the given component type.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Generally, the id of a locality can be used for instance to create new instances of components and to invoke plain actions (global functions).</dd>
<dt><strong>Return</strong></dt>
<dd>The global ids representing the remote localities currently available to this application.</dd>
<dt><strong>Note</strong></dt>
<dd>As long as <em>ec</em> is not pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> this function doesn’t throw but returns the result code using the parameter <em>ec</em>. Otherwise it throws an instance of <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a>.</dd>
<dt><strong>Note</strong></dt>
<dd>This function will return meaningful results only if called from an HPX-thread. It will return an empty vector otherwise.</dd>
<dt><strong>See</strong></dt>
<dd><em><a class="reference internal" href="#namespacehpx_1af07c1b6e26bcdfb1138643a1a2133cf4"><span class="std std-ref">hpx::find_here()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1adde1eeefca5bbb4863e54ca81dfb1b6f"><span class="std std-ref">hpx::find_locality()</span></a></em> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">type</span></code>: [in] The type of the components for which the function should return the available remote localities. </li>
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx13find_localityEN10components14component_typeER10error_code">
<span id="_CPPv2N3hpx13find_localityEN10components14component_typeER10error_code"></span><span id="hpx::find_locality__components::component_type.error_codeR"></span><span class="target" id="namespacehpx_1adde1eeefca5bbb4863e54ca81dfb1b6f"></span><a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type <code class="descname">find_locality</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx10componentsE" title="hpx::components">components</a>::component_type <em>type</em>, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx13find_localityEN10components14component_typeER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the global id representing an arbitrary locality which supports the given component type. </p>
<p>The function <em><a class="reference internal" href="#namespacehpx_1adde1eeefca5bbb4863e54ca81dfb1b6f"><span class="std std-ref">find_locality()</span></a></em> can be used to retrieve the global id of an arbitrary locality currently available to this application which supports the creation of instances of the given component type.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Generally, the id of a locality can be used for instance to create new instances of components and to invoke plain actions (global functions).</dd>
<dt><strong>Return</strong></dt>
<dd>The global id representing an arbitrary locality currently available to this application which supports the creation of instances of the given component type. If no locality supporting the given component type is currently available, this function will return <em>hpx::naming::invalid_id</em>.</dd>
<dt><strong>Note</strong></dt>
<dd>As long as <em>ec</em> is not pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> this function doesn’t throw but returns the result code using the parameter <em>ec</em>. Otherwise it throws an instance of <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a>.</dd>
<dt><strong>Note</strong></dt>
<dd>This function will return meaningful results only if called from an HPX-thread. It will return <em>hpx::naming::invalid_id</em> otherwise.</dd>
<dt><strong>See</strong></dt>
<dd><em><a class="reference internal" href="#namespacehpx_1af07c1b6e26bcdfb1138643a1a2133cf4"><span class="std std-ref">hpx::find_here()</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1ad7e2f65f28022cc809a10034ee8379d2"><span class="std std-ref">hpx::find_all_localities()</span></a></em> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">type</span></code>: [in] The type of the components for which the function should return any available locality. </li>
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx17get_colocation_idEN6launch11sync_policyERN6naming7id_typeER10error_code">
<span id="_CPPv2N3hpx17get_colocation_idEN6launch11sync_policyERN6naming7id_typeER10error_code"></span><span id="hpx::get_colocation_id__launch::sync_policy.naming::id_typeCR.error_codeR"></span><span class="target" id="namespacehpx_1ad71888005ccae819b23eb88e8c4683be"></span><a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type <code class="descname">get_colocation_id</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx6launchE" title="hpx::launch">launch</a>::sync_policy, <a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type <em class="property">const</em> &amp;<em>id</em>, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx17get_colocation_idEN6launch11sync_policyERN6naming7id_typeER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the id of the locality where the object referenced by the given id is currently located on. </p>
<p>The function <a class="reference internal" href="#namespacehpx_1ad71888005ccae819b23eb88e8c4683be"><span class="std std-ref">hpx::get_colocation_id()</span></a> returns the id of the locality where the given object is currently located.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>As long as <em>ec</em> is not pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> this function doesn’t throw but returns the result code using the parameter <em>ec</em>. Otherwise it throws an instance of <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a>.</dd>
<dt><strong>See</strong></dt>
<dd><em><a class="reference internal" href="#namespacehpx_1ad71888005ccae819b23eb88e8c4683be"><span class="std std-ref">hpx::get_colocation_id()</span></a></em> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">id</span></code>: [in] The id of the object to locate. </li>
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx17get_colocation_idERN6naming7id_typeE">
<span id="_CPPv2N3hpx17get_colocation_idERN6naming7id_typeE"></span><span id="hpx::get_colocation_id__naming::id_typeCR"></span><span class="target" id="namespacehpx_1a10d1ac7350bf764e61602797b10d2f2c"></span><a class="reference internal" href="#_CPPv3N3hpx4lcosE" title="hpx::lcos">lcos</a>::future&lt;<a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type&gt; <code class="descname">get_colocation_id</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type <em class="property">const</em> &amp;<em>id</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx17get_colocation_idERN6naming7id_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Asynchronously return the id of the locality where the object referenced by the given id is currently located on. </p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd><em>hpx::get_colocation_id(launch::sync_policy)</em> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">id</span></code>: [in] The id of the object to locate.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7get_ptrERN6naming7id_typeE">
<span id="_CPPv2N3hpx7get_ptrERN6naming7id_typeE"></span><span id="hpx::get_ptr__naming::id_typeCR"></span><em class="property">template </em>&lt;<em class="property">typename</em> Component&gt;<br /><span class="target" id="namespacehpx_1aeb814737de830a2e8e340ca052d5ebfa"></span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::future&lt;std::shared_ptr&lt;Component&gt;&gt; <code class="descname">get_ptr</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type <em class="property">const</em> &amp;<em>id</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx7get_ptrERN6naming7id_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns a future referring to the pointer to the underlying memory of a component. </p>
<p>The function <a class="reference internal" href="#namespacehpx_1aeb814737de830a2e8e340ca052d5ebfa"><span class="std std-ref">hpx::get_ptr</span></a> can be used to extract a future referring to the pointer to the underlying memory of a given component.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>This function returns a future representing the pointer to the underlying memory for the component instance with the given <em>id</em>.</dd>
<dt><strong>Note</strong></dt>
<dd>This function will successfully return the requested result only if the given component is currently located on the calling locality. Otherwise the function will raise an error.</dd>
<dt><strong>Note</strong></dt>
<dd>The component instance the returned pointer refers to can not be migrated as long as there is at least one copy of the returned shared_ptr alive. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">id</span></code>: [in] The global id of the component for which the pointer to the underlying memory should be retrieved.</li>
</ul>
</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">The</span></code>: only template parameter has to be the type of the server side component.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7get_ptrERN10components11client_baseI7Derived4StubEE">
<span id="_CPPv2N3hpx7get_ptrERN10components11client_baseI7Derived4StubEE"></span><span id="hpx::get_ptr__components::client_base:Derived.Stub:CR"></span><em class="property">template </em>&lt;<em class="property">typename</em> Derived, <em class="property">typename</em> Stub&gt;<br /><span class="target" id="namespacehpx_1a488c36e8791a0f000ffce5ce86994602"></span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::future&lt;std::shared_ptr&lt;<em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx10componentsE" title="hpx::components">components</a>::client_base&lt;Derived, Stub&gt;::server_component_type&gt;&gt; <code class="descname">get_ptr</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx10componentsE" title="hpx::components">components</a>::client_base&lt;Derived, Stub&gt; <em class="property">const</em> &amp;<em>c</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx7get_ptrERN10components11client_baseI7Derived4StubEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns a future referring to the pointer to the underlying memory of a component. </p>
<p>The function <a class="reference internal" href="#namespacehpx_1aeb814737de830a2e8e340ca052d5ebfa"><span class="std std-ref">hpx::get_ptr</span></a> can be used to extract a future referring to the pointer to the underlying memory of a given component.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>This function returns a future representing the pointer to the underlying memory for the component instance with the given <em>id</em>.</dd>
<dt><strong>Note</strong></dt>
<dd>This function will successfully return the requested result only if the given component is currently located on the calling locality. Otherwise the function will raise an error.</dd>
<dt><strong>Note</strong></dt>
<dd>The component instance the returned pointer refers to can not be migrated as long as there is at least one copy of the returned shared_ptr alive. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">c</span></code>: [in] A client side representation of the component for which the pointer to the underlying memory should be retrieved.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7get_ptrEN6launch11sync_policyERN6naming7id_typeER10error_code">
<span id="_CPPv2N3hpx7get_ptrEN6launch11sync_policyERN6naming7id_typeER10error_code"></span><span id="hpx::get_ptr__launch::sync_policy.naming::id_typeCR.error_codeR"></span><em class="property">template </em>&lt;<em class="property">typename</em> Component&gt;<br /><span class="target" id="namespacehpx_1a9c602f1678bb64941918a86a6d509fb8"></span>std::shared_ptr&lt;Component&gt; <code class="descname">get_ptr</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx6launchE" title="hpx::launch">launch</a>::sync_policy <em>p</em>, <a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type <em class="property">const</em> &amp;<em>id</em>, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx7get_ptrEN6launch11sync_policyERN6naming7id_typeER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the pointer to the underlying memory of a component. </p>
<p>The function hpx::get_ptr_sync can be used to extract the pointer to the underlying memory of a given component.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>This function returns the pointer to the underlying memory for the component instance with the given <em>id</em>.</dd>
<dt><strong>Note</strong></dt>
<dd>This function will successfully return the requested result only if the given component is currently located on the requesting locality. Otherwise the function will raise and error.</dd>
<dt><strong>Note</strong></dt>
<dd>The component instance the returned pointer refers to can not be migrated as long as there is at least one copy of the returned shared_ptr alive.</dd>
<dt><strong>Note</strong></dt>
<dd>As long as <em>ec</em> is not pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> this function doesn’t throw but returns the result code using the parameter <em>ec</em>. Otherwise it throws an instance of <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">p</span></code>: [in] The parameter <em>p</em> represents a placeholder type to turn make the call synchronous. </li>
<li><code class="docutils literal notranslate"><span class="pre">id</span></code>: [in] The global id of the component for which the pointer to the underlying memory should be retrieved. </li>
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">The</span></code>: only template parameter has to be the type of the server side component.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7get_ptrEN6launch11sync_policyERN10components11client_baseI7Derived4StubEER10error_code">
<span id="_CPPv2N3hpx7get_ptrEN6launch11sync_policyERN10components11client_baseI7Derived4StubEER10error_code"></span><span id="hpx::get_ptr__launch::sync_policy.components::client_base:Derived.Stub:CR.error_codeR"></span><em class="property">template </em>&lt;<em class="property">typename</em> Derived, <em class="property">typename</em> Stub&gt;<br /><span class="target" id="namespacehpx_1afac2da8aef3362960bf207c5ad5ac2cd"></span>std::shared_ptr&lt;<em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx10componentsE" title="hpx::components">components</a>::client_base&lt;Derived, Stub&gt;::server_component_type&gt; <code class="descname">get_ptr</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx6launchE" title="hpx::launch">launch</a>::sync_policy <em>p</em>, <a class="reference internal" href="#_CPPv3N3hpx10componentsE" title="hpx::components">components</a>::client_base&lt;Derived, Stub&gt; <em class="property">const</em> &amp;<em>c</em>, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx7get_ptrEN6launch11sync_policyERN10components11client_baseI7Derived4StubEER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the pointer to the underlying memory of a component. </p>
<p>The function hpx::get_ptr_sync can be used to extract the pointer to the underlying memory of a given component.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>This function returns the pointer to the underlying memory for the component instance with the given <em>id</em>.</dd>
<dt><strong>Note</strong></dt>
<dd>This function will successfully return the requested result only if the given component is currently located on the requesting locality. Otherwise the function will raise and error.</dd>
<dt><strong>Note</strong></dt>
<dd>The component instance the returned pointer refers to can not be migrated as long as there is at least one copy of the returned shared_ptr alive.</dd>
<dt><strong>Note</strong></dt>
<dd>As long as <em>ec</em> is not pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> this function doesn’t throw but returns the result code using the parameter <em>ec</em>. Otherwise it throws an instance of <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">p</span></code>: [in] The parameter <em>p</em> represents a placeholder type to turn make the call synchronous. </li>
<li><code class="docutils literal notranslate"><span class="pre">c</span></code>: [in] A client side representation of the component for which the pointer to the underlying memory should be retrieved. </li>
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx15get_locality_idER10error_code">
<span id="_CPPv2N3hpx15get_locality_idER10error_code"></span><span id="hpx::get_locality_id__error_codeR"></span><span class="target" id="namespacehpx_1a158d7c54a657bb364c1704033010697b"></span>std::uint32_t <code class="descname">get_locality_id</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx15get_locality_idER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the number of the locality this function is being called from. </p>
<p>This function returns the id of the current locality.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The returned value is zero based and its maximum value is smaller than the overall number of localities the current application is running on (as returned by <em><a class="reference internal" href="#namespacehpx_1a4dd860f6c435319c019eed326455f646"><span class="std std-ref">get_num_localities()</span></a></em>).</dd>
<dt><strong>Note</strong></dt>
<dd>As long as <em>ec</em> is not pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> this function doesn’t throw but returns the result code using the parameter <em>ec</em>. Otherwise it throws an instance of <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a>.</dd>
<dt><strong>Note</strong></dt>
<dd>This function needs to be executed on a HPX-thread. It will fail otherwise (it will return -1). </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx17get_locality_nameEv">
<span id="_CPPv2N3hpx17get_locality_nameEv"></span><span id="hpx::get_locality_name"></span><span class="target" id="namespacehpx_1af59b323d00d708f6f9faed64817f15f6"></span>std::string <code class="descname">get_locality_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx17get_locality_nameEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the name of the locality this function is called on. </p>
<p>This function returns the name for the locality on which this function is called.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>This function returns the name for the locality on which the function is called. The name is retrieved from the underlying networking layer and may be different for different parcelports.</dd>
<dt><strong>See</strong></dt>
<dd><em>future&lt;std::string&gt;</em> <a class="reference internal" href="#namespacehpx_1af9a88c1545670a4cbde4e2f3320666d5"><span class="std std-ref">get_locality_name(naming::id_type const&amp; id)</span></a> </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx17get_locality_nameERN6naming7id_typeE">
<span id="_CPPv2N3hpx17get_locality_nameERN6naming7id_typeE"></span><span id="hpx::get_locality_name__naming::id_typeCR"></span><span class="target" id="namespacehpx_1af9a88c1545670a4cbde4e2f3320666d5"></span>future&lt;std::string&gt; <code class="descname">get_locality_name</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type <em class="property">const</em> &amp;<em>id</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx17get_locality_nameERN6naming7id_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the name of the referenced locality. </p>
<p>This function returns a future referring to the name for the locality of the given id.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>This function returns the name for the locality of the given id. The name is retrieved from the underlying networking layer and may be different for different parcel ports.</dd>
<dt><strong>See</strong></dt>
<dd><em>std::string</em> <a class="reference internal" href="#namespacehpx_1af59b323d00d708f6f9faed64817f15f6"><span class="std std-ref">get_locality_name()</span></a> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">id</span></code>: [in] The global id of the locality for which the name should be retrieved</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx26get_initial_num_localitiesEv">
<span id="_CPPv2N3hpx26get_initial_num_localitiesEv"></span><span id="hpx::get_initial_num_localities"></span><span class="target" id="namespacehpx_1a68d4aa44bb8e58c6b0a6aff2920fdd8d"></span>std::uint32_t <code class="descname">get_initial_num_localities</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx26get_initial_num_localitiesEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the number of localities which were registered at startup for the running application. </p>
<p>The function <em>get_initial_num_localities</em> returns the number of localities which were connected to the console at application startup.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>As long as <em>ec</em> is not pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> this function doesn’t throw but returns the result code using the parameter <em>ec</em>. Otherwise it throws an instance of <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a>.</dd>
<dt><strong>See</strong></dt>
<dd><em><a class="reference internal" href="#namespacehpx_1ad7e2f65f28022cc809a10034ee8379d2"><span class="std std-ref">hpx::find_all_localities</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a4dd860f6c435319c019eed326455f646"><span class="std std-ref">hpx::get_num_localities</span></a></em> </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx18get_num_localitiesEv">
<span id="_CPPv2N3hpx18get_num_localitiesEv"></span><span id="hpx::get_num_localities"></span><span class="target" id="namespacehpx_1a4dd860f6c435319c019eed326455f646"></span><a class="reference internal" href="#_CPPv3N3hpx4lcosE" title="hpx::lcos">lcos</a>::future&lt;std::uint32_t&gt; <code class="descname">get_num_localities</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx18get_num_localitiesEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Asynchronously return the number of localities which are currently registered for the running application. </p>
<p>The function <em>get_num_localities</em> asynchronously returns the number of localities currently connected to the console. The returned future represents the actual result.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function will return meaningful results only if called from an HPX-thread. It will return 0 otherwise.</dd>
<dt><strong>See</strong></dt>
<dd><em><a class="reference internal" href="#namespacehpx_1ad7e2f65f28022cc809a10034ee8379d2"><span class="std std-ref">hpx::find_all_localities</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a4dd860f6c435319c019eed326455f646"><span class="std std-ref">hpx::get_num_localities</span></a></em> </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx18get_num_localitiesEN6launch11sync_policyER10error_code">
<span id="_CPPv2N3hpx18get_num_localitiesEN6launch11sync_policyER10error_code"></span><span id="hpx::get_num_localities__launch::sync_policy.error_codeR"></span><span class="target" id="namespacehpx_1acc87bce31e8a2758be4aef89def33204"></span>std::uint32_t <code class="descname">get_num_localities</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx6launchE" title="hpx::launch">launch</a>::sync_policy, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx18get_num_localitiesEN6launch11sync_policyER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the number of localities which are currently registered for the running application. </p>
<p>The function <em>get_num_localities</em> returns the number of localities currently connected to the console.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function will return meaningful results only if called from an HPX-thread. It will return 0 otherwise.</dd>
<dt><strong>Note</strong></dt>
<dd>As long as <em>ec</em> is not pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> this function doesn’t throw but returns the result code using the parameter <em>ec</em>. Otherwise it throws an instance of <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a>.</dd>
<dt><strong>See</strong></dt>
<dd><em><a class="reference internal" href="#namespacehpx_1ad7e2f65f28022cc809a10034ee8379d2"><span class="std std-ref">hpx::find_all_localities</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a4dd860f6c435319c019eed326455f646"><span class="std std-ref">hpx::get_num_localities</span></a></em> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx18get_num_localitiesEN10components14component_typeE">
<span id="_CPPv2N3hpx18get_num_localitiesEN10components14component_typeE"></span><span id="hpx::get_num_localities__components::component_type"></span><span class="target" id="namespacehpx_1ad87429472cce631ff4aa3b9538850cc8"></span><a class="reference internal" href="#_CPPv3N3hpx4lcosE" title="hpx::lcos">lcos</a>::future&lt;std::uint32_t&gt; <code class="descname">get_num_localities</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx10componentsE" title="hpx::components">components</a>::component_type <em>t</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx18get_num_localitiesEN10components14component_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Asynchronously return the number of localities which are currently registered for the running application. </p>
<p>The function <em>get_num_localities</em> asynchronously returns the number of localities currently connected to the console which support the creation of the given component type. The returned future represents the actual result.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function will return meaningful results only if called from an HPX-thread. It will return 0 otherwise.</dd>
<dt><strong>See</strong></dt>
<dd><em><a class="reference internal" href="#namespacehpx_1ad7e2f65f28022cc809a10034ee8379d2"><span class="std std-ref">hpx::find_all_localities</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a4dd860f6c435319c019eed326455f646"><span class="std std-ref">hpx::get_num_localities</span></a></em> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">t</span></code>: The component type for which the number of connected localities should be retrieved.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx18get_num_localitiesEN6launch11sync_policyEN10components14component_typeER10error_code">
<span id="_CPPv2N3hpx18get_num_localitiesEN6launch11sync_policyEN10components14component_typeER10error_code"></span><span id="hpx::get_num_localities__launch::sync_policy.components::component_type.error_codeR"></span><span class="target" id="namespacehpx_1ae3d554fde53654e1812e72cec6198bd5"></span>std::uint32_t <code class="descname">get_num_localities</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx6launchE" title="hpx::launch">launch</a>::sync_policy, <a class="reference internal" href="#_CPPv3N3hpx10componentsE" title="hpx::components">components</a>::component_type <em>t</em>, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx18get_num_localitiesEN6launch11sync_policyEN10components14component_typeER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Synchronously return the number of localities which are currently registered for the running application. </p>
<p>The function <em>get_num_localities</em> returns the number of localities currently connected to the console which support the creation of the given component type. The returned future represents the actual result.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function will return meaningful results only if called from an HPX-thread. It will return 0 otherwise.</dd>
<dt><strong>See</strong></dt>
<dd><em><a class="reference internal" href="#namespacehpx_1ad7e2f65f28022cc809a10034ee8379d2"><span class="std std-ref">hpx::find_all_localities</span></a></em>, <em><a class="reference internal" href="#namespacehpx_1a4dd860f6c435319c019eed326455f646"><span class="std std-ref">hpx::get_num_localities</span></a></em> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">t</span></code>: The component type for which the number of connected localities should be retrieved. </li>
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx19get_os_thread_countEv">
<span id="_CPPv2N3hpx19get_os_thread_countEv"></span><span id="hpx::get_os_thread_count"></span><span class="target" id="namespacehpx_1a7899ab2136e9b3ba674caf70aa659a59"></span>std::size_t <code class="descname">get_os_thread_count</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx19get_os_thread_countEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the number of OS-threads running in the runtime instance the current HPX-thread is associated with. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx19get_os_thread_countERN7threads8executorE">
<span id="_CPPv2N3hpx19get_os_thread_countERN7threads8executorE"></span><span id="hpx::get_os_thread_count__threads::executorCR"></span><span class="target" id="namespacehpx_1adcb3c8ac96fa1583317926a64a1abd3a"></span>std::size_t <code class="descname">get_os_thread_count</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx7threadsE" title="hpx::threads">threads</a>::executor <em class="property">const</em> &amp;<em>exec</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx19get_os_thread_countERN7threads8executorE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the number of worker OS- threads used by the given executor to execute HPX threads. </p>
<p>This function returns the number of cores used to execute HPX threads for the given executor. If the function is called while no HPX runtime system is active, it will return zero. If the executor is not valid, this function will fall back to retrieving the number of OS threads used by HPX.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">exec</span></code>: [in] The executor to be used. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx15get_thread_nameEv">
<span id="_CPPv2N3hpx15get_thread_nameEv"></span><span id="hpx::get_thread_name"></span><span class="target" id="namespacehpx_1aaa2a7b43b2655775e3811d5a3f9c0f5e"></span>std::string <code class="descname">get_thread_name</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx15get_thread_nameEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the name of the calling thread. </p>
<p>This function returns the name of the calling thread. This name uniquely identifies the thread in the context of HPX. If the function is called while no HPX runtime system is active, the result will be “&lt;unknown&gt;”. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx21get_worker_thread_numEv">
<span id="_CPPv2N3hpx21get_worker_thread_numEv"></span><span id="hpx::get_worker_thread_num"></span><span class="target" id="namespacehpx_1ad438935ca2f8603f9cab036b68b34f36"></span>std::size_t <code class="descname">get_worker_thread_num</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx21get_worker_thread_numEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the number of the current OS-thread running in the runtime instance the current HPX-thread is executed with. </p>
<p>This function returns the zero based index of the OS-thread which executes the current HPX-thread.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The returned value is zero based and its maximum value is smaller than the overall number of OS-threads executed (as returned by <em><a class="reference internal" href="#namespacehpx_1a7899ab2136e9b3ba674caf70aa659a59"><span class="std std-ref">get_os_thread_count()</span></a></em>.</dd>
<dt><strong>Note</strong></dt>
<dd>This function needs to be executed on a HPX-thread. It will fail otherwise (it will return -1). </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx21get_worker_thread_numER10error_code">
<span id="_CPPv2N3hpx21get_worker_thread_numER10error_code"></span><span id="hpx::get_worker_thread_num__error_codeR"></span><span class="target" id="namespacehpx_1adc17eda7c3c7c6b2a0f7cb1affed8520"></span>std::size_t <code class="descname">get_worker_thread_num</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx21get_worker_thread_numER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return the number of the current OS-thread running in the runtime instance the current HPX-thread is executed with. </p>
<p>This function returns the zero based index of the OS-thread which executes the current HPX-thread.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The returned value is zero based and its maximum value is smaller than the overall number of OS-threads executed (as returned by <em><a class="reference internal" href="#namespacehpx_1a7899ab2136e9b3ba674caf70aa659a59"><span class="std std-ref">get_os_thread_count()</span></a></em>. It will return -1 if the current thread is not a known thread or if the runtime is not in running state.</dd>
<dt><strong>Note</strong></dt>
<dd>This function needs to be executed on a HPX-thread. It will fail otherwise (it will return -1). </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx12report_errorENSt6size_tERNSt13exception_ptrE">
<span id="_CPPv2N3hpx12report_errorENSt6size_tERNSt13exception_ptrE"></span><span id="hpx::report_error__std::s.std::exception_ptrCR"></span><span class="target" id="namespacehpx_1ad3a47f9cb15f1800be181e4f249a0ede"></span>void <code class="descname">report_error</code><span class="sig-paren">(</span>std::size_t <em>num_thread</em>, std::exception_ptr <em class="property">const</em> &amp;<em>e</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx12report_errorENSt6size_tERNSt13exception_ptrE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function report_error reports the given exception to the console. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx12report_errorERNSt13exception_ptrE">
<span id="_CPPv2N3hpx12report_errorERNSt13exception_ptrE"></span><span id="hpx::report_error__std::exception_ptrCR"></span><span class="target" id="namespacehpx_1a7eee13362368297121876ddbed28afb8"></span>void <code class="descname">report_error</code><span class="sig-paren">(</span>std::exception_ptr <em class="property">const</em> &amp;<em>e</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx12report_errorERNSt13exception_ptrE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function report_error reports the given exception to the console. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx21get_runtime_mode_nameE12runtime_mode">
<span id="_CPPv2N3hpx21get_runtime_mode_nameE12runtime_mode"></span><span id="hpx::get_runtime_mode_name__runtime_mode"></span><span class="target" id="namespacehpx_1a5142a5307ed300520b3bb1d6e57bd82b"></span>char <em class="property">const</em> *<code class="descname">get_runtime_mode_name</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx12runtime_modeE" title="hpx::runtime_mode">runtime_mode</a> <em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx21get_runtime_mode_nameE12runtime_mode" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the readable string representing the name of the given runtime_mode constant. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx26get_runtime_mode_from_nameERNSt6stringE">
<span id="_CPPv2N3hpx26get_runtime_mode_from_nameERNSt6stringE"></span><span id="hpx::get_runtime_mode_from_name__ssCR"></span><span class="target" id="namespacehpx_1a11d80cdb93e72f01fcace23152950bf8"></span><a class="reference internal" href="#_CPPv3N3hpx12runtime_modeE" title="hpx::runtime_mode">runtime_mode</a> <code class="descname">get_runtime_mode_from_name</code><span class="sig-paren">(</span>std::string <em class="property">const</em> &amp;<em>mode</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx26get_runtime_mode_from_nameERNSt6stringE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the internal representation (runtime_mode constant) from the readable string representing the name. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx24set_parcel_write_handlerER25parcel_write_handler_type">
<span id="_CPPv2N3hpx24set_parcel_write_handlerER25parcel_write_handler_type"></span><span id="hpx::set_parcel_write_handler__parcel_write_handler_typeCR"></span><span class="target" id="namespacehpx_1aeb594d703895a387b89e4fba621b13f4"></span><a class="reference internal" href="#_CPPv3N3hpx25parcel_write_handler_typeE" title="hpx::parcel_write_handler_type">parcel_write_handler_type</a> <code class="descname">set_parcel_write_handler</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx25parcel_write_handler_typeE" title="hpx::parcel_write_handler_type">parcel_write_handler_type</a> <em class="property">const</em> &amp;<em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx24set_parcel_write_handlerER25parcel_write_handler_type" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the default parcel write handler which is invoked once a parcel has been sent if no explicit write handler was specified.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The function returns the parcel write handler which was installed before this function was called.</dd>
<dt><strong>Note</strong></dt>
<dd>If no parcel handler function is registered by the user the system will call a default parcel handler function which is not performing any actions. However, this default function will terminate the application in case of any errors detected during preparing or sending the parcel. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: The new parcel write handler to use from this point on</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx30register_pre_shutdown_functionE22shutdown_function_type">
<span id="_CPPv2N3hpx30register_pre_shutdown_functionE22shutdown_function_type"></span><span id="hpx::register_pre_shutdown_function__shutdown_function_type"></span><span class="target" id="namespacehpx_1af9d4996bd26c9518cad472ae5da0e52b"></span>void <code class="descname">register_pre_shutdown_function</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx22shutdown_function_typeE" title="hpx::shutdown_function_type">shutdown_function_type</a> <em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx30register_pre_shutdown_functionE22shutdown_function_type" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Add a function to be executed by a HPX thread during <em><a class="reference internal" href="#namespacehpx_1ab7eb159cb77997b366b5d79e65f04cd0"><span class="std std-ref">hpx::finalize()</span></a></em> but guaranteed before any shutdown function is executed (system-wide) </p>
<p>Any of the functions registered with <em>register_pre_shutdown_function</em> are guaranteed to be executed by an HPX thread during the execution of <em><a class="reference internal" href="#namespacehpx_1ab7eb159cb77997b366b5d79e65f04cd0"><span class="std std-ref">hpx::finalize()</span></a></em> before any of the registered shutdown functions are executed (see: <em><a class="reference internal" href="#namespacehpx_1af2378fac549f2d83f691f5990fcd3453"><span class="std std-ref">hpx::register_shutdown_function()</span></a></em>).</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>If this function is called while the pre-shutdown functions are being executed, or after that point, it will raise a invalid_status exception.</dd>
<dt><strong>See</strong></dt>
<dd><em><a class="reference internal" href="#namespacehpx_1af2378fac549f2d83f691f5990fcd3453"><span class="std std-ref">hpx::register_shutdown_function()</span></a></em> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: [in] The function to be registered to run by an HPX thread as a pre-shutdown function.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx26register_shutdown_functionE22shutdown_function_type">
<span id="_CPPv2N3hpx26register_shutdown_functionE22shutdown_function_type"></span><span id="hpx::register_shutdown_function__shutdown_function_type"></span><span class="target" id="namespacehpx_1af2378fac549f2d83f691f5990fcd3453"></span>void <code class="descname">register_shutdown_function</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx22shutdown_function_typeE" title="hpx::shutdown_function_type">shutdown_function_type</a> <em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx26register_shutdown_functionE22shutdown_function_type" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Add a function to be executed by a HPX thread during <em><a class="reference internal" href="#namespacehpx_1ab7eb159cb77997b366b5d79e65f04cd0"><span class="std std-ref">hpx::finalize()</span></a></em> but guaranteed after any pre-shutdown function is executed (system-wide) </p>
<p>Any of the functions registered with <em>register_shutdown_function</em> are guaranteed to be executed by an HPX thread during the execution of <em><a class="reference internal" href="#namespacehpx_1ab7eb159cb77997b366b5d79e65f04cd0"><span class="std std-ref">hpx::finalize()</span></a></em> after any of the registered pre-shutdown functions are executed (see: <em><a class="reference internal" href="#namespacehpx_1af9d4996bd26c9518cad472ae5da0e52b"><span class="std std-ref">hpx::register_pre_shutdown_function()</span></a></em>).</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>If this function is called while the shutdown functions are being executed, or after that point, it will raise a invalid_status exception.</dd>
<dt><strong>See</strong></dt>
<dd><em><a class="reference internal" href="#namespacehpx_1af9d4996bd26c9518cad472ae5da0e52b"><span class="std std-ref">hpx::register_pre_shutdown_function()</span></a></em> </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: [in] The function to be registered to run by an HPX thread as a shutdown function.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx29register_pre_startup_functionE21startup_function_type">
<span id="_CPPv2N3hpx29register_pre_startup_functionE21startup_function_type"></span><span id="hpx::register_pre_startup_function__startup_function_type"></span><span class="target" id="namespacehpx_1af4a89a9a8c4f3d8d4d256fcf5a9093fc"></span>void <code class="descname">register_pre_startup_function</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx21startup_function_typeE" title="hpx::startup_function_type">startup_function_type</a> <em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx29register_pre_startup_functionE21startup_function_type" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Add a function to be executed by a HPX thread before hpx_main but guaranteed before any startup function is executed (system-wide). </p>
<p>Any of the functions registered with <em>register_pre_startup_function</em> are guaranteed to be executed by an HPX thread before any of the registered startup functions are executed (see <em><a class="reference internal" href="#namespacehpx_1a606821ec55263e6dc0905e8ac9c47e7e"><span class="std std-ref">hpx::register_startup_function()</span></a></em>).</p>
<p><p>This function is one of the few API functions which can be called before the runtime system has been fully initialized. It will automatically stage the provided startup function to the runtime system during its initialization (if necessary).</p>
<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>If this function is called while the pre-startup functions are being executed or after that point, it will raise a invalid_status exception.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: [in] The function to be registered to run by an HPX thread as a pre-startup function.</li>
</ul>
</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd><em><a class="reference internal" href="#namespacehpx_1a606821ec55263e6dc0905e8ac9c47e7e"><span class="std std-ref">hpx::register_startup_function()</span></a></em> </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx25register_startup_functionE21startup_function_type">
<span id="_CPPv2N3hpx25register_startup_functionE21startup_function_type"></span><span id="hpx::register_startup_function__startup_function_type"></span><span class="target" id="namespacehpx_1a606821ec55263e6dc0905e8ac9c47e7e"></span>void <code class="descname">register_startup_function</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx21startup_function_typeE" title="hpx::startup_function_type">startup_function_type</a> <em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx25register_startup_functionE21startup_function_type" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Add a function to be executed by a HPX thread before hpx_main but guaranteed after any pre-startup function is executed (system-wide). </p>
<p>Any of the functions registered with <em>register_startup_function</em> are guaranteed to be executed by an HPX thread after any of the registered pre-startup functions are executed (see: <em><a class="reference internal" href="#namespacehpx_1af4a89a9a8c4f3d8d4d256fcf5a9093fc"><span class="std std-ref">hpx::register_pre_startup_function()</span></a></em>), but before <em>hpx_main</em> is being called.</p>
<p><p>This function is one of the few API functions which can be called before the runtime system has been fully initialized. It will automatically stage the provided startup function to the runtime system during its initialization (if necessary).</p>
<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>If this function is called while the startup functions are being executed or after that point, it will raise a invalid_status exception.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: [in] The function to be registered to run by an HPX thread as a startup function.</li>
</ul>
</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>See</strong></dt>
<dd><em><a class="reference internal" href="#namespacehpx_1af4a89a9a8c4f3d8d4d256fcf5a9093fc"><span class="std std-ref">hpx::register_pre_startup_function()</span></a></em> </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx17trigger_lco_eventERN6naming7id_typeERRN6naming7addressEb">
<span id="_CPPv2N3hpx17trigger_lco_eventERN6naming7id_typeERRN6naming7addressEb"></span><span id="hpx::trigger_lco_event__naming::id_typeCR.naming::addressRR.b"></span><span class="target" id="namespacehpx_1a490eaa9c98d00ed130f79ceb3752aa70"></span>void <code class="descname">trigger_lco_event</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type <em class="property">const</em> &amp;<em>id</em>, <a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::address &amp;&amp;<em>addr</em>, bool <em>move_credits</em> = true<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx17trigger_lco_eventERN6naming7id_typeERRN6naming7addressEb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Trigger the LCO referenced by the given id. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">id</span></code>: [in] This represents the id of the LCO which should be triggered. </li>
<li><code class="docutils literal notranslate"><span class="pre">addr</span></code>: [in] This represents the addr of the LCO which should be triggered. </li>
<li><code class="docutils literal notranslate"><span class="pre">move_credits</span></code>: [in] If this is set to <em>true</em> then it is ok to send all credits in <em>id</em> along with the generated message. The default value is <em>true</em>. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx17trigger_lco_eventERN6naming7id_typeEb">
<span id="_CPPv2N3hpx17trigger_lco_eventERN6naming7id_typeEb"></span><span id="hpx::trigger_lco_event__naming::id_typeCR.b"></span><span class="target" id="namespacehpx_1aee5263bb66115a5b7a4fc3e0a9ebfe05"></span>void <code class="descname">trigger_lco_event</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type <em class="property">const</em> &amp;<em>id</em>, bool <em>move_credits</em> = true<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx17trigger_lco_eventERN6naming7id_typeEb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Trigger the LCO referenced by the given id. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">id</span></code>: [in] This represents the id of the LCO which should be triggered. </li>
<li><code class="docutils literal notranslate"><span class="pre">move_credits</span></code>: [in] If this is set to <em>true</em> then it is ok to send all credits in <em>id</em> along with the generated message. The default value is <em>true</em>. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx17trigger_lco_eventERN6naming7id_typeERRN6naming7addressERN6naming7id_typeEb">
<span id="_CPPv2N3hpx17trigger_lco_eventERN6naming7id_typeERRN6naming7addressERN6naming7id_typeEb"></span><span id="hpx::trigger_lco_event__naming::id_typeCR.naming::addressRR.naming::id_typeCR.b"></span><span class="target" id="namespacehpx_1ac077308029ea3e2b7d240123fdbf3c2b"></span>void <code class="descname">trigger_lco_event</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type <em class="property">const</em> &amp;<em>id</em>, <a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::address &amp;&amp;<em>addr</em>, <a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type <em class="property">const</em> &amp;<em>cont</em>, bool <em>move_credits</em> = true<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx17trigger_lco_eventERN6naming7id_typeERRN6naming7addressERN6naming7id_typeEb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Trigger the LCO referenced by the given id. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">id</span></code>: [in] This represents the id of the LCO which should be triggered. </li>
<li><code class="docutils literal notranslate"><span class="pre">addr</span></code>: [in] This represents the addr of the LCO which should be triggered. </li>
<li><code class="docutils literal notranslate"><span class="pre">cont</span></code>: [in] This represents the LCO to trigger after completion. </li>
<li><code class="docutils literal notranslate"><span class="pre">move_credits</span></code>: [in] If this is set to <em>true</em> then it is ok to send all credits in <em>id</em> along with the generated message. The default value is <em>true</em>. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx17trigger_lco_eventERN6naming7id_typeERN6naming7id_typeEb">
<span id="_CPPv2N3hpx17trigger_lco_eventERN6naming7id_typeERN6naming7id_typeEb"></span><span id="hpx::trigger_lco_event__naming::id_typeCR.naming::id_typeCR.b"></span><span class="target" id="namespacehpx_1a40c094e74b6dafbda7384b5abaa87608"></span>void <code class="descname">trigger_lco_event</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type <em class="property">const</em> &amp;<em>id</em>, <a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type <em class="property">const</em> &amp;<em>cont</em>, bool <em>move_credits</em> = true<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx17trigger_lco_eventERN6naming7id_typeERN6naming7id_typeEb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Trigger the LCO referenced by the given id. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">id</span></code>: [in] This represents the id of the LCO which should be triggered. </li>
<li><code class="docutils literal notranslate"><span class="pre">cont</span></code>: [in] This represents the LCO to trigger after completion. </li>
<li><code class="docutils literal notranslate"><span class="pre">move_credits</span></code>: [in] If this is set to <em>true</em> then it is ok to send all credits in <em>id</em> along with the generated message. The default value is <em>true</em>. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx13set_lco_valueERN6naming7id_typeERRN6naming7addressERR6Resultb">
<span id="_CPPv2N3hpx13set_lco_valueERN6naming7id_typeERRN6naming7addressERR6Resultb"></span><span id="hpx::set_lco_value__naming::id_typeCR.naming::addressRR.ResultRR.b"></span><em class="property">template </em>&lt;<em class="property">typename</em> Result&gt;<br /><span class="target" id="namespacehpx_1ac39c86d0a66ad9dba32b6206499dd80f"></span>void <code class="descname">set_lco_value</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type <em class="property">const</em> &amp;<em>id</em>, <a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::address &amp;&amp;<em>addr</em>, Result &amp;&amp;<em>t</em>, bool <em>move_credits</em> = true<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx13set_lco_valueERN6naming7id_typeERRN6naming7addressERR6Resultb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the result value for the LCO referenced by the given id. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">id</span></code>: [in] This represents the id of the LCO which should receive the given value. </li>
<li><code class="docutils literal notranslate"><span class="pre">addr</span></code>: [in] This represents the addr of the LCO which should be triggered. </li>
<li><code class="docutils literal notranslate"><span class="pre">t</span></code>: [in] This is the value which should be sent to the LCO. </li>
<li><code class="docutils literal notranslate"><span class="pre">move_credits</span></code>: [in] If this is set to <em>true</em> then it is ok to send all credits in <em>id</em> along with the generated message. The default value is <em>true</em>. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx13set_lco_valueERN6naming7id_typeERR6Resultb">
<span id="_CPPv2N3hpx13set_lco_valueERN6naming7id_typeERR6Resultb"></span><span id="hpx::set_lco_value__naming::id_typeCR.ResultRR.b"></span><em class="property">template </em>&lt;<em class="property">typename</em> Result&gt;<br /><span class="target" id="namespacehpx_1a05c65a0220aff046a181cb6e14dd316b"></span>std::enable_if&lt;!std::is_same&lt;<em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::decay&lt;Result&gt;::type, <a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::address&gt;::value&gt;::type <code class="descname">set_lco_value</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type <em class="property">const</em> &amp;<em>id</em>, Result &amp;&amp;<em>t</em>, bool <em>move_credits</em> = true<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx13set_lco_valueERN6naming7id_typeERR6Resultb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the result value for the (managed) LCO referenced by the given id. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">id</span></code>: [in] This represents the id of the LCO which should receive the given value. </li>
<li><code class="docutils literal notranslate"><span class="pre">t</span></code>: [in] This is the value which should be sent to the LCO. </li>
<li><code class="docutils literal notranslate"><span class="pre">move_credits</span></code>: [in] If this is set to <em>true</em> then it is ok to send all credits in <em>id</em> along with the generated message. The default value is <em>true</em>. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx23set_lco_value_unmanagedERN6naming7id_typeERR6Resultb">
<span id="_CPPv2N3hpx23set_lco_value_unmanagedERN6naming7id_typeERR6Resultb"></span><span id="hpx::set_lco_value_unmanaged__naming::id_typeCR.ResultRR.b"></span><em class="property">template </em>&lt;<em class="property">typename</em> Result&gt;<br /><span class="target" id="namespacehpx_1acde4bb5dada3349bd52512791239ce70"></span>std::enable_if&lt;!std::is_same&lt;<em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::decay&lt;Result&gt;::type, <a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::address&gt;::value&gt;::type <code class="descname">set_lco_value_unmanaged</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type <em class="property">const</em> &amp;<em>id</em>, Result &amp;&amp;<em>t</em>, bool <em>move_credits</em> = true<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx23set_lco_value_unmanagedERN6naming7id_typeERR6Resultb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the result value for the (unmanaged) LCO referenced by the given id. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">id</span></code>: [in] This represents the id of the LCO which should receive the given value. </li>
<li><code class="docutils literal notranslate"><span class="pre">t</span></code>: [in] This is the value which should be sent to the LCO. </li>
<li><code class="docutils literal notranslate"><span class="pre">move_credits</span></code>: [in] If this is set to <em>true</em> then it is ok to send all credits in <em>id</em> along with the generated message. The default value is <em>true</em>. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx13set_lco_valueERN6naming7id_typeERRN6naming7addressERR6ResultRN6naming7id_typeEb">
<span id="_CPPv2N3hpx13set_lco_valueERN6naming7id_typeERRN6naming7addressERR6ResultRN6naming7id_typeEb"></span><span id="hpx::set_lco_value__naming::id_typeCR.naming::addressRR.ResultRR.naming::id_typeCR.b"></span><em class="property">template </em>&lt;<em class="property">typename</em> Result&gt;<br /><span class="target" id="namespacehpx_1aaef2f83c6529712c6bd720ceb081ba06"></span>void <code class="descname">set_lco_value</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type <em class="property">const</em> &amp;<em>id</em>, <a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::address &amp;&amp;<em>addr</em>, Result &amp;&amp;<em>t</em>, <a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type <em class="property">const</em> &amp;<em>cont</em>, bool <em>move_credits</em> = true<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx13set_lco_valueERN6naming7id_typeERRN6naming7addressERR6ResultRN6naming7id_typeEb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the result value for the LCO referenced by the given id. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">id</span></code>: [in] This represents the id of the LCO which should receive the given value. </li>
<li><code class="docutils literal notranslate"><span class="pre">addr</span></code>: [in] This represents the addr of the LCO which should be triggered. </li>
<li><code class="docutils literal notranslate"><span class="pre">t</span></code>: [in] This is the value which should be sent to the LCO. </li>
<li><code class="docutils literal notranslate"><span class="pre">cont</span></code>: [in] This represents the LCO to trigger after completion. </li>
<li><code class="docutils literal notranslate"><span class="pre">move_credits</span></code>: [in] If this is set to <em>true</em> then it is ok to send all credits in <em>id</em> along with the generated message. The default value is <em>true</em>. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx13set_lco_valueERN6naming7id_typeERR6ResultRN6naming7id_typeEb">
<span id="_CPPv2N3hpx13set_lco_valueERN6naming7id_typeERR6ResultRN6naming7id_typeEb"></span><span id="hpx::set_lco_value__naming::id_typeCR.ResultRR.naming::id_typeCR.b"></span><em class="property">template </em>&lt;<em class="property">typename</em> Result&gt;<br /><span class="target" id="namespacehpx_1a136a26af26eb9478e0f9d5e98f54e4b1"></span>std::enable_if&lt;!std::is_same&lt;<em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::decay&lt;Result&gt;::type, <a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::address&gt;::value&gt;::type <code class="descname">set_lco_value</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type <em class="property">const</em> &amp;<em>id</em>, Result &amp;&amp;<em>t</em>, <a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type <em class="property">const</em> &amp;<em>cont</em>, bool <em>move_credits</em> = true<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx13set_lco_valueERN6naming7id_typeERR6ResultRN6naming7id_typeEb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the result value for the (managed) LCO referenced by the given id. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">id</span></code>: [in] This represents the id of the LCO which should receive the given value. </li>
<li><code class="docutils literal notranslate"><span class="pre">t</span></code>: [in] This is the value which should be sent to the LCO. </li>
<li><code class="docutils literal notranslate"><span class="pre">cont</span></code>: [in] This represents the LCO to trigger after completion. </li>
<li><code class="docutils literal notranslate"><span class="pre">move_credits</span></code>: [in] If this is set to <em>true</em> then it is ok to send all credits in <em>id</em> along with the generated message. The default value is <em>true</em>. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx23set_lco_value_unmanagedERN6naming7id_typeERR6ResultRN6naming7id_typeEb">
<span id="_CPPv2N3hpx23set_lco_value_unmanagedERN6naming7id_typeERR6ResultRN6naming7id_typeEb"></span><span id="hpx::set_lco_value_unmanaged__naming::id_typeCR.ResultRR.naming::id_typeCR.b"></span><em class="property">template </em>&lt;<em class="property">typename</em> Result&gt;<br /><span class="target" id="namespacehpx_1af1706601c83026e3adb568d436b33fbf"></span>std::enable_if&lt;!std::is_same&lt;<em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::decay&lt;Result&gt;::type, <a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::address&gt;::value&gt;::type <code class="descname">set_lco_value_unmanaged</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type <em class="property">const</em> &amp;<em>id</em>, Result &amp;&amp;<em>t</em>, <a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type <em class="property">const</em> &amp;<em>cont</em>, bool <em>move_credits</em> = true<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx23set_lco_value_unmanagedERN6naming7id_typeERR6ResultRN6naming7id_typeEb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the result value for the (unmanaged) LCO referenced by the given id. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">id</span></code>: [in] This represents the id of the LCO which should receive the given value. </li>
<li><code class="docutils literal notranslate"><span class="pre">t</span></code>: [in] This is the value which should be sent to the LCO. </li>
<li><code class="docutils literal notranslate"><span class="pre">cont</span></code>: [in] This represents the LCO to trigger after completion. </li>
<li><code class="docutils literal notranslate"><span class="pre">move_credits</span></code>: [in] If this is set to <em>true</em> then it is ok to send all credits in <em>id</em> along with the generated message. The default value is <em>true</em>. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx13set_lco_errorERN6naming7id_typeERRN6naming7addressERNSt13exception_ptrEb">
<span id="_CPPv2N3hpx13set_lco_errorERN6naming7id_typeERRN6naming7addressERNSt13exception_ptrEb"></span><span id="hpx::set_lco_error__naming::id_typeCR.naming::addressRR.std::exception_ptrCR.b"></span><span class="target" id="namespacehpx_1af0c26df1ee631f99d7bb04ec2507c900"></span>void <code class="descname">set_lco_error</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type <em class="property">const</em> &amp;<em>id</em>, <a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::address &amp;&amp;<em>addr</em>, std::exception_ptr <em class="property">const</em> &amp;<em>e</em>, bool <em>move_credits</em> = true<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx13set_lco_errorERN6naming7id_typeERRN6naming7addressERNSt13exception_ptrEb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the error state for the LCO referenced by the given id. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">id</span></code>: [in] This represents the id of the LCO which should receive the error value. </li>
<li><code class="docutils literal notranslate"><span class="pre">addr</span></code>: [in] This represents the addr of the LCO which should be triggered. </li>
<li><code class="docutils literal notranslate"><span class="pre">e</span></code>: [in] This is the error value which should be sent to the LCO. </li>
<li><code class="docutils literal notranslate"><span class="pre">move_credits</span></code>: [in] If this is set to <em>true</em> then it is ok to send all credits in <em>id</em> along with the generated message. The default value is <em>true</em>. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx13set_lco_errorERN6naming7id_typeERRN6naming7addressERRNSt13exception_ptrEb">
<span id="_CPPv2N3hpx13set_lco_errorERN6naming7id_typeERRN6naming7addressERRNSt13exception_ptrEb"></span><span id="hpx::set_lco_error__naming::id_typeCR.naming::addressRR.std::exception_ptrRR.b"></span><span class="target" id="namespacehpx_1a5212afa7a0c98340c84329667ee9d76d"></span>void <code class="descname">set_lco_error</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type <em class="property">const</em> &amp;<em>id</em>, <a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::address &amp;&amp;<em>addr</em>, std::exception_ptr &amp;&amp;<em>e</em>, bool <em>move_credits</em> = true<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx13set_lco_errorERN6naming7id_typeERRN6naming7addressERRNSt13exception_ptrEb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the error state for the LCO referenced by the given id. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">id</span></code>: [in] This represents the id of the LCO which should receive the error value. </li>
<li><code class="docutils literal notranslate"><span class="pre">addr</span></code>: [in] This represents the addr of the LCO which should be triggered. </li>
<li><code class="docutils literal notranslate"><span class="pre">e</span></code>: [in] This is the error value which should be sent to the LCO. </li>
<li><code class="docutils literal notranslate"><span class="pre">move_credits</span></code>: [in] If this is set to <em>true</em> then it is ok to send all credits in <em>id</em> along with the generated message. The default value is <em>true</em>. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx13set_lco_errorERN6naming7id_typeERNSt13exception_ptrEb">
<span id="_CPPv2N3hpx13set_lco_errorERN6naming7id_typeERNSt13exception_ptrEb"></span><span id="hpx::set_lco_error__naming::id_typeCR.std::exception_ptrCR.b"></span><span class="target" id="namespacehpx_1a4319f12b95c698b336d3bddcdc86fa9a"></span>void <code class="descname">set_lco_error</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type <em class="property">const</em> &amp;<em>id</em>, std::exception_ptr <em class="property">const</em> &amp;<em>e</em>, bool <em>move_credits</em> = true<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx13set_lco_errorERN6naming7id_typeERNSt13exception_ptrEb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the error state for the LCO referenced by the given id. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">id</span></code>: [in] This represents the id of the LCO which should receive the error value. </li>
<li><code class="docutils literal notranslate"><span class="pre">e</span></code>: [in] This is the error value which should be sent to the LCO. </li>
<li><code class="docutils literal notranslate"><span class="pre">move_credits</span></code>: [in] If this is set to <em>true</em> then it is ok to send all credits in <em>id</em> along with the generated message. The default value is <em>true</em>. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx13set_lco_errorERN6naming7id_typeERRNSt13exception_ptrEb">
<span id="_CPPv2N3hpx13set_lco_errorERN6naming7id_typeERRNSt13exception_ptrEb"></span><span id="hpx::set_lco_error__naming::id_typeCR.std::exception_ptrRR.b"></span><span class="target" id="namespacehpx_1a31702a9ce79826a733156e3e4d1bc086"></span>void <code class="descname">set_lco_error</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type <em class="property">const</em> &amp;<em>id</em>, std::exception_ptr &amp;&amp;<em>e</em>, bool <em>move_credits</em> = true<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx13set_lco_errorERN6naming7id_typeERRNSt13exception_ptrEb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the error state for the LCO referenced by the given id. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">id</span></code>: [in] This represents the id of the LCO which should receive the error value. </li>
<li><code class="docutils literal notranslate"><span class="pre">e</span></code>: [in] This is the error value which should be sent to the LCO. </li>
<li><code class="docutils literal notranslate"><span class="pre">move_credits</span></code>: [in] If this is set to <em>true</em> then it is ok to send all credits in <em>id</em> along with the generated message. The default value is <em>true</em>. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx13set_lco_errorERN6naming7id_typeERRN6naming7addressERNSt13exception_ptrERN6naming7id_typeEb">
<span id="_CPPv2N3hpx13set_lco_errorERN6naming7id_typeERRN6naming7addressERNSt13exception_ptrERN6naming7id_typeEb"></span><span id="hpx::set_lco_error__naming::id_typeCR.naming::addressRR.std::exception_ptrCR.naming::id_typeCR.b"></span><span class="target" id="namespacehpx_1acf6b5cb329463f47953fff7d4fcfb620"></span>void <code class="descname">set_lco_error</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type <em class="property">const</em> &amp;<em>id</em>, <a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::address &amp;&amp;<em>addr</em>, std::exception_ptr <em class="property">const</em> &amp;<em>e</em>, <a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type <em class="property">const</em> &amp;<em>cont</em>, bool <em>move_credits</em> = true<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx13set_lco_errorERN6naming7id_typeERRN6naming7addressERNSt13exception_ptrERN6naming7id_typeEb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the error state for the LCO referenced by the given id. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">id</span></code>: [in] This represents the id of the LCO which should receive the error value. </li>
<li><code class="docutils literal notranslate"><span class="pre">addr</span></code>: [in] This represents the addr of the LCO which should be triggered. </li>
<li><code class="docutils literal notranslate"><span class="pre">e</span></code>: [in] This is the error value which should be sent to the LCO. </li>
<li><code class="docutils literal notranslate"><span class="pre">cont</span></code>: [in] This represents the LCO to trigger after completion. </li>
<li><code class="docutils literal notranslate"><span class="pre">move_credits</span></code>: [in] If this is set to <em>true</em> then it is ok to send all credits in <em>id</em> along with the generated message. The default value is <em>true</em>. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx13set_lco_errorERN6naming7id_typeERRN6naming7addressERRNSt13exception_ptrERN6naming7id_typeEb">
<span id="_CPPv2N3hpx13set_lco_errorERN6naming7id_typeERRN6naming7addressERRNSt13exception_ptrERN6naming7id_typeEb"></span><span id="hpx::set_lco_error__naming::id_typeCR.naming::addressRR.std::exception_ptrRR.naming::id_typeCR.b"></span><span class="target" id="namespacehpx_1a09c2fb701954a101f1d9bedb94f1ed19"></span>void <code class="descname">set_lco_error</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type <em class="property">const</em> &amp;<em>id</em>, <a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::address &amp;&amp;<em>addr</em>, std::exception_ptr &amp;&amp;<em>e</em>, <a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type <em class="property">const</em> &amp;<em>cont</em>, bool <em>move_credits</em> = true<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx13set_lco_errorERN6naming7id_typeERRN6naming7addressERRNSt13exception_ptrERN6naming7id_typeEb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the error state for the LCO referenced by the given id. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">id</span></code>: [in] This represents the id of the LCO which should receive the error value. </li>
<li><code class="docutils literal notranslate"><span class="pre">addr</span></code>: [in] This represents the addr of the LCO which should be triggered. </li>
<li><code class="docutils literal notranslate"><span class="pre">e</span></code>: [in] This is the error value which should be sent to the LCO. </li>
<li><code class="docutils literal notranslate"><span class="pre">cont</span></code>: [in] This represents the LCO to trigger after completion. </li>
<li><code class="docutils literal notranslate"><span class="pre">move_credits</span></code>: [in] If this is set to <em>true</em> then it is ok to send all credits in <em>id</em> along with the generated message. The default value is <em>true</em>. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx13set_lco_errorERN6naming7id_typeERNSt13exception_ptrERN6naming7id_typeEb">
<span id="_CPPv2N3hpx13set_lco_errorERN6naming7id_typeERNSt13exception_ptrERN6naming7id_typeEb"></span><span id="hpx::set_lco_error__naming::id_typeCR.std::exception_ptrCR.naming::id_typeCR.b"></span><span class="target" id="namespacehpx_1a49faf5cfa444c6e603b89d704bc15d7d"></span>void <code class="descname">set_lco_error</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type <em class="property">const</em> &amp;<em>id</em>, std::exception_ptr <em class="property">const</em> &amp;<em>e</em>, <a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type <em class="property">const</em> &amp;<em>cont</em>, bool <em>move_credits</em> = true<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx13set_lco_errorERN6naming7id_typeERNSt13exception_ptrERN6naming7id_typeEb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the error state for the LCO referenced by the given id. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">id</span></code>: [in] This represents the id of the LCO which should receive the error value. </li>
<li><code class="docutils literal notranslate"><span class="pre">e</span></code>: [in] This is the error value which should be sent to the LCO. </li>
<li><code class="docutils literal notranslate"><span class="pre">cont</span></code>: [in] This represents the LCO to trigger after completion. </li>
<li><code class="docutils literal notranslate"><span class="pre">move_credits</span></code>: [in] If this is set to <em>true</em> then it is ok to send all credits in <em>id</em> along with the generated message. The default value is <em>true</em>. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx13set_lco_errorERN6naming7id_typeERRNSt13exception_ptrERN6naming7id_typeEb">
<span id="_CPPv2N3hpx13set_lco_errorERN6naming7id_typeERRNSt13exception_ptrERN6naming7id_typeEb"></span><span id="hpx::set_lco_error__naming::id_typeCR.std::exception_ptrRR.naming::id_typeCR.b"></span><span class="target" id="namespacehpx_1ada564cac88cc7c4d5cd03f7c55d7e7f2"></span>void <code class="descname">set_lco_error</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type <em class="property">const</em> &amp;<em>id</em>, std::exception_ptr &amp;&amp;<em>e</em>, <a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type <em class="property">const</em> &amp;<em>cont</em>, bool <em>move_credits</em> = true<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx13set_lco_errorERN6naming7id_typeERRNSt13exception_ptrERN6naming7id_typeEb" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the error state for the LCO referenced by the given id. </p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">id</span></code>: [in] This represents the id of the LCO which should receive the error value. </li>
<li><code class="docutils literal notranslate"><span class="pre">e</span></code>: [in] This is the error value which should be sent to the LCO. </li>
<li><code class="docutils literal notranslate"><span class="pre">cont</span></code>: [in] This represents the LCO to trigger after completion. </li>
<li><code class="docutils literal notranslate"><span class="pre">move_credits</span></code>: [in] If this is set to <em>true</em> then it is ok to send all credits in <em>id</em> along with the generated message. The default value is <em>true</em>. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> Component, <em class="property">typename</em> … <em>Ts</em>&gt;</dt>
<dt>
<span class="target" id="namespacehpx_1aa43897833f0f0ed2afc53006fc80dad5"></span><code class="descname">&lt;unspecified&gt; hpx::new_(id_type const &amp; locality, Ts &amp;&amp;... vs)</code></dt>
<dd><p>Create one or more new instances of the given Component type on the specified locality. </p>
<p>This function creates one or more new instances of the given Component type on the specified locality and returns a future object for the global address which can be used to reference the new component instance.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function requires to specify an explicit template argument which will define what type of component(s) to create, for instance: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">hpx</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">hpx</span><span class="o">::</span><span class="n">id_type</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span>
   <span class="n">hpx</span><span class="o">::</span><span class="n">new_</span><span class="o">&lt;</span><span class="n">some_component</span><span class="o">&gt;</span><span class="p">(</span><span class="n">hpx</span><span class="o">::</span><span class="n">find_here</span><span class="p">(),</span> <span class="p">...);</span>
<span class="n">hpx</span><span class="o">::</span><span class="n">id_type</span> <span class="n">id</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
</pre></div>
</div>
</dd>
<dt><strong>Return</strong></dt>
<dd>The function returns different types depending on its use:<ul class="simple">
<li>If the explicit template argument <em>Component</em> represents a component type (<code class="docutils literal notranslate"><span class="pre">traits::is_component&lt;Component&gt;::value</span></code> evaluates to true), the function will return an <em>hpx::future</em> object instance which can be used to retrieve the global address of the newly created component.</li>
<li>If the explicit template argument <em>Component</em> represents a client side object (<code class="docutils literal notranslate"><span class="pre">traits::is_client&lt;Component&gt;::value</span></code> evaluates to true), the function will return a new instance of that type which can be used to refer to the newly created component instance. </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">locality</span></code>: [in] The global address of the locality where the new instance should be created on. </li>
<li><code class="docutils literal notranslate"><span class="pre">vs</span></code>: [in] Any number of arbitrary arguments (passed by value, by const reference or by rvalue reference) which will be forwarded to the constructor of the created component instance.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> Component, <em class="property">typename</em> … <em>Ts</em>&gt;</dt>
<dt>
<span class="target" id="namespacehpx_1afe0790913a2940c611d6e4a0e738821f"></span><code class="descname">&lt;unspecified&gt; hpx::local_new(Ts &amp;&amp;... vs)</code></dt>
<dd><p>Create one new instance of the given Component type on the current locality. </p>
<p>This function creates one new instance of the given Component type on the current locality and returns a future object for the global address which can be used to reference the new component instance.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function requires to specify an explicit template argument which will define what type of component(s) to create, for instance: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">hpx</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">hpx</span><span class="o">::</span><span class="n">id_type</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span>
   <span class="n">hpx</span><span class="o">::</span><span class="n">local_new</span><span class="o">&lt;</span><span class="n">some_component</span><span class="o">&gt;</span><span class="p">(...);</span>
<span class="n">hpx</span><span class="o">::</span><span class="n">id_type</span> <span class="n">id</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
</pre></div>
</div>
</dd>
<dt><strong>Return</strong></dt>
<dd>The function returns different types depending on its use:<ul class="simple">
<li>If the explicit template argument <em>Component</em> represents a component type (<code class="docutils literal notranslate"><span class="pre">traits::is_component&lt;Component&gt;::value</span></code> evaluates to true), the function will return an <em>hpx::future</em> object instance which can be used to retrieve the global address of the newly created component.</li>
<li>If the explicit template argument <em>Component</em> represents a client side object (<code class="docutils literal notranslate"><span class="pre">traits::is_client&lt;Component&gt;::value</span></code> evaluates to true), the function will return a new instance of that type which can be used to refer to the newly created component instance.</li>
</ul>
</dd>
<dt><strong>Note</strong></dt>
<dd>The difference of this funtion to <em><a class="reference internal" href="#namespacehpx_1aa43897833f0f0ed2afc53006fc80dad5"><span class="std std-ref">hpx::new_</span></a></em> is that it can be used in cases where the supplied arguments are non-copyable and non-movable. All operations are guaranteed to be local only. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">vs</span></code>: [in] Any number of arbitrary arguments (passed by value, by const reference or by rvalue reference) which will be forwarded to the constructor of the created component instance.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> Component, <em class="property">typename</em> … <em>Ts</em>&gt;</dt>
<dt>
<span class="target" id="namespacehpx_1aea2980125a99fd4c163b868f29516221"></span><code class="descname">&lt;unspecified&gt; hpx::new_(id_type const &amp; locality, std::size_t count, Ts &amp;&amp;... vs)</code></dt>
<dd><p>Create multiple new instances of the given Component type on the specified locality. </p>
<p>This function creates multiple new instances of the given Component type on the specified locality and returns a future object for the global address which can be used to reference the new component instance.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function requires to specify an explicit template argument which will define what type of component(s) to create, for instance: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">hpx</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">hpx</span><span class="o">::</span><span class="n">id_type</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span>
   <span class="n">hpx</span><span class="o">::</span><span class="n">new_</span><span class="o">&lt;</span><span class="n">some_component</span><span class="p">[]</span><span class="o">&gt;</span><span class="p">(</span><span class="n">hpx</span><span class="o">::</span><span class="n">find_here</span><span class="p">(),</span> <span class="mi">10</span><span class="p">,</span> <span class="p">...);</span>
<span class="n">hpx</span><span class="o">::</span><span class="n">id_type</span> <span class="n">id</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
</pre></div>
</div>
</dd>
<dt><strong>Return</strong></dt>
<dd>The function returns different types depending on its use:<ul class="simple">
<li>If the explicit template argument <em>Component</em> represents an array of a component type (i.e. <em>Component</em>[], where <code class="docutils literal notranslate"><span class="pre">traits::is_component&lt;Component&gt;::value</span></code> evaluates to true), the function will return an <em>hpx::future</em> object instance which holds a std::vector&lt;hpx::id_type&gt;, where each of the items in this vector is a global address of one of the newly created components.</li>
<li>If the explicit template argument <em>Component</em> represents an array of a client side object type (i.e. <em>Component</em>[], where <code class="docutils literal notranslate"><span class="pre">traits::is_client&lt;Component&gt;::value</span></code> evaluates to true), the function will return an <em>hpx::future</em> object instance which holds a std::vector&lt;hpx::id_type&gt;, where each of the items in this vector is a client side instance of the given type, each representing one of the newly created components. </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">locality</span></code>: [in] The global address of the locality where the new instance should be created on. </li>
<li><code class="docutils literal notranslate"><span class="pre">count</span></code>: [in] The number of component instances to create </li>
<li><code class="docutils literal notranslate"><span class="pre">vs</span></code>: [in] Any number of arbitrary arguments (passed by value, by const reference or by rvalue reference) which will be forwarded to the constructor of the created component instance.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> Component, <em class="property">typename</em> DistPolicy, <em class="property">typename</em> … <em>Ts</em>&gt;</dt>
<dt>
<span class="target" id="namespacehpx_1aa9f418d7039ba0ff4b13917c158b6630"></span><code class="descname">&lt;unspecified&gt; hpx::new_(DistPolicy const &amp; policy, Ts &amp;&amp;... vs)</code></dt>
<dd><p>Create one or more new instances of the given Component type based on the given distribution policy. </p>
<p>This function creates one or more new instances of the given Component type on the localities defined by the given distribution policy and returns a future object for global address which can be used to reference the new component instance(s).</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function requires to specify an explicit template argument which will define what type of component(s) to create, for instance: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">hpx</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">hpx</span><span class="o">::</span><span class="n">id_type</span><span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span>
   <span class="n">hpx</span><span class="o">::</span><span class="n">new_</span><span class="o">&lt;</span><span class="n">some_component</span><span class="o">&gt;</span><span class="p">(</span><span class="n">hpx</span><span class="o">::</span><span class="n">default_layout</span><span class="p">,</span> <span class="p">...);</span>
<span class="n">hpx</span><span class="o">::</span><span class="n">id_type</span> <span class="n">id</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
</pre></div>
</div>
</dd>
<dt><strong>Return</strong></dt>
<dd>The function returns different types depending on its use:<ul class="simple">
<li>If the explicit template argument <em>Component</em> represents a component type (<code class="docutils literal notranslate"><span class="pre">traits::is_component&lt;Component&gt;::value</span></code> evaluates to true), the function will return an <em>hpx::future</em> object instance which can be used to retrieve the global address of the newly created component.</li>
<li>If the explicit template argument <em>Component</em> represents a client side object (<code class="docutils literal notranslate"><span class="pre">traits::is_client&lt;Component&gt;::value</span></code> evaluates to true), the function will return a new instance of that type which can be used to refer to the newly created component instance. </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: [in] The distribution policy used to decide where to place the newly created. </li>
<li><code class="docutils literal notranslate"><span class="pre">vs</span></code>: [in] Any number of arbitrary arguments (passed by value, by const reference or by rvalue reference) which will be forwarded to the constructor of the created component instance.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> Component, <em class="property">typename</em> DistPolicy, <em class="property">typename</em> … <em>Ts</em>&gt;</dt>
<dt>
<span class="target" id="namespacehpx_1ad90881264fb7fbb31ed956e5573b0f66"></span><code class="descname">&lt;unspecified&gt; hpx::new_(DistPolicy const &amp; policy, std::size_t count, Ts &amp;&amp;... vs)</code></dt>
<dd><p>Create multiple new instances of the given Component type on the localities as defined by the given distribution policy. </p>
<p>This function creates multiple new instances of the given Component type on the localities defined by the given distribution policy and returns a future object for the global address which can be used to reference the new component instance.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function requires to specify an explicit template argument which will define what type of component(s) to create, for instance: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">hpx</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">hpx</span><span class="o">::</span><span class="n">id_type</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">f</span> <span class="o">=</span>
   <span class="n">hpx</span><span class="o">::</span><span class="n">new_</span><span class="o">&lt;</span><span class="n">some_component</span><span class="p">[]</span><span class="o">&gt;</span><span class="p">(</span><span class="n">hpx</span><span class="o">::</span><span class="n">default_layout</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="p">...);</span>
<span class="n">hpx</span><span class="o">::</span><span class="n">id_type</span> <span class="n">id</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
</pre></div>
</div>
</dd>
<dt><strong>Return</strong></dt>
<dd>The function returns different types depending on its use:<ul class="simple">
<li>If the explicit template argument <em>Component</em> represents an array of a component type (i.e. <em>Component</em>[], where <code class="docutils literal notranslate"><span class="pre">traits::is_component&lt;Component&gt;::value</span></code> evaluates to true), the function will return an <em>hpx::future</em> object instance which holds a std::vector&lt;hpx::id_type&gt;, where each of the items in this vector is a global address of one of the newly created components.</li>
<li>If the explicit template argument <em>Component</em> represents an array of a client side object type (i.e. <em>Component</em>[], where <code class="docutils literal notranslate"><span class="pre">traits::is_client&lt;Component&gt;::value</span></code> evaluates to true), the function will return an <em>hpx::future</em> object instance which holds a std::vector&lt;hpx::id_type&gt;, where each of the items in this vector is a client side instance of the given type, each representing one of the newly created components. </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: [in] The distribution policy used to decide where to place the newly created. </li>
<li><code class="docutils literal notranslate"><span class="pre">count</span></code>: [in] The number of component instances to create </li>
<li><code class="docutils literal notranslate"><span class="pre">vs</span></code>: [in] Any number of arbitrary arguments (passed by value, by const reference or by rvalue reference) which will be forwarded to the constructor of the created component instance.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx12split_futureERR6futureI5tupleIDp2TsEE">
<span id="_CPPv2N3hpx12split_futureERR6futureI5tupleIDp2TsEE"></span><span id="hpx::split_future__future:tuple:TsDp::RR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ... <em>Ts</em>&gt;<br /><span class="target" id="namespacehpx_1a316e1a9ed8e48a5cd1ad58c150c0b990"></span>tuple&lt;future&lt;Ts&gt;...&gt; <code class="descname">split_future</code><span class="sig-paren">(</span>future&lt;tuple&lt;Ts...&gt;&gt; &amp;&amp;<em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx12split_futureERR6futureI5tupleIDp2TsEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>split_future</em> is an operator allowing to split a given future of a sequence of values (any tuple, std::pair, or std::array) into an equivalent container of futures where each future represents one of the values from the original future. In some sense this function provides the inverse operation of <em>when_all</em>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Returns an equivalent container (same container type as passed as the argument) of futures, where each future refers to the corresponding value in the input parameter. All of the returned futures become ready once the input future has become ready. If the input future is exceptional, all output futures will be exceptional as well.</dd>
<dt><strong>Note</strong></dt>
<dd>The following cases are special: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">tuple</span><span class="o">&lt;</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">split_future</span><span class="p">(</span><span class="n">future</span><span class="o">&lt;</span><span class="n">tuple</span><span class="o">&lt;&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">);</span>
<span class="n">array</span><span class="o">&lt;</span><span class="n">future</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">split_future</span><span class="p">(</span><span class="n">future</span><span class="o">&lt;</span><span class="n">array</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">);</span>
</pre></div>
</div>
 here the returned futures are directly representing the futures which were passed to the function. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: [in] A future holding an arbitrary sequence of values stored in a tuple-like container. This facility supports <em>hpx::util::tuple&lt;&gt;</em>, <em>std::pair&lt;T1, T2&gt;</em>, and <em>std::array&lt;T, N&gt;</em> </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx12split_futureERR6futureINSt6vectorI1TEEENSt6size_tE">
<span id="_CPPv2N3hpx12split_futureERR6futureINSt6vectorI1TEEENSt6size_tE"></span><span id="hpx::split_future__future:std::vector:T::RR.std::s"></span><em class="property">template </em>&lt;<em class="property">typename</em> T&gt;<br /><span class="target" id="namespacehpx_1a790ed8efd6e91700384fe44b7e363157"></span>std::vector&lt;future&lt;T&gt;&gt; <code class="descname">split_future</code><span class="sig-paren">(</span>future&lt;std::vector&lt;T&gt;&gt; &amp;&amp;<em>f</em>, std::size_t <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx12split_futureERR6futureINSt6vectorI1TEEENSt6size_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>split_future</em> is an operator allowing to split a given future of a sequence of values (any std::vector) into a std::vector of futures where each future represents one of the values from the original std::vector. In some sense this function provides the inverse operation of <em>when_all</em>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Returns a std::vector of futures, where each future refers to the corresponding value in the input parameter. All of the returned futures become ready once the input future has become ready. If the input future is exceptional, all output futures will be exceptional as well. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: [in] A future holding an arbitrary sequence of values stored in a std::vector. </li>
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: [in] The number of elements the vector will hold once the input future has become ready</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8wait_allE9InputIter9InputIter">
<span id="_CPPv2N3hpx8wait_allE9InputIter9InputIter"></span><span id="hpx::wait_all__InputIter.InputIter"></span><em class="property">template </em>&lt;<em class="property">typename</em> InputIter&gt;<br /><span class="target" id="namespacehpx_1a2813387f73914c8820932b17345a9a3c"></span>void <code class="descname">wait_all</code><span class="sig-paren">(</span>InputIter <em>first</em>, InputIter <em>last</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8wait_allE9InputIter9InputIter" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>wait_all</em> is an operator allowing to join on the result of all given futures. It AND-composes all future objects given and returns after they finished executing.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The function <em>wait_all</em> returns after all futures have become ready. All input futures are still valid after <em>wait_all</em> returns. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: The iterator pointing to the first element of a sequence of <em>future</em> or <em>shared_future</em> objects for which <em>wait_all</em> should wait. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: The iterator pointing to the last element of a sequence of <em>future</em> or <em>shared_future</em> objects for which <em>wait_all</em> should wait.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8wait_allERRNSt6vectorI6futureI1REEE">
<span id="_CPPv2N3hpx8wait_allERRNSt6vectorI6futureI1REEE"></span><span id="hpx::wait_all__std::vector:future:R::RR"></span><em class="property">template </em>&lt;<em class="property">typename</em> R&gt;<br /><span class="target" id="namespacehpx_1a66b1f971ef6e3a7047209f46bb5363a2"></span>void <code class="descname">wait_all</code><span class="sig-paren">(</span>std::vector&lt;future&lt;R&gt;&gt; &amp;&amp;<em>futures</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8wait_allERRNSt6vectorI6futureI1REEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>wait_all</em> is an operator allowing to join on the result of all given futures. It AND-composes all future objects given and returns after they finished executing.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The function <em>wait_all</em> returns after all futures have become ready. All input futures are still valid after <em>wait_all</em> returns. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">futures</span></code>: A vector or array holding an arbitrary amount of <em>future</em> or <em>shared_future</em> objects for which <em>wait_all</em> should wait.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8wait_allERRNSt5arrayI6futureI1RE1NEE">
<span id="_CPPv2N3hpx8wait_allERRNSt5arrayI6futureI1RE1NEE"></span><span id="hpx::wait_all__std::array:future:R:.N:RR"></span><em class="property">template </em>&lt;<em class="property">typename</em> R, std::size_t <em>N</em>&gt;<br /><span class="target" id="namespacehpx_1a3708e444b4d1b065391134bce018bac5"></span>void <code class="descname">wait_all</code><span class="sig-paren">(</span>std::array&lt;future&lt;R&gt;, N&gt; &amp;&amp;<em>futures</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8wait_allERRNSt5arrayI6futureI1RE1NEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>wait_all</em> is an operator allowing to join on the result of all given futures. It AND-composes all future objects given and returns after they finished executing.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The function <em>wait_all</em> returns after all futures have become ready. All input futures are still valid after <em>wait_all</em> returns. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">futures</span></code>: A vector or array holding an arbitrary amount of <em>future</em> or <em>shared_future</em> objects for which <em>wait_all</em> should wait.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8wait_allEDpRR1T">
<span id="_CPPv2N3hpx8wait_allEDpRR1T"></span><span id="hpx::wait_all__TRRDp"></span><em class="property">template </em>&lt;<em class="property">typename</em> ... <em>T</em>&gt;<br /><span class="target" id="namespacehpx_1afb0e337050655c63eb2037276c45936c"></span>void <code class="descname">wait_all</code><span class="sig-paren">(</span>T&amp;&amp;... <em>futures</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8wait_allEDpRR1T" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>wait_all</em> is an operator allowing to join on the result of all given futures. It AND-composes all future objects given and returns after they finished executing.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The function <em>wait_all</em> returns after all futures have become ready. All input futures are still valid after <em>wait_all</em> returns. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">futures</span></code>: An arbitrary number of <em>future</em> or <em>shared_future</em> objects, possibly holding different types for which <em>wait_all</em> should wait.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx10wait_all_nE9InputIterNSt6size_tE">
<span id="_CPPv2N3hpx10wait_all_nE9InputIterNSt6size_tE"></span><span id="hpx::wait_all_n__InputIter.std::s"></span><em class="property">template </em>&lt;<em class="property">typename</em> InputIter&gt;<br /><span class="target" id="namespacehpx_1aca58b9f93caf250031cbf3aa4aaec489"></span>InputIter <code class="descname">wait_all_n</code><span class="sig-paren">(</span>InputIter <em>begin</em>, std::size_t <em>count</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx10wait_all_nE9InputIterNSt6size_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>wait_all_n</em> is an operator allowing to join on the result of all given futures. It AND-composes all future objects given and returns after they finished executing.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The function <em>wait_all_n</em> will return an iterator referring to the first element in the input sequence after the last processed element.</dd>
<dt><strong>Note</strong></dt>
<dd>The function <em>wait_all_n</em> returns after all futures have become ready. All input futures are still valid after <em>wait_all_n</em> returns. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">begin</span></code>: The iterator pointing to the first element of a sequence of <em>future</em> or <em>shared_future</em> objects for which <em>wait_all_n</em> should wait. </li>
<li><code class="docutils literal notranslate"><span class="pre">count</span></code>: The number of elements in the sequence starting at <em>first</em>.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8when_allE9InputIter9InputIter">
<span id="_CPPv2N3hpx8when_allE9InputIter9InputIter"></span><span id="hpx::when_all__InputIter.InputIter"></span><em class="property">template </em>&lt;<em class="property">typename</em> InputIter, <em class="property">typename</em> Container = vector&lt;future&lt;typename std::iterator_traits&lt;InputIter&gt;::value_type&gt;&gt;&gt;<br /><span class="target" id="namespacehpx_1a5ad5592e9ab00e19076037495d55d3e9"></span>future&lt;Container&gt; <code class="descname">when_all</code><span class="sig-paren">(</span>InputIter <em>first</em>, InputIter <em>last</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8when_allE9InputIter9InputIter" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>when_all</em> is an operator allowing to join on the result of all given futures. It AND-composes all future objects given and returns a new future object representing the same list of futures after they finished executing.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Returns a future holding the same list of futures as has been passed to <em>when_all</em>.<ul class="simple">
<li>future&lt;Container&lt;future&lt;R&gt;&gt;&gt;: If the input cardinality is unknown at compile time and the futures are all of the same type. The order of the futures in the output container will be the same as given by the input iterator.</li>
</ul>
</dd>
<dt><strong>Note</strong></dt>
<dd>Calling this version of <em>when_all</em> where first == last, returns a future with an empty container that is immediately ready. Each future and shared_future is waited upon and then copied into the collection of the output (returned) future, maintaining the order of the futures in the input collection. The future returned by <em>when_all</em> will not throw an exception, but the futures held in the output collection may. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: [in] The iterator pointing to the first element of a sequence of <em>future</em> or <em>shared_future</em> objects for which <em>when_all</em> should wait. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: [in] The iterator pointing to the last element of a sequence of <em>future</em> or <em>shared_future</em> objects for which <em>when_all</em> should wait.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8when_allERR5Range">
<span id="_CPPv2N3hpx8when_allERR5Range"></span><span id="hpx::when_all__RangeRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> Range&gt;<br /><span class="target" id="namespacehpx_1a2162cc879aa5c37b993e641f5e62bcfc"></span>future&lt;Range&gt; <code class="descname">when_all</code><span class="sig-paren">(</span>Range &amp;&amp;<em>values</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8when_allERR5Range" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>when_all</em> is an operator allowing to join on the result of all given futures. It AND-composes all future objects given and returns a new future object representing the same list of futures after they finished executing.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Returns a future holding the same list of futures as has been passed to when_all.<ul class="simple">
<li>future&lt;Container&lt;future&lt;R&gt;&gt;&gt;: If the input cardinality is unknown at compile time and the futures are all of the same type.</li>
</ul>
</dd>
<dt><strong>Note</strong></dt>
<dd>Calling this version of <em>when_all</em> where the input container is empty, returns a future with an empty container that is immediately ready. Each future and shared_future is waited upon and then copied into the collection of the output (returned) future, maintaining the order of the futures in the input collection. The future returned by <em>when_all</em> will not throw an exception, but the futures held in the output collection may. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">values</span></code>: [in] A range holding an arbitrary amount of <em>future</em> or <em>shared_future</em> objects for which <em>when_all</em> should wait.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8when_allEDpRR1T">
<span id="_CPPv2N3hpx8when_allEDpRR1T"></span><span id="hpx::when_all__TRRDp"></span><em class="property">template </em>&lt;<em class="property">typename</em> ... <em>T</em>&gt;<br /><span class="target" id="namespacehpx_1a5487cfa0e100bffc9a9fbd49afbb7664"></span>future&lt;tuple&lt;future&lt;T&gt;...&gt;&gt; <code class="descname">when_all</code><span class="sig-paren">(</span>T&amp;&amp;... <em>futures</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8when_allEDpRR1T" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>when_all</em> is an operator allowing to join on the result of all given futures. It AND-composes all future objects given and returns a new future object representing the same list of futures after they finished executing.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Returns a future holding the same list of futures as has been passed to <em>when_all</em>.<ul class="simple">
<li>future&lt;tuple&lt;future&lt;T0&gt;, future&lt;T1&gt;, future&lt;T2&gt;…&gt;&gt;: If inputs are fixed in number and are of heterogeneous types. The inputs can be any arbitrary number of future objects.</li>
<li>future&lt;tuple&lt;&gt;&gt; if <em>when_all</em> is called with zero arguments. The returned future will be initially ready.</li>
</ul>
</dd>
<dt><strong>Note</strong></dt>
<dd>Each future and shared_future is waited upon and then copied into the collection of the output (returned) future, maintaining the order of the futures in the input collection. The future returned by <em>when_all</em> will not throw an exception, but the futures held in the output collection may. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">futures</span></code>: [in] An arbitrary number of <em>future</em> or <em>shared_future</em> objects, possibly holding different types for which <em>when_all</em> should wait.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx10when_all_nE9InputIterNSt6size_tE">
<span id="_CPPv2N3hpx10when_all_nE9InputIterNSt6size_tE"></span><span id="hpx::when_all_n__InputIter.std::s"></span><em class="property">template </em>&lt;<em class="property">typename</em> InputIter, <em class="property">typename</em> Container = vector&lt;future&lt;typename std::iterator_traits&lt;InputIter&gt;::value_type&gt;&gt;&gt;<br /><span class="target" id="namespacehpx_1ab92c88e6a0d8c6632caa863f7ece9694"></span>future&lt;Container&gt; <code class="descname">when_all_n</code><span class="sig-paren">(</span>InputIter <em>begin</em>, std::size_t <em>count</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx10when_all_nE9InputIterNSt6size_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>when_all_n</em> is an operator allowing to join on the result of all given futures. It AND-composes all future objects given and returns a new future object representing the same list of futures after they finished executing.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Returns a future holding the same list of futures as has been passed to <em>when_all_n</em>.<ul class="simple">
<li>future&lt;Container&lt;future&lt;R&gt;&gt;&gt;: If the input cardinality is unknown at compile time and the futures are all of the same type. The order of the futures in the output vector will be the same as given by the input iterator.</li>
</ul>
</dd>
<dt><strong>Note</strong></dt>
<dd>As long as <em>ec</em> is not pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> this function doesn’t throw but returns the result code using the parameter <em>ec</em>. Otherwise it throws an instance of <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a>.</dd>
<dt><strong>Note</strong></dt>
<dd>None of the futures in the input sequence are invalidated. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">begin</span></code>: [in] The iterator pointing to the first element of a sequence of <em>future</em> or <em>shared_future</em> objects for which <em>wait_all_n</em> should wait. </li>
<li><code class="docutils literal notranslate"><span class="pre">count</span></code>: [in] The number of elements in the sequence starting at <em>first</em>.</li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">This</span></code>: function will throw errors which are encountered while setting up the requested operation only. Errors encountered while executing the operations delivering the results to be stored in the futures are reported through the futures themselves.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8wait_anyE9InputIter9InputIterR10error_code">
<span id="_CPPv2N3hpx8wait_anyE9InputIter9InputIterR10error_code"></span><span id="hpx::wait_any__InputIter.InputIter.error_codeR"></span><em class="property">template </em>&lt;<em class="property">typename</em> InputIter&gt;<br /><span class="target" id="namespacehpx_1aa6c2d1fdea349e2a9937f249aa4d895a"></span>void <code class="descname">wait_any</code><span class="sig-paren">(</span>InputIter <em>first</em>, InputIter <em>last</em>, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8wait_anyE9InputIter9InputIterR10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>wait_any</em> is a non-deterministic choice operator. It OR-composes all future objects given and returns after one future of that list finishes execution.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The function <em>wait_any</em> returns after at least one future has become ready. All input futures are still valid after <em>wait_any</em> returns.</dd>
<dt><strong>Note</strong></dt>
<dd>As long as <em>ec</em> is not pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> this function doesn’t throw but returns the result code using the parameter <em>ec</em>. Otherwise it throws an instance of <em><a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a></em>.</dd>
<dt><strong>Note</strong></dt>
<dd>None of the futures in the input sequence are invalidated. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: [in] The iterator pointing to the first element of a sequence of <em>future</em> or <em>shared_future</em> objects for which <em>wait_any</em> should wait. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: [in] The iterator pointing to the last element of a sequence of <em>future</em> or <em>shared_future</em> objects for which <em>wait_any</em> should wait. </li>
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8wait_anyERNSt6vectorI6futureI1REEER10error_code">
<span id="_CPPv2N3hpx8wait_anyERNSt6vectorI6futureI1REEER10error_code"></span><span id="hpx::wait_any__std::vector:future:R::R.error_codeR"></span><em class="property">template </em>&lt;<em class="property">typename</em> R&gt;<br /><span class="target" id="namespacehpx_1a2f6e1ea8b8e8c8641163dca6bd76a398"></span>void <code class="descname">wait_any</code><span class="sig-paren">(</span>std::vector&lt;future&lt;R&gt;&gt; &amp;<em>futures</em>, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8wait_anyERNSt6vectorI6futureI1REEER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>wait_any</em> is a non-deterministic choice operator. It OR-composes all future objects given and returns after one future of that list finishes execution.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The function <em>wait_any</em> returns after at least one future has become ready. All input futures are still valid after <em>wait_any</em> returns.</dd>
<dt><strong>Note</strong></dt>
<dd>As long as <em>ec</em> is not pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> this function doesn’t throw but returns the result code using the parameter <em>ec</em>. Otherwise it throws an instance of <em><a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a></em>.</dd>
<dt><strong>Note</strong></dt>
<dd>None of the futures in the input sequence are invalidated. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">futures</span></code>: [in] A vector holding an arbitrary amount of <em>future</em> or <em>shared_future</em> objects for which <em>wait_any</em> should wait. </li>
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8wait_anyERNSt5arrayI6futureI1RE1NEER10error_code">
<span id="_CPPv2N3hpx8wait_anyERNSt5arrayI6futureI1RE1NEER10error_code"></span><span id="hpx::wait_any__std::array:future:R:.N:R.error_codeR"></span><em class="property">template </em>&lt;<em class="property">typename</em> R, std:;size_t <em>N</em>&gt;<br /><span class="target" id="namespacehpx_1a494d58af1e4c954cac20c0281e1000a7"></span>void <code class="descname">wait_any</code><span class="sig-paren">(</span>std::array&lt;future&lt;R&gt;, N&gt; &amp;<em>futures</em>, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8wait_anyERNSt5arrayI6futureI1RE1NEER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>wait_any</em> is a non-deterministic choice operator. It OR-composes all future objects given and returns after one future of that list finishes execution.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The function <em>wait_any</em> returns after at least one future has become ready. All input futures are still valid after <em>wait_any</em> returns.</dd>
<dt><strong>Note</strong></dt>
<dd>As long as <em>ec</em> is not pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> this function doesn’t throw but returns the result code using the parameter <em>ec</em>. Otherwise it throws an instance of <em><a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a></em>.</dd>
<dt><strong>Note</strong></dt>
<dd>None of the futures in the input sequence are invalidated. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">futures</span></code>: [in] Amn array holding an arbitrary amount of <em>future</em> or <em>shared_future</em> objects for which <em>wait_any</em> should wait. </li>
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8wait_anyER10error_codeDpRR1T">
<span id="_CPPv2N3hpx8wait_anyER10error_codeDpRR1T"></span><span id="hpx::wait_any__error_codeR.TRRDp"></span><em class="property">template </em>&lt;<em class="property">typename</em> ... <em>T</em>&gt;<br /><span class="target" id="namespacehpx_1a753be8b612b525011128316b03a11a0d"></span>void <code class="descname">wait_any</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em>, T&amp;&amp;... <em>futures</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8wait_anyER10error_codeDpRR1T" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>wait_any</em> is a non-deterministic choice operator. It OR-composes all future objects given and returns after one future of that list finishes execution.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The function <em>wait_any</em> returns after at least one future has become ready. All input futures are still valid after <em>wait_any</em> returns.</dd>
<dt><strong>Note</strong></dt>
<dd>As long as <em>ec</em> is not pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> this function doesn’t throw but returns the result code using the parameter <em>ec</em>. Otherwise it throws an instance of <em><a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a></em>.</dd>
<dt><strong>Note</strong></dt>
<dd>None of the futures in the input sequence are invalidated. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">futures</span></code>: [in] An arbitrary number of <em>future</em> or <em>shared_future</em> objects, possibly holding different types for which <em>wait_any</em> should wait. </li>
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8wait_anyEDpRR1T">
<span id="_CPPv2N3hpx8wait_anyEDpRR1T"></span><span id="hpx::wait_any__TRRDp"></span><em class="property">template </em>&lt;<em class="property">typename</em> ... <em>T</em>&gt;<br /><span class="target" id="namespacehpx_1a7643b830c016c4243d3510e6abbe8518"></span>void <code class="descname">wait_any</code><span class="sig-paren">(</span>T&amp;&amp;... <em>futures</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8wait_anyEDpRR1T" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>wait_any</em> is a non-deterministic choice operator. It OR-composes all future objects given and returns after one future of that list finishes execution.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The function <em>wait_any</em> returns after at least one future has become ready. All input futures are still valid after <em>wait_any</em> returns.</dd>
<dt><strong>Note</strong></dt>
<dd>None of the futures in the input sequence are invalidated. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">futures</span></code>: [in] An arbitrary number of <em>future</em> or <em>shared_future</em> objects, possibly holding different types for which <em>wait_any</em> should wait.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx10wait_any_nE9InputIterNSt6size_tER10error_code">
<span id="_CPPv2N3hpx10wait_any_nE9InputIterNSt6size_tER10error_code"></span><span id="hpx::wait_any_n__InputIter.std::s.error_codeR"></span><em class="property">template </em>&lt;<em class="property">typename</em> InputIter&gt;<br /><span class="target" id="namespacehpx_1a473595a452088ddf13454f952fc85909"></span>InputIter <code class="descname">wait_any_n</code><span class="sig-paren">(</span>InputIter <em>first</em>, std::size_t <em>count</em>, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx10wait_any_nE9InputIterNSt6size_tER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>wait_any_n</em> is a non-deterministic choice operator. It OR-composes all future objects given and returns after one future of that list finishes execution.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The function <em>wait_any_n</em> returns after at least one future has become ready. All input futures are still valid after <em>wait_any_n</em> returns.</dd>
<dt><strong>Return</strong></dt>
<dd>The function <em>wait_all_n</em> will return an iterator referring to the first element in the input sequence after the last processed element.</dd>
<dt><strong>Note</strong></dt>
<dd>As long as <em>ec</em> is not pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> this function doesn’t throw but returns the result code using the parameter <em>ec</em>. Otherwise it throws an instance of <em><a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a></em>.</dd>
<dt><strong>Note</strong></dt>
<dd>None of the futures in the input sequence are invalidated. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: [in] The iterator pointing to the first element of a sequence of <em>future</em> or <em>shared_future</em> objects for which <em>wait_any_n</em> should wait. </li>
<li><code class="docutils literal notranslate"><span class="pre">count</span></code>: [in] The number of elements in the sequence starting at <em>first</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8when_anyE9InputIter9InputIter">
<span id="_CPPv2N3hpx8when_anyE9InputIter9InputIter"></span><span id="hpx::when_any__InputIter.InputIter"></span><em class="property">template </em>&lt;<em class="property">typename</em> InputIter, <em class="property">typename</em> Container = vector&lt;future&lt;typename std::iterator_traits&lt;InputIter&gt;::value_type&gt;&gt;&gt;<br /><span class="target" id="namespacehpx_1a39262d7122af673a49fe039cd8f860d9"></span>future&lt;<a class="reference internal" href="#_CPPv3N3hpx15when_any_resultE" title="hpx::when_any_result">when_any_result</a>&lt;Container&gt;&gt; <code class="descname">when_any</code><span class="sig-paren">(</span>InputIter <em>first</em>, InputIter <em>last</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8when_anyE9InputIter9InputIter" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>when_any</em> is a non-deterministic choice operator. It OR-composes all future objects given and returns a new future object representing the same list of futures after one future of that list finishes execution.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Returns a <a class="reference internal" href="#structhpx_1_1when__any__result"><span class="std std-ref">when_any_result</span></a> holding the same list of futures as has been passed to when_any and an index pointing to a ready future.<ul class="simple">
<li>future&lt;<a class="reference internal" href="#structhpx_1_1when__any__result"><span class="std std-ref">when_any_result</span></a>&lt;Container&lt;future&lt;R&gt;&gt;&gt;&gt;: If the input cardinality is unknown at compile time and the futures are all of the same type. The order of the futures in the output container will be the same as given by the input iterator. </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: [in] The iterator pointing to the first element of a sequence of <em>future</em> or <em>shared_future</em> objects for which <em>when_any</em> should wait. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: [in] The iterator pointing to the last element of a sequence of <em>future</em> or <em>shared_future</em> objects for which <em>when_any</em> should wait.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8when_anyER5Range">
<span id="_CPPv2N3hpx8when_anyER5Range"></span><span id="hpx::when_any__RangeR"></span><em class="property">template </em>&lt;<em class="property">typename</em> Range&gt;<br /><span class="target" id="namespacehpx_1a873832b1838b63f2532ddee810bd3999"></span>future&lt;<a class="reference internal" href="#_CPPv3N3hpx15when_any_resultE" title="hpx::when_any_result">when_any_result</a>&lt;Range&gt;&gt; <code class="descname">when_any</code><span class="sig-paren">(</span>Range &amp;<em>values</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8when_anyER5Range" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>when_any</em> is a non-deterministic choice operator. It OR-composes all future objects given and returns a new future object representing the same list of futures after one future of that list finishes execution.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Returns a <a class="reference internal" href="#structhpx_1_1when__any__result"><span class="std std-ref">when_any_result</span></a> holding the same list of futures as has been passed to when_any and an index pointing to a ready future.<ul class="simple">
<li>future&lt;<a class="reference internal" href="#structhpx_1_1when__any__result"><span class="std std-ref">when_any_result</span></a>&lt;Container&lt;future&lt;R&gt;&gt;&gt;&gt;: If the input cardinality is unknown at compile time and the futures are all of the same type. The order of the futures in the output container will be the same as given by the input iterator. </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">values</span></code>: [in] A range holding an arbitrary amount of <em>futures</em> or <em>shared_future</em> objects for which <em>when_any</em> should wait.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8when_anyEDpRR1T">
<span id="_CPPv2N3hpx8when_anyEDpRR1T"></span><span id="hpx::when_any__TRRDp"></span><em class="property">template </em>&lt;<em class="property">typename</em> ... <em>T</em>&gt;<br /><span class="target" id="namespacehpx_1a30dd3855c03be0f67bd1f2a22f90db65"></span>future&lt;<a class="reference internal" href="#_CPPv3N3hpx15when_any_resultE" title="hpx::when_any_result">when_any_result</a>&lt;tuple&lt;future&lt;T&gt;...&gt;&gt;&gt; <code class="descname">when_any</code><span class="sig-paren">(</span>T&amp;&amp;... <em>futures</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8when_anyEDpRR1T" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>when_any</em> is a non-deterministic choice operator. It OR-composes all future objects given and returns a new future object representing the same list of futures after one future of that list finishes execution.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Returns a <a class="reference internal" href="#structhpx_1_1when__any__result"><span class="std std-ref">when_any_result</span></a> holding the same list of futures as has been passed to when_any and an index pointing to a ready future..<ul class="simple">
<li>future&lt;<a class="reference internal" href="#structhpx_1_1when__any__result"><span class="std std-ref">when_any_result</span></a>&lt;tuple&lt;future&lt;T0&gt;, future&lt;T1&gt;…&gt;&gt;&gt;: If inputs are fixed in number and are of heterogeneous types. The inputs can be any arbitrary number of future objects.</li>
<li>future&lt;<a class="reference internal" href="#structhpx_1_1when__any__result"><span class="std std-ref">when_any_result</span></a>&lt;tuple&lt;&gt;&gt;&gt; if <em>when_any</em> is called with zero arguments. The returned future will be initially ready. </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">futures</span></code>: [in] An arbitrary number of <em>future</em> or <em>shared_future</em> objects, possibly holding different types for which <em>when_any</em> should wait.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx10when_any_nE9InputIterNSt6size_tE">
<span id="_CPPv2N3hpx10when_any_nE9InputIterNSt6size_tE"></span><span id="hpx::when_any_n__InputIter.std::s"></span><em class="property">template </em>&lt;<em class="property">typename</em> InputIter, <em class="property">typename</em> Container = vector&lt;future&lt;typename std::iterator_traits&lt;InputIter&gt;::value_type&gt;&gt;&gt;<br /><span class="target" id="namespacehpx_1a5ce49e380ca54cdfb5418f3b949121c1"></span>future&lt;<a class="reference internal" href="#_CPPv3N3hpx15when_any_resultE" title="hpx::when_any_result">when_any_result</a>&lt;Container&gt;&gt; <code class="descname">when_any_n</code><span class="sig-paren">(</span>InputIter <em>first</em>, std::size_t <em>count</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx10when_any_nE9InputIterNSt6size_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>when_any_n</em> is a non-deterministic choice operator. It OR-composes all future objects given and returns a new future object representing the same list of futures after one future of that list finishes execution.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Returns a <a class="reference internal" href="#structhpx_1_1when__any__result"><span class="std std-ref">when_any_result</span></a> holding the same list of futures as has been passed to when_any and an index pointing to a ready future.<ul class="simple">
<li>future&lt;<a class="reference internal" href="#structhpx_1_1when__any__result"><span class="std std-ref">when_any_result</span></a>&lt;Container&lt;future&lt;R&gt;&gt;&gt;&gt;: If the input cardinality is unknown at compile time and the futures are all of the same type. The order of the futures in the output container will be the same as given by the input iterator.</li>
</ul>
</dd>
<dt><strong>Note</strong></dt>
<dd>None of the futures in the input sequence are invalidated. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: [in] The iterator pointing to the first element of a sequence of <em>future</em> or <em>shared_future</em> objects for which <em>when_any_n</em> should wait. </li>
<li><code class="docutils literal notranslate"><span class="pre">count</span></code>: [in] The number of elements in the sequence starting at <em>first</em>.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx9wait_someENSt6size_tE8Iterator8IteratorR10error_code">
<span id="_CPPv2N3hpx9wait_someENSt6size_tE8Iterator8IteratorR10error_code"></span><span id="hpx::wait_some__std::s.Iterator.Iterator.error_codeR"></span><em class="property">template </em>&lt;<em class="property">typename</em> InputIter&gt;<br /><span class="target" id="namespacehpx_1a3bdc4048a047990e555ed5cc4d907186"></span>future&lt;vector&lt;future&lt;<em class="property">typename</em> std::iterator_traits&lt;InputIter&gt;::value_type&gt;&gt;&gt; <code class="descname">wait_some</code><span class="sig-paren">(</span>std::size_t <em>n</em>, Iterator <em>first</em>, Iterator <em>last</em>, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx9wait_someENSt6size_tE8Iterator8IteratorR10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>wait_some</em> is an operator allowing to join on the result of all given futures. It AND-composes all future objects given and returns a new future object representing the same list of futures after n of them finished executing.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The future returned by the function <em>wait_some</em> becomes ready when at least <em>n</em> argument futures have become ready.</dd>
<dt><strong>Return</strong></dt>
<dd>Returns a future holding the same list of futures as has been passed to wait_some.<ul class="simple">
<li>future&lt;vector&lt;future&lt;R&gt;&gt;&gt;: If the input cardinality is unknown at compile time and the futures are all of the same type.</li>
</ul>
</dd>
<dt><strong>Note</strong></dt>
<dd>Calling this version of <em>wait_some</em> where first == last, returns a future with an empty vector that is immediately ready. Each future and shared_future is waited upon and then copied into the collection of the output (returned) future, maintaining the order of the futures in the input collection. The future returned by <em>wait_some</em> will not throw an exception, but the futures held in the output collection may. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">n</span></code>: [in] The number of futures out of the arguments which have to become ready in order for the returned future to get ready. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: [in] The iterator pointing to the first element of a sequence of <em>future</em> or <em>shared_future</em> objects for which <em>when_all</em> should wait. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: [in] The iterator pointing to the last element of a sequence of <em>future</em> or <em>shared_future</em> objects for which <em>when_all</em> should wait. </li>
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx9wait_someENSt6size_tERRNSt6vectorI6futureI1REEER10error_code">
<span id="_CPPv2N3hpx9wait_someENSt6size_tERRNSt6vectorI6futureI1REEER10error_code"></span><span id="hpx::wait_some__std::s.std::vector:future:R::RR.error_codeR"></span><em class="property">template </em>&lt;<em class="property">typename</em> R&gt;<br /><span class="target" id="namespacehpx_1a5a9f799e2f9d3067a6eb0a50f56c5ff7"></span>void <code class="descname">wait_some</code><span class="sig-paren">(</span>std::size_t <em>n</em>, std::vector&lt;future&lt;R&gt;&gt; &amp;&amp;<em>futures</em>, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx9wait_someENSt6size_tERRNSt6vectorI6futureI1REEER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>wait_some</em> is an operator allowing to join on the result of all given futures. It AND-composes all future objects given and returns a new future object representing the same list of futures after n of them finished executing.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The function <em>wait_all</em> returns after <em>n</em> futures have become ready. All input futures are still valid after <em>wait_all</em> returns.</dd>
<dt><strong>Note</strong></dt>
<dd>Each future and shared_future is waited upon and then copied into the collection of the output (returned) future, maintaining the order of the futures in the input collection. The future returned by <em>wait_some</em> will not throw an exception, but the futures held in the output collection may. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">n</span></code>: [in] The number of futures out of the arguments which have to become ready in order for the returned future to get ready. </li>
<li><code class="docutils literal notranslate"><span class="pre">futures</span></code>: [in] A vector holding an arbitrary amount of <em>future</em> or <em>shared_future</em> objects for which <em>wait_some</em> should wait. </li>
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx9wait_someENSt6size_tERRNSt5arrayI6futureI1RE1NEER10error_code">
<span id="_CPPv2N3hpx9wait_someENSt6size_tERRNSt5arrayI6futureI1RE1NEER10error_code"></span><span id="hpx::wait_some__std::s.std::array:future:R:.N:RR.error_codeR"></span><em class="property">template </em>&lt;<em class="property">typename</em> R, std::size_t <em>N</em>&gt;<br /><span class="target" id="namespacehpx_1a8197e0310ca56f286f76fd320d34d36b"></span>void <code class="descname">wait_some</code><span class="sig-paren">(</span>std::size_t <em>n</em>, std::array&lt;future&lt;R&gt;, N&gt; &amp;&amp;<em>futures</em>, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx9wait_someENSt6size_tERRNSt5arrayI6futureI1RE1NEER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>wait_some</em> is an operator allowing to join on the result of all given futures. It AND-composes all future objects given and returns a new future object representing the same list of futures after n of them finished executing.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The function <em>wait_all</em> returns after <em>n</em> futures have become ready. All input futures are still valid after <em>wait_all</em> returns.</dd>
<dt><strong>Note</strong></dt>
<dd>Each future and shared_future is waited upon and then copied into the collection of the output (returned) future, maintaining the order of the futures in the input collection. The future returned by <em>wait_some</em> will not throw an exception, but the futures held in the output collection may. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">n</span></code>: [in] The number of futures out of the arguments which have to become ready in order for the returned future to get ready. </li>
<li><code class="docutils literal notranslate"><span class="pre">futures</span></code>: [in] An array holding an arbitrary amount of <em>future</em> or <em>shared_future</em> objects for which <em>wait_some</em> should wait. </li>
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx9wait_someENSt6size_tEDpRR1TR10error_code">
<span id="_CPPv2N3hpx9wait_someENSt6size_tEDpRR1TR10error_code"></span><span id="hpx::wait_some__std::s.TRRDp.error_codeR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ... <em>T</em>&gt;<br /><span class="target" id="namespacehpx_1a889a1f42bc0fc5e4adcd480fb41ba7d1"></span>void <code class="descname">wait_some</code><span class="sig-paren">(</span>std::size_t <em>n</em>, T&amp;&amp;... <em>futures</em>, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx9wait_someENSt6size_tEDpRR1TR10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>wait_some</em> is an operator allowing to join on the result of all given futures. It AND-composes all future objects given and returns a new future object representing the same list of futures after n of them finished executing.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The function <em>wait_all</em> returns after <em>n</em> futures have become ready. All input futures are still valid after <em>wait_all</em> returns.</dd>
<dt><strong>Note</strong></dt>
<dd>Calling this version of <em>wait_some</em> where first == last, returns a future with an empty vector that is immediately ready. Each future and shared_future is waited upon and then copied into the collection of the output (returned) future, maintaining the order of the futures in the input collection. The future returned by <em>wait_some</em> will not throw an exception, but the futures held in the output collection may. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">n</span></code>: [in] The number of futures out of the arguments which have to become ready in order for the returned future to get ready. </li>
<li><code class="docutils literal notranslate"><span class="pre">futures</span></code>: [in] An arbitrary number of <em>future</em> or <em>shared_future</em> objects, possibly holding different types for which <em>wait_some</em> should wait. </li>
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx11wait_some_nENSt6size_tE8IteratorNSt6size_tER10error_code">
<span id="_CPPv2N3hpx11wait_some_nENSt6size_tE8IteratorNSt6size_tER10error_code"></span><span id="hpx::wait_some_n__std::s.Iterator.std::s.error_codeR"></span><em class="property">template </em>&lt;<em class="property">typename</em> InputIter&gt;<br /><span class="target" id="namespacehpx_1aa0b7f68e78d76b35853777b2fd736cd6"></span>InputIter <code class="descname">wait_some_n</code><span class="sig-paren">(</span>std::size_t <em>n</em>, Iterator <em>first</em>, std::size_t <em>count</em>, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx11wait_some_nENSt6size_tE8IteratorNSt6size_tER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>wait_some_n</em> is an operator allowing to join on the result of all given futures. It AND-composes all future objects given and returns a new future object representing the same list of futures after n of them finished executing.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The function <em>wait_all</em> returns after <em>n</em> futures have become ready. All input futures are still valid after <em>wait_all</em> returns.</dd>
<dt><strong>Return</strong></dt>
<dd>This function returns an Iterator referring to the first element after the last processed input element.</dd>
<dt><strong>Note</strong></dt>
<dd>Calling this version of <em>wait_some_n</em> where count == 0, returns a future with the same elements as the arguments that is immediately ready. Possibly none of the futures in that vector are ready. Each future and shared_future is waited upon and then copied into the collection of the output (returned) future, maintaining the order of the futures in the input collection. The future returned by <em>wait_some_n</em> will not throw an exception, but the futures held in the output collection may. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">n</span></code>: [in] The number of futures out of the arguments which have to become ready in order for the returned future to get ready. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: [in] The iterator pointing to the first element of a sequence of <em>future</em> or <em>shared_future</em> objects for which <em>when_all</em> should wait. </li>
<li><code class="docutils literal notranslate"><span class="pre">count</span></code>: [in] The number of elements in the sequence starting at <em>first</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx9when_someENSt6size_tE8Iterator8IteratorR10error_code">
<span id="_CPPv2N3hpx9when_someENSt6size_tE8Iterator8IteratorR10error_code"></span><span id="hpx::when_some__std::s.Iterator.Iterator.error_codeR"></span><em class="property">template </em>&lt;<em class="property">typename</em> InputIter, <em class="property">typename</em> Container = vector&lt;future&lt;typename std::iterator_traits&lt;InputIter&gt;::value_type&gt;&gt;&gt;<br /><span class="target" id="namespacehpx_1a4bd1040a6422fc4653e90cdbb56ac8a7"></span>future&lt;<a class="reference internal" href="#_CPPv3N3hpx16when_some_resultE" title="hpx::when_some_result">when_some_result</a>&lt;Container&gt;&gt; <code class="descname">when_some</code><span class="sig-paren">(</span>std::size_t <em>n</em>, Iterator <em>first</em>, Iterator <em>last</em>, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx9when_someENSt6size_tE8Iterator8IteratorR10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>when_some</em> is an operator allowing to join on the result of all given futures. It AND-composes all future objects given and returns a new future object representing the same list of futures after n of them finished executing.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The future returned by the function <em>when_some</em> becomes ready when at least <em>n</em> argument futures have become ready.</dd>
<dt><strong>Return</strong></dt>
<dd>Returns a <a class="reference internal" href="#structhpx_1_1when__some__result"><span class="std std-ref">when_some_result</span></a> holding the same list of futures as has been passed to when_some and indices pointing to ready futures.<ul class="simple">
<li>future&lt;<a class="reference internal" href="#structhpx_1_1when__some__result"><span class="std std-ref">when_some_result</span></a>&lt;Container&lt;future&lt;R&gt;&gt;&gt;&gt;: If the input cardinality is unknown at compile time and the futures are all of the same type. The order of the futures in the output container will be the same as given by the input iterator.</li>
</ul>
</dd>
<dt><strong>Note</strong></dt>
<dd>Calling this version of <em>when_some</em> where first == last, returns a future with an empty container that is immediately ready. Each future and shared_future is waited upon and then copied into the collection of the output (returned) future, maintaining the order of the futures in the input collection. The future returned by <em>when_some</em> will not throw an exception, but the futures held in the output collection may. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">n</span></code>: [in] The number of futures out of the arguments which have to become ready in order for the returned future to get ready. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: [in] The iterator pointing to the first element of a sequence of <em>future</em> or <em>shared_future</em> objects for which <em>when_all</em> should wait. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: [in] The iterator pointing to the last element of a sequence of <em>future</em> or <em>shared_future</em> objects for which <em>when_all</em> should wait. </li>
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx9when_someENSt6size_tERR5RangeR10error_code">
<span id="_CPPv2N3hpx9when_someENSt6size_tERR5RangeR10error_code"></span><span id="hpx::when_some__std::s.RangeRR.error_codeR"></span><em class="property">template </em>&lt;<em class="property">typename</em> Range&gt;<br /><span class="target" id="namespacehpx_1a9f139b5deacfac09f271f5e10e7fb9e8"></span>future&lt;<a class="reference internal" href="#_CPPv3N3hpx16when_some_resultE" title="hpx::when_some_result">when_some_result</a>&lt;Range&gt;&gt; <code class="descname">when_some</code><span class="sig-paren">(</span>std::size_t <em>n</em>, Range &amp;&amp;<em>futures</em>, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx9when_someENSt6size_tERR5RangeR10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>when_some</em> is an operator allowing to join on the result of all given futures. It AND-composes all future objects given and returns a new future object representing the same list of futures after n of them finished executing.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The future returned by the function <em>when_some</em> becomes ready when at least <em>n</em> argument futures have become ready.</dd>
<dt><strong>Return</strong></dt>
<dd>Returns a <a class="reference internal" href="#structhpx_1_1when__some__result"><span class="std std-ref">when_some_result</span></a> holding the same list of futures as has been passed to when_some and indices pointing to ready futures.<ul class="simple">
<li>future&lt;<a class="reference internal" href="#structhpx_1_1when__some__result"><span class="std std-ref">when_some_result</span></a>&lt;Container&lt;future&lt;R&gt;&gt;&gt;&gt;: If the input cardinality is unknown at compile time and the futures are all of the same type. The order of the futures in the output container will be the same as given by the input iterator.</li>
</ul>
</dd>
<dt><strong>Note</strong></dt>
<dd>Each future and shared_future is waited upon and then copied into the collection of the output (returned) future, maintaining the order of the futures in the input collection. The future returned by <em>when_some</em> will not throw an exception, but the futures held in the output collection may. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">n</span></code>: [in] The number of futures out of the arguments which have to become ready in order for the returned future to get ready. </li>
<li><code class="docutils literal notranslate"><span class="pre">futures</span></code>: [in] A container holding an arbitrary amount of <em>future</em> or <em>shared_future</em> objects for which <em>when_some</em> should wait. </li>
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx9when_someENSt6size_tER10error_codeDpRR1T">
<span id="_CPPv2N3hpx9when_someENSt6size_tER10error_codeDpRR1T"></span><span id="hpx::when_some__std::s.error_codeR.TRRDp"></span><em class="property">template </em>&lt;<em class="property">typename</em> ... <em>T</em>&gt;<br /><span class="target" id="namespacehpx_1abe15ece162ff9c9295bf747419457372"></span>future&lt;<a class="reference internal" href="#_CPPv3N3hpx16when_some_resultE" title="hpx::when_some_result">when_some_result</a>&lt;tuple&lt;future&lt;T&gt;...&gt;&gt;&gt; <code class="descname">when_some</code><span class="sig-paren">(</span>std::size_t <em>n</em>, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em>, T&amp;&amp;... <em>futures</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx9when_someENSt6size_tER10error_codeDpRR1T" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>when_some</em> is an operator allowing to join on the result of all given futures. It AND-composes all future objects given and returns a new future object representing the same list of futures after n of them finished executing.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The future returned by the function <em>when_some</em> becomes ready when at least <em>n</em> argument futures have become ready.</dd>
<dt><strong>Return</strong></dt>
<dd>Returns a <a class="reference internal" href="#structhpx_1_1when__some__result"><span class="std std-ref">when_some_result</span></a> holding the same list of futures as has been passed to when_some and an index pointing to a ready future..<ul class="simple">
<li>future&lt;<a class="reference internal" href="#structhpx_1_1when__some__result"><span class="std std-ref">when_some_result</span></a>&lt;tuple&lt;future&lt;T0&gt;, future&lt;T1&gt;…&gt;&gt;&gt;: If inputs are fixed in number and are of heterogeneous types. The inputs can be any arbitrary number of future objects.</li>
<li>future&lt;<a class="reference internal" href="#structhpx_1_1when__some__result"><span class="std std-ref">when_some_result</span></a>&lt;tuple&lt;&gt;&gt;&gt; if <em>when_some</em> is called with zero arguments. The returned future will be initially ready.</li>
</ul>
</dd>
<dt><strong>Note</strong></dt>
<dd>Each future and shared_future is waited upon and then copied into the collection of the output (returned) future, maintaining the order of the futures in the input collection. The future returned by <em>when_some</em> will not throw an exception, but the futures held in the output collection may. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">n</span></code>: [in] The number of futures out of the arguments which have to become ready in order for the returned future to get ready. </li>
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead. </li>
<li><code class="docutils literal notranslate"><span class="pre">futures</span></code>: [in] An arbitrary number of <em>future</em> or <em>shared_future</em> objects, possibly holding different types for which <em>when_some</em> should wait.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx9when_someENSt6size_tEDpRR1T">
<span id="_CPPv2N3hpx9when_someENSt6size_tEDpRR1T"></span><span id="hpx::when_some__std::s.TRRDp"></span><em class="property">template </em>&lt;<em class="property">typename</em> ... <em>T</em>&gt;<br /><span class="target" id="namespacehpx_1aab33ab749e355cd660d4927dca64bb94"></span>future&lt;<a class="reference internal" href="#_CPPv3N3hpx16when_some_resultE" title="hpx::when_some_result">when_some_result</a>&lt;tuple&lt;future&lt;T&gt;...&gt;&gt;&gt; <code class="descname">when_some</code><span class="sig-paren">(</span>std::size_t <em>n</em>, T&amp;&amp;... <em>futures</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx9when_someENSt6size_tEDpRR1T" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>when_some</em> is an operator allowing to join on the result of all given futures. It AND-composes all future objects given and returns a new future object representing the same list of futures after n of them finished executing.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The future returned by the function <em>when_some</em> becomes ready when at least <em>n</em> argument futures have become ready.</dd>
<dt><strong>Return</strong></dt>
<dd>Returns a <a class="reference internal" href="#structhpx_1_1when__some__result"><span class="std std-ref">when_some_result</span></a> holding the same list of futures as has been passed to when_some and an index pointing to a ready future..<ul class="simple">
<li>future&lt;<a class="reference internal" href="#structhpx_1_1when__some__result"><span class="std std-ref">when_some_result</span></a>&lt;tuple&lt;future&lt;T0&gt;, future&lt;T1&gt;…&gt;&gt;&gt;: If inputs are fixed in number and are of heterogeneous types. The inputs can be any arbitrary number of future objects.</li>
<li>future&lt;<a class="reference internal" href="#structhpx_1_1when__some__result"><span class="std std-ref">when_some_result</span></a>&lt;tuple&lt;&gt;&gt;&gt; if <em>when_some</em> is called with zero arguments. The returned future will be initially ready.</li>
</ul>
</dd>
<dt><strong>Note</strong></dt>
<dd>Each future and shared_future is waited upon and then copied into the collection of the output (returned) future, maintaining the order of the futures in the input collection. The future returned by <em>when_some</em> will not throw an exception, but the futures held in the output collection may. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">n</span></code>: [in] The number of futures out of the arguments which have to become ready in order for the returned future to get ready. </li>
<li><code class="docutils literal notranslate"><span class="pre">futures</span></code>: [in] An arbitrary number of <em>future</em> or <em>shared_future</em> objects, possibly holding different types for which <em>when_some</em> should wait.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx11when_some_nENSt6size_tE8IteratorNSt6size_tER10error_code">
<span id="_CPPv2N3hpx11when_some_nENSt6size_tE8IteratorNSt6size_tER10error_code"></span><span id="hpx::when_some_n__std::s.Iterator.std::s.error_codeR"></span><em class="property">template </em>&lt;<em class="property">typename</em> InputIter, <em class="property">typename</em> Container = vector&lt;future&lt;typename std::iterator_traits&lt;InputIter&gt;::value_type&gt;&gt;&gt;<br /><span class="target" id="namespacehpx_1a26b0d20e428ca92acf91daa131116991"></span>future&lt;<a class="reference internal" href="#_CPPv3N3hpx16when_some_resultE" title="hpx::when_some_result">when_some_result</a>&lt;Container&gt;&gt; <code class="descname">when_some_n</code><span class="sig-paren">(</span>std::size_t <em>n</em>, Iterator <em>first</em>, std::size_t <em>count</em>, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx11when_some_nENSt6size_tE8IteratorNSt6size_tER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>when_some_n</em> is an operator allowing to join on the result of all given futures. It AND-composes all future objects given and returns a new future object representing the same list of futures after n of them finished executing.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The future returned by the function <em>when_some_n</em> becomes ready when at least <em>n</em> argument futures have become ready.</dd>
<dt><strong>Return</strong></dt>
<dd>Returns a <a class="reference internal" href="#structhpx_1_1when__some__result"><span class="std std-ref">when_some_result</span></a> holding the same list of futures as has been passed to when_some and indices pointing to ready futures.<ul class="simple">
<li>future&lt;<a class="reference internal" href="#structhpx_1_1when__some__result"><span class="std std-ref">when_some_result</span></a>&lt;Container&lt;future&lt;R&gt;&gt;&gt;&gt;: If the input cardinality is unknown at compile time and the futures are all of the same type. The order of the futures in the output container will be the same as given by the input iterator.</li>
</ul>
</dd>
<dt><strong>Note</strong></dt>
<dd>Calling this version of <em>when_some_n</em> where count == 0, returns a future with the same elements as the arguments that is immediately ready. Possibly none of the futures in that container are ready. Each future and shared_future is waited upon and then copied into the collection of the output (returned) future, maintaining the order of the futures in the input collection. The future returned by <em>when_some_n</em> will not throw an exception, but the futures held in the output collection may. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">n</span></code>: [in] The number of futures out of the arguments which have to become ready in order for the returned future to get ready. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: [in] The iterator pointing to the first element of a sequence of <em>future</em> or <em>shared_future</em> objects for which <em>when_all</em> should wait. </li>
<li><code class="docutils literal notranslate"><span class="pre">count</span></code>: [in] The number of elements in the sequence starting at <em>first</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx9wait_eachERR1FRRNSt6vectorI6FutureEE">
<span id="_CPPv2N3hpx9wait_eachERR1FRRNSt6vectorI6FutureEE"></span><span id="hpx::wait_each__FRR.std::vector:Future:RR"></span><em class="property">template </em>&lt;<em class="property">typename</em> F, <em class="property">typename</em> Future&gt;<br /><span class="target" id="namespacehpx_1ac6b482038537407a111c5cd1450e7da3"></span>void <code class="descname">wait_each</code><span class="sig-paren">(</span>F &amp;&amp;<em>f</em>, std::vector&lt;Future&gt; &amp;&amp;<em>futures</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx9wait_eachERR1FRRNSt6vectorI6FutureEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>wait_each</em> is an operator allowing to join on the results of all given futures. It AND-composes all future objects given and returns after they finished executing. Additionally, the supplied function is called for each of the passed futures as soon as the future has become ready. <em>wait_each</em> returns after all futures have been become ready.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function consumes the futures as they are passed on to the supplied function. The callback should take one or two parameters, namely either a <em>future</em> to be processed or a type that <em>std::size_t</em> is implicitly convertible to as the first parameter and the <em>future</em> as the second parameter. The first parameter will correspond to the index of the current <em>future</em> in the collection. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: The function which will be called for each of the input futures once the future has become ready. </li>
<li><code class="docutils literal notranslate"><span class="pre">futures</span></code>: A vector holding an arbitrary amount of <em>future</em> or <em>shared_future</em> objects for which <em>wait_each</em> should wait.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx9wait_eachERR1F8Iterator8Iterator">
<span id="_CPPv2N3hpx9wait_eachERR1F8Iterator8Iterator"></span><span id="hpx::wait_each__FRR.Iterator.Iterator"></span><em class="property">template </em>&lt;<em class="property">typename</em> F, <em class="property">typename</em> Iterator&gt;<br /><span class="target" id="namespacehpx_1a1f84c6d619603f1f006332b38282827b"></span>void <code class="descname">wait_each</code><span class="sig-paren">(</span>F &amp;&amp;<em>f</em>, Iterator <em>begin</em>, Iterator <em>end</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx9wait_eachERR1F8Iterator8Iterator" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>wait_each</em> is an operator allowing to join on the results of all given futures. It AND-composes all future objects given and returns after they finished executing. Additionally, the supplied function is called for each of the passed futures as soon as the future has become ready. <em>wait_each</em> returns after all futures have been become ready.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function consumes the futures as they are passed on to the supplied function. The callback should take one or two parameters, namely either a <em>future</em> to be processed or a type that <em>std::size_t</em> is implicitly convertible to as the first parameter and the <em>future</em> as the second parameter. The first parameter will correspond to the index of the current <em>future</em> in the collection. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: The function which will be called for each of the input futures once the future has become ready. </li>
<li><code class="docutils literal notranslate"><span class="pre">begin</span></code>: The iterator pointing to the first element of a sequence of <em>future</em> or <em>shared_future</em> objects for which <em>wait_each</em> should wait. </li>
<li><code class="docutils literal notranslate"><span class="pre">end</span></code>: The iterator pointing to the last element of a sequence of <em>future</em> or <em>shared_future</em> objects for which <em>wait_each</em> should wait.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx9wait_eachERR1FDpRR1T">
<span id="_CPPv2N3hpx9wait_eachERR1FDpRR1T"></span><span id="hpx::wait_each__FRR.TRRDp"></span><em class="property">template </em>&lt;<em class="property">typename</em> F, <em class="property">typename</em> ... <em>T</em>&gt;<br /><span class="target" id="namespacehpx_1ae4f21fe90a34bf80db58da41f1e1c927"></span>void <code class="descname">wait_each</code><span class="sig-paren">(</span>F &amp;&amp;<em>f</em>, T&amp;&amp;... <em>futures</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx9wait_eachERR1FDpRR1T" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>wait_each</em> is an operator allowing to join on the results of all given futures. It AND-composes all future objects given and returns after they finished executing. Additionally, the supplied function is called for each of the passed futures as soon as the future has become ready. <em>wait_each</em> returns after all futures have been become ready.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function consumes the futures as they are passed on to the supplied function. The callback should take one or two parameters, namely either a <em>future</em> to be processed or a type that <em>std::size_t</em> is implicitly convertible to as the first parameter and the <em>future</em> as the second parameter. The first parameter will correspond to the index of the current <em>future</em> in the collection. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: The function which will be called for each of the input futures once the future has become ready. </li>
<li><code class="docutils literal notranslate"><span class="pre">futures</span></code>: An arbitrary number of <em>future</em> or <em>shared_future</em> objects, possibly holding different types for which <em>wait_each</em> should wait.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx11wait_each_nERR1F8IteratorNSt6size_tE">
<span id="_CPPv2N3hpx11wait_each_nERR1F8IteratorNSt6size_tE"></span><span id="hpx::wait_each_n__FRR.Iterator.std::s"></span><em class="property">template </em>&lt;<em class="property">typename</em> F, <em class="property">typename</em> Iterator&gt;<br /><span class="target" id="namespacehpx_1aa9dbb6eec3a4793006888ce9319cef7f"></span>void <code class="descname">wait_each_n</code><span class="sig-paren">(</span>F &amp;&amp;<em>f</em>, Iterator <em>begin</em>, std::size_t <em>count</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx11wait_each_nERR1F8IteratorNSt6size_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>wait_each</em> is an operator allowing to join on the result of all given futures. It AND-composes all future objects given and returns after they finished executing. Additionally, the supplied function is called for each of the passed futures as soon as the future has become ready.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function consumes the futures as they are passed on to the supplied function. The callback should take one or two parameters, namely either a <em>future</em> to be processed or a type that <em>std::size_t</em> is implicitly convertible to as the first parameter and the <em>future</em> as the second parameter. The first parameter will correspond to the index of the current <em>future</em> in the collection. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: The function which will be called for each of the input futures once the future has become ready. </li>
<li><code class="docutils literal notranslate"><span class="pre">begin</span></code>: The iterator pointing to the first element of a sequence of <em>future</em> or <em>shared_future</em> objects for which <em>wait_each_n</em> should wait. </li>
<li><code class="docutils literal notranslate"><span class="pre">count</span></code>: The number of elements in the sequence starting at <em>first</em>.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx9when_eachERR1FRRNSt6vectorI6FutureEE">
<span id="_CPPv2N3hpx9when_eachERR1FRRNSt6vectorI6FutureEE"></span><span id="hpx::when_each__FRR.std::vector:Future:RR"></span><em class="property">template </em>&lt;<em class="property">typename</em> F, <em class="property">typename</em> Future&gt;<br /><span class="target" id="namespacehpx_1a28891e415cdd55013fc8bfb772ba1033"></span>future&lt;void&gt; <code class="descname">when_each</code><span class="sig-paren">(</span>F &amp;&amp;<em>f</em>, std::vector&lt;Future&gt; &amp;&amp;<em>futures</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx9when_eachERR1FRRNSt6vectorI6FutureEE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>when_each</em> is an operator allowing to join on the results of all given futures. It AND-composes all future objects given and returns a new future object representing the event of all those futures having finished executing. It also calls the supplied callback for each of the futures which becomes ready.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function consumes the futures as they are passed on to the supplied function. The callback should take one or two parameters, namely either a <em>future</em> to be processed or a type that <em>std::size_t</em> is implicitly convertible to as the first parameter and the <em>future</em> as the second parameter. The first parameter will correspond to the index of the current <em>future</em> in the collection.</dd>
<dt><strong>Return</strong></dt>
<dd>Returns a future representing the event of all input futures being ready. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: The function which will be called for each of the input futures once the future has become ready.</li>
<li><code class="docutils literal notranslate"><span class="pre">futures</span></code>: A vector holding an arbitrary amount of <em>future</em> or <em>shared_future</em> objects for which <em>wait_each</em> should wait.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx9when_eachERR1F8Iterator8Iterator">
<span id="_CPPv2N3hpx9when_eachERR1F8Iterator8Iterator"></span><span id="hpx::when_each__FRR.Iterator.Iterator"></span><em class="property">template </em>&lt;<em class="property">typename</em> F, <em class="property">typename</em> Iterator&gt;<br /><span class="target" id="namespacehpx_1aa6092f39d3499b082417824545bab9c7"></span>future&lt;Iterator&gt; <code class="descname">when_each</code><span class="sig-paren">(</span>F &amp;&amp;<em>f</em>, Iterator <em>begin</em>, Iterator <em>end</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx9when_eachERR1F8Iterator8Iterator" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>when_each</em> is an operator allowing to join on the results of all given futures. It AND-composes all future objects given and returns a new future object representing the event of all those futures having finished executing. It also calls the supplied callback for each of the futures which becomes ready.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function consumes the futures as they are passed on to the supplied function. The callback should take one or two parameters, namely either a <em>future</em> to be processed or a type that <em>std::size_t</em> is implicitly convertible to as the first parameter and the <em>future</em> as the second parameter. The first parameter will correspond to the index of the current <em>future</em> in the collection.</dd>
<dt><strong>Return</strong></dt>
<dd>Returns a future representing the event of all input futures being ready. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: The function which will be called for each of the input futures once the future has become ready. </li>
<li><code class="docutils literal notranslate"><span class="pre">begin</span></code>: The iterator pointing to the first element of a sequence of <em>future</em> or <em>shared_future</em> objects for which <em>wait_each</em> should wait. </li>
<li><code class="docutils literal notranslate"><span class="pre">end</span></code>: The iterator pointing to the last element of a sequence of <em>future</em> or <em>shared_future</em> objects for which <em>wait_each</em> should wait.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx9when_eachERR1FDpRR2Ts">
<span id="_CPPv2N3hpx9when_eachERR1FDpRR2Ts"></span><span id="hpx::when_each__FRR.TsRRDp"></span><em class="property">template </em>&lt;<em class="property">typename</em> F, typename... <em>Ts</em>&gt;<br /><span class="target" id="namespacehpx_1a19551f2294b4e5d05601873845e00537"></span>future&lt;void&gt; <code class="descname">when_each</code><span class="sig-paren">(</span>F &amp;&amp;<em>f</em>, Ts&amp;&amp;... <em>futures</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx9when_eachERR1FDpRR2Ts" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>when_each</em> is an operator allowing to join on the results of all given futures. It AND-composes all future objects given and returns a new future object representing the event of all those futures having finished executing. It also calls the supplied callback for each of the futures which becomes ready.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function consumes the futures as they are passed on to the supplied function. The callback should take one or two parameters, namely either a <em>future</em> to be processed or a type that <em>std::size_t</em> is implicitly convertible to as the first parameter and the <em>future</em> as the second parameter. The first parameter will correspond to the index of the current <em>future</em> in the collection.</dd>
<dt><strong>Return</strong></dt>
<dd>Returns a future representing the event of all input futures being ready. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: The function which will be called for each of the input futures once the future has become ready. </li>
<li><code class="docutils literal notranslate"><span class="pre">futures</span></code>: An arbitrary number of <em>future</em> or <em>shared_future</em> objects, possibly holding different types for which <em>wait_each</em> should wait.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx11when_each_nERR1F8IteratorNSt6size_tE">
<span id="_CPPv2N3hpx11when_each_nERR1F8IteratorNSt6size_tE"></span><span id="hpx::when_each_n__FRR.Iterator.std::s"></span><em class="property">template </em>&lt;<em class="property">typename</em> F, <em class="property">typename</em> Iterator&gt;<br /><span class="target" id="namespacehpx_1a3ffc42990d742339663bdcca1785a9b8"></span>future&lt;Iterator&gt; <code class="descname">when_each_n</code><span class="sig-paren">(</span>F &amp;&amp;<em>f</em>, Iterator <em>begin</em>, std::size_t <em>count</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx11when_each_nERR1F8IteratorNSt6size_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>when_each</em> is an operator allowing to join on the results of all given futures. It AND-composes all future objects given and returns a new future object representing the event of all those futures having finished executing. It also calls the supplied callback for each of the futures which becomes ready.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function consumes the futures as they are passed on to the supplied function. The callback should take one or two parameters, namely either a <em>future</em> to be processed or a type that <em>std::size_t</em> is implicitly convertible to as the first parameter and the <em>future</em> as the second parameter. The first parameter will correspond to the index of the current <em>future</em> in the collection.</dd>
<dt><strong>Return</strong></dt>
<dd>Returns a future holding the iterator pointing to the first element after the last one. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: The function which will be called for each of the input futures once the future has become ready. </li>
<li><code class="docutils literal notranslate"><span class="pre">begin</span></code>: The iterator pointing to the first element of a sequence of <em>future</em> or <em>shared_future</em> objects for which <em>wait_each_n</em> should wait. </li>
<li><code class="docutils literal notranslate"><span class="pre">count</span></code>: The number of elements in the sequence starting at <em>first</em>.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Variables</p>
<dl class="member">
<dt id="_CPPv3N3hpx6throwsE">
<span id="_CPPv2N3hpx6throwsE"></span><span id="hpx::throws__error_code"></span><span class="target" id="namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"></span><a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> <code class="descname">throws</code><a class="headerlink" href="#_CPPv3N3hpx6throwsE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Predefined <a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">error_code</span></a> object used as “throw on error” tag. </p>
<p>The predefined <a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">hpx::error_code</span></a> object <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> is supplied for use as a “throw on error” tag.</p>
<p>Functions that specify an argument in the form ‘<a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">error_code</span></a>&amp; ec=throws’ (with appropriate namespace qualifiers), have the following error handling semantics:</p>
<p>If &amp;ec != &amp;throws and an error occurred: ec.value() returns the implementation specific error number for the particular error that occurred and ec.category() returns the error_category for ec.value().</p>
<p>If &amp;ec != &amp;throws and an error did not occur, ec.clear().</p>
<p>If an error occurs and &amp;ec == &amp;throws, the function throws an exception of type <em><a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a></em> or of a type derived from it. The exception’s <em>get_errorcode()</em> member function returns a reference to an <em><a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">hpx::error_code</span></a></em> object with the behavior as specified above. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx7actionsE">
<span id="_CPPv2N3hpx7actionsE"></span><span id="hpx::actions"></span><span class="target" id="namespacehpx_1_1actions"></span><em class="property">namespace </em><code class="descname">actions</code><a class="headerlink" href="#_CPPv3N3hpx7actionsE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx7applierE">
<span id="_CPPv2N3hpx7applierE"></span><span id="hpx::applier"></span><span class="target" id="namespacehpx_1_1applier"></span><em class="property">namespace </em><code class="descname">applier</code><a class="headerlink" href="#_CPPv3N3hpx7applierE" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx7applier11get_applierEv">
<span id="_CPPv2N3hpx7applier11get_applierEv"></span><span id="hpx::applier::get_applier"></span><span class="target" id="namespacehpx_1_1applier_1a8436a8d528e58052e8162be86c21d2c5"></span><a class="reference internal" href="#_CPPv3N3hpx7applierE" title="hpx::applier">applier</a> &amp;<code class="descname">get_applier</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx7applier11get_applierEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>get_applier</em> returns a reference to the (thread specific) applier instance. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7applier15get_applier_ptrEv">
<span id="_CPPv2N3hpx7applier15get_applier_ptrEv"></span><span id="hpx::applier::get_applier_ptr"></span><span class="target" id="namespacehpx_1_1applier_1a3a5e95b60a060ddf7ea21d677d5a7aba"></span><a class="reference internal" href="#_CPPv3N3hpx7applierE" title="hpx::applier">applier</a> *<code class="descname">get_applier_ptr</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx7applier15get_applier_ptrEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>get_applier</em> returns a pointer to the (thread specific) applier instance. The returned pointer is NULL if the current thread is not known to HPX or if the runtime system is not active. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx10componentsE">
<span id="_CPPv2N3hpx10componentsE"></span><span id="hpx::components"></span><span class="target" id="namespacehpx_1_1components"></span><em class="property">namespace </em><code class="descname">components</code><a class="headerlink" href="#_CPPv3N3hpx10componentsE" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx10components20migrate_from_storageERN6naming7id_typeERN6naming7id_typeE">
<span id="_CPPv2N3hpx10components20migrate_from_storageERN6naming7id_typeERN6naming7id_typeE"></span><span id="hpx::components::migrate_from_storage__naming::id_typeCR.naming::id_typeCR"></span><em class="property">template </em>&lt;<em class="property">typename</em> Component&gt;<br /><span class="target" id="namespacehpx_1_1components_1ab9d1dd359539cdab7532b47f4153b66d"></span>future&lt;<a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type&gt; <code class="descname">migrate_from_storage</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type <em class="property">const</em> &amp;<em>to_resurrect</em>, <a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type <em class="property">const</em> &amp;<em>target</em> = <a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::invalid_id<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx10components20migrate_from_storageERN6naming7id_typeERN6naming7id_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Migrate the component with the given id from the specified target storage (resurrect the object)</p>
<p>The function <em>migrate_from_storage&lt;Component&gt;</em> will migrate the component referenced by <em>to_resurrect</em> from the storage facility specified where the object is currently stored on. It returns a future referring to the migrated component instance. The component instance is resurrected on the locality specified by <em>target_locality</em>.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>A future representing the global id of the migrated component instance. This should be the same as <em>to_resurrect</em>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">to_resurrect</span></code>: [in] The global id of the component to migrate. </li>
<li><code class="docutils literal notranslate"><span class="pre">target</span></code>: [in] The optional locality to resurrect the object on. By default the object is resurrected on the locality it was located on last.</li>
</ul>
</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">The</span></code>: only template argument specifies the component type of the component to migrate from the given storage facility.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx10components18migrate_to_storageERN6naming7id_typeERN6naming7id_typeE">
<span id="_CPPv2N3hpx10components18migrate_to_storageERN6naming7id_typeERN6naming7id_typeE"></span><span id="hpx::components::migrate_to_storage__naming::id_typeCR.naming::id_typeCR"></span><em class="property">template </em>&lt;<em class="property">typename</em> Component&gt;<br /><span class="target" id="namespacehpx_1_1components_1a4541854c4c450e3eae2621296d9bc8e5"></span>future&lt;<a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type&gt; <code class="descname">migrate_to_storage</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type <em class="property">const</em> &amp;<em>to_migrate</em>, <a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type <em class="property">const</em> &amp;<em>target_storage</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx10components18migrate_to_storageERN6naming7id_typeERN6naming7id_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Migrate the component with the given id to the specified target storage</p>
<p>The function <em>migrate_to_storage&lt;Component&gt;</em> will migrate the component referenced by <em>to_migrate</em> to the storage facility specified with <em>target_storage</em>. It returns a future referring to the migrated component instance.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>A future representing the global id of the migrated component instance. This should be the same as <em>migrate_to</em>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">to_migrate</span></code>: [in] The global id of the component to migrate. </li>
<li><code class="docutils literal notranslate"><span class="pre">target_storage</span></code>: [in] The id of the storage facility to migrate this object to.</li>
</ul>
</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">The</span></code>: only template argument specifies the component type of the component to migrate to the given storage facility.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx10components18migrate_to_storageER11client_baseI7Derived4StubERN3hpx10components17component_storageE">
<span id="_CPPv2N3hpx10components18migrate_to_storageER11client_baseI7Derived4StubERN3hpx10components17component_storageE"></span><span id="hpx::components::migrate_to_storage__client_base:Derived.Stub:CR.hpx::components::component_storageCR"></span><em class="property">template </em>&lt;<em class="property">typename</em> Derived, <em class="property">typename</em> Stub&gt;<br /><span class="target" id="namespacehpx_1_1components_1a301d835079ce0ed82160a9aafd43e234"></span>Derived <code class="descname">migrate_to_storage</code><span class="sig-paren">(</span>client_base&lt;Derived, Stub&gt; <em class="property">const</em> &amp;<em>to_migrate</em>, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx10componentsE" title="hpx::components">components</a>::component_storage <em class="property">const</em> &amp;<em>target_storage</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx10components18migrate_to_storageER11client_baseI7Derived4StubERN3hpx10components17component_storageE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Migrate the given component to the specified target storage</p>
<p>The function <em>migrate_to_storage</em> will migrate the component referenced by <em>to_migrate</em> to the storage facility specified with <em>target_storage</em>. It returns a future referring to the migrated component instance.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>A client side representation of representing of the migrated component instance. This should be the same as <em>migrate_to</em>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">to_migrate</span></code>: [in] The client side representation of the component to migrate. </li>
<li><code class="docutils literal notranslate"><span class="pre">target_storage</span></code>: [in] The id of the storage facility to migrate this object to.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx10components4copyERN6naming7id_typeE">
<span id="_CPPv2N3hpx10components4copyERN6naming7id_typeE"></span><span id="hpx::components::copy__naming::id_typeCR"></span><em class="property">template </em>&lt;<em class="property">typename</em> Component&gt;<br /><span class="target" id="namespacehpx_1_1components_1a7c546317ebb5ae649f8abcd6249195c4"></span>future&lt;<a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type&gt; <code class="descname">copy</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type <em class="property">const</em> &amp;<em>to_copy</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx10components4copyERN6naming7id_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy given component to the specified target locality. </p>
<p>The function <em>copy&lt;Component&gt;</em> will create a copy of the component referenced by <em>to_copy</em> on the locality specified with <em>target_locality</em>. It returns a future referring to the newly created component instance.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>A future representing the global id of the newly (copied) component instance.</dd>
<dt><strong>Note</strong></dt>
<dd>The new component instance is created on the locality of the component instance which is to be copied. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">to_copy</span></code>: [in] The global id of the component to copy</li>
</ul>
</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">The</span></code>: only template argument specifies the component type to create.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx10components4copyERN6naming7id_typeERN6naming7id_typeE">
<span id="_CPPv2N3hpx10components4copyERN6naming7id_typeERN6naming7id_typeE"></span><span id="hpx::components::copy__naming::id_typeCR.naming::id_typeCR"></span><em class="property">template </em>&lt;<em class="property">typename</em> Component&gt;<br /><span class="target" id="namespacehpx_1_1components_1a1f96d037afe36fff147002345a3ac396"></span>future&lt;<a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type&gt; <code class="descname">copy</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type <em class="property">const</em> &amp;<em>to_copy</em>, <a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type <em class="property">const</em> &amp;<em>target_locality</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx10components4copyERN6naming7id_typeERN6naming7id_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy given component to the specified target locality. </p>
<p>The function <em>copy&lt;Component&gt;</em> will create a copy of the component referenced by <em>to_copy</em> on the locality specified with <em>target_locality</em>. It returns a future referring to the newly created component instance.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>A future representing the global id of the newly (copied) component instance. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">to_copy</span></code>: [in] The global id of the component to copy </li>
<li><code class="docutils literal notranslate"><span class="pre">target_locality</span></code>: [in ] The locality where the copy should be created.</li>
</ul>
</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">The</span></code>: only template argument specifies the component type to create.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx10components4copyER11client_baseI7Derived4StubERN6naming7id_typeE">
<span id="_CPPv2N3hpx10components4copyER11client_baseI7Derived4StubERN6naming7id_typeE"></span><span id="hpx::components::copy__client_base:Derived.Stub:CR.naming::id_typeCR"></span><em class="property">template </em>&lt;<em class="property">typename</em> Derived, <em class="property">typename</em> Stub&gt;<br /><span class="target" id="namespacehpx_1_1components_1a2ca635455c7ad7b6c71b4b75ad0a1095"></span>Derived <code class="descname">copy</code><span class="sig-paren">(</span>client_base&lt;Derived, Stub&gt; <em class="property">const</em> &amp;<em>to_copy</em>, <a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type <em class="property">const</em> &amp;<em>target_locality</em> = <a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::invalid_id<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx10components4copyER11client_baseI7Derived4StubERN6naming7id_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copy given component to the specified target locality. </p>
<p>The function <em>copy</em> will create a copy of the component referenced by the client side object <em>to_copy</em> on the locality specified with <em>target_locality</em>. It returns a new client side object future referring to the newly created component instance.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>A future representing the global id of the newly (copied) component instance.</dd>
<dt><strong>Note</strong></dt>
<dd>If the second argument is omitted (or is invalid_id) the new component instance is created on the locality of the component instance which is to be copied. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">to_copy</span></code>: [in] The client side object representing the component to copy </li>
<li><code class="docutils literal notranslate"><span class="pre">target_locality</span></code>: [in, optional] The locality where the copy should be created (default is same locality as source).</li>
</ul>
</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">The</span></code>: only template argument specifies the component type to create.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx10components7migrateERN6naming7id_typeER10DistPolicy">
<span id="_CPPv2N3hpx10components7migrateERN6naming7id_typeER10DistPolicy"></span><span id="hpx::components::migrate__naming::id_typeCR.DistPolicyCR"></span><em class="property">template </em>&lt;<em class="property">typename</em> Component, <em class="property">typename</em> DistPolicy&gt;<br /><span class="target" id="namespacehpx_1_1components_1a7e2c5af829fbb9901c2405493a616d6c"></span>future&lt;<a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type&gt; <code class="descname">migrate</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type <em class="property">const</em> &amp;<em>to_migrate</em>, DistPolicy <em class="property">const</em> &amp;<em>policy</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx10components7migrateERN6naming7id_typeER10DistPolicy" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Migrate the given component to the specified target locality</p>
<p>The function <em>migrate&lt;Component&gt;</em> will migrate the component referenced by <em>to_migrate</em> to the locality specified with <em>target_locality</em>. It returns a future referring to the migrated component instance.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>A future representing the global id of the migrated component instance. This should be the same as <em>migrate_to</em>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">to_migrate</span></code>: [in] The client side representation of the component to migrate. </li>
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: [in] A distribution policy which will be used to determine the locality to migrate this object to.</li>
</ul>
</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">Component</span></code>: Specifies the component type of the component to migrate. </li>
<li><code class="docutils literal notranslate"><span class="pre">DistPolicy</span></code>: Specifies the distribution policy to use to determine the destination locality.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx10components7migrateER11client_baseI7Derived4StubER10DistPolicy">
<span id="_CPPv2N3hpx10components7migrateER11client_baseI7Derived4StubER10DistPolicy"></span><span id="hpx::components::migrate__client_base:Derived.Stub:CR.DistPolicyCR"></span><em class="property">template </em>&lt;<em class="property">typename</em> Derived, <em class="property">typename</em> Stub, <em class="property">typename</em> DistPolicy&gt;<br /><span class="target" id="namespacehpx_1_1components_1a68273f08ca4e312d977d563be6449853"></span>Derived <code class="descname">migrate</code><span class="sig-paren">(</span>client_base&lt;Derived, Stub&gt; <em class="property">const</em> &amp;<em>to_migrate</em>, DistPolicy <em class="property">const</em> &amp;<em>policy</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx10components7migrateER11client_baseI7Derived4StubER10DistPolicy" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Migrate the given component to the specified target locality</p>
<p>The function <em>migrate&lt;Component&gt;</em> will migrate the component referenced by <em>to_migrate</em> to the locality specified with <em>target_locality</em>. It returns a future referring to the migrated component instance.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>A future representing the global id of the migrated component instance. This should be the same as <em>migrate_to</em>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">to_migrate</span></code>: [in] The client side representation of the component to migrate. </li>
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: [in] A distribution policy which will be used to determine the locality to migrate this object to.</li>
</ul>
</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">Derived</span></code>: Specifies the component type of the component to migrate. </li>
<li><code class="docutils literal notranslate"><span class="pre">DistPolicy</span></code>: Specifies the distribution policy to use to determine the destination locality.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx10components7migrateERN6naming7id_typeERN6naming7id_typeE">
<span id="_CPPv2N3hpx10components7migrateERN6naming7id_typeERN6naming7id_typeE"></span><span id="hpx::components::migrate__naming::id_typeCR.naming::id_typeCR"></span><em class="property">template </em>&lt;<em class="property">typename</em> Component&gt;<br /><span class="target" id="namespacehpx_1_1components_1a8f0f8f01c06a5336aec73d8a59d29a2a"></span>future&lt;<a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type&gt; <code class="descname">migrate</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type <em class="property">const</em> &amp;<em>to_migrate</em>, <a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type <em class="property">const</em> &amp;<em>target_locality</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx10components7migrateERN6naming7id_typeERN6naming7id_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Migrate the component with the given id to the specified target locality</p>
<p>The function <em>migrate&lt;Component&gt;</em> will migrate the component referenced by <em>to_migrate</em> to the locality specified with <em>target_locality</em>. It returns a future referring to the migrated component instance.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>A future representing the global id of the migrated component instance. This should be the same as <em>migrate_to</em>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">to_migrate</span></code>: [in] The global id of the component to migrate. </li>
<li><code class="docutils literal notranslate"><span class="pre">target_locality</span></code>: [in] The locality where the component should be migrated to.</li>
</ul>
</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">Component</span></code>: Specifies the component type of the component to migrate.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx10components7migrateER11client_baseI7Derived4StubERN6naming7id_typeE">
<span id="_CPPv2N3hpx10components7migrateER11client_baseI7Derived4StubERN6naming7id_typeE"></span><span id="hpx::components::migrate__client_base:Derived.Stub:CR.naming::id_typeCR"></span><em class="property">template </em>&lt;<em class="property">typename</em> Derived, <em class="property">typename</em> Stub&gt;<br /><span class="target" id="namespacehpx_1_1components_1a2a6edcf4641235d791e3862dfb6075bf"></span>Derived <code class="descname">migrate</code><span class="sig-paren">(</span>client_base&lt;Derived, Stub&gt; <em class="property">const</em> &amp;<em>to_migrate</em>, <a class="reference internal" href="#_CPPv3N3hpx6namingE" title="hpx::naming">naming</a>::id_type <em class="property">const</em> &amp;<em>target_locality</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx10components7migrateER11client_baseI7Derived4StubERN6naming7id_typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Migrate the given component to the specified target locality</p>
<p>The function <em>migrate&lt;Component&gt;</em> will migrate the component referenced by <em>to_migrate</em> to the locality specified with <em>target_locality</em>. It returns a future referring to the migrated component instance.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>A client side representation of representing of the migrated component instance. This should be the same as <em>migrate_to</em>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">to_migrate</span></code>: [in] The client side representation of the component to migrate. </li>
<li><code class="docutils literal notranslate"><span class="pre">target_locality</span></code>: [in] The id of the locality to migrate this object to.</li>
</ul>
</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">Derived</span></code>: Specifies the component type of the component to migrate.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Variables</p>
<dl class="member">
<dt id="_CPPv3N3hpx10components31default_binpacking_counter_nameE">
<span id="_CPPv2N3hpx10components31default_binpacking_counter_nameE"></span><span id="hpx::components::default_binpacking_counter_name__cCPC"></span><span class="target" id="namespacehpx_1_1components_1a66cbdfe3b4c6ce5df4ffee4c1ed3b403"></span>char <em class="property">const</em> *<em class="property">const</em> <code class="descname">default_binpacking_counter_name</code><p>=</p>
<p>        “/runtime{locality/total}/count/component&#64;”</p>
<a class="headerlink" href="#_CPPv3N3hpx10components31default_binpacking_counter_nameE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="member">
<dt id="_CPPv3N3hpx10components9binpackedE">
<span id="_CPPv2N3hpx10components9binpackedE"></span><span id="hpx::components::binpacked__binpacking_distribution_policyC"></span><span class="target" id="namespacehpx_1_1components_1a59e6eb1d1c50f0fe2915fe004aaaa3a8"></span><a class="reference internal" href="#_CPPv3N3hpx10components30binpacking_distribution_policyE" title="hpx::components::binpacking_distribution_policy">binpacking_distribution_policy</a> <em class="property">const</em> <code class="descname">binpacked</code><a class="headerlink" href="#_CPPv3N3hpx10components9binpackedE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A predefined instance of the binpacking <em>distribution_policy</em>. It will represent the local locality and will place all items to create here. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv3N3hpx10components9colocatedE">
<span id="_CPPv2N3hpx10components9colocatedE"></span><span id="hpx::components::colocated__colocating_distribution_policyC"></span><span class="target" id="namespacehpx_1_1components_1a61a4bf8b4a51be1160eca7e26f48334f"></span><a class="reference internal" href="#_CPPv3N3hpx10components30colocating_distribution_policyE" title="hpx::components::colocating_distribution_policy">colocating_distribution_policy</a> <em class="property">const</em> <code class="descname">colocated</code><a class="headerlink" href="#_CPPv3N3hpx10components9colocatedE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A predefined instance of the co-locating <em>distribution_policy</em>. It will represent the local locality and will place all items to create here. </p>
</dd></dl>

<dl class="member">
<dt id="_CPPv3N3hpx10components14default_layoutE">
<span id="_CPPv2N3hpx10components14default_layoutE"></span><span id="hpx::components::default_layout__default_distribution_policyC"></span><span class="target" id="namespacehpx_1_1components_1aeb87ca1feeacb8aeabed7e35f0b7a434"></span><a class="reference internal" href="#_CPPv3N3hpx10components27default_distribution_policyE" title="hpx::components::default_distribution_policy">default_distribution_policy</a> <em class="property">const</em> <code class="descname">default_layout</code> = {}<a class="headerlink" href="#_CPPv3N3hpx10components14default_layoutE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A predefined instance of the default <em>distribution_policy</em>. It will represent the local locality and will place all items to create here. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx4lcosE">
<span id="_CPPv2N3hpx4lcosE"></span><span id="hpx::lcos"></span><span class="target" id="namespacehpx_1_1lcos"></span><em class="property">namespace </em><code class="descname">lcos</code><a class="headerlink" href="#_CPPv3N3hpx4lcosE" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx4lcos9broadcastERNSt6vectorIN3hpx7id_typeEEE4ArgNz">
<span id="_CPPv2N3hpx4lcos9broadcastERNSt6vectorIN3hpx7id_typeEEE4ArgNz"></span><span id="hpx::lcos::broadcast__std::vector:hpx::id_type:CR.ArgN.z"></span><em class="property">template </em>&lt;<em class="property">typename</em> Action, <em class="property">typename</em> ArgN, ...&gt;<br /><span class="target" id="namespacehpx_1_1lcos_1ab1777e42cca5d8179d0df0edd5c1048b"></span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::future&lt;std::vector&lt;decltype(Action(hpx::id_type, ArgN, ...))&gt;&gt; <code class="descname">broadcast</code><span class="sig-paren">(</span>std::vector&lt;<a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::id_type&gt; <em class="property">const</em> &amp;<em>ids</em>, ArgN <em>argN</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4lcos9broadcastERNSt6vectorIN3hpx7id_typeEEE4ArgNz" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Perform a distributed broadcast operation. </p>
<p>The function <a class="reference internal" href="#namespacehpx_1_1lcos_1ab1777e42cca5d8179d0df0edd5c1048b"><span class="std std-ref">hpx::lcos::broadcast</span></a> performs a distributed broadcast operation resulting in action invocations on a given set of global identifiers. The action can be either a plain action (in which case the global identifiers have to refer to localities) or a component action (in which case the global identifiers have to refer to instances of a component type which exposes the action.</p>
<p>The given action is invoked asynchronously on all given identifiers, and the arguments ArgN are passed along to those invocations.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>This function returns a future representing the result of the overall reduction operation.</dd>
<dt><strong>Note</strong></dt>
<dd>If decltype(Action(…)) is void, then the result of this function is future&lt;void&gt;. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ids</span></code>: [in] A list of global identifiers identifying the target objects for which the given action will be invoked. </li>
<li><code class="docutils literal notranslate"><span class="pre">argN</span></code>: [in] Any number of arbitrary arguments (passed by const reference) which will be forwarded to the action invocation.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4lcos15broadcast_applyERNSt6vectorIN3hpx7id_typeEEE4ArgNz">
<span id="_CPPv2N3hpx4lcos15broadcast_applyERNSt6vectorIN3hpx7id_typeEEE4ArgNz"></span><span id="hpx::lcos::broadcast_apply__std::vector:hpx::id_type:CR.ArgN.z"></span><em class="property">template </em>&lt;<em class="property">typename</em> Action, <em class="property">typename</em> ArgN, ...&gt;<br /><span class="target" id="namespacehpx_1_1lcos_1a5f7754e260328904b12ff9a34df705e8"></span>void <code class="descname">broadcast_apply</code><span class="sig-paren">(</span>std::vector&lt;<a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::id_type&gt; <em class="property">const</em> &amp;<em>ids</em>, ArgN <em>argN</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4lcos15broadcast_applyERNSt6vectorIN3hpx7id_typeEEE4ArgNz" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Perform an asynchronous (fire&amp;forget) distributed broadcast operation. </p>
<p>The function <a class="reference internal" href="#namespacehpx_1_1lcos_1a5f7754e260328904b12ff9a34df705e8"><span class="std std-ref">hpx::lcos::broadcast_apply</span></a> performs an asynchronous (fire&amp;forget) distributed broadcast operation resulting in action invocations on a given set of global identifiers. The action can be either a plain action (in which case the global identifiers have to refer to localities) or a component action (in which case the global identifiers have to refer to instances of a component type which exposes the action.</p>
<p>The given action is invoked asynchronously on all given identifiers, and the arguments ArgN are passed along to those invocations.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ids</span></code>: [in] A list of global identifiers identifying the target objects for which the given action will be invoked. </li>
<li><code class="docutils literal notranslate"><span class="pre">argN</span></code>: [in] Any number of arbitrary arguments (passed by const reference) which will be forwarded to the action invocation. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4lcos20broadcast_with_indexERNSt6vectorIN3hpx7id_typeEEE4ArgNz">
<span id="_CPPv2N3hpx4lcos20broadcast_with_indexERNSt6vectorIN3hpx7id_typeEEE4ArgNz"></span><span id="hpx::lcos::broadcast_with_index__std::vector:hpx::id_type:CR.ArgN.z"></span><em class="property">template </em>&lt;<em class="property">typename</em> Action, <em class="property">typename</em> ArgN, ...&gt;<br /><span class="target" id="namespacehpx_1_1lcos_1a1900e1c885e7a8599ece952ae2846e9e"></span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::future&lt;std::vector&lt;decltype(Action(hpx::id_type, ArgN, ..., std::size_t))&gt;&gt; <code class="descname">broadcast_with_index</code><span class="sig-paren">(</span>std::vector&lt;<a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::id_type&gt; <em class="property">const</em> &amp;<em>ids</em>, ArgN <em>argN</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4lcos20broadcast_with_indexERNSt6vectorIN3hpx7id_typeEEE4ArgNz" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Perform a distributed broadcast operation. </p>
<p>The function <a class="reference internal" href="#namespacehpx_1_1lcos_1a1900e1c885e7a8599ece952ae2846e9e"><span class="std std-ref">hpx::lcos::broadcast_with_index</span></a> performs a distributed broadcast operation resulting in action invocations on a given set of global identifiers. The action can be either a plain action (in which case the global identifiers have to refer to localities) or a component action (in which case the global identifiers have to refer to instances of a component type which exposes the action.</p>
<p>The given action is invoked asynchronously on all given identifiers, and the arguments ArgN are passed along to those invocations.</p>
<p>The function passes the index of the global identifier in the given list of identifiers as the last argument to the action.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>This function returns a future representing the result of the overall reduction operation.</dd>
<dt><strong>Note</strong></dt>
<dd>If decltype(Action(…)) is void, then the result of this function is future&lt;void&gt;. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ids</span></code>: [in] A list of global identifiers identifying the target objects for which the given action will be invoked. </li>
<li><code class="docutils literal notranslate"><span class="pre">argN</span></code>: [in] Any number of arbitrary arguments (passed by const reference) which will be forwarded to the action invocation.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4lcos26broadcast_apply_with_indexERNSt6vectorIN3hpx7id_typeEEE4ArgNz">
<span id="_CPPv2N3hpx4lcos26broadcast_apply_with_indexERNSt6vectorIN3hpx7id_typeEEE4ArgNz"></span><span id="hpx::lcos::broadcast_apply_with_index__std::vector:hpx::id_type:CR.ArgN.z"></span><em class="property">template </em>&lt;<em class="property">typename</em> Action, <em class="property">typename</em> ArgN, ...&gt;<br /><span class="target" id="namespacehpx_1_1lcos_1aabcbe03a5b761ce51255617d98f9ffc1"></span>void <code class="descname">broadcast_apply_with_index</code><span class="sig-paren">(</span>std::vector&lt;<a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::id_type&gt; <em class="property">const</em> &amp;<em>ids</em>, ArgN <em>argN</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4lcos26broadcast_apply_with_indexERNSt6vectorIN3hpx7id_typeEEE4ArgNz" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Perform an asynchronous (fire&amp;forget) distributed broadcast operation. </p>
<p>The function <a class="reference internal" href="#namespacehpx_1_1lcos_1aabcbe03a5b761ce51255617d98f9ffc1"><span class="std std-ref">hpx::lcos::broadcast_apply_with_index</span></a> performs an asynchronous (fire&amp;forget) distributed broadcast operation resulting in action invocations on a given set of global identifiers. The action can be either a plain action (in which case the global identifiers have to refer to localities) or a component action (in which case the global identifiers have to refer to instances of a component type which exposes the action.</p>
<p>The given action is invoked asynchronously on all given identifiers, and the arguments ArgN are passed along to those invocations.</p>
<p>The function passes the index of the global identifier in the given list of identifiers as the last argument to the action.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ids</span></code>: [in] A list of global identifiers identifying the target objects for which the given action will be invoked. </li>
<li><code class="docutils literal notranslate"><span class="pre">argN</span></code>: [in] Any number of arbitrary arguments (passed by const reference) which will be forwarded to the action invocation. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4lcos4foldERNSt6vectorIN3hpx7id_typeEEERR6FoldOpRR4Init4ArgNz">
<span id="_CPPv2N3hpx4lcos4foldERNSt6vectorIN3hpx7id_typeEEERR6FoldOpRR4Init4ArgNz"></span><span id="hpx::lcos::fold__std::vector:hpx::id_type:CR.FoldOpRR.InitRR.ArgN.z"></span><em class="property">template </em>&lt;<em class="property">typename</em> Action, <em class="property">typename</em> FoldOp, <em class="property">typename</em> Init, <em class="property">typename</em> ArgN, ...&gt;<br /><span class="target" id="namespacehpx_1_1lcos_1a0264362a25694fb18c71b62cf47826ed"></span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::future&lt;decltype(Action(hpx::id_type, ArgN, ...))&gt; <code class="descname">fold</code><span class="sig-paren">(</span>std::vector&lt;<a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::id_type&gt; <em class="property">const</em> &amp;<em>ids</em>, FoldOp &amp;&amp;<em>fold_op</em>, Init &amp;&amp;<em>init</em>, ArgN <em>argN</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4lcos4foldERNSt6vectorIN3hpx7id_typeEEERR6FoldOpRR4Init4ArgNz" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Perform a distributed fold operation. </p>
<p>The function <a class="reference internal" href="#namespacehpx_1_1lcos_1a0264362a25694fb18c71b62cf47826ed"><span class="std std-ref">hpx::lcos::fold</span></a> performs a distributed folding operation over results returned from action invocations on a given set of global identifiers. The action can be either a plain action (in which case the global identifiers have to refer to localities) or a component action (in which case the global identifiers have to refer to instances of a component type which exposes the action.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The type of the initial value must be convertible to the result type returned from the invoked action.</dd>
<dt><strong>Return</strong></dt>
<dd>This function returns a future representing the result of the overall folding operation. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ids</span></code>: [in] A list of global identifiers identifying the target objects for which the given action will be invoked. </li>
<li><code class="docutils literal notranslate"><span class="pre">fold_op</span></code>: [in] A binary function expecting two results as returned from the action invocations. The function (or function object) is expected to return the result of the folding operation performed on its arguments. </li>
<li><code class="docutils literal notranslate"><span class="pre">init</span></code>: [in] The initial value to be used for the folding operation </li>
<li><code class="docutils literal notranslate"><span class="pre">argN</span></code>: [in] Any number of arbitrary arguments (passed by value, by const reference or by rvalue reference) which will be forwarded to the action invocation.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4lcos15fold_with_indexERNSt6vectorIN3hpx7id_typeEEERR6FoldOpRR4Init4ArgNz">
<span id="_CPPv2N3hpx4lcos15fold_with_indexERNSt6vectorIN3hpx7id_typeEEERR6FoldOpRR4Init4ArgNz"></span><span id="hpx::lcos::fold_with_index__std::vector:hpx::id_type:CR.FoldOpRR.InitRR.ArgN.z"></span><em class="property">template </em>&lt;<em class="property">typename</em> Action, <em class="property">typename</em> FoldOp, <em class="property">typename</em> Init, <em class="property">typename</em> ArgN, ...&gt;<br /><span class="target" id="namespacehpx_1_1lcos_1a28a571528cc387c0ff37af04cd26a4cd"></span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::future&lt;decltype(Action(hpx::id_type, ArgN, ..., std::size_t))&gt; <code class="descname">fold_with_index</code><span class="sig-paren">(</span>std::vector&lt;<a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::id_type&gt; <em class="property">const</em> &amp;<em>ids</em>, FoldOp &amp;&amp;<em>fold_op</em>, Init &amp;&amp;<em>init</em>, ArgN <em>argN</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4lcos15fold_with_indexERNSt6vectorIN3hpx7id_typeEEERR6FoldOpRR4Init4ArgNz" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Perform a distributed folding operation. </p>
<p>The function <a class="reference internal" href="#namespacehpx_1_1lcos_1a28a571528cc387c0ff37af04cd26a4cd"><span class="std std-ref">hpx::lcos::fold_with_index</span></a> performs a distributed folding operation over results returned from action invocations on a given set of global identifiers. The action can be either plain action (in which case the global identifiers have to refer to localities) or a component action (in which case the global identifiers have to refer to instances of a component type which exposes the action.</p>
<p>The function passes the index of the global identifier in the given list of identifiers as the last argument to the action.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The type of the initial value must be convertible to the result type returned from the invoked action.</dd>
<dt><strong>Return</strong></dt>
<dd>This function returns a future representing the result of the overall folding operation. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ids</span></code>: [in] A list of global identifiers identifying the target objects for which the given action will be invoked. </li>
<li><code class="docutils literal notranslate"><span class="pre">fold_op</span></code>: [in] A binary function expecting two results as returned from the action invocations. The function (or function object) is expected to return the result of the folding operation performed on its arguments. </li>
<li><code class="docutils literal notranslate"><span class="pre">init</span></code>: [in] The initial value to be used for the folding operation </li>
<li><code class="docutils literal notranslate"><span class="pre">argN</span></code>: [in] Any number of arbitrary arguments (passed by value, by const reference or by rvalue reference) which will be forwarded to the action invocation.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4lcos12inverse_foldERNSt6vectorIN3hpx7id_typeEEERR6FoldOpRR4Init4ArgNz">
<span id="_CPPv2N3hpx4lcos12inverse_foldERNSt6vectorIN3hpx7id_typeEEERR6FoldOpRR4Init4ArgNz"></span><span id="hpx::lcos::inverse_fold__std::vector:hpx::id_type:CR.FoldOpRR.InitRR.ArgN.z"></span><em class="property">template </em>&lt;<em class="property">typename</em> Action, <em class="property">typename</em> FoldOp, <em class="property">typename</em> Init, <em class="property">typename</em> ArgN, ...&gt;<br /><span class="target" id="namespacehpx_1_1lcos_1a4722179d40b6ca8fc28474ff51166adc"></span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::future&lt;decltype(Action(hpx::id_type, ArgN, ...))&gt; <code class="descname">inverse_fold</code><span class="sig-paren">(</span>std::vector&lt;<a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::id_type&gt; <em class="property">const</em> &amp;<em>ids</em>, FoldOp &amp;&amp;<em>fold_op</em>, Init &amp;&amp;<em>init</em>, ArgN <em>argN</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4lcos12inverse_foldERNSt6vectorIN3hpx7id_typeEEERR6FoldOpRR4Init4ArgNz" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Perform a distributed inverse folding operation. </p>
<p>The function <a class="reference internal" href="#namespacehpx_1_1lcos_1a4722179d40b6ca8fc28474ff51166adc"><span class="std std-ref">hpx::lcos::inverse_fold</span></a> performs an inverse distributed folding operation over results returned from action invocations on a given set of global identifiers. The action can be either a plain action (in which case the global identifiers have to refer to localities) or a component action (in which case the global identifiers have to refer to instances of a component type which exposes the action.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The type of the initial value must be convertible to the result type returned from the invoked action.</dd>
<dt><strong>Return</strong></dt>
<dd>This function returns a future representing the result of the overall folding operation. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ids</span></code>: [in] A list of global identifiers identifying the target objects for which the given action will be invoked. </li>
<li><code class="docutils literal notranslate"><span class="pre">fold_op</span></code>: [in] A binary function expecting two results as returned from the action invocations. The function (or function object) is expected to return the result of the folding operation performed on its arguments. </li>
<li><code class="docutils literal notranslate"><span class="pre">init</span></code>: [in] The initial value to be used for the folding operation </li>
<li><code class="docutils literal notranslate"><span class="pre">argN</span></code>: [in] Any number of arbitrary arguments (passed by value, by const reference or by rvalue reference) which will be forwarded to the action invocation.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4lcos23inverse_fold_with_indexERNSt6vectorIN3hpx7id_typeEEERR6FoldOpRR4Init4ArgNz">
<span id="_CPPv2N3hpx4lcos23inverse_fold_with_indexERNSt6vectorIN3hpx7id_typeEEERR6FoldOpRR4Init4ArgNz"></span><span id="hpx::lcos::inverse_fold_with_index__std::vector:hpx::id_type:CR.FoldOpRR.InitRR.ArgN.z"></span><em class="property">template </em>&lt;<em class="property">typename</em> Action, <em class="property">typename</em> FoldOp, <em class="property">typename</em> Init, <em class="property">typename</em> ArgN, ...&gt;<br /><span class="target" id="namespacehpx_1_1lcos_1af6c63d9b714d7cce6542fc5bf01c68c1"></span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::future&lt;decltype(Action(hpx::id_type, ArgN, ..., std::size_t))&gt; <code class="descname">inverse_fold_with_index</code><span class="sig-paren">(</span>std::vector&lt;<a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::id_type&gt; <em class="property">const</em> &amp;<em>ids</em>, FoldOp &amp;&amp;<em>fold_op</em>, Init &amp;&amp;<em>init</em>, ArgN <em>argN</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4lcos23inverse_fold_with_indexERNSt6vectorIN3hpx7id_typeEEERR6FoldOpRR4Init4ArgNz" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Perform a distributed inverse folding operation. </p>
<p>The function <a class="reference internal" href="#namespacehpx_1_1lcos_1af6c63d9b714d7cce6542fc5bf01c68c1"><span class="std std-ref">hpx::lcos::inverse_fold_with_index</span></a> performs an inverse distributed folding operation over results returned from action invocations on a given set of global identifiers. The action can be either plain action (in which case the global identifiers have to refer to localities) or a component action (in which case the global identifiers have to refer to instances of a component type which exposes the action.</p>
<p>The function passes the index of the global identifier in the given list of identifiers as the last argument to the action.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The type of the initial value must be convertible to the result type returned from the invoked action.</dd>
<dt><strong>Return</strong></dt>
<dd>This function returns a future representing the result of the overall folding operation. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ids</span></code>: [in] A list of global identifiers identifying the target objects for which the given action will be invoked. </li>
<li><code class="docutils literal notranslate"><span class="pre">fold_op</span></code>: [in] A binary function expecting two results as returned from the action invocations. The function (or function object) is expected to return the result of the folding operation performed on its arguments. </li>
<li><code class="docutils literal notranslate"><span class="pre">init</span></code>: [in] The initial value to be used for the folding operation </li>
<li><code class="docutils literal notranslate"><span class="pre">argN</span></code>: [in] Any number of arbitrary arguments (passed by value, by const reference or by rvalue reference) which will be forwarded to the action invocation.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4lcos11gather_hereEPcN3hpx6futureI1TEENSt6size_tENSt6size_tENSt6size_tE">
<span id="_CPPv2N3hpx4lcos11gather_hereEPcN3hpx6futureI1TEENSt6size_tENSt6size_tENSt6size_tE"></span><span id="hpx::lcos::gather_here__cCP.hpx::future:T:.std::s.std::s.std::s"></span><em class="property">template </em>&lt;<em class="property">typename</em> T&gt;<br /><span class="target" id="namespacehpx_1_1lcos_1aebc9313a9b521471ff489f783f568483"></span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::future&lt;std::vector&lt;T&gt;&gt; <code class="descname">gather_here</code><span class="sig-paren">(</span>char <em class="property">const</em> *<em>basename</em>, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::future&lt;T&gt; <em>result</em>, std::size_t <em>num_sites</em> = std::size_t(-1), std::size_t <em>generation</em> = std::size_t(-1), std::size_t <em>this_site</em> = std::size_t(-1)<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4lcos11gather_hereEPcN3hpx6futureI1TEENSt6size_tENSt6size_tENSt6size_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Gather a set of values from different call sites</p>
<p>This function receives a set of values from all call sites operating on the given base name.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Each gather operation has to be accompanied with a unique usage of the <em>HPX_REGISTER_GATHER</em> macro to define the necessary internal facilities used by <em>gather_here</em> and <em>gather_there</em> </dd>
<dt><strong>Return</strong></dt>
<dd>This function returns a future holding a vector with all gathered values. It will become ready once the gather operation has been completed. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">basename</span></code>: The base name identifying the gather operation </li>
<li><code class="docutils literal notranslate"><span class="pre">result</span></code>: A future referring to the value to transmit to the central gather point from this call site. </li>
<li><code class="docutils literal notranslate"><span class="pre">num_sites</span></code>: The number of participating sites (default: all localities). </li>
<li><code class="docutils literal notranslate"><span class="pre">generation</span></code>: The generational counter identifying the sequence number of the gather operation performed on the given base name. This is optional and needs to be supplied only if the gather operation on the given base name has to be performed more than once. </li>
<li><code class="docutils literal notranslate"><span class="pre">this_site</span></code>: The sequence number of this invocation (usually the locality id). This value is optional and defaults to whatever <a class="reference internal" href="#namespacehpx_1a158d7c54a657bb364c1704033010697b"><span class="std std-ref">hpx::get_locality_id()</span></a> returns.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4lcos12gather_thereEPcN3hpx6futureI1TEENSt6size_tENSt6size_tENSt6size_tE">
<span id="_CPPv2N3hpx4lcos12gather_thereEPcN3hpx6futureI1TEENSt6size_tENSt6size_tENSt6size_tE"></span><span id="hpx::lcos::gather_there__cCP.hpx::future:T:.std::s.std::s.std::s"></span><em class="property">template </em>&lt;<em class="property">typename</em> T&gt;<br /><span class="target" id="namespacehpx_1_1lcos_1acd461f27f5635ae7aa033ad9634c244e"></span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::future&lt;void&gt; <code class="descname">gather_there</code><span class="sig-paren">(</span>char <em class="property">const</em> *<em>basename</em>, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::future&lt;T&gt; <em>result</em>, std::size_t <em>generation</em> = std::size_t(-1), std::size_t <em>root_site</em> = 0, std::size_t <em>this_site</em> = std::size_t(-1)<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4lcos12gather_thereEPcN3hpx6futureI1TEENSt6size_tENSt6size_tENSt6size_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Gather a given value at the given call site</p>
<p>This function transmits the value given by <em>result</em> to a central gather site (where the corresponding <em>gather_here</em> is executed)</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Each gather operation has to be accompanied with a unique usage of the <em>HPX_REGISTER_GATHER</em> macro to define the necessary internal facilities used by <em>gather_here</em> and <em>gather_there</em> </dd>
<dt><strong>Return</strong></dt>
<dd>This function returns a future which will become ready once the gather operation has been completed. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">basename</span></code>: The base name identifying the gather operation </li>
<li><code class="docutils literal notranslate"><span class="pre">result</span></code>: A future referring to the value to transmit to the central gather point from this call site. </li>
<li><code class="docutils literal notranslate"><span class="pre">generation</span></code>: The generational counter identifying the sequence number of the gather operation performed on the given base name. This is optional and needs to be supplied only if the gather operation on the given base name has to be performed more than once. </li>
<li><code class="docutils literal notranslate"><span class="pre">root_site</span></code>: The sequence number of the central gather point (usually the locality id). This value is optional and defaults to 0. </li>
<li><code class="docutils literal notranslate"><span class="pre">this_site</span></code>: The sequence number of this invocation (usually the locality id). This value is optional and defaults to whatever <a class="reference internal" href="#namespacehpx_1a158d7c54a657bb364c1704033010697b"><span class="std std-ref">hpx::get_locality_id()</span></a> returns.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4lcos11gather_hereEPcRR1TNSt6size_tENSt6size_tENSt6size_tE">
<span id="_CPPv2N3hpx4lcos11gather_hereEPcRR1TNSt6size_tENSt6size_tENSt6size_tE"></span><span id="hpx::lcos::gather_here__cCP.TRR.std::s.std::s.std::s"></span><em class="property">template </em>&lt;<em class="property">typename</em> T&gt;<br /><span class="target" id="namespacehpx_1_1lcos_1a6547d22730263a7d46b8f59e605a086e"></span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::future&lt;std::vector&lt;<em class="property">typename</em> std::decay&lt;T&gt;::type&gt;&gt; <code class="descname">gather_here</code><span class="sig-paren">(</span>char <em class="property">const</em> *<em>basename</em>, T &amp;&amp;<em>result</em>, std::size_t <em>num_sites</em> = std::size_t(-1), std::size_t <em>generation</em> = std::size_t(-1), std::size_t <em>this_site</em> = std::size_t(-1)<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4lcos11gather_hereEPcRR1TNSt6size_tENSt6size_tENSt6size_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Gather a set of values from different call sites</p>
<p>This function receives a set of values from all call sites operating on the given base name.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Each gather operation has to be accompanied with a unique usage of the <em>HPX_REGISTER_GATHER</em> macro to define the necessary internal facilities used by <em>gather_here</em> and <em>gather_there</em> </dd>
<dt><strong>Return</strong></dt>
<dd>This function returns a future holding a vector with all gathered values. It will become ready once the gather operation has been completed. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">basename</span></code>: The base name identifying the gather operation </li>
<li><code class="docutils literal notranslate"><span class="pre">result</span></code>: The value to transmit to the central gather point from this call site. </li>
<li><code class="docutils literal notranslate"><span class="pre">num_sites</span></code>: The number of participating sites (default: all localities). </li>
<li><code class="docutils literal notranslate"><span class="pre">generation</span></code>: The generational counter identifying the sequence number of the gather operation performed on the given base name. This is optional and needs to be supplied only if the gather operation on the given base name has to be performed more than once. </li>
<li><code class="docutils literal notranslate"><span class="pre">this_site</span></code>: The sequence number of this invocation (usually the locality id). This value is optional and defaults to whatever <a class="reference internal" href="#namespacehpx_1a158d7c54a657bb364c1704033010697b"><span class="std std-ref">hpx::get_locality_id()</span></a> returns.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4lcos12gather_thereEPcRR1TNSt6size_tENSt6size_tENSt6size_tE">
<span id="_CPPv2N3hpx4lcos12gather_thereEPcRR1TNSt6size_tENSt6size_tENSt6size_tE"></span><span id="hpx::lcos::gather_there__cCP.TRR.std::s.std::s.std::s"></span><em class="property">template </em>&lt;<em class="property">typename</em> T&gt;<br /><span class="target" id="namespacehpx_1_1lcos_1acd15a01115b9c7a80e57da3dacfbcbb9"></span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::future&lt;void&gt; <code class="descname">gather_there</code><span class="sig-paren">(</span>char <em class="property">const</em> *<em>basename</em>, T &amp;&amp;<em>result</em>, std::size_t <em>generation</em> = std::size_t(-1), std::size_t <em>root_site</em> = 0, std::size_t <em>this_site</em> = std::size_t(-1)<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4lcos12gather_thereEPcRR1TNSt6size_tENSt6size_tENSt6size_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Gather a given value at the given call site</p>
<p>This function transmits the value given by <em>result</em> to a central gather site (where the corresponding <em>gather_here</em> is executed)</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Each gather operation has to be accompanied with a unique usage of the <em>HPX_REGISTER_GATHER</em> macro to define the necessary internal facilities used by <em>gather_here</em> and <em>gather_there</em> </dd>
<dt><strong>Return</strong></dt>
<dd>This function returns a future which will become ready once the gather operation has been completed. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">basename</span></code>: The base name identifying the gather operation </li>
<li><code class="docutils literal notranslate"><span class="pre">result</span></code>: The value to transmit to the central gather point from this call site. </li>
<li><code class="docutils literal notranslate"><span class="pre">generation</span></code>: The generational counter identifying the sequence number of the gather operation performed on the given base name. This is optional and needs to be supplied only if the gather operation on the given base name has to be performed more than once. </li>
<li><code class="docutils literal notranslate"><span class="pre">root_site</span></code>: The sequence number of the central gather point (usually the locality id). This value is optional and defaults to 0. </li>
<li><code class="docutils literal notranslate"><span class="pre">this_site</span></code>: The sequence number of this invocation (usually the locality id). This value is optional and defaults to whatever <a class="reference internal" href="#namespacehpx_1a158d7c54a657bb364c1704033010697b"><span class="std std-ref">hpx::get_locality_id()</span></a> returns.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4lcos6reduceERNSt6vectorIN3hpx7id_typeEEERR8ReduceOp4ArgNz">
<span id="_CPPv2N3hpx4lcos6reduceERNSt6vectorIN3hpx7id_typeEEERR8ReduceOp4ArgNz"></span><span id="hpx::lcos::reduce__std::vector:hpx::id_type:CR.ReduceOpRR.ArgN.z"></span><em class="property">template </em>&lt;<em class="property">typename</em> Action, <em class="property">typename</em> ReduceOp, <em class="property">typename</em> ArgN, ...&gt;<br /><span class="target" id="namespacehpx_1_1lcos_1a1f925cbd0929a3aef51364bf269e2ae5"></span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::future&lt;decltype(Action(hpx::id_type, ArgN, ...))&gt; <code class="descname">reduce</code><span class="sig-paren">(</span>std::vector&lt;<a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::id_type&gt; <em class="property">const</em> &amp;<em>ids</em>, ReduceOp &amp;&amp;<em>reduce_op</em>, ArgN <em>argN</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4lcos6reduceERNSt6vectorIN3hpx7id_typeEEERR8ReduceOp4ArgNz" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Perform a distributed reduction operation. </p>
<p>The function <a class="reference internal" href="#namespacehpx_1_1lcos_1a1f925cbd0929a3aef51364bf269e2ae5"><span class="std std-ref">hpx::lcos::reduce</span></a> performs a distributed reduction operation over results returned from action invocations on a given set of global identifiers. The action can be either a plain action (in which case the global identifiers have to refer to localities) or a component action (in which case the global identifiers have to refer to instances of a component type which exposes the action.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>This function returns a future representing the result of the overall reduction operation. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ids</span></code>: [in] A list of global identifiers identifying the target objects for which the given action will be invoked. </li>
<li><code class="docutils literal notranslate"><span class="pre">reduce_op</span></code>: [in] A binary function expecting two results as returned from the action invocations. The function (or function object) is expected to return the result of the reduction operation performed on its arguments. </li>
<li><code class="docutils literal notranslate"><span class="pre">argN</span></code>: [in] Any number of arbitrary arguments (passed by by const reference) which will be forwarded to the action invocation.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4lcos17reduce_with_indexERNSt6vectorIN3hpx7id_typeEEERR8ReduceOp4ArgNz">
<span id="_CPPv2N3hpx4lcos17reduce_with_indexERNSt6vectorIN3hpx7id_typeEEERR8ReduceOp4ArgNz"></span><span id="hpx::lcos::reduce_with_index__std::vector:hpx::id_type:CR.ReduceOpRR.ArgN.z"></span><em class="property">template </em>&lt;<em class="property">typename</em> Action, <em class="property">typename</em> ReduceOp, <em class="property">typename</em> ArgN, ...&gt;<br /><span class="target" id="namespacehpx_1_1lcos_1a02cd4375bd21d729fc8dced3aac39767"></span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::future&lt;decltype(Action(hpx::id_type, ArgN, ..., std::size_t))&gt; <code class="descname">reduce_with_index</code><span class="sig-paren">(</span>std::vector&lt;<a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::id_type&gt; <em class="property">const</em> &amp;<em>ids</em>, ReduceOp &amp;&amp;<em>reduce_op</em>, ArgN <em>argN</em>, ...<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4lcos17reduce_with_indexERNSt6vectorIN3hpx7id_typeEEERR8ReduceOp4ArgNz" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Perform a distributed reduction operation. </p>
<p>The function <a class="reference internal" href="#namespacehpx_1_1lcos_1a02cd4375bd21d729fc8dced3aac39767"><span class="std std-ref">hpx::lcos::reduce_with_index</span></a> performs a distributed reduction operation over results returned from action invocations on a given set of global identifiers. The action can be either plain action (in which case the global identifiers have to refer to localities) or a component action (in which case the global identifiers have to refer to instances of a component type which exposes the action.</p>
<p>The function passes the index of the global identifier in the given list of identifiers as the last argument to the action.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>This function returns a future representing the result of the overall reduction operation. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ids</span></code>: [in] A list of global identifiers identifying the target objects for which the given action will be invoked. </li>
<li><code class="docutils literal notranslate"><span class="pre">reduce_op</span></code>: [in] A binary function expecting two results as returned from the action invocations. The function (or function object) is expected to return the result of the reduction operation performed on its arguments. </li>
<li><code class="docutils literal notranslate"><span class="pre">argN</span></code>: [in] Any number of arbitrary arguments (passed by by const reference) which will be forwarded to the action invocation.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx6namingE">
<span id="_CPPv2N3hpx6namingE"></span><span id="hpx::naming"></span><span class="target" id="namespacehpx_1_1naming"></span><em class="property">namespace </em><code class="descname">naming</code><a class="headerlink" href="#_CPPv3N3hpx6namingE" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx6naming9unmanagedER7id_type">
<span id="_CPPv2N3hpx6naming9unmanagedER7id_type"></span><span id="hpx::naming::unmanaged__id_typeCR"></span><span class="target" id="namespacehpx_1_1naming_1a8b643a46e6d3010373f8a313ca43c5b5"></span>id_type <code class="descname">unmanaged</code><span class="sig-paren">(</span>id_type <em class="property">const</em> &amp;<em>id</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx6naming9unmanagedER7id_type" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The helper function <em>hpx::unmanaged</em> can be used to generate a global identifier which does not participate in the automatic garbage collection.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>This function returns a new global id referencing the same object as the parameter <em>id</em>. The only difference is that the returned global identifier does not participate in the automatic garbage collection.</dd>
<dt><strong>Note</strong></dt>
<dd>This function allows to apply certain optimizations to the process of memory management in HPX. It however requires the user to take full responsibility for keeping the referenced objects alive long enough. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">id</span></code>: [in] The id to generated the unmanaged global id from This parameter can be itself a managed or a unmanaged global id.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx8parallelE">
<span id="_CPPv2N3hpx8parallelE"></span><span id="hpx::parallel"></span><span class="target" id="namespacehpx_1_1parallel"></span><em class="property">namespace </em><code class="descname">parallel</code><a class="headerlink" href="#_CPPv3N3hpx8parallelE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx8parallel9executionE">
<span id="_CPPv2N3hpx8parallel9executionE"></span><span id="hpx::parallel::execution"></span><span class="target" id="namespacehpx_1_1parallel_1_1execution"></span><em class="property">namespace </em><code class="descname">execution</code><a class="headerlink" href="#_CPPv3N3hpx8parallel9executionE" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Typedefs</p>
<dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1execution_1a145ed13953eab568938127679016af0b"></span><em class="property">using </em><code class="descname">hpx::parallel::execution::parallel_executor = typedef parallel_policy_executor&lt;hpx::launch&gt;</code></dt>
<dd></dd></dl>

<dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1execution_1a29ce45fce2d059162a60eb04dcc135a5"></span><em class="property">using </em><code class="descname">hpx::parallel::execution::service_executor = typedef threads::executors::service_executor</code></dt>
<dd><p>A <em>service_executor</em> exposes one of the predefined HPX thread pools through an executor interface.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>All tasks executed by one of these executors will run on one of the OS-threads dedicated for the given thread pool. The tasks will not run as HPX-threads. </dd>
</dl>
</p>
</dd></dl>

<dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1execution_1a3b4e7d31d0b112d896d825f3e18ef88e"></span><em class="property">using </em><code class="descname">hpx::parallel::execution::io_pool_executor = typedef threads::executors::io_pool_executor</code></dt>
<dd><p>A <em>io_pool_executor</em> exposes the predefined HPX IO thread pool through an executor interface.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>All tasks executed by one of these executors will run on one of the OS-threads dedicated for the IO thread pool. The tasks will not run as HPX-threads. </dd>
</dl>
</p>
</dd></dl>

<dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1execution_1aaf699efe7451389c926b48ea5c23c58b"></span><em class="property">using </em><code class="descname">hpx::parallel::execution::parcel_pool_executor = typedef threads::executors::parcel_pool_executor</code></dt>
<dd><p>A <em>io_pool_executor</em> exposes the predefined HPX parcel thread pool through an executor interface.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>All tasks executed by one of these executors will run on one of the OS-threads dedicated for the parcel thread pool. The tasks will not run as HPX-threads. </dd>
</dl>
</p>
</dd></dl>

<dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1execution_1a15967cbd9cbc9a3897901b86e75a7d22"></span><em class="property">using </em><code class="descname">hpx::parallel::execution::timer_pool_executor = typedef threads::executors::timer_pool_executor</code></dt>
<dd><p>A <em>io_pool_executor</em> exposes the predefined HPX timer thread pool through an executor interface.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>All tasks executed by one of these executors will run on one of the OS-threads dedicated for the timer thread pool. The tasks will not run as HPX-threads. </dd>
</dl>
</p>
</dd></dl>

<dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1execution_1a7ab3f5bb60831868e7624e5faf6896a3"></span><em class="property">using </em><code class="descname">hpx::parallel::execution::main_pool_executor = typedef threads::executors::main_pool_executor</code></dt>
<dd><p>A <em>io_pool_executor</em> exposes the predefined HPX main thread pool through an executor interface.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>All tasks executed by one of these executors will run on one of the OS-threads dedicated for the main thread pool. The tasks will not run as HPX-threads. </dd>
</dl>
</p>
</dd></dl>

<dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1execution_1ac4d0cb953702c2b4d9227d8f750ec530"></span><em class="property">using </em><code class="descname">hpx::parallel::execution::local_priority_queue_executor = typedef threads::executors::local_priority_queue_executor</code></dt>
<dd><p>Creates a new local_priority_queue_executor</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">max_punits</span></code>: [in] The maximum number of processing units to associate with the newly created executor. </li>
<li><code class="docutils literal notranslate"><span class="pre">min_punits</span></code>: [in] The minimum number of processing units to associate with the newly created executor (default: 1). </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Variables</p>
<dl class="member">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1execution_1a379ad4dc40ef57f1dfada5de37cba421"></span><code class="descname">task_policy_tag HPX_CONSTEXPR_OR_CONST hpx::parallel::execution::task</code></dt>
<dd><p>Default sequential execution policy object. </p>
</dd></dl>

<dl class="member">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1execution_1aa42dc9cec2bf4586b8f5f236637db308"></span><code class="descname">HPX_STATIC_CONSTEXPR sequenced_policy hpx::parallel::execution::seq</code></dt>
<dd><p>Default sequential execution policy object. </p>
</dd></dl>

<dl class="member">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1execution_1aff7612e112313e7279899522814adb22"></span><code class="descname">HPX_STATIC_CONSTEXPR parallel_policy hpx::parallel::execution::par</code></dt>
<dd><p>Default parallel execution policy object. </p>
</dd></dl>

<dl class="member">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1execution_1ad8c4bc27c0ce1912fa289d7164ef8b0a"></span><code class="descname">HPX_STATIC_CONSTEXPR parallel_unsequenced_policy hpx::parallel::execution::par_unseq</code></dt>
<dd><p>Default vector execution policy object. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1execution_1_1_0D89"></span><em class="property">namespace </em></dt>
<dd></dd></dl>

<dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1parallel_1_1execution_1_1_0D90"></span><em class="property">namespace </em></dt>
<dd></dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx8parallel2v1E">
<span id="_CPPv2N3hpx8parallel2v1E"></span><span id="hpx::parallel::v1"></span><span class="target" id="namespacehpx_1_1parallel_1_1v1"></span><em class="property">namespace </em><code class="descname">v1</code><a class="headerlink" href="#_CPPv3N3hpx8parallel2v1E" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v119adjacent_differenceERR8ExPolicy8FwdIter18FwdIter18FwdIter2">
<span id="_CPPv2N3hpx8parallel2v119adjacent_differenceERR8ExPolicy8FwdIter18FwdIter18FwdIter2"></span><span id="hpx::parallel::v1::adjacent_difference__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a5aa9e2c155c1c458889ad7b38be140e1"></span>std::enable_if&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter2&gt;::type&gt;::type <code class="descname">adjacent_difference</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, FwdIter1 <em>last</em>, FwdIter2 <em>dest</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v119adjacent_differenceERR8ExPolicy8FwdIter18FwdIter18FwdIter2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assigns each value in the range given by result its corresponding element in the range [first, last] and the one preceding it except *result, which is assigned *first</p>
<p><p>The difference operations in the parallel </p>
<em>adjacent_difference</em> invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Exactly (last - first) - 1 application of the binary operator and (last - first) assignments.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used for the input range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the source iterators used for the output range (deduced). This iterator type must meet the requirements of an forward iterator.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements of the range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements of the range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the sequence of elements the results will be assigned to.</li>
</ul>
</dd>
</dl>
</p>
<p>The difference operations in the parallel <em>adjacent_difference</em> invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><p>This overload of </p>
<em>adjacent_find</em> is available if the user decides to provide their algorithm their own binary predicate <em>op</em>. <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>adjacent_difference</em> algorithm returns a <em>hpx::future&lt;FwdIter2&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter2</em> otherwise. The <em>adjacent_find</em> algorithm returns an iterator to the last element in the output range.</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v119adjacent_differenceERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR2Op">
<span id="_CPPv2N3hpx8parallel2v119adjacent_differenceERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR2Op"></span><span id="hpx::parallel::v1::adjacent_difference__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.OpRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> Op&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1acc00da8b1642d026540fc4fb5256ec68"></span>std::enable_if&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter2&gt;::type&gt;::type <code class="descname">adjacent_difference</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, FwdIter1 <em>last</em>, FwdIter2 <em>dest</em>, Op &amp;&amp;<em>op</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v119adjacent_differenceERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR2Op" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assigns each value in the range given by result its corresponding element in the range [first, last] and the one preceding it except *result, which is assigned *first</p>
<p><p>The difference operations in the parallel </p>
<em>adjacent_difference</em> invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Exactly (last - first) - 1 application of the binary operator and (last - first) assignments.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used for the input range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the source iterators used for the output range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Op</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>adjacent_difference</em> requires <em>Op</em> to meet the requirements of <em>CopyConstructible</em>.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements of the range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements of the range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the sequence of elements the results will be assigned to. </li>
<li><code class="docutils literal notranslate"><span class="pre">op</span></code>: The binary operator which returns the difference of elements. The signature should be equivalent to the following: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">op</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> must be such that objects of type <em>FwdIter1</em> can be dereferenced and then implicitly converted to the dereferenced type of <em>dest</em>.</li>
</ul>
</dd>
</dl>
</p>
<p>The difference operations in the parallel <em>adjacent_difference</em> invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>adjacent_difference</em> algorithm returns a <em>hpx::future&lt;FwdIter2&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter2</em> otherwise. The <em>adjacent_find</em> algorithm returns an iterator to the last element in the output range. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v113adjacent_findERR8ExPolicy7FwdIter7FwdIterRR4Pred">
<span id="_CPPv2N3hpx8parallel2v113adjacent_findERR8ExPolicy7FwdIter7FwdIterRR4Pred"></span><span id="hpx::parallel::v1::adjacent_find__ExPolicyRR.FwdIter.FwdIter.PredRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> Pred = detail::equal_to&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a5adc6ae701415ba01961fa29836e00fa"></span>std::enable_if&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type&gt;::type <code class="descname">adjacent_find</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, Pred &amp;&amp;<em>op</em> = Pred()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v113adjacent_findERR8ExPolicy7FwdIter7FwdIterRR4Pred" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Searches the range [first, last) for two consecutive identical elements. This version uses the given binary predicate op</p>
<p><p>The comparison operations in the parallel </p>
<em>adjacent_find</em> invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Exactly the smaller of (result - first) + 1 and (last - first) - 1 application of the predicate where <em>result</em> is the value returned</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used for the range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <em>adjacent_find</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::equal_to&lt;&gt;</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements of the range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements of the range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">op</span></code>: The binary predicate which returns <em>true</em> if the elements should be treated as equal. The signature should be equivalent to the following: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> must be such that objects of type <em>FwdIter</em> can be dereferenced and then implicitly converted to <em>Type1</em> .</li>
</ul>
</dd>
</dl>
</p>
<p>The comparison operations in the parallel <em>adjacent_find</em> invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><p>This overload of </p>
<em>adjacent_find</em> is available if the user decides to provide their algorithm their own binary predicate <em>op</em>. <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>adjacent_find</em> algorithm returns a <em>hpx::future&lt;InIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>InIter</em> otherwise. The <em>adjacent_find</em> algorithm returns an iterator to the first of the identical elements. If no such elements are found, <em>last</em> is returned.</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v17none_ofERR8ExPolicy7FwdIter7FwdIterRR1FRR4Proj">
<span id="_CPPv2N3hpx8parallel2v17none_ofERR8ExPolicy7FwdIter7FwdIterRR1FRR4Proj"></span><span id="hpx::parallel::v1::none_of__ExPolicyRR.FwdIter.FwdIter.FRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> F, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a5f34b49fe744e1ea82df76e1c514aa49"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, bool&gt;::type <code class="descname">none_of</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, F &amp;&amp;<em>f</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v17none_ofERR8ExPolicy7FwdIter7FwdIterRR1FRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Checks if unary predicate <em>f</em> returns true for no elements in the range [first, last).</p>
<p><p>The application of function objects in parallel algorithm invoked with an execution policy object of type </p>
<em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: At most <em>last</em> - <em>first</em> applications of the predicate <em>f</em> </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>none_of</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter</em> can be dereferenced and then implicitly converted to Type. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>none_of</em> algorithm returns a <em>hpx::future&lt;bool&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>bool</em> otherwise. The <em>none_of</em> algorithm returns true if the unary predicate <em>f</em> returns true for no elements in the range, false otherwise. It returns true if the range is empty. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v16any_ofERR8ExPolicy7FwdIter7FwdIterRR1FRR4Proj">
<span id="_CPPv2N3hpx8parallel2v16any_ofERR8ExPolicy7FwdIter7FwdIterRR1FRR4Proj"></span><span id="hpx::parallel::v1::any_of__ExPolicyRR.FwdIter.FwdIter.FRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> F, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1afab0800132ab9eedfc6cf4fd89ee1913"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, bool&gt;::type <code class="descname">any_of</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, F &amp;&amp;<em>f</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v16any_ofERR8ExPolicy7FwdIter7FwdIterRR1FRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Checks if unary predicate <em>f</em> returns true for at least one element in the range [first, last).</p>
<p><p>The application of function objects in parallel algorithm invoked with an execution policy object of type </p>
<em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: At most <em>last</em> - <em>first</em> applications of the predicate <em>f</em> </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>any_of</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter</em> can be dereferenced and then implicitly converted to Type. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>any_of</em> algorithm returns a <em>hpx::future&lt;bool&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>bool</em> otherwise. The <em>any_of</em> algorithm returns true if the unary predicate <em>f</em> returns true for at least one element in the range, false otherwise. It returns false if the range is empty. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v16all_ofERR8ExPolicy7FwdIter7FwdIterRR1FRR4Proj">
<span id="_CPPv2N3hpx8parallel2v16all_ofERR8ExPolicy7FwdIter7FwdIterRR1FRR4Proj"></span><span id="hpx::parallel::v1::all_of__ExPolicyRR.FwdIter.FwdIter.FRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> F, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a879e3cf8d3b4a2d70efa0dce73acb5ec"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, bool&gt;::type <code class="descname">all_of</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, F &amp;&amp;<em>f</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v16all_ofERR8ExPolicy7FwdIter7FwdIterRR1FRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Checks if unary predicate <em>f</em> returns true for all elements in the range [first, last).</p>
<p><p>The application of function objects in parallel algorithm invoked with an execution policy object of type </p>
<em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: At most <em>last</em> - <em>first</em> applications of the predicate <em>f</em> </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>all_of</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter</em> can be dereferenced and then implicitly converted to Type. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>all_of</em> algorithm returns a <em>hpx::future&lt;bool&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>bool</em> otherwise. The <em>all_of</em> algorithm returns true if the unary predicate <em>f</em> returns true for all elements in the range, false otherwise. It returns true if the range is empty. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v14copyERR8ExPolicy8FwdIter18FwdIter18FwdIter2">
<span id="_CPPv2N3hpx8parallel2v14copyERR8ExPolicy8FwdIter18FwdIter18FwdIter2"></span><span id="hpx::parallel::v1::copy__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a22a7a61f1a245998f3dfb5905a165ba2"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::in<span class="sig-paren">(</span>FwdIter1<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>FwdIter2<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">copy</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, FwdIter1 <em>last</em>, FwdIter2 <em>dest</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v14copyERR8ExPolicy8FwdIter18FwdIter18FwdIter2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the elements in the range, defined by [first, last), to another range beginning at <em>dest</em>.</p>
<p><p>The assignments in the parallel </p>
<em>copy</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>last</em> - <em>first</em> assignments.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>copy</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>copy</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</em> &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</em> otherwise. The <em>copy</em> algorithm returns the pair of the input iterator <em>last</em> and the output iterator to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v16copy_nERR8ExPolicy8FwdIter14Size8FwdIter2">
<span id="_CPPv2N3hpx8parallel2v16copy_nERR8ExPolicy8FwdIter14Size8FwdIter2"></span><span id="hpx::parallel::v1::copy_n__ExPolicyRR.FwdIter1.Size.FwdIter2"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> Size, <em class="property">typename</em> FwdIter2&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a6d350049604581b94b5f2be53f44de3c"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::in<span class="sig-paren">(</span>FwdIter1<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>FwdIter2<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">copy_n</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, Size <em>count</em>, FwdIter2 <em>dest</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v16copy_nERR8ExPolicy8FwdIter14Size8FwdIter2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the elements in the range [first, first + count), starting from first and proceeding to first + count - 1., to another range beginning at dest.</p>
<p><p>The assignments in the parallel </p>
<em>copy_n</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>count</em> assignments, if count &gt; 0, no assignments otherwise.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Size</span></code>: The type of the argument specifying the number of elements to apply <em>f</em> to. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">count</span></code>: Refers to the number of elements starting at <em>first</em> the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>copy_n</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>copy_n</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</em> &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</em> otherwise. The <em>copy</em> algorithm returns the pair of the input iterator forwarded to the first element after the last in the input sequence and the output iterator to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v17copy_ifERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR1FRR4Proj">
<span id="_CPPv2N3hpx8parallel2v17copy_ifERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR1FRR4Proj"></span><span id="hpx::parallel::v1::copy_if__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.FRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> F, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1ad89029658c0519f9fa9ad90ec4e6301c"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::in<span class="sig-paren">(</span>FwdIter1<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>FwdIter2<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">copy_if</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, FwdIter1 <em>last</em>, FwdIter2 <em>dest</em>, F &amp;&amp;<em>f</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v17copy_ifERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR1FRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the elements in the range, defined by [first, last), to another range beginning at <em>dest</em>. Copies only the elements for which the predicate <em>f</em> returns true. The order of the elements that are not removed is preserved.</p>
<p><p>The assignments in the parallel </p>
<em>copy_if</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs not more than <em>last</em> - <em>first</em> assignments, exactly <em>last</em> - <em>first</em> applications of the predicate <em>f</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>copy_if</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is an unary predicate which returns <em>true</em> for the required elements. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter1</em> can be dereferenced and then implicitly converted to Type. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>copy_if</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>copy_if</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</em> &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</em> otherwise. The <em>copy</em> algorithm returns the pair of the input iterator forwarded to the first element after the last in the input sequence and the output iterator to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v15countERR8ExPolicy7FwdIter7FwdIterR1TRR4Proj">
<span id="_CPPv2N3hpx8parallel2v15countERR8ExPolicy7FwdIter7FwdIterR1TRR4Proj"></span><span id="hpx::parallel::v1::count__ExPolicyRR.FwdIter.FwdIter.TCR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> T, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1ae258fb726908a80a6bd50479416d9605"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <em class="property">typename</em> std::iterator_traits&lt;FwdIter&gt;::difference_type&gt;::type <code class="descname">count</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, T <em class="property">const</em> &amp;<em>value</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v15countERR8ExPolicy7FwdIter7FwdIterR1TRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the number of elements in the range [first, last) satisfying a specific criteria. This version counts the elements that are equal to the given <em>value</em>.</p>
<p><p>The comparisons in the parallel </p>
<em>count</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>last</em> - <em>first</em> comparisons.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the comparisons. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the value to search for (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">value</span></code>: The value to search for. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The comparisons in the parallel <em>count</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</dd>
<dt><strong>Return</strong></dt>
<dd>The <em>count</em> algorithm returns a <em>hpx::future&lt;difference_type&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>difference_type</em> otherwise (where <em>difference_type</em> is defined by <em>std::iterator_traits&lt;FwdIter&gt;::difference_type</em>. The <em>count</em> algorithm returns the number of elements satisfying the given criteria. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v18count_ifERR8ExPolicy7FwdIter7FwdIterRR1FRR4Proj">
<span id="_CPPv2N3hpx8parallel2v18count_ifERR8ExPolicy7FwdIter7FwdIterRR1FRR4Proj"></span><span id="hpx::parallel::v1::count_if__ExPolicyRR.FwdIter.FwdIter.FRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> F, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1aa37d778b6c79f6221b72eb738799057f"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <em class="property">typename</em> std::iterator_traits&lt;FwdIter&gt;::difference_type&gt;::type <code class="descname">count_if</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, F &amp;&amp;<em>f</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v18count_ifERR8ExPolicy7FwdIter7FwdIterRR1FRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the number of elements in the range [first, last) satisfying a specific criteria. This version counts elements for which predicate <em>f</em> returns true.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>last</em> - <em>first</em> applications of the predicate.</dd>
<dt><strong>Note</strong></dt>
<dd>The assignments in the parallel <em>count_if</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread. </dd>
<dt><strong>Note</strong></dt>
<dd>The assignments in the parallel <em>count_if</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</dd>
<dt><strong>Return</strong></dt>
<dd>The <em>count_if</em> algorithm returns <em>hpx::future&lt;difference_type&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>difference_type</em> otherwise (where <em>difference_type</em> is defined by <em>std::iterator_traits&lt;FwdIter&gt;::difference_type</em>. The <em>count</em> algorithm returns the number of elements satisfying the given criteria. </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the comparisons. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>count_if</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is an unary predicate which returns <em>true</em> for the required elements. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter</em> can be dereferenced and then implicitly converted to Type. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v17destroyERR8ExPolicy7FwdIter7FwdIter">
<span id="_CPPv2N3hpx8parallel2v17destroyERR8ExPolicy7FwdIter7FwdIter"></span><span id="hpx::parallel::v1::destroy__ExPolicyRR.FwdIter.FwdIter"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a70065cb704eb09d1fa9328763fe358d3"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy&gt;::type <code class="descname">destroy</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v17destroyERR8ExPolicy7FwdIter7FwdIter" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Destroys objects of type typename iterator_traits&lt;ForwardIt&gt;::value_type in the range [first, last).</p>
<p><p>The operations in the parallel </p>
<em>destroy</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>last</em> - <em>first</em> operations.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to.</li>
</ul>
</dd>
</dl>
</p>
<p>The operations in the parallel <em>destroy</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>destroy</em> algorithm returns a <em>hpx::future&lt;void&gt;</em>, if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>void</em> otherwise. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v19destroy_nERR8ExPolicy7FwdIter4Size">
<span id="_CPPv2N3hpx8parallel2v19destroy_nERR8ExPolicy7FwdIter4Size"></span><span id="hpx::parallel::v1::destroy_n__ExPolicyRR.FwdIter.Size"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> Size&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1abe254a1d5dfcac6f794487708b10f63a"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type <code class="descname">destroy_n</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, Size <em>count</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v19destroy_nERR8ExPolicy7FwdIter4Size" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Destroys objects of type typename iterator_traits&lt;ForwardIt&gt;::value_type in the range [first, first + count).</p>
<p><p>The operations in the parallel </p>
<em>destroy_n</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>count</em> operations, if count &gt; 0, no assignments otherwise.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Size</span></code>: The type of the argument specifying the number of elements to apply this algorithm to.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">count</span></code>: Refers to the number of elements starting at <em>first</em> the algorithm will be applied to.</li>
</ul>
</dd>
</dl>
</p>
<p>The operations in the parallel <em>destroy_n</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>destroy_n</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter</em> otherwise. The <em>destroy_n</em> algorithm returns the iterator to the element in the source range, one past the last element constructed. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v15equalERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter2RR4Pred">
<span id="_CPPv2N3hpx8parallel2v15equalERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter2RR4Pred"></span><span id="hpx::parallel::v1::equal__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.FwdIter2.PredRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> Pred = detail::equal_to&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a0c7fdfade58cb9d4dda65892a877aa58"></span>std::enable_if&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, bool&gt;::type&gt;::type <code class="descname">equal</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first1</em>, FwdIter1 <em>last1</em>, FwdIter2 <em>first2</em>, FwdIter2 <em>last2</em>, Pred &amp;&amp;<em>op</em> = Pred()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v15equalERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter2RR4Pred" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns true if the range [first1, last1) is equal to the range [first2, last2), and false otherwise.</p>
<p><p>The comparison operations in the parallel </p>
<em>equal</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: At most min(last1 - first1, last2 - first2) applications of the predicate <em>f</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used for the first range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the source iterators used for the second range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <em>equal</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::equal_to&lt;&gt;</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first1</span></code>: Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last1</span></code>: Refers to the end of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">first2</span></code>: Refers to the beginning of the sequence of elements of the second range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last2</span></code>: Refers to the end of the sequence of elements of the second range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">op</span></code>: The binary predicate which returns true if the elements should be treated as equal. The signature of the predicate function should be equivalent to the following: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type2</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> and <em>Type2</em> must be such that objects of types <em>FwdIter1</em> and <em>FwdIter2</em> can be dereferenced and then implicitly converted to <em>Type1</em> and <em>Type2</em> respectively</li>
</ul>
</dd>
</dl>
</p>
<p>The comparison operations in the parallel <em>equal</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The two ranges are considered equal if, for every iterator i in the range [first1,last1), *i equals *(first2 + (i - first1)). This overload of equal uses operator== to determine if two elements are equal.</dd>
<dt><strong>Return</strong></dt>
<dd>The <em>equal</em> algorithm returns a <em>hpx::future&lt;bool&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>bool</em> otherwise. The <em>equal</em> algorithm returns true if the elements in the two ranges are equal, otherwise it returns false. If the length of the range [first1, last1) does not equal the length of the range [first2, last2), it returns false. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v15equalERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR4Pred">
<span id="_CPPv2N3hpx8parallel2v15equalERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR4Pred"></span><span id="hpx::parallel::v1::equal__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.PredRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> Pred = detail::equal_to&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1aae6a4bb3c2e497c3bf1425763047b39d"></span>std::enable_if&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, bool&gt;::type&gt;::type <code class="descname">equal</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first1</em>, FwdIter1 <em>last1</em>, FwdIter2 <em>first2</em>, Pred &amp;&amp;<em>op</em> = Pred()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v15equalERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR4Pred" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns true if the range [first1, last1) is equal to the range starting at first2, and false otherwise.</p>
<p><p>The comparison operations in the parallel </p>
<em>equal</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: At most <em>last1</em> - <em>first1</em> applications of the predicate <em>f</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used for the first range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the source iterators used for the second range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <em>equal</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::equal_to&lt;&gt;</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first1</span></code>: Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last1</span></code>: Refers to the end of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">first2</span></code>: Refers to the beginning of the sequence of elements of the second range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">op</span></code>: The binary predicate which returns true if the elements should be treated as equal. The signature of the predicate function should be equivalent to the following: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type2</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> and <em>Type2</em> must be such that objects of types <em>FwdIter1</em> and <em>FwdIter2</em> can be dereferenced and then implicitly converted to <em>Type1</em> and <em>Type2</em> respectively</li>
</ul>
</dd>
</dl>
</p>
<p>The comparison operations in the parallel <em>equal</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The two ranges are considered equal if, for every iterator i in the range [first1,last1), *i equals *(first2 + (i - first1)). This overload of equal uses operator== to determine if two elements are equal.</dd>
<dt><strong>Return</strong></dt>
<dd>The <em>equal</em> algorithm returns a <em>hpx::future&lt;bool&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>bool</em> otherwise. The <em>equal</em> algorithm returns true if the elements in the two ranges are equal, otherwise it returns false. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v114exclusive_scanERR8ExPolicy8FwdIter18FwdIter18FwdIter21TRR2Op">
<span id="_CPPv2N3hpx8parallel2v114exclusive_scanERR8ExPolicy8FwdIter18FwdIter18FwdIter21TRR2Op"></span><span id="hpx::parallel::v1::exclusive_scan__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.T.OpRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> T, <em class="property">typename</em> Op&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a1470fceceb3fd845bc561c8435a94685"></span>std::enable_if&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter2&gt;::type&gt;::type <code class="descname">exclusive_scan</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, FwdIter1 <em>last</em>, FwdIter2 <em>dest</em>, T <em>init</em>, Op &amp;&amp;<em>op</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v114exclusive_scanERR8ExPolicy8FwdIter18FwdIter18FwdIter21TRR2Op" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assigns through each iterator <em>i</em> in [result, result + (last - first)) the value of GENERALIZED_NONCOMMUTATIVE_SUM(binary_op, init, *first, …, *(first + (i - result) - 1)).</p>
<p><p>The reduce operations in the parallel </p>
<em>exclusive_scan</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: O(<em>last</em> - <em>first</em>) applications of the predicate <em>op</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the value to be used as initial (and intermediate) values (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">Op</span></code>: The type of the binary function object used for the reduction operation.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">init</span></code>: The initial value for the generalized sum. </li>
<li><code class="docutils literal notranslate"><span class="pre">op</span></code>: Specifies the function (or function object) which will be invoked for each of the values of the input sequence. This is a binary predicate. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ret</span> <span class="nf">fun</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> and <em>Ret</em> must be such that an object of a type as given by the input sequence can be implicitly converted to any of those types.</li>
</ul>
</dd>
</dl>
</p>
<p>The reduce operations in the parallel <em>exclusive_scan</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><p>The difference between </p>
<em>exclusive_scan</em> and <em>inclusive_scan</em> is that <em>inclusive_scan</em> includes the ith input element in the ith sum. If <em>op</em> is not mathematically associative, the behavior of <em>inclusive_scan</em> may be non-deterministic. <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>copy_n</em> algorithm returns a <em>hpx::future&lt;FwdIter2&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter2</em> otherwise. The <em>exclusive_scan</em> algorithm returns the output iterator to the element in the destination range, one past the last element copied.</dd>
<dt><strong>Note</strong></dt>
<dd>GENERALIZED_NONCOMMUTATIVE_SUM(op, a1, …, aN) is defined as:<ul class="simple">
<li>a1 when N is 1</li>
<li>op(GENERALIZED_NONCOMMUTATIVE_SUM(op, a1, …, aK), GENERALIZED_NONCOMMUTATIVE_SUM(op, aM, …, aN)) where 1 &lt; K+1 = M &lt;= N.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v114exclusive_scanERR8ExPolicy8FwdIter18FwdIter18FwdIter21T">
<span id="_CPPv2N3hpx8parallel2v114exclusive_scanERR8ExPolicy8FwdIter18FwdIter18FwdIter21T"></span><span id="hpx::parallel::v1::exclusive_scan__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.T"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> T&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a064ea3f7e2564c51f7aa41b41ea5adeb"></span>std::enable_if&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter2&gt;::type&gt;::type <code class="descname">exclusive_scan</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, FwdIter1 <em>last</em>, FwdIter2 <em>dest</em>, T <em>init</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v114exclusive_scanERR8ExPolicy8FwdIter18FwdIter18FwdIter21T" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assigns through each iterator <em>i</em> in [result, result + (last - first)) the value of GENERALIZED_NONCOMMUTATIVE_SUM(+, init, *first, …, *(first + (i - result) - 1))</p>
<p><p>The reduce operations in the parallel </p>
<em>exclusive_scan</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: O(<em>last</em> - <em>first</em>) applications of the predicate <em>std::plus&lt;T&gt;</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the value to be used as initial (and intermediate) values (deduced).</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">init</span></code>: The initial value for the generalized sum.</li>
</ul>
</dd>
</dl>
</p>
<p>The reduce operations in the parallel <em>exclusive_scan</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><p>The difference between </p>
<em>exclusive_scan</em> and <em>inclusive_scan</em> is that <em>inclusive_scan</em> includes the ith input element in the ith sum. <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>copy_n</em> algorithm returns a <em>hpx::future&lt;FwdIter2&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter2</em> otherwise. The <em>exclusive_scan</em> algorithm returns the output iterator to the element in the destination range, one past the last element copied.</dd>
<dt><strong>Note</strong></dt>
<dd>GENERALIZED_NONCOMMUTATIVE_SUM(+, a1, …, aN) is defined as:<ul class="simple">
<li>a1 when N is 1</li>
<li>GENERALIZED_NONCOMMUTATIVE_SUM(+, a1, …, aK)<ul>
<li>GENERALIZED_NONCOMMUTATIVE_SUM(+, aM, …, aN) where 1 &lt; K+1 = M &lt;= N.</li>
</ul>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v14fillERR8ExPolicy7FwdIter7FwdIter1T">
<span id="_CPPv2N3hpx8parallel2v14fillERR8ExPolicy7FwdIter7FwdIter1T"></span><span id="hpx::parallel::v1::fill__ExPolicyRR.FwdIter.FwdIter.T"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> T&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1ab171416328f41cfba30983f0ed87d857"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy&gt;::type <code class="descname">fill</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, T <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v14fillERR8ExPolicy7FwdIter7FwdIter1T" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assigns the given value to the elements in the range [first, last).</p>
<p><p>The comparisons in the parallel </p>
<em>fill</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>last</em> - <em>first</em> assignments.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the value to be assigned (deduced).</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">value</span></code>: The value to be assigned.</li>
</ul>
</dd>
</dl>
</p>
<p>The comparisons in the parallel <em>fill</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>fill</em> algorithm returns a <em>hpx::future&lt;void&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>difference_type</em> otherwise (where <em>difference_type</em> is defined by <em>void</em>. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v16fill_nERR8ExPolicy7FwdIter4Size1T">
<span id="_CPPv2N3hpx8parallel2v16fill_nERR8ExPolicy7FwdIter4Size1T"></span><span id="hpx::parallel::v1::fill_n__ExPolicyRR.FwdIter.Size.T"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> Size, <em class="property">typename</em> T&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a7af4288c99d46acbc017b1f8e7ef7ac8"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type <code class="descname">fill_n</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, Size <em>count</em>, T <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v16fill_nERR8ExPolicy7FwdIter4Size1T" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assigns the given value value to the first count elements in the range beginning at first if count &gt; 0. Does nothing otherwise.</p>
<p><p>The comparisons in the parallel </p>
<em>fill_n</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>count</em> assignments, for count &gt; 0.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an output iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Size</span></code>: The type of the argument specifying the number of elements to apply <em>f</em> to. </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the value to be assigned (deduced).</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">count</span></code>: Refers to the number of elements starting at <em>first</em> the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">value</span></code>: The value to be assigned.</li>
</ul>
</dd>
</dl>
</p>
<p>The comparisons in the parallel <em>fill_n</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>fill_n</em> algorithm returns a <em>hpx::future&lt;void&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>difference_type</em> otherwise (where <em>difference_type</em> is defined by <em>void</em>. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v14findERR8ExPolicy7FwdIter7FwdIterR1T">
<span id="_CPPv2N3hpx8parallel2v14findERR8ExPolicy7FwdIter7FwdIterR1T"></span><span id="hpx::parallel::v1::find__ExPolicyRR.FwdIter.FwdIter.TCR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> T&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a76c5f5c453899c36a61bfa76425b007a"></span>std::enable_if&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type&gt;::type <code class="descname">find</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, T <em class="property">const</em> &amp;<em>val</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v14findERR8ExPolicy7FwdIter7FwdIterR1T" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the first element in the range [first, last) that is equal to value</p>
<p><p>The comparison operations in the parallel </p>
<em>find</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: At most last - first applications of the operator==().</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used for the first range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the value to find (deduced).</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">val</span></code>: the value to compare the elements to</li>
</ul>
</dd>
</dl>
</p>
<p>The comparison operations in the parallel <em>find</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>find</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter</em> otherwise. The <em>find</em> algorithm returns the first element in the range [first,last) that is equal to <em>val</em>. If no such element in the range of [first,last) is equal to <em>val</em>, then the algorithm returns <em>last</em>. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v17find_ifERR8ExPolicy7FwdIter7FwdIterRR1F">
<span id="_CPPv2N3hpx8parallel2v17find_ifERR8ExPolicy7FwdIter7FwdIterRR1F"></span><span id="hpx::parallel::v1::find_if__ExPolicyRR.FwdIter.FwdIter.FRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> F&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a1f66ab2a9b26ef5b5ed2c08194586b86"></span>std::enable_if&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type&gt;::type <code class="descname">find_if</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, F &amp;&amp;<em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v17find_ifERR8ExPolicy7FwdIter7FwdIterRR1F" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the first element in the range [first, last) for which predicate <em>f</em> returns true</p>
<p><p>The comparison operations in the parallel </p>
<em>find_if</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: At most last - first applications of the predicate.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used for the first range (deduced). This iterator type must meet the requirements of a forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>equal</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: The unary predicate which returns true for the required element. The signature of the predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that objects of type <em>FwdIter</em> can be dereferenced and then implicitly converted to <em>Type</em>.</li>
</ul>
</dd>
</dl>
</p>
<p>The comparison operations in the parallel <em>find_if</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>find_if</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter</em> otherwise. The <em>find_if</em> algorithm returns the first element in the range [first,last) that satisfies the predicate <em>f</em>. If no such element exists that satisfies the predicate f, the algorithm returns <em>last</em>. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v111find_if_notERR8ExPolicy7FwdIter7FwdIterRR1F">
<span id="_CPPv2N3hpx8parallel2v111find_if_notERR8ExPolicy7FwdIter7FwdIterRR1F"></span><span id="hpx::parallel::v1::find_if_not__ExPolicyRR.FwdIter.FwdIter.FRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> F&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1ac7aaee4759c37f4d0e83b51f313aa28d"></span>std::enable_if&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type&gt;::type <code class="descname">find_if_not</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, F &amp;&amp;<em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v111find_if_notERR8ExPolicy7FwdIter7FwdIterRR1F" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the first element in the range [first, last) for which predicate <em>f</em> returns false</p>
<p><p>The comparison operations in the parallel </p>
<em>find_if_not</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: At most last - first applications of the predicate.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used for the first range (deduced). This iterator type must meet the requirements of a forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>equal</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: The unary predicate which returns false for the required element. The signature of the predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that objects of type <em>FwdIter</em> can be dereferenced and then implicitly converted to <em>Type</em>.</li>
</ul>
</dd>
</dl>
</p>
<p>The comparison operations in the parallel <em>find_if_not</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>find_if_not</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter</em> otherwise. The <em>find_if_not</em> algorithm returns the first element in the range [first, last) that does <strong>not</strong> satisfy the predicate <em>f</em>. If no such element exists that does not satisfy the predicate f, the algorithm returns <em>last</em>. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v18find_endERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter2RR4PredRR4Proj">
<span id="_CPPv2N3hpx8parallel2v18find_endERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter2RR4PredRR4Proj"></span><span id="hpx::parallel::v1::find_end__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.FwdIter2.PredRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> Pred = detail::equal_to, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a59ea9f8ce4b447a377d4d78ef2dbd2b5"></span>std::enable_if&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter1&gt;::type&gt;::type <code class="descname">find_end</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first1</em>, FwdIter1 <em>last1</em>, FwdIter2 <em>first2</em>, FwdIter2 <em>last2</em>, Pred &amp;&amp;<em>op</em> = Pred(), Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v18find_endERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter2RR4PredRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the last subsequence of elements [first2, last2) found in the range [first, last) using the given predicate <em>f</em> to compare elements.</p>
<p><p>The comparison operations in the parallel </p>
<em>find_end</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: at most S*(N-S+1) comparisons where <em>S</em> = distance(first2, last2) and <em>N</em> = distance(first1, last1).</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used for the first range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the source iterators used for the second range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <em>replace</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::equal_to&lt;&gt; </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> and is applied to the elements of type dereferenced <em>FwdIter1</em> and dereferenced <em>FwdIter2</em>.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first1</span></code>: Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last1</span></code>: Refers to the end of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">first2</span></code>: Refers to the beginning of the sequence of elements the algorithm will be searching for. </li>
<li><code class="docutils literal notranslate"><span class="pre">last2</span></code>: Refers to the end of the sequence of elements of the algorithm will be searching for. </li>
<li><code class="docutils literal notranslate"><span class="pre">op</span></code>: The binary predicate which returns <em>true</em> if the elements should be treated as equal. The signature should be equivalent to the following: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type2</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> and <em>Type2</em> must be such that objects of types <em>FwdIter1</em> and <em>FwdIter2</em> can be dereferenced and then implicitly converted to <em>Type1</em> and <em>Type2</em> respectively. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of type dereferenced <em>FwdIter1</em> and dereferenced <em>FwdIter2</em> as a projection operation before the function <em>f</em> is invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The comparison operations in the parallel <em>find_end</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><p>This overload of </p>
<em>find_end</em> is available if the user decides to provide the algorithm their own predicate <em>f</em>. <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>find_end</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter</em> otherwise. The <em>find_end</em> algorithm returns an iterator to the beginning of the last subsequence [first2, last2) in range [first, last). If the length of the subsequence [first2, last2) is greater than the length of the range [first1, last1), <em>last1</em> is returned. Additionally if the size of the subsequence is empty or no subsequence is found, <em>last1</em> is also returned.</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v113find_first_ofERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter2RR4PredRR5Proj1RR5Proj2">
<span id="_CPPv2N3hpx8parallel2v113find_first_ofERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter2RR4PredRR5Proj1RR5Proj2"></span><span id="hpx::parallel::v1::find_first_of__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.FwdIter2.PredRR.Proj1RR.Proj2RR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> Pred = detail::equal_to, <em class="property">typename</em> Proj1 = util::projection_identity, <em class="property">typename</em> Proj2 = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a9a2a32b88ef22a7af9c9009eac33c6de"></span>std::enable_if&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter1&gt;::type&gt;::type <code class="descname">find_first_of</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, FwdIter1 <em>last</em>, FwdIter2 <em>s_first</em>, FwdIter2 <em>s_last</em>, Pred &amp;&amp;<em>op</em> = Pred(), Proj1 &amp;&amp;<em>proj1</em> = Proj1(), Proj2 &amp;&amp;<em>proj2</em> = Proj2()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v113find_first_ofERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter2RR4PredRR5Proj1RR5Proj2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Searches the range [first, last) for any elements in the range [s_first, s_last). Uses binary predicate p to compare elements</p>
<p><p>The comparison operations in the parallel </p>
<em>find_first_of</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: at most (S*N) comparisons where <em>S</em> = distance(s_first, s_last) and <em>N</em> = distance(first, last).</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used for the first range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the source iterators used for the second range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <em>equal</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::equal_to&lt;&gt; </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj1</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> and is applied to the elements of type dereferenced <em>FwdIter1</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj2</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> and is applied to the elements of type dereferenced <em>FwdIter2</em>.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">s_first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be searching for. </li>
<li><code class="docutils literal notranslate"><span class="pre">s_last</span></code>: Refers to the end of the sequence of elements of the algorithm will be searching for. </li>
<li><code class="docutils literal notranslate"><span class="pre">op</span></code>: The binary predicate which returns <em>true</em> if the elements should be treated as equal. The signature should be equivalent to the following: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type2</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> and <em>Type2</em> must be such that objects of types <em>FwdIter1</em> and <em>FwdIter2</em> can be dereferenced and then implicitly converted to <em>Type1</em> and <em>Type2</em> respectively. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj1</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of type dereferenced <em>FwdIter1</em> as a projection operation before the function <em>op</em> is invoked. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj2</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of type dereferenced <em>FwdIter2</em> as a projection operation before the function <em>op</em> is invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The comparison operations in the parallel <em>find_first_of</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>find_first_of</em> algorithm returns a <em>hpx::future&lt;FwdIter1&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter1</em> otherwise. The <em>find_first_of</em> algorithm returns an iterator to the first element in the range [first, last) that is equal to an element from the range [s_first, s_last). If the length of the subsequence [s_first, s_last) is greater than the length of the range [first, last), <em>last</em> is returned. Additionally if the size of the subsequence is empty or no subsequence is found, <em>last</em> is also returned. This overload of <em>find_end</em> is available if the user decides to provide the algorithm their own predicate <em>f</em>. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v110for_each_nERR8ExPolicy7FwdIter4SizeRR1FRR4Proj">
<span id="_CPPv2N3hpx8parallel2v110for_each_nERR8ExPolicy7FwdIter4SizeRR1FRR4Proj"></span><span id="hpx::parallel::v1::for_each_n__ExPolicyRR.FwdIter.Size.FRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> Size, <em class="property">typename</em> F, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1ae99cf785be3f48daf11e9ff21e2c2ebb"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type <code class="descname">for_each_n</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, Size <em>count</em>, F &amp;&amp;<em>f</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v110for_each_nERR8ExPolicy7FwdIter4SizeRR1FRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Applies <em>f</em> to the result of dereferencing every iterator in the range [first, first + count), starting from first and proceeding to first + count - 1.</p>
<p><p>If </p>
<em>f</em> returns a result, the result is ignored.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Applies <em>f</em> exactly <em>count</em> times.</dd>
</dl>
</p>
<p>If the type of <em>first</em> satisfies the requirements of a mutable iterator, <em>f</em> may apply non-constant functions through the dereferenced iterator.</p>
<p>Unlike its sequential form, the parallel overload of <em>for_each</em> does not return a copy of its <em>Function</em> parameter, since parallelization may not permit efficient state accumulation.</p>
<p><p>The application of function objects in parallel algorithm invoked with an execution policy object of type </p>
<em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Size</span></code>: The type of the argument specifying the number of elements to apply <em>f</em> to. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>for_each</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">count</span></code>: Refers to the number of elements starting at <em>first</em> the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">ignored</span><span class="o">&gt;</span> <span class="n">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter</em> can be dereferenced and then implicitly converted to Type. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>f</em> is invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>for_each_n</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter</em> otherwise. It returns <em>first</em> + <em>count</em> for non-negative values of <em>count</em> and <em>first</em> for negative values. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v18for_eachERR8ExPolicy7FwdIter7FwdIterRR1FRR4Proj">
<span id="_CPPv2N3hpx8parallel2v18for_eachERR8ExPolicy7FwdIter7FwdIterRR1FRR4Proj"></span><span id="hpx::parallel::v1::for_each__ExPolicyRR.FwdIter.FwdIter.FRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> F, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a4eeac314eec9001c03e68882d85e9123"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type <code class="descname">for_each</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, F &amp;&amp;<em>f</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v18for_eachERR8ExPolicy7FwdIter7FwdIterRR1FRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Applies <em>f</em> to the result of dereferencing every iterator in the range [first, last).</p>
<p><p>If </p>
<em>f</em> returns a result, the result is ignored.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Applies <em>f</em> exactly <em>last</em> - <em>first</em> times.</dd>
</dl>
</p>
<p>If the type of <em>first</em> satisfies the requirements of a mutable iterator, <em>f</em> may apply non-constant functions through the dereferenced iterator.</p>
<p>Unlike its sequential form, the parallel overload of <em>for_each</em> does not return a copy of its <em>Function</em> parameter, since parallelization may not permit efficient state accumulation.</p>
<p><p>The application of function objects in parallel algorithm invoked with an execution policy object of type </p>
<em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>for_each</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">ignored</span><span class="o">&gt;</span> <span class="n">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter</em> can be dereferenced and then implicitly converted to Type. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>f</em> is invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>for_each</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter</em> otherwise. It returns <em>last</em>. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v18generateERR8ExPolicy7FwdIter7FwdIterRR1F">
<span id="_CPPv2N3hpx8parallel2v18generateERR8ExPolicy7FwdIter7FwdIterRR1F"></span><span id="hpx::parallel::v1::generate__ExPolicyRR.FwdIter.FwdIter.FRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> F&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a8b4e673fc690318448e989c780055d17"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type <code class="descname">generate</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, F &amp;&amp;<em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v18generateERR8ExPolicy7FwdIter7FwdIterRR1F" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assign each element in range [first, last) a value generated by the given function object f</p>
<p><p>The assignments in the parallel </p>
<em>generate</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Exactly <em>distance(first, last)</em> invocations of <em>f</em> and assignments.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of a forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>equal</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: generator function that will be called. signature of function should be equivalent to the following: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ret</span> <span class="nf">fun</span><span class="p">();</span>
</pre></div>
</div>
 <p> The type </p>
<em>Ret</em> must be such that an object of type <em>FwdIter</em> can be dereferenced and assigned a value of type <em>Ret</em>.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>generate</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>replace_if</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter</em> otherwise. It returns <em>last</em>. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v110generate_nERR8ExPolicy7FwdIter4SizeRR1F">
<span id="_CPPv2N3hpx8parallel2v110generate_nERR8ExPolicy7FwdIter4SizeRR1F"></span><span id="hpx::parallel::v1::generate_n__ExPolicyRR.FwdIter.Size.FRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> Size, <em class="property">typename</em> F&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a76accd6d0c29469d74b51c9ebb3d4586"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type <code class="descname">generate_n</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, Size <em>count</em>, F &amp;&amp;<em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v110generate_nERR8ExPolicy7FwdIter4SizeRR1F" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assigns each element in range [first, first+count) a value generated by the given function object g.</p>
<p><p>The assignments in the parallel </p>
<em>generate_n</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Exactly <em>count</em> invocations of <em>f</em> and assignments, for count &gt; 0.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>equal</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">count</span></code>: Refers to the number of elements in the sequence the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Refers to the generator function object that will be called. The signature of the function should be equivalent to <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ret</span> <span class="nf">fun</span><span class="p">();</span>
</pre></div>
</div>
 <p> The type </p>
<em>Ret</em> must be such that an object of type <em>OutputIt</em> can be dereferenced and assigned a value of type <em>Ret</em>.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>generate_n</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>replace_if</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter</em> otherwise. It returns <em>last</em>. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v17is_heapERR8ExPolicy8RandIter8RandIterRR4CompRR4Proj">
<span id="_CPPv2N3hpx8parallel2v17is_heapERR8ExPolicy8RandIter8RandIterRR4CompRR4Proj"></span><span id="hpx::parallel::v1::is_heap__ExPolicyRR.RandIter.RandIter.CompRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> RandIter, <em class="property">typename</em> Comp = detail::less, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a284adaa6f9b0e09f16df5985b9750f93"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, bool&gt;::type <code class="descname">is_heap</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, RandIter <em>first</em>, RandIter <em>last</em>, Comp &amp;&amp;<em>comp</em> = Comp(), Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v17is_heapERR8ExPolicy8RandIter8RandIterRR4CompRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns whether the range is max heap. That is, true if the range is max heap, false otherwise. The function uses the given comparison function object <em>comp</em> (defaults to using operator&lt;()).</p>
<p><em>comp</em> has to induce a strict weak ordering on the values.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs at most N applications of the comparison <em>comp</em>, at most 2 * N applications of the projection <em>proj</em>, where N = last - first.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">RandIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of a random access iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Comp</span></code>: The type of the function/function object to use (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">comp</span></code>: <em>comp</em> is a callable object. The return value of the INVOKE operation applied to an object of type <em>Comp</em>, when contextually converted to bool, yields true if the first argument of the call is less than the second, and false otherwise. It is assumed that comp will not apply any non-constant function through the dereferenced iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>is_heap</em> algorithm returns a <em>hpx::future&lt;bool&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>bool</em> otherwise. The <em>is_heap</em> algorithm returns whether the range is max heap. That is, true if the range is max heap, false otherwise. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v113is_heap_untilERR8ExPolicy8RandIter8RandIterRR4CompRR4Proj">
<span id="_CPPv2N3hpx8parallel2v113is_heap_untilERR8ExPolicy8RandIter8RandIterRR4CompRR4Proj"></span><span id="hpx::parallel::v1::is_heap_until__ExPolicyRR.RandIter.RandIter.CompRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> RandIter, <em class="property">typename</em> Comp = detail::less, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1af348f9ef4c58daed9fb9cb1d057678fb"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, RandIter&gt;::type <code class="descname">is_heap_until</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, RandIter <em>first</em>, RandIter <em>last</em>, Comp &amp;&amp;<em>comp</em> = Comp(), Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v113is_heap_untilERR8ExPolicy8RandIter8RandIterRR4CompRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the upper bound of the largest range beginning at <em>first</em> which is a max heap. That is, the last iterator <em>it</em> for which range [first, it) is a max heap. The function uses the given comparison function object <em>comp</em> (defaults to using operator&lt;()).</p>
<p><em>comp</em> has to induce a strict weak ordering on the values.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs at most N applications of the comparison <em>comp</em>, at most 2 * N applications of the projection <em>proj</em>, where N = last - first.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">RandIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of a random access iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Comp</span></code>: The type of the function/function object to use (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">comp</span></code>: <em>comp</em> is a callable object. The return value of the INVOKE operation applied to an object of type <em>Comp</em>, when contextually converted to bool, yields true if the first argument of the call is less than the second, and false otherwise. It is assumed that comp will not apply any non-constant function through the dereferenced iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>is_heap_until</em> algorithm returns a <em>hpx::future&lt;RandIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>RandIter</em> otherwise. The <em>is_heap_until</em> algorithm returns the upper bound of the largest range beginning at first which is a max heap. That is, the last iterator <em>it</em> for which range [first, it) is a max heap. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v18includesERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter2RR4Pred">
<span id="_CPPv2N3hpx8parallel2v18includesERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter2RR4Pred"></span><span id="hpx::parallel::v1::includes__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.FwdIter2.PredRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> Pred = detail::less&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a3ab31b809075cedeedb2fa9ef05a55e5"></span>std::enable_if&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, bool&gt;::type&gt;::type <code class="descname">includes</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first1</em>, FwdIter1 <em>last1</em>, FwdIter2 <em>first2</em>, FwdIter2 <em>last2</em>, Pred &amp;&amp;<em>op</em> = Pred()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v18includesERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter2RR4Pred" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns true if every element from the sorted range [first2, last2) is found within the sorted range [first1, last1). Also returns true if [first2, last2) is empty. The version expects both ranges to be sorted with the user supplied binary predicate <em>f</em>.</p>
<p><p>The comparison operations in the parallel </p>
<em>includes</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>At most 2*(N1+N2-1) comparisons, where N1 = std::distance(first1, last1) and N2 = std::distance(first2, last2).</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used for the first range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the source iterators used for the second range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <em>includes</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::less&lt;&gt;</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first1</span></code>: Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last1</span></code>: Refers to the end of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">first2</span></code>: Refers to the beginning of the sequence of elements of the second range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last2</span></code>: Refers to the end of the sequence of elements of the second range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">op</span></code>: The binary predicate which returns true if the elements should be treated as includes. The signature of the predicate function should be equivalent to the following: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type2</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> and <em>Type2</em> must be such that objects of types <em>FwdIter1</em> and <em>FwdIter2</em> can be dereferenced and then implicitly converted to <em>Type1</em> and <em>Type2</em> respectively</li>
</ul>
</dd>
</dl>
</p>
<p>The comparison operations in the parallel <em>includes</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>includes</em> algorithm returns a <em>hpx::future&lt;bool&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>bool</em> otherwise. The <em>includes</em> algorithm returns true every element from the sorted range [first2, last2) is found within the sorted range [first1, last1). Also returns true if [first2, last2) is empty. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v114inclusive_scanERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR2Op1T">
<span id="_CPPv2N3hpx8parallel2v114inclusive_scanERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR2Op1T"></span><span id="hpx::parallel::v1::inclusive_scan__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.OpRR.T"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> Op, <em class="property">typename</em> T&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a7d18e1d19d9f0c47b01fea61deb4af81"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter2&gt;::type <code class="descname">inclusive_scan</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, FwdIter1 <em>last</em>, FwdIter2 <em>dest</em>, Op &amp;&amp;<em>op</em>, T <em>init</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v114inclusive_scanERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR2Op1T" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assigns through each iterator <em>i</em> in [result, result + (last - first)) the value of GENERALIZED_NONCOMMUTATIVE_SUM(op, init, *first, …, *(first + (i - result))).</p>
<p><p>The reduce operations in the parallel </p>
<em>inclusive_scan</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: O(<em>last</em> - <em>first</em>) applications of the predicate <em>op</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the value to be used as initial (and intermediate) values (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">Op</span></code>: The type of the binary function object used for the reduction operation.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">init</span></code>: The initial value for the generalized sum. </li>
<li><code class="docutils literal notranslate"><span class="pre">op</span></code>: Specifies the function (or function object) which will be invoked for each of the values of the input sequence. This is a binary predicate. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ret</span> <span class="nf">fun</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> and <em>Ret</em> must be such that an object of a type as given by the input sequence can be implicitly converted to any of those types.</li>
</ul>
</dd>
</dl>
</p>
<p>The reduce operations in the parallel <em>inclusive_scan</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><p>The difference between </p>
<em>exclusive_scan</em> and <em>inclusive_scan</em> is that <em>inclusive_scan</em> includes the ith input element in the ith sum. If <em>op</em> is not mathematically associative, the behavior of <em>inclusive_scan</em> may be non-deterministic. <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>copy_n</em> algorithm returns a <em>hpx::future&lt;FwdIter2&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter2</em> otherwise. The <em>inclusive_scan</em> algorithm returns the output iterator to the element in the destination range, one past the last element copied.</dd>
<dt><strong>Note</strong></dt>
<dd>GENERALIZED_NONCOMMUTATIVE_SUM(op, a1, …, aN) is defined as:<ul class="simple">
<li>a1 when N is 1</li>
<li>op(GENERALIZED_NONCOMMUTATIVE_SUM(op, a1, …, aK), GENERALIZED_NONCOMMUTATIVE_SUM(op, aM, …, aN)) where 1 &lt; K+1 = M &lt;= N.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v114inclusive_scanERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR2Op">
<span id="_CPPv2N3hpx8parallel2v114inclusive_scanERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR2Op"></span><span id="hpx::parallel::v1::inclusive_scan__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.OpRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> Op&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a7b29dcbcbfc375cf8b2f24ee539a2c81"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter2&gt;::type <code class="descname">inclusive_scan</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, FwdIter1 <em>last</em>, FwdIter2 <em>dest</em>, Op &amp;&amp;<em>op</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v114inclusive_scanERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR2Op" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assigns through each iterator <em>i</em> in [result, result + (last - first)) the value of GENERALIZED_NONCOMMUTATIVE_SUM(op, *first, …, *(first + (i - result))).</p>
<p><p>The reduce operations in the parallel </p>
<em>inclusive_scan</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: O(<em>last</em> - <em>first</em>) applications of the predicate <em>op</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Op</span></code>: The type of the binary function object used for the reduction operation.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">op</span></code>: Specifies the function (or function object) which will be invoked for each of the values of the input sequence. This is a binary predicate. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ret</span> <span class="nf">fun</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> and <em>Ret</em> must be such that an object of a type as given by the input sequence can be implicitly converted to any of those types.</li>
</ul>
</dd>
</dl>
</p>
<p>The reduce operations in the parallel <em>inclusive_scan</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><p>The difference between </p>
<em>exclusive_scan</em> and <em>inclusive_scan</em> is that <em>inclusive_scan</em> includes the ith input element in the ith sum. <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>copy_n</em> algorithm returns a <em>hpx::future&lt;FwdIter2&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter2</em> otherwise. The <em>inclusive_scan</em> algorithm returns the output iterator to the element in the destination range, one past the last element copied.</dd>
<dt><strong>Note</strong></dt>
<dd>GENERALIZED_NONCOMMUTATIVE_SUM(+, a1, …, aN) is defined as:<ul class="simple">
<li>a1 when N is 1</li>
<li>GENERALIZED_NONCOMMUTATIVE_SUM(op, a1, …, aK)<ul>
<li>GENERALIZED_NONCOMMUTATIVE_SUM(+, aM, …, aN) where 1 &lt; K+1 = M &lt;= N.</li>
</ul>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v114inclusive_scanERR8ExPolicy8FwdIter18FwdIter18FwdIter2">
<span id="_CPPv2N3hpx8parallel2v114inclusive_scanERR8ExPolicy8FwdIter18FwdIter18FwdIter2"></span><span id="hpx::parallel::v1::inclusive_scan__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a0398fe2e741f85a40c6edfac14a75a6b"></span>std::enable_if&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter2&gt;::type&gt;::type <code class="descname">inclusive_scan</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, FwdIter1 <em>last</em>, FwdIter2 <em>dest</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v114inclusive_scanERR8ExPolicy8FwdIter18FwdIter18FwdIter2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assigns through each iterator <em>i</em> in [result, result + (last - first)) the value of gENERALIZED_NONCOMMUTATIVE_SUM(+, *first, …, *(first + (i - result))).</p>
<p><p>The reduce operations in the parallel </p>
<em>inclusive_scan</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: O(<em>last</em> - <em>first</em>) applications of the predicate <em>op</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range.</li>
</ul>
</dd>
</dl>
</p>
<p>The reduce operations in the parallel <em>inclusive_scan</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><p>The difference between </p>
<em>exclusive_scan</em> and <em>inclusive_scan</em> is that <em>inclusive_scan</em> includes the ith input element in the ith sum. <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>copy_n</em> algorithm returns a <em>hpx::future&lt;FwdIter2&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter2</em> otherwise. The <em>inclusive_scan</em> algorithm returns the output iterator to the element in the destination range, one past the last element copied.</dd>
<dt><strong>Note</strong></dt>
<dd>GENERALIZED_NONCOMMUTATIVE_SUM(+, a1, …, aN) is defined as:<ul class="simple">
<li>a1 when N is 1</li>
<li>GENERALIZED_NONCOMMUTATIVE_SUM(+, a1, …, aK)<ul>
<li>GENERALIZED_NONCOMMUTATIVE_SUM(+, aM, …, aN) where 1 &lt; K+1 = M &lt;= N.</li>
</ul>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v114is_partitionedERR8ExPolicy7FwdIter7FwdIterRR4Pred">
<span id="_CPPv2N3hpx8parallel2v114is_partitionedERR8ExPolicy7FwdIter7FwdIterRR4Pred"></span><span id="hpx::parallel::v1::is_partitioned__ExPolicyRR.FwdIter.FwdIter.PredRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> Pred&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1ad7462a990ff3755c73bf5cfa130cd70a"></span>std::enable_if&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, bool&gt;::type&gt;::type <code class="descname">is_partitioned</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, Pred &amp;&amp;<em>pred</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v114is_partitionedERR8ExPolicy7FwdIter7FwdIterRR4Pred" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Determines if the range [first, last) is partitioned.</p>
<p><p>The predicate operations in the parallel </p>
<em>is_partitioned</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> executes in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: at most (N) predicate evaluations where <em>N</em> = distance(first, last).</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used for the This iterator type must meet the requirements of a forward iterator. </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements of that the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements of that the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">pred</span></code>: Refers to the binary predicate which returns true if the first argument should be treated as less than the second argument. The signature of the function should be equivalent to <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that objects of types <em>FwdIter</em> can be dereferenced and then implicitly converted to Type.</li>
</ul>
</dd>
</dl>
</p>
<p>The comparison operations in the parallel <em>is_partitioned</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>is_partitioned</em> algorithm returns a <em>hpx::future&lt;bool&gt;</em> if the execution policy is of type <em>task_execution_policy</em> and returns <em>bool</em> otherwise. The <em>is_partitioned</em> algorithm returns true if each element in the sequence for which pred returns true precedes those for which pred returns false. Otherwise is_partitioned returns false. If the range [first, last) contains less than two elements, the function is always true. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v19is_sortedERR8ExPolicy7FwdIter7FwdIterRR4Pred">
<span id="_CPPv2N3hpx8parallel2v19is_sortedERR8ExPolicy7FwdIter7FwdIterRR4Pred"></span><span id="hpx::parallel::v1::is_sorted__ExPolicyRR.FwdIter.FwdIter.PredRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> Pred = detail::less&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a85efa0a779518b75859d9c55fd211cb0"></span>std::enable_if&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, bool&gt;::type&gt;::type <code class="descname">is_sorted</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, Pred &amp;&amp;<em>pred</em> = Pred()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v19is_sortedERR8ExPolicy7FwdIter7FwdIterRR4Pred" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Determines if the range [first, last) is sorted. Uses pred to compare elements.</p>
<p><p>The comparison operations in the parallel </p>
<em>is_sorted</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> executes in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: at most (N+S-1) comparisons where <em>N</em> = distance(first, last). <em>S</em> = number of partitions</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used for the This iterator type must meet the requirements of a forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <em>is_sorted</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::less&lt;&gt;</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements of that the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements of that the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">pred</span></code>: Refers to the binary predicate which returns true if the first argument should be treated as less than the second argument. The signature of the function should be equivalent to <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that objects of types <em>FwdIter</em> can be dereferenced and then implicitly converted to Type.</li>
</ul>
</dd>
</dl>
</p>
<p>The comparison operations in the parallel <em>is_sorted</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>is_sorted</em> algorithm returns a <em>hpx::future&lt;bool&gt;</em> if the execution policy is of type <em>task_execution_policy</em> and returns <em>bool</em> otherwise. The <em>is_sorted</em> algorithm returns a bool if each element in the sequence [first, last) satisfies the predicate passed. If the range [first, last) contains less than two elements, the function always returns true. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v115is_sorted_untilERR8ExPolicy7FwdIter7FwdIterRR4Pred">
<span id="_CPPv2N3hpx8parallel2v115is_sorted_untilERR8ExPolicy7FwdIter7FwdIterRR4Pred"></span><span id="hpx::parallel::v1::is_sorted_until__ExPolicyRR.FwdIter.FwdIter.PredRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> Pred = detail::less&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a2de35f1dad5cc7422fad516a7624daa5"></span>std::enable_if&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type&gt;::type <code class="descname">is_sorted_until</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, Pred &amp;&amp;<em>pred</em> = Pred()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v115is_sorted_untilERR8ExPolicy7FwdIter7FwdIterRR4Pred" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the first element in the range [first, last) that is not sorted. Uses a predicate to compare elements or the less than operator.</p>
<p><p>The comparison operations in the parallel </p>
<em>is_sorted_until</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> executes in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: at most (N+S-1) comparisons where <em>N</em> = distance(first, last). <em>S</em> = number of partitions</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used for the This iterator type must meet the requirements of a forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <em>is_sorted_until</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::less&lt;&gt;</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements of that the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements of that the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">pred</span></code>: Refers to the binary predicate which returns true if the first argument should be treated as less than the second argument. The signature of the function should be equivalent to <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that objects of types <em>FwdIter</em> can be dereferenced and then implicitly converted to Type.</li>
</ul>
</dd>
</dl>
</p>
<p>The comparison operations in the parallel <em>is_sorted_until</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>is_sorted_until</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>task_execution_policy</em> and returns <em>FwdIter</em> otherwise. The <em>is_sorted_until</em> algorithm returns the first unsorted element. If the sequence has less than two elements or the sequence is sorted, last is returned. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v123lexicographical_compareERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter2RR4Pred">
<span id="_CPPv2N3hpx8parallel2v123lexicographical_compareERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter2RR4Pred"></span><span id="hpx::parallel::v1::lexicographical_compare__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.FwdIter2.PredRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> Pred = detail::less&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a6a8e24d8e68f80b9692b010b7d0199a4"></span>std::enable_if&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, bool&gt;::type&gt;::type <code class="descname">lexicographical_compare</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first1</em>, FwdIter1 <em>last1</em>, FwdIter2 <em>first2</em>, FwdIter2 <em>last2</em>, Pred &amp;&amp;<em>pred</em> = Pred()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v123lexicographical_compareERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter2RR4Pred" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Checks if the first range [first1, last1) is lexicographically less than the second range [first2, last2). uses a provided predicate to compare elements.</p>
<p><p>The comparison operations in the parallel </p>
<em>lexicographical_compare</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: At most 2 * min(N1, N2) applications of the comparison operation, where N1 = std::distance(first1, last) and N2 = std::distance(first2, last2).</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used for the first range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the source iterators used for the second range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <em>lexicographical_compare</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::less&lt;&gt;</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first1</span></code>: Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last1</span></code>: Refers to the end of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">first2</span></code>: Refers to the beginning of the sequence of elements of the second range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last2</span></code>: Refers to the end of the sequence of elements of the second range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">pred</span></code>: Refers to the comparison function that the first and second ranges will be applied to</li>
</ul>
</dd>
</dl>
</p>
<p>The comparison operations in the parallel <em>lexicographical_compare</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Lexicographical comparison is an operation with the following properties<ul class="simple">
<li>Two ranges are compared element by element</li>
<li>The first mismatching element defines which range is lexicographically <em>less</em> or <em>greater</em> than the other</li>
<li>If one range is a prefix of another, the shorter range is lexicographically <em>less</em> than the other</li>
<li>If two ranges have equivalent elements and are of the same length, then the ranges are lexicographically <em>equal</em> </li>
<li>An empty range is lexicographically <em>less</em> than any non-empty range</li>
<li>Two empty ranges are lexicographically <em>equal</em> </li>
</ul>
</dd>
<dt><strong>Return</strong></dt>
<dd>The <em>lexicographically_compare</em> algorithm returns a <em>hpx::future&lt;bool&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>bool</em> otherwise. The <em>lexicographically_compare</em> algorithm returns true if the first range is lexicographically less, otherwise it returns false. range [first2, last2), it returns false. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v15mergeERR8ExPolicy9RandIter19RandIter19RandIter29RandIter29RandIter3RR4CompRR5Proj1RR5Proj2">
<span id="_CPPv2N3hpx8parallel2v15mergeERR8ExPolicy9RandIter19RandIter19RandIter29RandIter29RandIter3RR4CompRR5Proj1RR5Proj2"></span><span id="hpx::parallel::v1::merge__ExPolicyRR.RandIter1.RandIter1.RandIter2.RandIter2.RandIter3.CompRR.Proj1RR.Proj2RR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> RandIter1, <em class="property">typename</em> RandIter2, <em class="property">typename</em> RandIter3, <em class="property">typename</em> Comp = detail::less, <em class="property">typename</em> Proj1 = util::projection_identity, <em class="property">typename</em> Proj2 = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1adb389c5b2102405a9f26c0633816e96e"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_tuple&lt;tag::in1<span class="sig-paren">(</span>RandIter1<span class="sig-paren">)</span>, tag::in2<span class="sig-paren">(</span>RandIter2<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>RandIter3<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">merge</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, RandIter1 <em>first1</em>, RandIter1 <em>last1</em>, RandIter2 <em>first2</em>, RandIter2 <em>last2</em>, RandIter3 <em>dest</em>, Comp &amp;&amp;<em>comp</em> = Comp(), Proj1 &amp;&amp;<em>proj1</em> = Proj1(), Proj2 &amp;&amp;<em>proj2</em> = Proj2()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v15mergeERR8ExPolicy9RandIter19RandIter19RandIter29RandIter29RandIter3RR4CompRR5Proj1RR5Proj2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Merges two sorted ranges [first1, last1) and [first2, last2) into one sorted range beginning at <em>dest</em>. The order of equivalent elements in the each of original two ranges is preserved. For equivalent elements in the original two ranges, the elements from the first range precede the elements from the second range. The destination range cannot overlap with either of the input ranges.</p>
<p><p>The assignments in the parallel </p>
<em>merge</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs O(std::distance(first1, last1) + std::distance(first2, last2)) applications of the comparison <em>comp</em> and the each projection.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">RandIter1</span></code>: The type of the source iterators used (deduced) representing the first sorted range. This iterator type must meet the requirements of an random access iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">RandIter2</span></code>: The type of the source iterators used (deduced) representing the second sorted range. This iterator type must meet the requirements of an random access iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">RandIter3</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an random access iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Comp</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>merge</em> requires <em>Comp</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::less&lt;&gt; </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj1</span></code>: The type of an optional projection function to be used for elements of the first range. This defaults to <em>util::projection_identity</em> </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj2</span></code>: The type of an optional projection function to be used for elements of the second range. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first1</span></code>: Refers to the beginning of the first range of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last1</span></code>: Refers to the end of the first range of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">first2</span></code>: Refers to the beginning of the second range of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last2</span></code>: Refers to the end of the second range of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">comp</span></code>: <em>comp</em> is a callable object which returns true if the first argument is less than the second, and false otherwise. The signature of this comparison should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">comp</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type2</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> and <em>Type2</em> must be such that objects of types <em>RandIter1</em> and <em>RandIter2</em> can be dereferenced and then implicitly converted to both <em>Type1</em> and <em>Type2</em> </li>
<li><code class="docutils literal notranslate"><span class="pre">proj1</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of the first range as a projection operation before the actual comparison <em>comp</em> is invoked. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj2</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of the second range as a projection operation before the actual comparison <em>comp</em> is invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>merge</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>merge</em> algorithm returns a <em>hpx::future&lt;tagged_tuple&lt;tag::in1(RandIter1), tag::in2(RandIter2), tag::out(RandIter3)&gt;</em> &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>tagged_tuple&lt;tag::in1(RandIter1), tag::in2(RandIter2), tag::out(RandIter3)&gt;</em> otherwise. The <em>merge</em> algorithm returns the tuple of the source iterator <em>last1</em>, the source iterator <em>last2</em>, the destination iterator to the end of the <em>dest</em> range. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v113inplace_mergeERR8ExPolicy8RandIter8RandIter8RandIterRR4CompRR4Proj">
<span id="_CPPv2N3hpx8parallel2v113inplace_mergeERR8ExPolicy8RandIter8RandIter8RandIterRR4CompRR4Proj"></span><span id="hpx::parallel::v1::inplace_merge__ExPolicyRR.RandIter.RandIter.RandIter.CompRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> RandIter, <em class="property">typename</em> Comp = detail::less, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1acb1ee3de7dba68b96b6dc668cd380e7a"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, RandIter&gt;::type <code class="descname">inplace_merge</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, RandIter <em>first</em>, RandIter <em>middle</em>, RandIter <em>last</em>, Comp &amp;&amp;<em>comp</em> = Comp(), Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v113inplace_mergeERR8ExPolicy8RandIter8RandIter8RandIterRR4CompRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Merges two consecutive sorted ranges [first, middle) and [middle, last) into one sorted range [first, last). The order of equivalent elements in the each of original two ranges is preserved. For equivalent elements in the original two ranges, the elements from the first range precede the elements from the second range.</p>
<p><p>The assignments in the parallel </p>
<em>inplace_merge</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs O(std::distance(first, last)) applications of the comparison <em>comp</em> and the each projection.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">RandIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an random access iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Comp</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>inplace_merge</em> requires <em>Comp</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::less&lt;&gt; </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the first sorted range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">middle</span></code>: Refers to the end of the first sorted range and the beginning of the second sorted range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the second sorted range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">comp</span></code>: <em>comp</em> is a callable object which returns true if the first argument is less than the second, and false otherwise. The signature of this comparison should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">comp</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type2</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> and <em>Type2</em> must be such that objects of types <em>RandIter</em> can be dereferenced and then implicitly converted to both <em>Type1</em> and <em>Type2</em> </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>inplace_merge</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>inplace_merge</em> algorithm returns a <em>hpx::future&lt;RandIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>RandIter</em> otherwise. The <em>inplace_merge</em> algorithm returns the source iterator <em>last</em> </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v111min_elementERR8ExPolicy7FwdIter7FwdIterRR1FRR4Proj">
<span id="_CPPv2N3hpx8parallel2v111min_elementERR8ExPolicy7FwdIter7FwdIterRR1FRR4Proj"></span><span id="hpx::parallel::v1::min_element__ExPolicyRR.FwdIter.FwdIter.FRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> Proj = util::projection_identity, <em class="property">typename</em> F = detail::less&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a24dba382bbce6a2fb11fadf711656d95"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type <code class="descname">min_element</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, F &amp;&amp;<em>f</em> = F(), Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v111min_elementERR8ExPolicy7FwdIter7FwdIterRR1FRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Finds the smallest element in the range [first, last) using the given comparison function <em>f</em>.</p>
<p><p>The comparisons in the parallel </p>
<em>min_element</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Exactly <em>max</em>(N-1, 0) comparisons, where N = std::distance(first, last).</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of a forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>min_element</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: The binary predicate which returns true if the the left argument is less than the right element. The signature of the predicate function should be equivalent to the following: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type1</em> must be such that objects of type <em>FwdIter</em> can be dereferenced and then implicitly converted to <em>Type1</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The comparisons in the parallel <em>min_element</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>min_element</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter</em> otherwise. The <em>min_element</em> algorithm returns the iterator to the smallest element in the range [first, last). If several elements in the range are equivalent to the smallest element, returns the iterator to the first such element. Returns last if the range is empty. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v111max_elementERR8ExPolicy7FwdIter7FwdIterRR1FRR4Proj">
<span id="_CPPv2N3hpx8parallel2v111max_elementERR8ExPolicy7FwdIter7FwdIterRR1FRR4Proj"></span><span id="hpx::parallel::v1::max_element__ExPolicyRR.FwdIter.FwdIter.FRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> Proj = util::projection_identity, <em class="property">typename</em> F = detail::less&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a624ca7fa873d5c8200717ab1f2c15e35"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type <code class="descname">max_element</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, F &amp;&amp;<em>f</em> = F(), Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v111max_elementERR8ExPolicy7FwdIter7FwdIterRR1FRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Finds the greatest element in the range [first, last) using the given comparison function <em>f</em>.</p>
<p><p>The comparisons in the parallel </p>
<em>max_element</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Exactly <em>max</em>(N-1, 0) comparisons, where N = std::distance(first, last).</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of a forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>max_element</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: The binary predicate which returns true if the This argument is optional and defaults to std::less. the left argument is less than the right element. The signature of the predicate function should be equivalent to the following: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type1</em> must be such that objects of type <em>FwdIter</em> can be dereferenced and then implicitly converted to <em>Type1</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The comparisons in the parallel <em>max_element</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>max_element</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter</em> otherwise. The <em>max_element</em> algorithm returns the iterator to the smallest element in the range [first, last). If several elements in the range are equivalent to the smallest element, returns the iterator to the first such element. Returns last if the range is empty. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v114minmax_elementERR8ExPolicy7FwdIter7FwdIterRR1FRR4Proj">
<span id="_CPPv2N3hpx8parallel2v114minmax_elementERR8ExPolicy7FwdIter7FwdIterRR1FRR4Proj"></span><span id="hpx::parallel::v1::minmax_element__ExPolicyRR.FwdIter.FwdIter.FRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> Proj = util::projection_identity, <em class="property">typename</em> F = detail::less&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1ae19ab1d1771be7fd161a092e23c879f4"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::min<span class="sig-paren">(</span>FwdIter<span class="sig-paren">)</span>, tag::max<span class="sig-paren">(</span>FwdIter<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">minmax_element</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, F &amp;&amp;<em>f</em> = F(), Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v114minmax_elementERR8ExPolicy7FwdIter7FwdIterRR1FRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Finds the greatest element in the range [first, last) using the given comparison function <em>f</em>.</p>
<p><p>The comparisons in the parallel </p>
<em>minmax_element</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: At most <em>max</em>(floor(3/2*(N-1)), 0) applications of the predicate, where N = std::distance(first, last).</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of a forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>minmax_element</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: The binary predicate which returns true if the the left argument is less than the right element. This argument is optional and defaults to std::less. The signature of the predicate function should be equivalent to the following: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type1</em> must be such that objects of type <em>FwdIter</em> can be dereferenced and then implicitly converted to <em>Type1</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The comparisons in the parallel <em>minmax_element</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>minmax_element</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::min(FwdIter), tag::max(FwdIter)&gt;</em> &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::min(FwdIter), tag::max(FwdIter)&gt;</em> otherwise. The <em>minmax_element</em> algorithm returns a pair consisting of an iterator to the smallest element as the first element and an iterator to the greatest element as the second. Returns std::make_pair(first, first) if the range is empty. If several elements are equivalent to the smallest element, the iterator to the first such element is returned. If several elements are equivalent to the largest element, the iterator to the last such element is returned. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v18mismatchERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter2RR4Pred">
<span id="_CPPv2N3hpx8parallel2v18mismatchERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter2RR4Pred"></span><span id="hpx::parallel::v1::mismatch__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.FwdIter2.PredRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> Pred = detail::equal_to&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1ad2210ac36941837306cdf8c12114a31a"></span>std::enable_if&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, std::pair&lt;FwdIter1, FwdIter2&gt;&gt;::type&gt;::type <code class="descname">mismatch</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first1</em>, FwdIter1 <em>last1</em>, FwdIter2 <em>first2</em>, FwdIter2 <em>last2</em>, Pred &amp;&amp;<em>op</em> = Pred()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v18mismatchERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter2RR4Pred" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns true if the range [first1, last1) is mismatch to the range [first2, last2), and false otherwise.</p>
<p><p>The comparison operations in the parallel </p>
<em>mismatch</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: At most min(last1 - first1, last2 - first2) applications of the predicate <em>f</em>. If <em>FwdIter1</em> and <em>FwdIter2</em> meet the requirements of <em>RandomAccessIterator</em> and (last1 - first1) != (last2 - first2) then no applications of the predicate <em>f</em> are made.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used for the first range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the source iterators used for the second range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <em>mismatch</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::equal_to&lt;&gt;</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first1</span></code>: Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last1</span></code>: Refers to the end of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">first2</span></code>: Refers to the beginning of the sequence of elements of the second range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last2</span></code>: Refers to the end of the sequence of elements of the second range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">op</span></code>: The binary predicate which returns true if the elements should be treated as mismatch. The signature of the predicate function should be equivalent to the following: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type2</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> and <em>Type2</em> must be such that objects of types <em>FwdIter1</em> and <em>FwdIter2</em> can be dereferenced and then implicitly converted to <em>Type1</em> and <em>Type2</em> respectively</li>
</ul>
</dd>
</dl>
</p>
<p>The comparison operations in the parallel <em>mismatch</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The two ranges are considered mismatch if, for every iterator i in the range [first1,last1), *i mismatchs *(first2 + (i - first1)). This overload of mismatch uses operator== to determine if two elements are mismatch.</dd>
<dt><strong>Return</strong></dt>
<dd>The <em>mismatch</em> algorithm returns a <em>hpx::future&lt;bool&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>bool</em> otherwise. The <em>mismatch</em> algorithm returns true if the elements in the two ranges are mismatch, otherwise it returns false. If the length of the range [first1, last1) does not mismatch the length of the range [first2, last2), it returns false. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v18mismatchERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR4Pred">
<span id="_CPPv2N3hpx8parallel2v18mismatchERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR4Pred"></span><span id="hpx::parallel::v1::mismatch__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.PredRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> Pred = detail::equal_to&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a6476df5b4e5ac7c2cef766f4e84b52a5"></span>std::enable_if&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, std::pair&lt;FwdIter1, FwdIter2&gt;&gt;::type&gt;::type <code class="descname">mismatch</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first1</em>, FwdIter1 <em>last1</em>, FwdIter2 <em>first2</em>, Pred &amp;&amp;<em>op</em> = Pred()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v18mismatchERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR4Pred" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns std::pair with iterators to the first two non-equivalent elements.</p>
<p><p>The comparison operations in the parallel </p>
<em>mismatch</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: At most <em>last1</em> - <em>first1</em> applications of the predicate <em>f</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used for the first range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the source iterators used for the second range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <em>mismatch</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::equal_to&lt;&gt;</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first1</span></code>: Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last1</span></code>: Refers to the end of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">first2</span></code>: Refers to the beginning of the sequence of elements of the second range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">op</span></code>: The binary predicate which returns true if the elements should be treated as mismatch. The signature of the predicate function should be equivalent to the following: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type2</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> and <em>Type2</em> must be such that objects of types <em>FwdIter1</em> and <em>FwdIter2</em> can be dereferenced and then implicitly converted to <em>Type1</em> and <em>Type2</em> respectively</li>
</ul>
</dd>
</dl>
</p>
<p>The comparison operations in the parallel <em>mismatch</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>mismatch</em> algorithm returns a <em>hpx::future&lt;std::pair&lt;FwdIter1, FwdIter2&gt;</em> &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>std::pair&lt;FwdIter1, FwdIter2&gt;</em> otherwise. The <em>mismatch</em> algorithm returns the first mismatching pair of elements from two ranges: one defined by [first1, last1) and another defined by [first2, last2). </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v14moveERR8ExPolicy8FwdIter18FwdIter18FwdIter2">
<span id="_CPPv2N3hpx8parallel2v14moveERR8ExPolicy8FwdIter18FwdIter18FwdIter2"></span><span id="hpx::parallel::v1::move__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a8becd6c721d0fa25a574df7bc22088c5"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::in<span class="sig-paren">(</span>FwdIter1<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>FwdIter2<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">move</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, FwdIter1 <em>last</em>, FwdIter2 <em>dest</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v14moveERR8ExPolicy8FwdIter18FwdIter18FwdIter2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Moves the elements in the range [first, last), to another range beginning at <em>dest</em>. After this operation the elements in the moved-from range will still contain valid values of the appropriate type, but not necessarily the same values as before the move.</p>
<p><p>The move assignments in the parallel </p>
<em>move</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>last</em> - <em>first</em> move assignments.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the move assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range.</li>
</ul>
</dd>
</dl>
</p>
<p>The move assignments in the parallel <em>move</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>move</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</em> &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</em> otherwise. The <em>move</em> algorithm returns the pair of the input iterator <em>last</em> and the output iterator to the element in the destination range, one past the last element moved. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v116stable_partitionERR8ExPolicy9BidirIter9BidirIterRR1FRR4Proj">
<span id="_CPPv2N3hpx8parallel2v116stable_partitionERR8ExPolicy9BidirIter9BidirIterRR1FRR4Proj"></span><span id="hpx::parallel::v1::stable_partition__ExPolicyRR.BidirIter.BidirIter.FRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> BidirIter, <em class="property">typename</em> F, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a51d223e340c4841518fee0e95a68e426"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, BidirIter&gt;::type <code class="descname">stable_partition</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, BidirIter <em>first</em>, BidirIter <em>last</em>, F &amp;&amp;<em>f</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v116stable_partitionERR8ExPolicy9BidirIter9BidirIterRR1FRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Permutes the elements in the range [first, last) such that there exists an iterator i such that for every iterator j in the range [first, i) INVOKE(f, INVOKE (proj, *j)) != false, and for every iterator k in the range [i, last), INVOKE(f, INVOKE (proj, *k)) == false</p>
<p><p>The invocations of </p>
<em>f</em> in the parallel <em>stable_partition</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> executes in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: At most (last - first) * log(last - first) swaps, but only linear number of swaps if there is enough extra memory. Exactly <em>last</em> - <em>first</em> applications of the predicate and projection.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the invocations of <em>f</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">BidirIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>transform</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Unary predicate which returns true if the element should be ordered before other elements. Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">fun</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;. The type </p>
<em>Type</em> must be such that an object of type <em>BidirIter</em> can be dereferenced and then implicitly converted to <em>Type</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>f</em> is invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The invocations of <em>f</em> in the parallel <em>stable_partition</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>stable_partition</em> algorithm returns an iterator i such that for every iterator j in the range [first, i), f(*j) != false INVOKE(f, INVOKE(proj, *j)) != false, and for every iterator k in the range [i, last), f(*k) == false INVOKE(f, INVOKE (proj, *k)) == false. The relative order of the elements in both groups is preserved. If the execution policy is of type <em>parallel_task_policy</em> the algorithm returns a future&lt;&gt; referring to this iterator. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v19partitionERR8ExPolicy7FwdIter7FwdIterRR4PredRR4Proj">
<span id="_CPPv2N3hpx8parallel2v19partitionERR8ExPolicy7FwdIter7FwdIterRR4PredRR4Proj"></span><span id="hpx::parallel::v1::partition__ExPolicyRR.FwdIter.FwdIter.PredRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> Pred, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a3ab0c3141a7e949ac7e4e0941dfc2af4"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type <code class="descname">partition</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, Pred &amp;&amp;<em>pred</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v19partitionERR8ExPolicy7FwdIter7FwdIterRR4PredRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Reorders the elements in the range [first, last) in such a way that all elements for which the predicate <em>pred</em> returns true precede the elements for which the predicate <em>pred</em> returns false. Relative order of the elements is not preserved.</p>
<p><p>The assignments in the parallel </p>
<em>partition</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: At most 2 * (last - first) swaps. Exactly <em>last</em> - <em>first</em> applications of the predicate and projection.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>partition</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">pred</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). This is an unary predicate for partitioning the source iterators. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>InIter</em> can be dereferenced and then implicitly converted to Type. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>partition</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>partition</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>parallel_task_policy</em> and returns <em>FwdIter</em> otherwise. The <em>partition</em> algorithm returns the iterator to the first element of the second group. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v114partition_copyERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter3RR4PredRR4Proj">
<span id="_CPPv2N3hpx8parallel2v114partition_copyERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter3RR4PredRR4Proj"></span><span id="hpx::parallel::v1::partition_copy__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.FwdIter3.PredRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> FwdIter3, <em class="property">typename</em> Pred, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a4cd508247887a0638c69812cdcb16b96"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_tuple&lt;tag::in<span class="sig-paren">(</span>FwdIter1<span class="sig-paren">)</span>, tag::out1<span class="sig-paren">(</span>FwdIter2<span class="sig-paren">)</span>, tag::out2<span class="sig-paren">(</span>FwdIter3<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">partition_copy</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, FwdIter1 <em>last</em>, FwdIter2 <em>dest_true</em>, FwdIter3 <em>dest_false</em>, Pred &amp;&amp;<em>pred</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v114partition_copyERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter3RR4PredRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the elements in the range, defined by [first, last), to two different ranges depending on the value returned by the predicate <em>pred</em>. The elements, that satisfy the predicate <em>pred</em>, are copied to the range beginning at <em>dest_true</em>. The rest of the elements are copied to the range beginning at <em>dest_false</em>. The order of the elements is preserved.</p>
<p><p>The assignments in the parallel </p>
<em>partition_copy</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs not more than <em>last</em> - <em>first</em> assignments, exactly <em>last</em> - <em>first</em> applications of the predicate <em>f</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range for the elements that satisfy the predicate <em>pred</em> (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter3</span></code>: The type of the iterator representing the destination range for the elements that don’t satisfy the predicate <em>pred</em> (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>partition_copy</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest_true</span></code>: Refers to the beginning of the destination range for the elements that satisfy the predicate <em>pred</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest_false</span></code>: Refers to the beginning of the destination range for the elements that don’t satisfy the predicate <em>pred</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">pred</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). This is an unary predicate for partitioning the source iterators. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter1</em> can be dereferenced and then implicitly converted to Type. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>partition_copy</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>partition_copy</em> algorithm returns a <em>hpx::future&lt;tagged_tuple&lt;tag::in(InIter), tag::out1(OutIter1), tag::out2(OutIter2)&gt;</em> &gt; if the execution policy is of type <em>parallel_task_policy</em> and returns <em>tagged_tuple&lt;tag::in(InIter), tag::out1(OutIter1), tag::out2(OutIter2)&gt;</em> otherwise. The <em>partition_copy</em> algorithm returns the tuple of the source iterator <em>last</em>, the destination iterator to the end of the <em>dest_true</em> range, and the destination iterator to the end of the <em>dest_false</em> range. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v16reduceERR8ExPolicy7FwdIter7FwdIter1TRR1F">
<span id="_CPPv2N3hpx8parallel2v16reduceERR8ExPolicy7FwdIter7FwdIter1TRR1F"></span><span id="hpx::parallel::v1::reduce__ExPolicyRR.FwdIter.FwdIter.T.FRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> T, <em class="property">typename</em> F&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a3c1fc4737f7ff6586c3cc8335f01ade2"></span>std::enable_if&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, T&gt;::type&gt;::type <code class="descname">reduce</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, T <em>init</em>, F &amp;&amp;<em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v16reduceERR8ExPolicy7FwdIter7FwdIter1TRR1F" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns GENERALIZED_SUM(f, init, *first, …, *(first + (last - first) - 1)).</p>
<p><p>The reduce operations in the parallel </p>
<em>reduce</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: O(<em>last</em> - <em>first</em>) applications of the predicate <em>f</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>copy_if</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the value to be used as initial (and intermediate) values (deduced).</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). This is a binary predicate. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ret</span> <span class="nf">fun</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;. The types </p>
<em>Type1</em> <em>Ret</em> must be such that an object of type <em>FwdIter</em> can be dereferenced and then implicitly converted to any of those types. </li>
<li><code class="docutils literal notranslate"><span class="pre">init</span></code>: The initial value for the generalized sum.</li>
</ul>
</dd>
</dl>
</p>
<p>The reduce operations in the parallel <em>copy_if</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><p>The difference between </p>
<em>reduce</em> and <em>accumulate</em> is that the behavior of reduce may be non-deterministic for non-associative or non-commutative binary predicate. <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>reduce</em> algorithm returns a <em>hpx::future&lt;T&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>T</em> otherwise. The <em>reduce</em> algorithm returns the result of the generalized sum over the elements given by the input range [first, last).</dd>
<dt><strong>Note</strong></dt>
<dd>GENERALIZED_SUM(op, a1, …, aN) is defined as follows:<ul class="simple">
<li>a1 when N is 1</li>
<li>op(GENERALIZED_SUM(op, b1, …, bK), GENERALIZED_SUM(op, bM, …, bN)), where:<ul>
<li>b1, …, bN may be any permutation of a1, …, aN and</li>
<li>1 &lt; K+1 = M &lt;= N.</li>
</ul>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v16reduceERR8ExPolicy7FwdIter7FwdIter1T">
<span id="_CPPv2N3hpx8parallel2v16reduceERR8ExPolicy7FwdIter7FwdIter1T"></span><span id="hpx::parallel::v1::reduce__ExPolicyRR.FwdIter.FwdIter.T"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> T&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1aa91f102ca49a069143e9f53d6c2375d2"></span>std::enable_if&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, T&gt;::type&gt;::type <code class="descname">reduce</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, T <em>init</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v16reduceERR8ExPolicy7FwdIter7FwdIter1T" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns GENERALIZED_SUM(+, init, *first, …, *(first + (last - first) - 1)).</p>
<p><p>The reduce operations in the parallel </p>
<em>reduce</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: O(<em>last</em> - <em>first</em>) applications of the operator+().</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the value to be used as initial (and intermediate) values (deduced).</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">init</span></code>: The initial value for the generalized sum.</li>
</ul>
</dd>
</dl>
</p>
<p>The reduce operations in the parallel <em>copy_if</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><p>The difference between </p>
<em>reduce</em> and <em>accumulate</em> is that the behavior of reduce may be non-deterministic for non-associative or non-commutative binary predicate. <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>reduce</em> algorithm returns a <em>hpx::future&lt;T&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>T</em> otherwise. The <em>reduce</em> algorithm returns the result of the generalized sum (applying operator+()) over the elements given by the input range [first, last).</dd>
<dt><strong>Note</strong></dt>
<dd>GENERALIZED_SUM(+, a1, …, aN) is defined as follows:<ul class="simple">
<li>a1 when N is 1</li>
<li>op(GENERALIZED_SUM(+, b1, …, bK), GENERALIZED_SUM(+, bM, …, bN)), where:<ul>
<li>b1, …, bN may be any permutation of a1, …, aN and</li>
<li>1 &lt; K+1 = M &lt;= N.</li>
</ul>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v16reduceERR8ExPolicy7FwdIter7FwdIter">
<span id="_CPPv2N3hpx8parallel2v16reduceERR8ExPolicy7FwdIter7FwdIter"></span><span id="hpx::parallel::v1::reduce__ExPolicyRR.FwdIter.FwdIter"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a00826196f454e21a740b586567a07ea9"></span>std::enable_if&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <em class="property">typename</em> std::iterator_traits&lt;FwdIter&gt;::value_type&gt;::type&gt;::type <code class="descname">reduce</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v16reduceERR8ExPolicy7FwdIter7FwdIter" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns GENERALIZED_SUM(+, T(), *first, …, *(first + (last - first) - 1)).</p>
<p><p>The reduce operations in the parallel </p>
<em>reduce</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: O(<em>last</em> - <em>first</em>) applications of the operator+().</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to.</li>
</ul>
</dd>
</dl>
</p>
<p>The reduce operations in the parallel <em>copy_if</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><p>The difference between </p>
<em>reduce</em> and <em>accumulate</em> is that the behavior of reduce may be non-deterministic for non-associative or non-commutative binary predicate. <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>reduce</em> algorithm returns a <em>hpx::future&lt;T&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns T otherwise (where T is the value_type of <em>FwdIter</em>). The <em>reduce</em> algorithm returns the result of the generalized sum (applying operator+()) over the elements given by the input range [first, last).</dd>
<dt><strong>Note</strong></dt>
<dd>The type of the initial value (and the result type) <em>T</em> is determined from the value_type of the used <em>FwdIter</em>.</dd>
<dt><strong>Note</strong></dt>
<dd>GENERALIZED_SUM(+, a1, …, aN) is defined as follows:<ul class="simple">
<li>a1 when N is 1</li>
<li>op(GENERALIZED_SUM(+, b1, …, bK), GENERALIZED_SUM(+, bM, …, bN)), where:<ul>
<li>b1, …, bN may be any permutation of a1, …, aN and</li>
<li>1 &lt; K+1 = M &lt;= N.</li>
</ul>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v113reduce_by_keyERR8ExPolicy7RanIter7RanIter8RanIter28FwdIter18FwdIter2RR7CompareRR4Func">
<span id="_CPPv2N3hpx8parallel2v113reduce_by_keyERR8ExPolicy7RanIter7RanIter8RanIter28FwdIter18FwdIter2RR7CompareRR4Func"></span><span id="hpx::parallel::v1::reduce_by_key__ExPolicyRR.RanIter.RanIter.RanIter2.FwdIter1.FwdIter2.CompareRR.FuncRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> RanIter, <em class="property">typename</em> RanIter2, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> Compare = std::equal_to&lt;typename std::iterator_traits&lt;RanIter&gt;::value_type&gt;, <em class="property">typename</em> Func = std::plus&lt;            typename std::iterator_traits&lt;RanIter2&gt;::value_type&gt;&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1ac7bcf699ef55259496e9060f0e784c17"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, std::pair&lt;FwdIter1, FwdIter2&gt;&gt;::type <code class="descname">reduce_by_key</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, RanIter <em>key_first</em>, RanIter <em>key_last</em>, RanIter2 <em>values_first</em>, FwdIter1 <em>keys_output</em>, FwdIter2 <em>values_output</em>, Compare &amp;&amp;<em>comp</em> = Compare(), Func &amp;&amp;<em>func</em> = Func()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v113reduce_by_keyERR8ExPolicy7RanIter7RanIter8RanIter28FwdIter18FwdIter2RR7CompareRR4Func" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Reduce by Key performs an inclusive scan reduction operation on elements supplied in key/value pairs. The algorithm produces a single output value for each set of equal consecutive keys in [key_first, key_last). the value being the GENERALIZED_NONCOMMUTATIVE_SUM(op, init, *first, …, *(first + (i - result))). for the run of consecutive matching keys. The number of keys supplied must match the number of values.</p>
<p><em>comp</em> has to induce a strict weak ordering on the values.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: O(<em>last</em> - <em>first</em>) applications of the predicate <em>op</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </li>
<li><code class="docutils literal notranslate"><span class="pre">RanIter</span></code>: The type of the key iterators used (deduced). This iterator type must meet the requirements of a random access iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">RanIter2</span></code>: The type of the value iterators used (deduced). This iterator type must meet the requirements of a random access iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the iterator representing the destination key range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination value range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Compare</span></code>: The type of the optional function/function object to use to compare keys (deduced). Assumed to be std::equal_to otherwise. </li>
<li><code class="docutils literal notranslate"><span class="pre">Func</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>copy_if</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">key_first</span></code>: Refers to the beginning of the sequence of key elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">key_last</span></code>: Refers to the end of the sequence of key elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">values_first</span></code>: Refers to the beginning of the sequence of value elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">keys_output</span></code>: Refers to the start output location for the keys produced by the algorithm. </li>
<li><code class="docutils literal notranslate"><span class="pre">values_output</span></code>: Refers to the start output location for the values produced by the algorithm. </li>
<li><code class="docutils literal notranslate"><span class="pre">comp</span></code>: comp is a callable object. The return value of the INVOKE operation applied to an object of type Comp, when contextually converted to bool, yields true if the first argument of the call is less than the second, and false otherwise. It is assumed that comp will not apply any non-constant function through the dereferenced iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">func</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). This is a binary predicate. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ret</span> <span class="nf">fun</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;. The types </p>
<em>Type1</em> <em>Ret</em> must be such that an object of type <em>FwdIter</em> can be dereferenced and then implicitly converted to any of those types.</li>
</ul>
</dd>
</dl>
</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>reduce_by_key</em> algorithm returns a <em>hpx::future&lt;pair&lt;Iter1,Iter2&gt;&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>pair&lt;Iter1,Iter2&gt;</em> otherwise. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v19remove_ifERR8ExPolicy7FwdIter7FwdIterRR4PredRR4Proj">
<span id="_CPPv2N3hpx8parallel2v19remove_ifERR8ExPolicy7FwdIter7FwdIterRR4PredRR4Proj"></span><span id="hpx::parallel::v1::remove_if__ExPolicyRR.FwdIter.FwdIter.PredRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> Pred, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1ab6ffb9377e7396ca547d58cd1e5581d4"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type <code class="descname">remove_if</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, Pred &amp;&amp;<em>pred</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v19remove_ifERR8ExPolicy7FwdIter7FwdIterRR4PredRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Removes all elements satisfying specific criteria from the range [first, last) and returns a past-the-end iterator for the new end of the range. This version removes all elements for which predicate <em>pred</em> returns true.</p>
<p><p>The assignments in the parallel </p>
<em>remove_if</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs not more than <em>last</em> - <em>first</em> assignments, exactly <em>last</em> - <em>first</em> applications of the predicate <em>pred</em> and the projection <em>proj</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>remove_if</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">pred</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is an unary predicate which returns <em>true</em> for the required elements. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter</em> can be dereferenced and then implicitly converted to Type. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>remove_if</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>remove_if</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter</em> otherwise. The <em>remove_if</em> algorithm returns the iterator to the new end of the range. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v16removeERR8ExPolicy7FwdIter7FwdIterR1TRR4Proj">
<span id="_CPPv2N3hpx8parallel2v16removeERR8ExPolicy7FwdIter7FwdIterR1TRR4Proj"></span><span id="hpx::parallel::v1::remove__ExPolicyRR.FwdIter.FwdIter.TCR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> T, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1ae827ce96cab7f1e90de0940ee51d1378"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type <code class="descname">remove</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, T <em class="property">const</em> &amp;<em>value</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v16removeERR8ExPolicy7FwdIter7FwdIterR1TRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Removes all elements satisfying specific criteria from the range [first, last) and returns a past-the-end iterator for the new end of the range. This version removes all elements that are equal to <em>value</em>.</p>
<p><p>The assignments in the parallel </p>
<em>remove</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs not more than <em>last</em> - <em>first</em> assignments, exactly <em>last</em> - <em>first</em> applications of the operator==() and the projection <em>proj</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the value to remove (deduced). This value type must meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">value</span></code>: Specifies the value of elements to remove. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>remove</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>remove</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter</em> otherwise. The <em>remove</em> algorithm returns the iterator to the new end of the range. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v111remove_copyERR8ExPolicy8FwdIter18FwdIter18FwdIter2R1TRR4Proj">
<span id="_CPPv2N3hpx8parallel2v111remove_copyERR8ExPolicy8FwdIter18FwdIter18FwdIter2R1TRR4Proj"></span><span id="hpx::parallel::v1::remove_copy__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.TCR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> T, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1adb30c2cd504c8d1860eac328ebdab75f"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::in<span class="sig-paren">(</span>FwdIter1<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>FwdIter2<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">remove_copy</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, FwdIter1 <em>last</em>, FwdIter2 <em>dest</em>, T <em class="property">const</em> &amp;<em>val</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v111remove_copyERR8ExPolicy8FwdIter18FwdIter18FwdIter2R1TRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the elements in the range, defined by [first, last), to another range beginning at <em>dest</em>. Copies only the elements for which the comparison operator returns false when compare to val. The order of the elements that are not removed is preserved.</p>
<p>Effects: Copies all the elements referred to by the iterator it in the range [first,last) for which the following corresponding conditions do not hold: INVOKE(proj, *it) == value</p>
<p><p>The assignments in the parallel </p>
<em>remove_copy</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs not more than <em>last</em> - <em>first</em> assignments, exactly <em>last</em> - <em>first</em> applications of the predicate <em>f</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type that the result of dereferencing FwdIter1 is compared to. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">val</span></code>: Value to be removed. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>remove_copy</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>remove_copy</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</em> &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</em> otherwise. The <em>copy</em> algorithm returns the pair of the input iterator forwarded to the first element after the last in the input sequence and the output iterator to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v114remove_copy_ifERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR1FRR4Proj">
<span id="_CPPv2N3hpx8parallel2v114remove_copy_ifERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR1FRR4Proj"></span><span id="hpx::parallel::v1::remove_copy_if__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.FRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> F, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a5423d1998cd9627340234b1dc4d59aa5"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::in<span class="sig-paren">(</span>FwdIter1<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>FwdIter2<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">remove_copy_if</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, FwdIter1 <em>last</em>, FwdIter2 <em>dest</em>, F &amp;&amp;<em>f</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v114remove_copy_ifERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR1FRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the elements in the range, defined by [first, last), to another range beginning at <em>dest</em>. Copies only the elements for which the predicate <em>f</em> returns false. The order of the elements that are not removed is preserved.</p>
<p>Effects: Copies all the elements referred to by the iterator it in the range [first,last) for which the following corresponding conditions do not hold: INVOKE(pred, INVOKE(proj, *it)) != false.</p>
<p><p>The assignments in the parallel </p>
<em>remove_copy_if</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs not more than <em>last</em> - <em>first</em> assignments, exactly <em>last</em> - <em>first</em> applications of the predicate <em>f</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>copy_if</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is an unary predicate which returns <em>true</em> for the elements to be removed. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter1</em> can be dereferenced and then implicitly converted to Type. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>remove_copy_if</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>remove_copy_if</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</em> &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</em> otherwise. The <em>copy</em> algorithm returns the pair of the input iterator forwarded to the first element after the last in the input sequence and the output iterator to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v17replaceERR8ExPolicy7FwdIter7FwdIterR2T1R2T2RR4Proj">
<span id="_CPPv2N3hpx8parallel2v17replaceERR8ExPolicy7FwdIter7FwdIterR2T1R2T2RR4Proj"></span><span id="hpx::parallel::v1::replace__ExPolicyRR.FwdIter.FwdIter.T1CR.T2CR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> T1, <em class="property">typename</em> T2, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a2a8af54cd1078cc756853a5f5fdf4550"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type <code class="descname">replace</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, T1 <em class="property">const</em> &amp;<em>old_value</em>, T2 <em class="property">const</em> &amp;<em>new_value</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v17replaceERR8ExPolicy7FwdIter7FwdIterR2T1R2T2RR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Replaces all elements satisfying specific criteria with <em>new_value</em> in the range [first, last).</p>
<p>Effects: Substitutes elements referred by the iterator it in the range [first, last) with new_value, when the following corresponding conditions hold: INVOKE(proj, *it) == old_value</p>
<p><p>The assignments in the parallel </p>
<em>replace</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>last</em> - <em>first</em> assignments.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of a forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">T1</span></code>: The type of the old value to replace (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">T2</span></code>: The type of the new values to replace (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">old_value</span></code>: Refers to the old value of the elements to replace. </li>
<li><code class="docutils literal notranslate"><span class="pre">new_value</span></code>: Refers to the new value to use as the replacement. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>replace</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>replace</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>void</em> otherwise. It returns <em>last</em>. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v110replace_ifERR8ExPolicy7FwdIter7FwdIterRR1FR1TRR4Proj">
<span id="_CPPv2N3hpx8parallel2v110replace_ifERR8ExPolicy7FwdIter7FwdIterRR1FR1TRR4Proj"></span><span id="hpx::parallel::v1::replace_if__ExPolicyRR.FwdIter.FwdIter.FRR.TCR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> F, <em class="property">typename</em> T, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a2e9ea84f6ce4d49680ade7b6b0be95c4"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type <code class="descname">replace_if</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, F &amp;&amp;<em>f</em>, T <em class="property">const</em> &amp;<em>new_value</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v110replace_ifERR8ExPolicy7FwdIter7FwdIterRR1FR1TRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Replaces all elements satisfying specific criteria (for which predicate <em>f</em> returns true) with <em>new_value</em> in the range [first, last).</p>
<p>Effects: Substitutes elements referred by the iterator it in the range [first, last) with new_value, when the following corresponding conditions hold: INVOKE(f, INVOKE(proj, *it)) != false</p>
<p><p>The assignments in the parallel </p>
<em>replace_if</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>last</em> - <em>first</em> applications of the predicate.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of a forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>equal</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the new values to replace (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is an unary predicate which returns <em>true</em> for the elements which need to replaced. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter</em> can be dereferenced and then implicitly converted to <em>Type</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">new_value</span></code>: Refers to the new value to use as the replacement. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>replace_if</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>replace_if</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter</em> otherwise. It returns <em>last</em>. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v112replace_copyERR8ExPolicy8FwdIter18FwdIter18FwdIter2R2T1R2T2RR4Proj">
<span id="_CPPv2N3hpx8parallel2v112replace_copyERR8ExPolicy8FwdIter18FwdIter18FwdIter2R2T1R2T2RR4Proj"></span><span id="hpx::parallel::v1::replace_copy__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.T1CR.T2CR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> T1, <em class="property">typename</em> T2, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1aed5a912dfc682304b9096953eb3854dd"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::in<span class="sig-paren">(</span>FwdIter1<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>FwdIter2<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">replace_copy</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, FwdIter1 <em>last</em>, FwdIter2 <em>dest</em>, T1 <em class="property">const</em> &amp;<em>old_value</em>, T2 <em class="property">const</em> &amp;<em>new_value</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v112replace_copyERR8ExPolicy8FwdIter18FwdIter18FwdIter2R2T1R2T2RR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the all elements from the range [first, last) to another range beginning at <em>dest</em> replacing all elements satisfying a specific criteria with <em>new_value</em>.</p>
<p>Effects: Assigns to every iterator it in the range [result, result + (last - first)) either new_value or *(first + (it - result)) depending on whether the following corresponding condition holds: INVOKE(proj, *(first + (i - result))) == old_value</p>
<p><p>The assignments in the parallel </p>
<em>replace_copy</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>last</em> - <em>first</em> applications of the predicate.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">T1</span></code>: The type of the old value to replace (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">T2</span></code>: The type of the new values to replace (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">old_value</span></code>: Refers to the old value of the elements to replace. </li>
<li><code class="docutils literal notranslate"><span class="pre">new_value</span></code>: Refers to the new value to use as the replacement. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>replace_copy</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>replace_copy</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</em> &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</em> otherwise. The <em>copy</em> algorithm returns the pair of the input iterator <em>last</em> and the output iterator to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v115replace_copy_ifERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR1FR1TRR4Proj">
<span id="_CPPv2N3hpx8parallel2v115replace_copy_ifERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR1FR1TRR4Proj"></span><span id="hpx::parallel::v1::replace_copy_if__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.FRR.TCR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> F, <em class="property">typename</em> T, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a0e77ebdd9607ee75e91f60109ac7a0e7"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::in<span class="sig-paren">(</span>FwdIter1<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>FwdIter2<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">replace_copy_if</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, FwdIter1 <em>last</em>, FwdIter2 <em>dest</em>, F &amp;&amp;<em>f</em>, T <em class="property">const</em> &amp;<em>new_value</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v115replace_copy_ifERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR1FR1TRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the all elements from the range [first, last) to another range beginning at <em>dest</em> replacing all elements satisfying a specific criteria with <em>new_value</em>.</p>
<p>Effects: Assigns to every iterator it in the range [result, result + (last - first)) either new_value or *(first + (it - result)) depending on whether the following corresponding condition holds: INVOKE(f, INVOKE(proj, *(first + (i - result)))) != false</p>
<p><p>The assignments in the parallel </p>
<em>replace_copy_if</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>last</em> - <em>first</em> applications of the predicate.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>equal</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the new values to replace (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is an unary predicate which returns <em>true</em> for the elements which need to replaced. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter1</em> can be dereferenced and then implicitly converted to <em>Type</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">new_value</span></code>: Refers to the new value to use as the replacement. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>replace_copy_if</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>replace_copy_if</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</em> &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</em> otherwise. The <em>replace_copy_if</em> algorithm returns the input iterator <em>last</em> and the output iterator to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v17reverseERR8ExPolicy9BidirIter9BidirIter">
<span id="_CPPv2N3hpx8parallel2v17reverseERR8ExPolicy9BidirIter9BidirIter"></span><span id="hpx::parallel::v1::reverse__ExPolicyRR.BidirIter.BidirIter"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> BidirIter&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a967582e2015a58617a450103228c2830"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, BidirIter&gt;::type <code class="descname">reverse</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, BidirIter <em>first</em>, BidirIter <em>last</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v17reverseERR8ExPolicy9BidirIter9BidirIter" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Reverses the order of the elements in the range [first, last). Behaves as if applying std::iter_swap to every pair of iterators first+i, (last-i) - 1 for each non-negative i &lt; (last-first)/2.</p>
<p><p>The assignments in the parallel </p>
<em>reverse</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Linear in the distance between <em>first</em> and <em>last</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">BidirIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an bidirectional iterator.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>reverse</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>reverse</em> algorithm returns a <em>hpx::future&lt;BidirIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>BidirIter</em> otherwise. It returns <em>last</em>. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v112reverse_copyERR8ExPolicy9BidirIter9BidirIter7FwdIter">
<span id="_CPPv2N3hpx8parallel2v112reverse_copyERR8ExPolicy9BidirIter9BidirIter7FwdIter"></span><span id="hpx::parallel::v1::reverse_copy__ExPolicyRR.BidirIter.BidirIter.FwdIter"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> BidirIter, <em class="property">typename</em> FwdIter&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a540985b828bcf4b522c9a9df67fcb29b"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::in<span class="sig-paren">(</span>BidirIter<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>FwdIter<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">reverse_copy</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, BidirIter <em>first</em>, BidirIter <em>last</em>, FwdIter <em>dest_first</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v112reverse_copyERR8ExPolicy9BidirIter9BidirIter7FwdIter" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the elements from the range [first, last) to another range beginning at dest_first in such a way that the elements in the new range are in reverse order. Behaves as if by executing the assignment *(dest_first + (last - first) - 1 - i) = *(first + i) once for each non-negative i &lt; (last - first) If the source and destination ranges (that is, [first, last) and [dest_first, dest_first+(last-first)) respectively) overlap, the behavior is undefined.</p>
<p><p>The assignments in the parallel </p>
<em>reverse_copy</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>last</em> - <em>first</em> assignments.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">BidirIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an bidirectional iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest_first</span></code>: Refers to the begin of the destination range.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>reverse_copy</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>reverse_copy</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::in(BidirIter), tag::out(FwdIter)&gt;</em> &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::in(BidirIter), tag::out(FwdIter)&gt;</em> otherwise. The <em>copy</em> algorithm returns the pair of the input iterator forwarded to the first element after the last in the input sequence and the output iterator to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v16rotateERR8ExPolicy7FwdIter7FwdIter7FwdIter">
<span id="_CPPv2N3hpx8parallel2v16rotateERR8ExPolicy7FwdIter7FwdIter7FwdIter"></span><span id="hpx::parallel::v1::rotate__ExPolicyRR.FwdIter.FwdIter.FwdIter"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1aa2dd57730fb01287bae897aa8a2d4591"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::begin<span class="sig-paren">(</span>FwdIter<span class="sig-paren">)</span>, tag::end<span class="sig-paren">(</span>FwdIter<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">rotate</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>new_first</em>, FwdIter <em>last</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v16rotateERR8ExPolicy7FwdIter7FwdIter7FwdIter" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Performs a left rotation on a range of elements. Specifically, <em>rotate</em> swaps the elements in the range [first, last) in such a way that the element new_first becomes the first element of the new range and new_first - 1 becomes the last element.</p>
<p><p>The assignments in the parallel </p>
<em>rotate</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Linear in the distance between <em>first</em> and <em>last</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">new_first</span></code>: Refers to the element that should appear at the beginning of the rotated range. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>rotate</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The type of dereferenced <em>FwdIter</em> must meet the requirements of <em>MoveAssignable</em> and <em>MoveConstructible</em>.</dd>
<dt><strong>Return</strong></dt>
<dd>The <em>rotate</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::begin(FwdIter), tag::end(FwdIter)&gt;</em> &gt; if the execution policy is of type <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::begin(FwdIter), tag::end(FwdIter)&gt;</em> otherwise. The <em>rotate</em> algorithm returns the iterator equal to pair(first + (last - new_first), last). </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v111rotate_copyERR8ExPolicy8FwdIter18FwdIter18FwdIter18FwdIter2">
<span id="_CPPv2N3hpx8parallel2v111rotate_copyERR8ExPolicy8FwdIter18FwdIter18FwdIter18FwdIter2"></span><span id="hpx::parallel::v1::rotate_copy__ExPolicyRR.FwdIter1.FwdIter1.FwdIter1.FwdIter2"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1ac4b99b981ee97f50731f009ee48cf1a3"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::in<span class="sig-paren">(</span>FwdIter1<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>FwdIter2<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">rotate_copy</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, FwdIter1 <em>new_first</em>, FwdIter1 <em>last</em>, FwdIter2 <em>dest_first</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v111rotate_copyERR8ExPolicy8FwdIter18FwdIter18FwdIter18FwdIter2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the elements from the range [first, last), to another range beginning at <em>dest_first</em> in such a way, that the element <em>new_first</em> becomes the first element of the new range and <em>new_first</em> - 1 becomes the last element.</p>
<p><p>The assignments in the parallel </p>
<em>rotate_copy</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>last</em> - <em>first</em> assignments.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an bidirectional iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">new_first</span></code>: Refers to the element that should appear at the beginning of the rotated range. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest_first</span></code>: Refers to the begin of the destination range.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>rotate_copy</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>rotate_copy</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</em> &gt; if the execution policy is of type <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</em> otherwise. The <em>rotate_copy</em> algorithm returns the output iterator to the element past the last element copied. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v16searchERR8ExPolicy7FwdIter7FwdIter8FwdIter28FwdIter2RR4PredRR5Proj1RR5Proj2">
<span id="_CPPv2N3hpx8parallel2v16searchERR8ExPolicy7FwdIter7FwdIter8FwdIter28FwdIter2RR4PredRR5Proj1RR5Proj2"></span><span id="hpx::parallel::v1::search__ExPolicyRR.FwdIter.FwdIter.FwdIter2.FwdIter2.PredRR.Proj1RR.Proj2RR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> Pred = detail::equal_to, <em class="property">typename</em> Proj1 = util::projection_identity, <em class="property">typename</em> Proj2 = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a0422631fee0a3f2510ebb2cfbd4698e7"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type <code class="descname">search</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, FwdIter2 <em>s_first</em>, FwdIter2 <em>s_last</em>, Pred &amp;&amp;<em>op</em> = Pred(), Proj1 &amp;&amp;<em>proj1</em> = Proj1(), Proj2 &amp;&amp;<em>proj2</em> = Proj2()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v16searchERR8ExPolicy7FwdIter7FwdIter8FwdIter28FwdIter2RR4PredRR5Proj1RR5Proj2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Searches the range [first, last) for any elements in the range [s_first, s_last). Uses a provided predicate to compare elements.</p>
<p><p>The comparison operations in the parallel </p>
<em>search</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: at most (S*N) comparisons where <em>S</em> = distance(s_first, s_last) and <em>N</em> = distance(first, last).</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used for the first range (deduced). This iterator type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the source iterators used for the second range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <em>adjacent_find</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::equal_to&lt;&gt; </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj1</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> and is applied to the elements of type dereferenced <em>FwdIter</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj2</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> and is applied to the elements of type dereferenced <em>FwdIter2</em>.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">s_first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be searching for. </li>
<li><code class="docutils literal notranslate"><span class="pre">s_last</span></code>: Refers to the end of the sequence of elements of the algorithm will be searching for. </li>
<li><code class="docutils literal notranslate"><span class="pre">op</span></code>: Refers to the binary predicate which returns true if the elements should be treated as equal. the signature of the function should be equivalent to <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type2</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> and <em>Type2</em> must be such that objects of types <em>FwdIter1</em> and <em>FwdIter2</em> can be dereferenced and then implicitly converted to <em>Type1</em> and <em>Type2</em> respectively </li>
<li><code class="docutils literal notranslate"><span class="pre">proj1</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of type dereferenced <em>FwdIter1</em> as a projection operation before the actual predicate <em>is</em> invoked. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj2</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of type dereferenced <em>FwdIter2</em> as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The comparison operations in the parallel <em>search</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>search</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>task_execution_policy</em> and returns <em>FwdIter</em> otherwise. The <em>search</em> algorithm returns an iterator to the beginning of the first subsequence [s_first, s_last) in range [first, last). If the length of the subsequence [s_first, s_last) is greater than the length of the range [first, last), <em>last</em> is returned. Additionally if the size of the subsequence is empty <em>first</em> is returned. If no subsequence is found, <em>last</em> is returned. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v18search_nERR8ExPolicy7FwdIterNSt6size_tE8FwdIter28FwdIter2RR4PredRR5Proj1RR5Proj2">
<span id="_CPPv2N3hpx8parallel2v18search_nERR8ExPolicy7FwdIterNSt6size_tE8FwdIter28FwdIter2RR4PredRR5Proj1RR5Proj2"></span><span id="hpx::parallel::v1::search_n__ExPolicyRR.FwdIter.std::s.FwdIter2.FwdIter2.PredRR.Proj1RR.Proj2RR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> Pred = detail::equal_to, <em class="property">typename</em> Proj1 = util::projection_identity, <em class="property">typename</em> Proj2 = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1ad56291e6bf23d7d9ecf498368c55017c"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type <code class="descname">search_n</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, std::size_t <em>count</em>, FwdIter2 <em>s_first</em>, FwdIter2 <em>s_last</em>, Pred &amp;&amp;<em>op</em> = Pred(), Proj1 &amp;&amp;<em>proj1</em> = Proj1(), Proj2 &amp;&amp;<em>proj2</em> = Proj2()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v18search_nERR8ExPolicy7FwdIterNSt6size_tE8FwdIter28FwdIter2RR4PredRR5Proj1RR5Proj2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Searches the range [first, last) for any elements in the range [s_first, s_last). Uses a provided predicate to compare elements.</p>
<p><p>The comparison operations in the parallel </p>
<em>search_n</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: at most (S*N) comparisons where <em>S</em> = distance(s_first, s_last) and <em>N</em> = count.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used for the first range (deduced). This iterator type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the source iterators used for the second range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <em>adjacent_find</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::equal_to&lt;&gt;</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">count</span></code>: Refers to the range of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">s_first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be searching for. </li>
<li><code class="docutils literal notranslate"><span class="pre">s_last</span></code>: Refers to the end of the sequence of elements of the algorithm will be searching for. </li>
<li><code class="docutils literal notranslate"><span class="pre">op</span></code>: Refers to the binary predicate which returns true if the elements should be treated as equal. the signature of the function should be equivalent to <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type2</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> and <em>Type2</em> must be such that objects of types <em>FwdIter1</em> and <em>FwdIter2</em> can be dereferenced and then implicitly converted to <em>Type1</em> and <em>Type2</em> respectively </li>
<li><code class="docutils literal notranslate"><span class="pre">proj1</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of type dereferenced <em>FwdIter1</em> as a projection operation before the actual predicate <em>is</em> invoked. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj2</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of type dereferenced <em>FwdIter2</em> as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The comparison operations in the parallel <em>search_n</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>search_n</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>task_execution_policy</em> and returns <em>FwdIter</em> otherwise. The <em>search_n</em> algorithm returns an iterator to the beginning of the last subsequence [s_first, s_last) in range [first, first+count). If the length of the subsequence [s_first, s_last) is greater than the length of the range [first, first+count), <em>first</em> is returned. Additionally if the size of the subsequence is empty or no subsequence is found, <em>first</em> is also returned. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v114set_differenceERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter28FwdIter3RR4Pred">
<span id="_CPPv2N3hpx8parallel2v114set_differenceERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter28FwdIter3RR4Pred"></span><span id="hpx::parallel::v1::set_difference__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.FwdIter2.FwdIter3.PredRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> FwdIter3, <em class="property">typename</em> Pred = detail::less&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1ae4f7b86deab4d83f55ac15d4f17c720b"></span>std::enable_if&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter3&gt;::type&gt;::type <code class="descname">set_difference</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first1</em>, FwdIter1 <em>last1</em>, FwdIter2 <em>first2</em>, FwdIter2 <em>last2</em>, FwdIter3 <em>dest</em>, Pred &amp;&amp;<em>op</em> = Pred()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v114set_differenceERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter28FwdIter3RR4Pred" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructs a sorted range beginning at dest consisting of all elements present in the range [first1, last1) and not present in the range [first2, last2). This algorithm expects both input ranges to be sorted with the given binary predicate <em>f</em>.</p>
<p><p>Equivalent elements are treated individually, that is, if some element is found </p>
<em>m</em> times in [first1, last1) and <em>n</em> times in [first2, last2), it will be copied to <em>dest</em> exactly std::max(m-n, 0) times. The resulting range cannot overlap with either of the input ranges.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: At most 2*(N1 + N2 - 1) comparisons, where <em>N1</em> is the length of the first sequence and <em>N2</em> is the length of the second sequence.</dd>
</dl>
</p>
<p>The resulting range cannot overlap with either of the input ranges.</p>
<p><p>The application of function objects in parallel algorithm invoked with a sequential execution policy object execute in sequential order in the calling thread (</p>
<em>sequenced_policy</em>) or in a single new thread spawned from the current thread (for <em>sequenced_task_policy</em>).<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced) representing the first sequence. This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the source iterators used (deduced) representing the first sequence. This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter3</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an output iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <em>set_difference</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::less&lt;&gt;</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first1</span></code>: Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last1</span></code>: Refers to the end of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">first2</span></code>: Refers to the beginning of the sequence of elements of the second range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last2</span></code>: Refers to the end of the sequence of elements of the second range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">op</span></code>: The binary predicate which returns true if the elements should be treated as equal. The signature of the predicate function should be equivalent to the following: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type1</em> must be such that objects of type <em>InIter</em> can be dereferenced and then implicitly converted to <em>Type1</em> </li>
</ul>
</dd>
</dl>
</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>set_difference</em> algorithm returns a <em>hpx::future&lt;FwdIter3&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter3</em> otherwise. The <em>set_difference</em> algorithm returns the output iterator to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v116set_intersectionERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter28FwdIter3RR4Pred">
<span id="_CPPv2N3hpx8parallel2v116set_intersectionERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter28FwdIter3RR4Pred"></span><span id="hpx::parallel::v1::set_intersection__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.FwdIter2.FwdIter3.PredRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> FwdIter3, <em class="property">typename</em> Pred = detail::less&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1add12fab06f2d2d3ed748b43f4de79a99"></span>std::enable_if&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter3&gt;::type&gt;::type <code class="descname">set_intersection</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first1</em>, FwdIter1 <em>last1</em>, FwdIter2 <em>first2</em>, FwdIter2 <em>last2</em>, FwdIter3 <em>dest</em>, Pred &amp;&amp;<em>op</em> = Pred()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v116set_intersectionERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter28FwdIter3RR4Pred" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructs a sorted range beginning at dest consisting of all elements present in both sorted ranges [first1, last1) and [first2, last2). This algorithm expects both input ranges to be sorted with the given binary predicate <em>f</em>.</p>
<p><p>If some element is found </p>
<em>m</em> times in [first1, last1) and <em>n</em> times in [first2, last2), the first std::min(m, n) elements will be copied from the first range to the destination range. The order of equivalent elements is preserved. The resulting range cannot overlap with either of the input ranges.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: At most 2*(N1 + N2 - 1) comparisons, where <em>N1</em> is the length of the first sequence and <em>N2</em> is the length of the second sequence.</dd>
</dl>
</p>
<p>The resulting range cannot overlap with either of the input ranges.</p>
<p><p>The application of function objects in parallel algorithm invoked with a sequential execution policy object execute in sequential order in the calling thread (</p>
<em>sequenced_policy</em>) or in a single new thread spawned from the current thread (for <em>sequenced_task_policy</em>).<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced) representing the first sequence. This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the source iterators used (deduced) representing the first sequence. This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter3</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an output iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <em>set_intersection</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::less&lt;&gt;</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first1</span></code>: Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last1</span></code>: Refers to the end of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">first2</span></code>: Refers to the beginning of the sequence of elements of the second range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last2</span></code>: Refers to the end of the sequence of elements of the second range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">op</span></code>: The binary predicate which returns true if the elements should be treated as equal. The signature of the predicate function should be equivalent to the following: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type1</em> must be such that objects of type <em>InIter</em> can be dereferenced and then implicitly converted to <em>Type1</em> </li>
</ul>
</dd>
</dl>
</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>set_intersection</em> algorithm returns a <em>hpx::future&lt;FwdIter3&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter3</em> otherwise. The <em>set_intersection</em> algorithm returns the output iterator to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v124set_symmetric_differenceERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter28FwdIter3RR4Pred">
<span id="_CPPv2N3hpx8parallel2v124set_symmetric_differenceERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter28FwdIter3RR4Pred"></span><span id="hpx::parallel::v1::set_symmetric_difference__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.FwdIter2.FwdIter3.PredRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> FwdIter3, <em class="property">typename</em> Pred = detail::less&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a522afd8e53771d027e0c98f940986587"></span>std::enable_if&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter3&gt;::type&gt;::type <code class="descname">set_symmetric_difference</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first1</em>, FwdIter1 <em>last1</em>, FwdIter2 <em>first2</em>, FwdIter2 <em>last2</em>, FwdIter3 <em>dest</em>, Pred &amp;&amp;<em>op</em> = Pred()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v124set_symmetric_differenceERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter28FwdIter3RR4Pred" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructs a sorted range beginning at dest consisting of all elements present in either of the sorted ranges [first1, last1) and [first2, last2), but not in both of them are copied to the range beginning at <em>dest</em>. The resulting range is also sorted. This algorithm expects both input ranges to be sorted with the given binary predicate <em>f</em>.</p>
<p><p>If some element is found </p>
<em>m</em> times in [first1, last1) and <em>n</em> times in [first2, last2), it will be copied to <em>dest</em> exactly std::abs(m-n) times. If m&gt;n, then the last m-n of those elements are copied from [first1,last1), otherwise the last n-m elements are copied from [first2,last2). The resulting range cannot overlap with either of the input ranges.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: At most 2*(N1 + N2 - 1) comparisons, where <em>N1</em> is the length of the first sequence and <em>N2</em> is the length of the second sequence.</dd>
</dl>
</p>
<p>The resulting range cannot overlap with either of the input ranges.</p>
<p><p>The application of function objects in parallel algorithm invoked with a sequential execution policy object execute in sequential order in the calling thread (</p>
<em>sequenced_policy</em>) or in a single new thread spawned from the current thread (for <em>sequenced_task_policy</em>).<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced) representing the first sequence. This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the source iterators used (deduced) representing the first sequence. This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter3</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an output iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <em>set_symmetric_difference</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::less&lt;&gt;</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first1</span></code>: Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last1</span></code>: Refers to the end of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">first2</span></code>: Refers to the beginning of the sequence of elements of the second range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last2</span></code>: Refers to the end of the sequence of elements of the second range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">op</span></code>: The binary predicate which returns true if the elements should be treated as equal. The signature of the predicate function should be equivalent to the following: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type1</em> must be such that objects of type <em>InIter</em> can be dereferenced and then implicitly converted to <em>Type1</em> </li>
</ul>
</dd>
</dl>
</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>set_symmetric_difference</em> algorithm returns a <em>hpx::future&lt;FwdIter3&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter3</em> otherwise. The <em>set_symmetric_difference</em> algorithm returns the output iterator to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v19set_unionERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter28FwdIter3RR4Pred">
<span id="_CPPv2N3hpx8parallel2v19set_unionERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter28FwdIter3RR4Pred"></span><span id="hpx::parallel::v1::set_union__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.FwdIter2.FwdIter3.PredRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> FwdIter3, <em class="property">typename</em> Pred = detail::less&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1ab6f109dcd077c01e1e7f9f34e8916f51"></span>std::enable_if&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter3&gt;::type&gt;::type <code class="descname">set_union</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first1</em>, FwdIter1 <em>last1</em>, FwdIter2 <em>first2</em>, FwdIter2 <em>last2</em>, FwdIter3 <em>dest</em>, Pred &amp;&amp;<em>op</em> = Pred()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v19set_unionERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter28FwdIter3RR4Pred" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructs a sorted range beginning at dest consisting of all elements present in one or both sorted ranges [first1, last1) and [first2, last2). This algorithm expects both input ranges to be sorted with the given binary predicate <em>f</em>.</p>
<p><p>If some element is found </p>
<em>m</em> times in [first1, last1) and <em>n</em> times in [first2, last2), then all <em>m</em> elements will be copied from [first1, last1) to dest, preserving order, and then exactly std::max(n-m, 0) elements will be copied from [first2, last2) to dest, also preserving order.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: At most 2*(N1 + N2 - 1) comparisons, where <em>N1</em> is the length of the first sequence and <em>N2</em> is the length of the second sequence.</dd>
</dl>
</p>
<p>The resulting range cannot overlap with either of the input ranges.</p>
<p><p>The application of function objects in parallel algorithm invoked with a sequential execution policy object execute in sequential order in the calling thread (</p>
<em>sequenced_policy</em>) or in a single new thread spawned from the current thread (for <em>sequenced_task_policy</em>).<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced) representing the first sequence. This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the source iterators used (deduced) representing the first sequence. This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter3</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an output iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Op</span></code>: The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <em>set_union</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::less&lt;&gt;</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first1</span></code>: Refers to the beginning of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last1</span></code>: Refers to the end of the sequence of elements of the first range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">first2</span></code>: Refers to the beginning of the sequence of elements of the second range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last2</span></code>: Refers to the end of the sequence of elements of the second range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">op</span></code>: The binary predicate which returns true if the elements should be treated as equal. The signature of the predicate function should be equivalent to the following: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type1</em> must be such that objects of type <em>InIter</em> can be dereferenced and then implicitly converted to <em>Type1</em> </li>
</ul>
</dd>
</dl>
</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>set_union</em> algorithm returns a <em>hpx::future&lt;FwdIter3&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter3</em> otherwise. The <em>set_union</em> algorithm returns the output iterator to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v14sortERR8ExPolicy8RandomIt8RandomItRR7CompareRR4Proj">
<span id="_CPPv2N3hpx8parallel2v14sortERR8ExPolicy8RandomIt8RandomItRR7CompareRR4Proj"></span><span id="hpx::parallel::v1::sort__ExPolicyRR.RandomIt.RandomIt.CompareRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> RandomIt, <em class="property">typename</em> Proj = util::projection_identity, <em class="property">typename</em> Compare = detail::less&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a19a39eb03a906b3fc2a00a9916d3d183"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, RandomIt&gt;::type <code class="descname">sort</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, RandomIt <em>first</em>, RandomIt <em>last</em>, Compare &amp;&amp;<em>comp</em> = Compare(), Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v14sortERR8ExPolicy8RandomIt8RandomItRR7CompareRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Sorts the elements in the range [first, last) in ascending order. The order of equal elements is not guaranteed to be preserved. The function uses the given comparison function object comp (defaults to using operator&lt;()).</p>
<p><p>A sequence is sorted with respect to a comparator </p>
<em>comp</em> and a projection <em>proj</em> if for every iterator i pointing to the sequence and every non-negative integer n such that i + n is a valid iterator pointing to an element of the sequence, and INVOKE(comp, INVOKE(proj, *(i + n)), INVOKE(proj, *i)) == false.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: O(Nlog(N)), where N = std::distance(first, last) comparisons.</dd>
</dl>
</p>
<p><em>comp</em> has to induce a strict weak ordering on the values.<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </li>
<li><code class="docutils literal notranslate"><span class="pre">Iter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of a random access iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Comp</span></code>: The type of the function/function object to use (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">comp</span></code>: comp is a callable object. The return value of the INVOKE operation applied to an object of type Comp, when contextually converted to bool, yields true if the first argument of the call is less than the second, and false otherwise. It is assumed that comp will not apply any non-constant function through the dereferenced iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each pair of elements as a projection operation before the actual predicate <em>comp</em> is invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>sort</em> algorithm returns a <em>hpx::future&lt;RandomIt&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>RandomIt</em> otherwise. The algorithm returns an iterator pointing to the first element after the last element in the input sequence. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v111sort_by_keyERR8ExPolicy7KeyIter7KeyIter9ValueIterRR7Compare">
<span id="_CPPv2N3hpx8parallel2v111sort_by_keyERR8ExPolicy7KeyIter7KeyIter9ValueIterRR7Compare"></span><span id="hpx::parallel::v1::sort_by_key__ExPolicyRR.KeyIter.KeyIter.ValueIter.CompareRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> KeyIter, <em class="property">typename</em> ValueIter, <em class="property">typename</em> Compare = detail::less&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a4654311fbeb730ed3fbae60c48987150"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::in1<span class="sig-paren">(</span>KeyIter<span class="sig-paren">)</span>, tag::in2<span class="sig-paren">(</span>ValueIter<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">sort_by_key</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, KeyIter <em>key_first</em>, KeyIter <em>key_last</em>, ValueIter <em>value_first</em>, Compare &amp;&amp;<em>comp</em> = Compare()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v111sort_by_keyERR8ExPolicy7KeyIter7KeyIter9ValueIterRR7Compare" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Sorts one range of data using keys supplied in another range. The key elements in the range [key_first, key_last) are sorted in ascending order with the corresponding elements in the value range moved to follow the sorted order. The algorithm is not stable, the order of equal elements is not guaranteed to be preserved. The function uses the given comparison function object comp (defaults to using operator&lt;()).</p>
<p><p>A sequence is sorted with respect to a comparator </p>
<em>comp</em> and a projection <em>proj</em> if for every iterator i pointing to the sequence and every non-negative integer n such that i + n is a valid iterator pointing to an element of the sequence, and INVOKE(comp, INVOKE(proj, *(i + n)), INVOKE(proj, *i)) == false.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: O(Nlog(N)), where N = std::distance(first, last) comparisons.</dd>
</dl>
</p>
<p><em>comp</em> has to induce a strict weak ordering on the values.<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </li>
<li><code class="docutils literal notranslate"><span class="pre">KeyIter</span></code>: The type of the key iterators used (deduced). This iterator type must meet the requirements of a random access iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">ValueIter</span></code>: The type of the value iterators used (deduced). This iterator type must meet the requirements of a random access iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Comp</span></code>: The type of the function/function object to use (deduced).</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">key_first</span></code>: Refers to the beginning of the sequence of key elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">key_last</span></code>: Refers to the end of the sequence of key elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">value_first</span></code>: Refers to the beginning of the sequence of value elements the algorithm will be applied to, the range of elements must match [key_first, key_last) </li>
<li><code class="docutils literal notranslate"><span class="pre">comp</span></code>: comp is a callable object. The return value of the INVOKE operation applied to an object of type Comp, when contextually converted to bool, yields true if the first argument of the call is less than the second, and false otherwise. It is assumed that comp will not apply any non-constant function through the dereferenced iterator.</li>
</ul>
</dd>
</dl>
</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>sort_by-key</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::in1(KeyIter&gt;</em>, tag::in2(ValueIter)&gt; &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em> otherwise</em>. The algorithm returns a pair holding an iterator pointing to the first element after the last element in the input key sequence and an iterator pointing to the first element after the last element in the input value sequence. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v111swap_rangesERR8ExPolicy8FwdIter18FwdIter18FwdIter2">
<span id="_CPPv2N3hpx8parallel2v111swap_rangesERR8ExPolicy8FwdIter18FwdIter18FwdIter2"></span><span id="hpx::parallel::v1::swap_ranges__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1ad97a105e8dafd8d11ec2d66d2d1ca2d8"></span>std::enable_if&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter2&gt;::type&gt;::type <code class="descname">swap_ranges</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first1</em>, FwdIter1 <em>last1</em>, FwdIter2 <em>first2</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v111swap_rangesERR8ExPolicy8FwdIter18FwdIter18FwdIter2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Exchanges elements between range [first1, last1) and another range starting at <em>first2</em>.</p>
<p><p>The swap operations in the parallel </p>
<em>swap_ranges</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Linear in the distance between <em>first1</em> and <em>last1</em> </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the swap operations. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the first range of iterators to swap (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the second range of iterators to swap (deduced). This iterator type must meet the requirements of an forward iterator.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first1</span></code>: Refers to the beginning of the first sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last1</span></code>: Refers to the end of the first sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">first2</span></code>: Refers to the beginning of the second sequence of elements the algorithm will be applied to.</li>
</ul>
</dd>
</dl>
</p>
<p>The swap operations in the parallel <em>swap_ranges</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>swap_ranges</em> algorithm returns a <em>hpx::future&lt;FwdIter2&gt;</em> if the execution policy is of type <em>parallel_task_policy</em> and returns <em>FwdIter2</em> otherwise. The <em>swap_ranges</em> algorithm returns iterator to the element past the last element exchanged in the range beginning with <em>first2</em>. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v19transformERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR1FRR4Proj">
<span id="_CPPv2N3hpx8parallel2v19transformERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR1FRR4Proj"></span><span id="hpx::parallel::v1::transform__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.FRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> F, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1afe123e60433fe2243f7245caf6a56776"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::in<span class="sig-paren">(</span>FwdIter1<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>FwdIter2<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">transform</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, FwdIter1 <em>last</em>, FwdIter2 <em>dest</em>, F &amp;&amp;<em>f</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v19transformERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR1FRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Applies the given function <em>f</em> to the range [first, last) and stores the result in another range, beginning at dest.</p>
<p><p>The invocations of </p>
<em>f</em> in the parallel <em>transform</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Exactly <em>last</em> - <em>first</em> applications of <em>f</em> </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the invocations of <em>f</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>transform</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is an unary predicate. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ret</span> <span class="nf">fun</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter</em> can be dereferenced and then implicitly converted to <em>Type</em>. The type <em>Ret</em> must be such that an object of type <em>FwdIter2</em> can be dereferenced and assigned a value of type <em>Ret</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>f</em> is invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The invocations of <em>f</em> in the parallel <em>transform</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>transform</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</em> &gt; if the execution policy is of type <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</em> otherwise. The <em>transform</em> algorithm returns a tuple holding an iterator referring to the first element after the input sequence and the output iterator to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v19transformERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter3RR1FRR5Proj1RR5Proj2">
<span id="_CPPv2N3hpx8parallel2v19transformERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter3RR1FRR5Proj1RR5Proj2"></span><span id="hpx::parallel::v1::transform__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.FwdIter3.FRR.Proj1RR.Proj2RR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> FwdIter3, <em class="property">typename</em> F, <em class="property">typename</em> Proj1 = util::projection_identity, <em class="property">typename</em> Proj2 = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1af7f78b7eb5dbe16a703b68aee48844b4"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_tuple&lt;tag::in1<span class="sig-paren">(</span>FwdIter1<span class="sig-paren">)</span>, tag::in2<span class="sig-paren">(</span>FwdIter2<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>FwdIter3<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">transform</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first1</em>, FwdIter1 <em>last1</em>, FwdIter2 <em>first2</em>, FwdIter3 <em>dest</em>, F &amp;&amp;<em>f</em>, Proj1 &amp;&amp;<em>proj1</em> = Proj1(), Proj2 &amp;&amp;<em>proj2</em> = Proj2()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v19transformERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter3RR1FRR5Proj1RR5Proj2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Applies the given function <em>f</em> to pairs of elements from two ranges: one defined by [first1, last1) and the other beginning at first2, and stores the result in another range, beginning at dest.</p>
<p><p>The invocations of </p>
<em>f</em> in the parallel <em>transform</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Exactly <em>last</em> - <em>first</em> applications of <em>f</em> </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the invocations of <em>f</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators for the first range used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the source iterators for the second range used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter3</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>transform</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj1</span></code>: The type of an optional projection function to be used for elements of the first sequence. This defaults to <em>util::projection_identity</em> </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj2</span></code>: The type of an optional projection function to be used for elements of the second sequence. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first1</span></code>: Refers to the beginning of the first sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last1</span></code>: Refers to the end of the first sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">first2</span></code>: Refers to the beginning of the second sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is a binary predicate. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ret</span> <span class="nf">fun</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type2</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;. The types </p>
<em>Type1</em> and <em>Type2</em> must be such that objects of types FwdIter1 and FwdIter2 can be dereferenced and then implicitly converted to <em>Type1</em> and <em>Type2</em> respectively. The type <em>Ret</em> must be such that an object of type <em>FwdIter3</em> can be dereferenced and assigned a value of type <em>Ret</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj1</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of the first sequence as a projection operation before the actual predicate <em>f</em> is invoked. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj2</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of the second sequence as a projection operation before the actual predicate <em>f</em> is invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The invocations of <em>f</em> in the parallel <em>transform</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>transform</em> algorithm returns a <em>hpx::future&lt;tagged_tuple&lt;tag::in1(FwdIter1), tag::in2(FwdIter2), tag::out(FwdIter3)&gt;</em> &gt; if the execution policy is of type <em>parallel_task_policy</em> and returns <em>tagged_tuple&lt;tag::in1(FwdIter1), tag::in2(FwdIter2), tag::out(FwdIter3)&gt;</em> otherwise. The <em>transform</em> algorithm returns a tuple holding an iterator referring to the first element after the first input sequence, an iterator referring to the first element after the second input sequence, and the output iterator referring to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v19transformERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter28FwdIter3RR1FRR5Proj1RR5Proj2">
<span id="_CPPv2N3hpx8parallel2v19transformERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter28FwdIter3RR1FRR5Proj1RR5Proj2"></span><span id="hpx::parallel::v1::transform__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.FwdIter2.FwdIter3.FRR.Proj1RR.Proj2RR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> FwdIter3, <em class="property">typename</em> F, <em class="property">typename</em> Proj1 = util::projection_identity, <em class="property">typename</em> Proj2 = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a2c88d036a1198ebba88d54d2f7d4984b"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_tuple&lt;tag::in1<span class="sig-paren">(</span>FwdIter1<span class="sig-paren">)</span>, tag::in2<span class="sig-paren">(</span>FwdIter2<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>FwdIter3<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">transform</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first1</em>, FwdIter1 <em>last1</em>, FwdIter2 <em>first2</em>, FwdIter2 <em>last2</em>, FwdIter3 <em>dest</em>, F &amp;&amp;<em>f</em>, Proj1 &amp;&amp;<em>proj1</em> = Proj1(), Proj2 &amp;&amp;<em>proj2</em> = Proj2()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v19transformERR8ExPolicy8FwdIter18FwdIter18FwdIter28FwdIter28FwdIter3RR1FRR5Proj1RR5Proj2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Applies the given function <em>f</em> to pairs of elements from two ranges: one defined by [first1, last1) and the other beginning at first2, and stores the result in another range, beginning at dest.</p>
<p><p>The invocations of </p>
<em>f</em> in the parallel <em>transform</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Exactly min(last2-first2, last1-first1) applications of <em>f</em> </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the invocations of <em>f</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators for the first range used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the source iterators for the second range used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter3</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>transform</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj1</span></code>: The type of an optional projection function to be used for elements of the first sequence. This defaults to <em>util::projection_identity</em> </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj2</span></code>: The type of an optional projection function to be used for elements of the second sequence. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first1</span></code>: Refers to the beginning of the first sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last1</span></code>: Refers to the end of the first sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">first2</span></code>: Refers to the beginning of the second sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last2</span></code>: Refers to the end of the second sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is a binary predicate. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ret</span> <span class="nf">fun</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type2</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;. The types </p>
<em>Type1</em> and <em>Type2</em> must be such that objects of types FwdIter1 and FwdIter2 can be dereferenced and then implicitly converted to <em>Type1</em> and <em>Type2</em> respectively. The type <em>Ret</em> must be such that an object of type <em>FwdIter3</em> can be dereferenced and assigned a value of type <em>Ret</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj1</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of the first sequence as a projection operation before the actual predicate <em>f</em> is invoked. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj2</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of the second sequence as a projection operation before the actual predicate <em>f</em> is invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The invocations of <em>f</em> in the parallel <em>transform</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The algorithm will invoke the binary predicate until it reaches the end of the shorter of the two given input sequences</dd>
<dt><strong>Return</strong></dt>
<dd>The <em>transform</em> algorithm returns a <em>hpx::future&lt;tagged_tuple&lt;tag::in1(FwdIter1), tag::in2(FwdIter2), tag::out(FwdIter3)&gt;</em> &gt; if the execution policy is of type <em>parallel_task_policy</em> and returns <em>tagged_tuple&lt;tag::in1(FwdIter1), tag::in2(FwdIter2), tag::out(FwdIter3)&gt;</em> otherwise. The <em>transform</em> algorithm returns a tuple holding an iterator referring to the first element after the first input sequence, an iterator referring to the first element after the second input sequence, and the output iterator referring to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v124transform_exclusive_scanERR8ExPolicy8FwdIter18FwdIter18FwdIter21TRR2OpRR4Conv">
<span id="_CPPv2N3hpx8parallel2v124transform_exclusive_scanERR8ExPolicy8FwdIter18FwdIter18FwdIter21TRR2OpRR4Conv"></span><span id="hpx::parallel::v1::transform_exclusive_scan__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.T.OpRR.ConvRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> T, <em class="property">typename</em> Op, <em class="property">typename</em> Conv&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a5b927b96e3f7a187d5762f2e88217319"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter2&gt;::type <code class="descname">transform_exclusive_scan</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, FwdIter1 <em>last</em>, FwdIter2 <em>dest</em>, T <em>init</em>, Op &amp;&amp;<em>op</em>, Conv &amp;&amp;<em>conv</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v124transform_exclusive_scanERR8ExPolicy8FwdIter18FwdIter18FwdIter21TRR2OpRR4Conv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assigns through each iterator <em>i</em> in [result, result + (last - first)) the value of GENERALIZED_NONCOMMUTATIVE_SUM(binary_op, init, conv(*first), …, conv(*(first + (i - result) - 1))).</p>
<p><p>The reduce operations in the parallel </p>
<em>transform_exclusive_scan</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: O(<em>last</em> - <em>first</em>) applications of the predicates <em>op</em> and <em>conv</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Conv</span></code>: The type of the unary function object used for the conversion operation. </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the value to be used as initial (and intermediate) values (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">Op</span></code>: The type of the binary function object used for the reduction operation.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">conv</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). This is a unary predicate. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">R</span> <span class="nf">fun</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter1</em> can be dereferenced and then implicitly converted to Type. The type <em>R</em> must be such that an object of this type can be implicitly converted to <em>T</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">init</span></code>: The initial value for the generalized sum. </li>
<li><code class="docutils literal notranslate"><span class="pre">op</span></code>: Specifies the function (or function object) which will be invoked for each of the values of the input sequence. This is a binary predicate. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ret</span> <span class="nf">fun</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> and <em>Ret</em> must be such that an object of a type as given by the input sequence can be implicitly converted to any of those types.</li>
</ul>
</dd>
</dl>
</p>
<p>The reduce operations in the parallel <em>transform_exclusive_scan</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><p>Neither </p>
<em>conv</em> nor <em>op</em> shall invalidate iterators or subranges, or modify elements in the ranges [first,last) or [result,result + (last - first)).<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>copy_n</em> algorithm returns a <em>hpx::future&lt;FwdIter2&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter2</em> otherwise. The <em>transform_exclusive_scan</em> algorithm returns the output iterator to the element in the destination range, one past the last element copied.</dd>
<dt><strong>Note</strong></dt>
<dd>GENERALIZED_NONCOMMUTATIVE_SUM(op, a1, …, aN) is defined as:<ul class="simple">
<li>a1 when N is 1</li>
<li>op(GENERALIZED_NONCOMMUTATIVE_SUM(op, a1, …, aK), GENERALIZED_NONCOMMUTATIVE_SUM(op, aM, …, aN) where 1 &lt; K+1 = M &lt;= N.</li>
</ul>
</dd>
</dl>
</p>
<p>The behavior of transform_exclusive_scan may be non-deterministic for a non-associative predicate. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v124transform_inclusive_scanERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR2OpRR4Conv1T">
<span id="_CPPv2N3hpx8parallel2v124transform_inclusive_scanERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR2OpRR4Conv1T"></span><span id="hpx::parallel::v1::transform_inclusive_scan__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.OpRR.ConvRR.T"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> Op, <em class="property">typename</em> Conv, <em class="property">typename</em> T&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1afa7b5c6696fe051a8871ee813c88c255"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter2&gt;::type <code class="descname">transform_inclusive_scan</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, FwdIter1 <em>last</em>, FwdIter2 <em>dest</em>, Op &amp;&amp;<em>op</em>, Conv &amp;&amp;<em>conv</em>, T <em>init</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v124transform_inclusive_scanERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR2OpRR4Conv1T" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assigns through each iterator <em>i</em> in [result, result + (last - first)) the value of GENERALIZED_NONCOMMUTATIVE_SUM(op, init, conv(*first), …, conv(*(first + (i - result)))).</p>
<p><p>The reduce operations in the parallel </p>
<em>transform_inclusive_scan</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: O(<em>last</em> - <em>first</em>) applications of the predicate <em>op</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Conv</span></code>: The type of the unary function object used for the conversion operation. </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the value to be used as initial (and intermediate) values (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">Op</span></code>: The type of the binary function object used for the reduction operation.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">conv</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). This is a unary predicate. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">R</span> <span class="nf">fun</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter1</em> can be dereferenced and then implicitly converted to Type. The type <em>R</em> must be such that an object of this type can be implicitly converted to <em>T</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">init</span></code>: The initial value for the generalized sum. </li>
<li><code class="docutils literal notranslate"><span class="pre">op</span></code>: Specifies the function (or function object) which will be invoked for each of the values of the input sequence. This is a binary predicate. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ret</span> <span class="nf">fun</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> and <em>Ret</em> must be such that an object of a type as given by the input sequence can be implicitly converted to any of those types.</li>
</ul>
</dd>
</dl>
</p>
<p>The reduce operations in the parallel <em>transform_inclusive_scan</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><p>Neither </p>
<em>conv</em> nor <em>op</em> shall invalidate iterators or subranges, or modify elements in the ranges [first,last) or [result,result + (last - first)).<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>copy_n</em> algorithm returns a <em>hpx::future&lt;FwdIter2&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter2</em> otherwise. The <em>transform_inclusive_scan</em> algorithm returns the output iterator to the element in the destination range, one past the last element copied.</dd>
<dt><strong>Note</strong></dt>
<dd>GENERALIZED_NONCOMMUTATIVE_SUM(op, a1, …, aN) is defined as:<ul class="simple">
<li>a1 when N is 1</li>
<li>op(GENERALIZED_NONCOMMUTATIVE_SUM(op, a1, …, aK), GENERALIZED_NONCOMMUTATIVE_SUM(op, aM, …, aN)) where 1 &lt; K+1 = M &lt;= N.</li>
</ul>
</dd>
</dl>
</p>
<p>The difference between <em>exclusive_scan</em> and <em>transform_inclusive_scan</em> is that <em>transform_inclusive_scan</em> includes the ith input element in the ith sum. If <em>op</em> is not mathematically associative, the behavior of <em>transform_inclusive_scan</em> may be non-deterministic. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v124transform_inclusive_scanERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR2OpRR4Conv">
<span id="_CPPv2N3hpx8parallel2v124transform_inclusive_scanERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR2OpRR4Conv"></span><span id="hpx::parallel::v1::transform_inclusive_scan__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.OpRR.ConvRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> Conv, <em class="property">typename</em> Op&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a9485c4191609660bd226d64a7d53df78"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter2&gt;::type <code class="descname">transform_inclusive_scan</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, FwdIter1 <em>last</em>, FwdIter2 <em>dest</em>, Op &amp;&amp;<em>op</em>, Conv &amp;&amp;<em>conv</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v124transform_inclusive_scanERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR2OpRR4Conv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assigns through each iterator <em>i</em> in [result, result + (last - first)) the value of GENERALIZED_NONCOMMUTATIVE_SUM(op, conv(*first), …, conv(*(first + (i - result)))).</p>
<p><p>The reduce operations in the parallel </p>
<em>transform_inclusive_scan</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: O(<em>last</em> - <em>first</em>) applications of the predicate <em>op</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Conv</span></code>: The type of the unary function object used for the conversion operation. </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the value to be used as initial (and intermediate) values (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">Op</span></code>: The type of the binary function object used for the reduction operation.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">conv</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). This is a unary predicate. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">R</span> <span class="nf">fun</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter1</em> can be dereferenced and then implicitly converted to Type. The type <em>R</em> must be such that an object of this type can be implicitly converted to <em>T</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">op</span></code>: Specifies the function (or function object) which will be invoked for each of the values of the input sequence. This is a binary predicate. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ret</span> <span class="nf">fun</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> and <em>Ret</em> must be such that an object of a type as given by the input sequence can be implicitly converted to any of those types.</li>
</ul>
</dd>
</dl>
</p>
<p>The reduce operations in the parallel <em>transform_inclusive_scan</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><p>Neither </p>
<em>conv</em> nor <em>op</em> shall invalidate iterators or subranges, or modify elements in the ranges [first,last) or [result,result + (last - first)).<dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>copy_n</em> algorithm returns a <em>hpx::future&lt;FwdIter2&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter2</em> otherwise. The <em>transform_inclusive_scan</em> algorithm returns the output iterator to the element in the destination range, one past the last element copied.</dd>
<dt><strong>Note</strong></dt>
<dd>GENERALIZED_NONCOMMUTATIVE_SUM(op, a1, …, aN) is defined as:<ul class="simple">
<li>a1 when N is 1</li>
<li>op(GENERALIZED_NONCOMMUTATIVE_SUM(op, a1, …, aK), GENERALIZED_NONCOMMUTATIVE_SUM(op, aM, …, aN)) where 1 &lt; K+1 = M &lt;= N.</li>
</ul>
</dd>
</dl>
</p>
<p>The difference between <em>exclusive_scan</em> and <em>transform_inclusive_scan</em> is that <em>transform_inclusive_scan</em> includes the ith input element in the ith sum. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v116transform_reduceERR8ExPolicy7FwdIter7FwdIter1TRR6ReduceRR7Convert">
<span id="_CPPv2N3hpx8parallel2v116transform_reduceERR8ExPolicy7FwdIter7FwdIter1TRR6ReduceRR7Convert"></span><span id="hpx::parallel::v1::transform_reduce__ExPolicyRR.FwdIter.FwdIter.T.ReduceRR.ConvertRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> T, <em class="property">typename</em> Reduce, <em class="property">typename</em> Convert&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1aa9f78549181118dc94894d157027bdb7"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, T&gt;::type <code class="descname">transform_reduce</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, T <em>init</em>, Reduce &amp;&amp;<em>red_op</em>, Convert &amp;&amp;<em>conv_op</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v116transform_reduceERR8ExPolicy7FwdIter7FwdIter1TRR6ReduceRR7Convert" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns GENERALIZED_SUM(red_op, init, conv_op(*first), …, conv_op(*(first + (last - first) - 1))).</p>
<p><p>The reduce operations in the parallel </p>
<em>transform_reduce</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: O(<em>last</em> - <em>first</em>) applications of the predicates <em>red_op</em> and <em>conv_op</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>copy_if</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the value to be used as initial (and intermediate) values (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">Reduce</span></code>: The type of the binary function object used for the reduction operation. </li>
<li><code class="docutils literal notranslate"><span class="pre">Convert</span></code>: The type of the unary function object used to transform the elements of the input sequence before invoking the reduce function.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">conv_op</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). This is a unary predicate. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">R</span> <span class="nf">fun</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter</em> can be dereferenced and then implicitly converted to Type. The type <em>R</em> must be such that an object of this type can be implicitly converted to <em>T</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">init</span></code>: The initial value for the generalized sum. </li>
<li><code class="docutils literal notranslate"><span class="pre">red_op</span></code>: Specifies the function (or function object) which will be invoked for each of the values returned from the invocation of <em>conv_op</em>. This is a binary predicate. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ret</span> <span class="nf">fun</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type2</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em>, <em>Type2</em>, and <em>Ret</em> must be such that an object of a type as returned from <em>conv_op</em> can be implicitly converted to any of those types.</li>
</ul>
</dd>
</dl>
</p>
<p>The reduce operations in the parallel <em>transform_reduce</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><p>The difference between </p>
<em>transform_reduce</em> and <em>accumulate</em> is that the behavior of transform_reduce may be non-deterministic for non-associative or non-commutative binary predicate. <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>transform_reduce</em> algorithm returns a <em>hpx::future&lt;T&gt;</em> if the execution policy is of type <em>parallel_task_policy</em> and returns <em>T</em> otherwise. The <em>transform_reduce</em> algorithm returns the result of the generalized sum over the values returned from <em>conv_op</em> when applied to the elements given by the input range [first, last).</dd>
<dt><strong>Note</strong></dt>
<dd>GENERALIZED_SUM(op, a1, …, aN) is defined as follows:<ul class="simple">
<li>a1 when N is 1</li>
<li>op(GENERALIZED_SUM(op, b1, …, bK), GENERALIZED_SUM(op, bM, …, bN)), where:<ul>
<li>b1, …, bN may be any permutation of a1, …, aN and</li>
<li>1 &lt; K+1 = M &lt;= N.</li>
</ul>
</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v116transform_reduceERR8ExPolicy8FwdIter18FwdIter18FwdIter21T">
<span id="_CPPv2N3hpx8parallel2v116transform_reduceERR8ExPolicy8FwdIter18FwdIter18FwdIter21T"></span><span id="hpx::parallel::v1::transform_reduce__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.T"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> T&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a693dae27f2f4fa48464229112b73ae56"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, T&gt;::type <code class="descname">transform_reduce</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first1</em>, FwdIter1 <em>last1</em>, FwdIter2 <em>first2</em>, T <em>init</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v116transform_reduceERR8ExPolicy8FwdIter18FwdIter18FwdIter21T" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the result of accumulating init with the inner products of the pairs formed by the elements of two ranges starting at first1 and first2.</p>
<p><p>The operations in the parallel </p>
<em>transform_reduce</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: O(<em>last</em> - <em>first</em>) applications of the predicate <em>op2</em>. </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the first source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the second source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the value to be used as return) values (deduced). </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first1</span></code>: Refers to the beginning of the first sequence of elements the result will be calculated with. </li>
<li><code class="docutils literal notranslate"><span class="pre">last1</span></code>: Refers to the end of the first sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">first2</span></code>: Refers to the beginning of the second sequence of elements the result will be calculated with. </li>
<li><code class="docutils literal notranslate"><span class="pre">init</span></code>: The initial value for the sum.</li>
</ul>
</dd>
</dl>
</p>
<p>The operations in the parallel <em>transform_reduce</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>transform_reduce</em> algorithm returns a <em>hpx::future&lt;T&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>T</em> otherwise. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v116transform_reduceERR8ExPolicy8FwdIter18FwdIter18FwdIter21TRR6ReduceRR7Convert">
<span id="_CPPv2N3hpx8parallel2v116transform_reduceERR8ExPolicy8FwdIter18FwdIter18FwdIter21TRR6ReduceRR7Convert"></span><span id="hpx::parallel::v1::transform_reduce__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.T.ReduceRR.ConvertRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> T, <em class="property">typename</em> Reduce, <em class="property">typename</em> Convert&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1ad0241a6affe0562bc8b0ccedc8a5af6b"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, T&gt;::type <code class="descname">transform_reduce</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first1</em>, FwdIter1 <em>last1</em>, FwdIter2 <em>first2</em>, T <em>init</em>, Reduce &amp;&amp;<em>red_op</em>, Convert &amp;&amp;<em>conv_op</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v116transform_reduceERR8ExPolicy8FwdIter18FwdIter18FwdIter21TRR6ReduceRR7Convert" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the result of accumulating init with the inner products of the pairs formed by the elements of two ranges starting at first1 and first2.</p>
<p><p>The operations in the parallel </p>
<em>transform_reduce</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: O(<em>last</em> - <em>first</em>) applications of the predicate <em>op2</em>. </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the first source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the second source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the value to be used as return) values (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">Reduce</span></code>: The type of the binary function object used for the multiplication operation. </li>
<li><code class="docutils literal notranslate"><span class="pre">Convert</span></code>: The type of the unary function object used to transform the elements of the input sequence before invoking the reduce function.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first1</span></code>: Refers to the beginning of the first sequence of elements the result will be calculated with. </li>
<li><code class="docutils literal notranslate"><span class="pre">last1</span></code>: Refers to the end of the first sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">first2</span></code>: Refers to the beginning of the second sequence of elements the result will be calculated with. </li>
<li><code class="docutils literal notranslate"><span class="pre">init</span></code>: The initial value for the sum. </li>
<li><code class="docutils literal notranslate"><span class="pre">red_op</span></code>: Specifies the function (or function object) which will be invoked for the initial value and each of the return values of <em>op2</em>. This is a binary predicate. The signature of this predicate should be equivalent to should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ret</span> <span class="nf">fun</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Ret</em> must be such that it can be implicitly converted to a type of <em>T</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">conv_op</span></code>: Specifies the function (or function object) which will be invoked for each of the input values of the sequence. This is a binary predicate. The signature of this predicate should be equivalent to <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ret</span> <span class="nf">fun</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type2</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Ret</em> must be such that it can be implicitly converted to an object for the second argument type of <em>op1</em>.</li>
</ul>
</dd>
</dl>
</p>
<p>The operations in the parallel <em>transform_reduce</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>transform_reduce</em> algorithm returns a <em>hpx::future&lt;T&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>T</em> otherwise. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v118uninitialized_copyERR8ExPolicy8FwdIter18FwdIter18FwdIter2">
<span id="_CPPv2N3hpx8parallel2v118uninitialized_copyERR8ExPolicy8FwdIter18FwdIter18FwdIter2"></span><span id="hpx::parallel::v1::uninitialized_copy__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a1c66bbb007b2e42175d491fa3ffba102"></span>std::enable_if&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter2&gt;::type&gt;::type <code class="descname">uninitialized_copy</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, FwdIter1 <em>last</em>, FwdIter2 <em>dest</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v118uninitialized_copyERR8ExPolicy8FwdIter18FwdIter18FwdIter2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the elements in the range, defined by [first, last), to an uninitialized memory area beginning at <em>dest</em>. If an exception is thrown during the copy operation, the function has no effects.</p>
<p><p>The assignments in the parallel </p>
<em>uninitialized_copy</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>last</em> - <em>first</em> assignments.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of a forward iterator.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>uninitialized_copy</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>uninitialized_copy</em> algorithm returns a <em>hpx::future&lt;FwdIter2&gt;</em>, if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter2</em> otherwise. The <em>uninitialized_copy</em> algorithm returns the output iterator to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v120uninitialized_copy_nERR8ExPolicy8FwdIter14Size8FwdIter2">
<span id="_CPPv2N3hpx8parallel2v120uninitialized_copy_nERR8ExPolicy8FwdIter14Size8FwdIter2"></span><span id="hpx::parallel::v1::uninitialized_copy_n__ExPolicyRR.FwdIter1.Size.FwdIter2"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> Size, <em class="property">typename</em> FwdIter2&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a1af39d96a6c148877116acdd2716b874"></span>std::enable_if&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter2&gt;::type&gt;::type <code class="descname">uninitialized_copy_n</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, Size <em>count</em>, FwdIter2 <em>dest</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v120uninitialized_copy_nERR8ExPolicy8FwdIter14Size8FwdIter2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the elements in the range [first, first + count), starting from first and proceeding to first + count - 1., to another range beginning at dest. If an exception is thrown during the copy operation, the function has no effects.</p>
<p><p>The assignments in the parallel </p>
<em>uninitialized_copy_n</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>count</em> assignments, if count &gt; 0, no assignments otherwise.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Size</span></code>: The type of the argument specifying the number of elements to apply <em>f</em> to. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of a forward iterator.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">count</span></code>: Refers to the number of elements starting at <em>first</em> the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>uninitialized_copy_n</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>uninitialized_copy_n</em> algorithm returns a <em>hpx::future&lt;FwdIter2&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter2</em> otherwise. The <em>uninitialized_copy_n</em> algorithm returns the output iterator to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v131uninitialized_default_constructERR8ExPolicy7FwdIter7FwdIter">
<span id="_CPPv2N3hpx8parallel2v131uninitialized_default_constructERR8ExPolicy7FwdIter7FwdIter"></span><span id="hpx::parallel::v1::uninitialized_default_construct__ExPolicyRR.FwdIter.FwdIter"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a0d3350b1ae15721218ff2578988fb3f6"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy&gt;::type <code class="descname">uninitialized_default_construct</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v131uninitialized_default_constructERR8ExPolicy7FwdIter7FwdIter" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructs objects of type typename iterator_traits&lt;ForwardIt&gt;::value_type in the uninitialized storage designated by the range [first, last) by default-initialization. If an exception is thrown during the initialization, the function has no effects.</p>
<p><p>The assignments in the parallel </p>
<em>uninitialized_default_construct</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>last</em> - <em>first</em> assignments.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>uninitialized_default_construct</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>uninitialized_default_construct</em> algorithm returns a <em>hpx::future&lt;void&gt;</em>, if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>void</em> otherwise. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v133uninitialized_default_construct_nERR8ExPolicy7FwdIter4Size">
<span id="_CPPv2N3hpx8parallel2v133uninitialized_default_construct_nERR8ExPolicy7FwdIter4Size"></span><span id="hpx::parallel::v1::uninitialized_default_construct_n__ExPolicyRR.FwdIter.Size"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> Size&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a2090d59706bbdecf6463dc8419d94d7b"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type <code class="descname">uninitialized_default_construct_n</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, Size <em>count</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v133uninitialized_default_construct_nERR8ExPolicy7FwdIter4Size" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructs objects of type typename iterator_traits&lt;ForwardIt&gt;::value_type in the uninitialized storage designated by the range [first, first + count) by default-initialization. If an exception is thrown during the initialization, the function has no effects.</p>
<p><p>The assignments in the parallel </p>
<em>uninitialized_default_construct_n</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>count</em> assignments, if count &gt; 0, no assignments otherwise.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Size</span></code>: The type of the argument specifying the number of elements to apply <em>f</em> to.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">count</span></code>: Refers to the number of elements starting at <em>first</em> the algorithm will be applied to.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>uninitialized_default_construct_n</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>uninitialized_default_construct_n</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter</em> otherwise. The <em>uninitialized_default_construct_n</em> algorithm returns the iterator to the element in the source range, one past the last element constructed. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v118uninitialized_fillERR8ExPolicy7FwdIter7FwdIterR1T">
<span id="_CPPv2N3hpx8parallel2v118uninitialized_fillERR8ExPolicy7FwdIter7FwdIterR1T"></span><span id="hpx::parallel::v1::uninitialized_fill__ExPolicyRR.FwdIter.FwdIter.TCR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> T&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a701ffa8fa1e317359d0d67afd73b865d"></span>std::enable_if&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy&gt;::type&gt;::type <code class="descname">uninitialized_fill</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, T <em class="property">const</em> &amp;<em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v118uninitialized_fillERR8ExPolicy7FwdIter7FwdIterR1T" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the given <em>value</em> to an uninitialized memory area, defined by the range [first, last). If an exception is thrown during the initialization, the function has no effects.</p>
<p><p>The initializations in the parallel </p>
<em>uninitialized_fill</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Linear in the distance between <em>first</em> and <em>last</em> </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the value to be assigned (deduced).</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">value</span></code>: The value to be assigned.</li>
</ul>
</dd>
</dl>
</p>
<p>The initializations in the parallel <em>uninitialized_fill</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>uninitialized_fill</em> algorithm returns a <em>hpx::future&lt;void&gt;</em>, if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns nothing otherwise. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v120uninitialized_fill_nERR8ExPolicy7FwdIter4SizeR1T">
<span id="_CPPv2N3hpx8parallel2v120uninitialized_fill_nERR8ExPolicy7FwdIter4SizeR1T"></span><span id="hpx::parallel::v1::uninitialized_fill_n__ExPolicyRR.FwdIter.Size.TCR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> Size, <em class="property">typename</em> T&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a6fd7b303fbd92ff86b28eeed710ab5a7"></span>std::enable_if&lt;<a class="reference internal" href="#_CPPv3N3hpx8parallel9executionE" title="hpx::parallel::execution">execution</a>::<a class="reference internal" href="#_CPPv3N3hpx8parallel9execution19is_execution_policyE" title="hpx::parallel::execution::is_execution_policy">is_execution_policy</a>&lt;ExPolicy&gt;::value, <em class="property">typename</em> <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy&gt;::type&gt;::type <code class="descname">uninitialized_fill_n</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, Size <em>count</em>, T <em class="property">const</em> &amp;<em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v120uninitialized_fill_nERR8ExPolicy7FwdIter4SizeR1T" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the given <em>value</em> value to the first count elements in an uninitialized memory area beginning at first. If an exception is thrown during the initialization, the function has no effects.</p>
<p><p>The initializations in the parallel </p>
<em>uninitialized_fill_n</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>count</em> assignments, if count &gt; 0, no assignments otherwise.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of a forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Size</span></code>: The type of the argument specifying the number of elements to apply <em>f</em> to. </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the value to be assigned (deduced).</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">count</span></code>: Refers to the number of elements starting at <em>first</em> the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">value</span></code>: The value to be assigned.</li>
</ul>
</dd>
</dl>
</p>
<p>The initializations in the parallel <em>uninitialized_fill_n</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>uninitialized_fill_n</em> algorithm returns a <em>hpx::future&lt;void&gt;</em>, if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns nothing otherwise. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v118uninitialized_moveERR8ExPolicy8FwdIter18FwdIter18FwdIter2">
<span id="_CPPv2N3hpx8parallel2v118uninitialized_moveERR8ExPolicy8FwdIter18FwdIter18FwdIter2"></span><span id="hpx::parallel::v1::uninitialized_move__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a58724c8d012c1ffe714681f0ed0661cd"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter2&gt;::type <code class="descname">uninitialized_move</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, FwdIter1 <em>last</em>, FwdIter2 <em>dest</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v118uninitialized_moveERR8ExPolicy8FwdIter18FwdIter18FwdIter2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Moves the elements in the range, defined by [first, last), to an uninitialized memory area beginning at <em>dest</em>. If an exception is thrown during the initialization, some objects in [first, last) are left in a valid but unspecified state.</p>
<p><p>The assignments in the parallel </p>
<em>uninitialized_move</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>last</em> - <em>first</em> move operations.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of a forward iterator.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>uninitialized_move</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>uninitialized_move</em> algorithm returns a <em>hpx::future&lt;FwdIter2&gt;</em>, if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter2</em> otherwise. The <em>uninitialized_move</em> algorithm returns the output iterator to the element in the destination range, one past the last element moved. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v120uninitialized_move_nERR8ExPolicy8FwdIter14Size8FwdIter2">
<span id="_CPPv2N3hpx8parallel2v120uninitialized_move_nERR8ExPolicy8FwdIter14Size8FwdIter2"></span><span id="hpx::parallel::v1::uninitialized_move_n__ExPolicyRR.FwdIter1.Size.FwdIter2"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> Size, <em class="property">typename</em> FwdIter2&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a3fcd3f40742c12956fb8e9650a121a92"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::in<span class="sig-paren">(</span>FwdIter1<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>FwdIter2<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">uninitialized_move_n</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, Size <em>count</em>, FwdIter2 <em>dest</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v120uninitialized_move_nERR8ExPolicy8FwdIter14Size8FwdIter2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Moves the elements in the range [first, first + count), starting from first and proceeding to first + count - 1., to another range beginning at dest. If an exception is thrown during the initialization, some objects in [first, first + count) are left in a valid but unspecified state.</p>
<p><p>The assignments in the parallel </p>
<em>uninitialized_move_n</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>count</em> movements, if count &gt; 0, no move operations otherwise.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Size</span></code>: The type of the argument specifying the number of elements to apply <em>f</em> to. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of a forward iterator.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">count</span></code>: Refers to the number of elements starting at <em>first</em> the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>uninitialized_move_n</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>uninitialized_move_n</em> algorithm returns a <em>hpx::future&lt;std::pair&lt;FwdIter1, FwdIter2&gt;&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>std::pair&lt;FwdIter1, FwdIter2&gt;</em> otherwise. The <em>uninitialized_move_n</em> algorithm returns the pair of the input iterator to the element past in the source range and an output iterator to the element in the destination range, one past the last element moved. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v129uninitialized_value_constructERR8ExPolicy7FwdIter7FwdIter">
<span id="_CPPv2N3hpx8parallel2v129uninitialized_value_constructERR8ExPolicy7FwdIter7FwdIter"></span><span id="hpx::parallel::v1::uninitialized_value_construct__ExPolicyRR.FwdIter.FwdIter"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a30a4fcff72d61a5c69d24d1982d6b2b4"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy&gt;::type <code class="descname">uninitialized_value_construct</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v129uninitialized_value_constructERR8ExPolicy7FwdIter7FwdIter" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructs objects of type typename iterator_traits&lt;ForwardIt&gt;::value_type in the uninitialized storage designated by the range [first, last) by default-initialization. If an exception is thrown during the initialization, the function has no effects.</p>
<p><p>The assignments in the parallel </p>
<em>uninitialized_value_construct</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>last</em> - <em>first</em> assignments.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>uninitialized_value_construct</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>uninitialized_value_construct</em> algorithm returns a <em>hpx::future&lt;void&gt;</em>, if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>void</em> otherwise. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v131uninitialized_value_construct_nERR8ExPolicy7FwdIter4Size">
<span id="_CPPv2N3hpx8parallel2v131uninitialized_value_construct_nERR8ExPolicy7FwdIter4Size"></span><span id="hpx::parallel::v1::uninitialized_value_construct_n__ExPolicyRR.FwdIter.Size"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> Size&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a26fb2b43578429cf5bcf837fe4be24cc"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type <code class="descname">uninitialized_value_construct_n</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, Size <em>count</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v131uninitialized_value_construct_nERR8ExPolicy7FwdIter4Size" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructs objects of type typename iterator_traits&lt;ForwardIt&gt;::value_type in the uninitialized storage designated by the range [first, first + count) by default-initialization. If an exception is thrown during the initialization, the function has no effects.</p>
<p><p>The assignments in the parallel </p>
<em>uninitialized_value_construct_n</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>count</em> assignments, if count &gt; 0, no assignments otherwise.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Size</span></code>: The type of the argument specifying the number of elements to apply <em>f</em> to.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">count</span></code>: Refers to the number of elements starting at <em>first</em> the algorithm will be applied to.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>uninitialized_value_construct_n</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>uninitialized_value_construct_n</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter</em> otherwise. The <em>uninitialized_value_construct_n</em> algorithm returns the iterator to the element in the source range, one past the last element constructed. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v16uniqueERR8ExPolicy7FwdIter7FwdIterRR4PredRR4Proj">
<span id="_CPPv2N3hpx8parallel2v16uniqueERR8ExPolicy7FwdIter7FwdIterRR4PredRR4Proj"></span><span id="hpx::parallel::v1::unique__ExPolicyRR.FwdIter.FwdIter.PredRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter, <em class="property">typename</em> Pred = detail::equal_to, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1ae64d84bb7aed7c2381b1fd0e10b7018e"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, FwdIter&gt;::type <code class="descname">unique</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter <em>first</em>, FwdIter <em>last</em>, Pred &amp;&amp;<em>pred</em> = Pred(), Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v16uniqueERR8ExPolicy7FwdIter7FwdIterRR4PredRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Eliminates all but the first element from every consecutive group of equivalent elements from the range [first, last) and returns a past-the-end iterator for the new logical end of the range.</p>
<p><p>The assignments in the parallel </p>
<em>unique</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs not more than <em>last</em> - <em>first</em> assignments, exactly <em>last</em> - <em>first</em> - 1 applications of the predicate <em>pred</em> and no more than twice as many applications of the projection <em>proj</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>unique</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::equal_to&lt;&gt; </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">pred</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). This is an binary predicate which returns <em>true</em> for the required elements. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type2</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> and <em>Type2</em> must be such that objects of types <em>FwdIter</em> can be dereferenced and then implicitly converted to both <em>Type1</em> and <em>Type2</em> </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>unique</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>unique</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter</em> otherwise. The <em>unique</em> algorithm returns the iterator to the new end of the range. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v111unique_copyERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR4PredRR4Proj">
<span id="_CPPv2N3hpx8parallel2v111unique_copyERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR4PredRR4Proj"></span><span id="hpx::parallel::v1::unique_copy__ExPolicyRR.FwdIter1.FwdIter1.FwdIter2.PredRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> FwdIter1, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> Pred = detail::equal_to, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1aabe3817149521a1a7e7384dba5bd68b9"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::in<span class="sig-paren">(</span>FwdIter1<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>FwdIter2<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">unique_copy</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, FwdIter1 <em>first</em>, FwdIter1 <em>last</em>, FwdIter2 <em>dest</em>, Pred &amp;&amp;<em>pred</em> = Pred(), Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v111unique_copyERR8ExPolicy8FwdIter18FwdIter18FwdIter2RR4PredRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the elements from the range [first, last), to another range beginning at <em>dest</em> in such a way that there are no consecutive equal elements. Only the first element of each group of equal elements is copied.</p>
<p><p>The assignments in the parallel </p>
<em>unique_copy</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs not more than <em>last</em> - <em>first</em> assignments, exactly <em>last</em> - <em>first</em> - 1 applications of the predicate <em>pred</em> and no more than twice as many applications of the projection <em>proj</em> </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter1</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>unique_copy</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::equal_to&lt;&gt; </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">pred</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). This is an binary predicate which returns <em>true</em> for the required elements. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter1</em> can be dereferenced and then implicitly converted to <em>Type</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>unique_copy</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>unique_copy</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</em> &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</em> otherwise. The <em>unique_copy</em> algorithm returns the pair of the source iterator to <em>last</em>, and the destination iterator to the end of the <em>dest</em> range. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v17none_ofERR8ExPolicyRR3RngRR1FRR4Proj">
<span id="_CPPv2N3hpx8parallel2v17none_ofERR8ExPolicyRR3RngRR1FRR4Proj"></span><span id="hpx::parallel::v1::none_of__ExPolicyRR.RngRR.FRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> F, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1ab8adfd5bd843e5e3be75695e94ea8a7e"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, bool&gt;::type <code class="descname">none_of</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, F &amp;&amp;<em>f</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v17none_ofERR8ExPolicyRR3RngRR1FRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Checks if unary predicate <em>f</em> returns true for no elements in the range <em>rng</em>.</p>
<p><p>The application of function objects in parallel algorithm invoked with an execution policy object of type </p>
<em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: At most std::distance(begin(rng), end(rng)) applications of the predicate <em>f</em> </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>none_of</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter</em> can be dereferenced and then implicitly converted to Type. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>none_of</em> algorithm returns a <em>hpx::future&lt;bool&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>bool</em> otherwise. The <em>none_of</em> algorithm returns true if the unary predicate <em>f</em> returns true for no elements in the range, false otherwise. It returns true if the range is empty. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v16any_ofERR8ExPolicyRR3RngRR1FRR4Proj">
<span id="_CPPv2N3hpx8parallel2v16any_ofERR8ExPolicyRR3RngRR1FRR4Proj"></span><span id="hpx::parallel::v1::any_of__ExPolicyRR.RngRR.FRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> F, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a645a8f385208732e17b7fd0edeff88b4"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, bool&gt;::type <code class="descname">any_of</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, F &amp;&amp;<em>f</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v16any_ofERR8ExPolicyRR3RngRR1FRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Checks if unary predicate <em>f</em> returns true for at least one element in the range <em>rng</em>.</p>
<p><p>The application of function objects in parallel algorithm invoked with an execution policy object of type </p>
<em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: At most std::distance(begin(rng), end(rng)) applications of the predicate <em>f</em> </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>none_of</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter</em> can be dereferenced and then implicitly converted to Type. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>any_of</em> algorithm returns a <em>hpx::future&lt;bool&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>bool</em> otherwise. The <em>any_of</em> algorithm returns true if the unary predicate <em>f</em> returns true for at least one element in the range, false otherwise. It returns false if the range is empty. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v16all_ofERR8ExPolicyRR3RngRR1FRR4Proj">
<span id="_CPPv2N3hpx8parallel2v16all_ofERR8ExPolicyRR3RngRR1FRR4Proj"></span><span id="hpx::parallel::v1::all_of__ExPolicyRR.RngRR.FRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> F, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1ab9145664976f55bb15fa51d275d3d3c5"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, bool&gt;::type <code class="descname">all_of</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, F &amp;&amp;<em>f</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v16all_ofERR8ExPolicyRR3RngRR1FRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Checks if unary predicate <em>f</em> returns true for all elements in the range <em>rng</em>.</p>
<p><p>The application of function objects in parallel algorithm invoked with an execution policy object of type </p>
<em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: At most std::distance(begin(rng), end(rng)) applications of the predicate <em>f</em> </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>none_of</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter</em> can be dereferenced and then implicitly converted to Type. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>all_of</em> algorithm returns a <em>hpx::future&lt;bool&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>bool</em> otherwise. The <em>all_of</em> algorithm returns true if the unary predicate <em>f</em> returns true for all elements in the range, false otherwise. It returns true if the range is empty. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v14copyERR8ExPolicyRR3Rng7OutIter">
<span id="_CPPv2N3hpx8parallel2v14copyERR8ExPolicyRR3Rng7OutIter"></span><span id="hpx::parallel::v1::copy__ExPolicyRR.RngRR.OutIter"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> OutIter&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1ae711203bbd4bdcb06d3bfbb43aa4b05c"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::in<span class="sig-paren">(</span><em class="property">typename</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_traits&lt;Rng&gt;::iterator_type<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>OutIter<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">copy</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, OutIter <em>dest</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v14copyERR8ExPolicyRR3Rng7OutIter" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the elements in the range <em>rng</em> to another range beginning at <em>dest</em>.</p>
<p><p>The assignments in the parallel </p>
<em>copy</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly std::distance(begin(rng), end(rng)) assignments.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">OutIter</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an output iterator.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>copy</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>copy</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::in(iterator_t&lt;Rng&gt;)</em>, tag::out(FwdIter2)&gt; &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::in(iterator_t&lt;Rng&gt;)</em>, tag::out(FwdIter2)&gt; otherwise. The <em>copy</em> algorithm returns the pair of the input iterator <em>last</em> and the output iterator to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v17copy_ifERR8ExPolicyRR3Rng7OutIterRR1FRR4Proj">
<span id="_CPPv2N3hpx8parallel2v17copy_ifERR8ExPolicyRR3Rng7OutIterRR1FRR4Proj"></span><span id="hpx::parallel::v1::copy_if__ExPolicyRR.RngRR.OutIter.FRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> OutIter, <em class="property">typename</em> F, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a003196f2c0a0f8406b8e8b641288d34a"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::in<span class="sig-paren">(</span><em class="property">typename</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_traits&lt;Rng&gt;::iterator_type<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>OutIter<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">copy_if</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, OutIter <em>dest</em>, F &amp;&amp;<em>f</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v17copy_ifERR8ExPolicyRR3Rng7OutIterRR1FRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the elements in the range <em>rng</em> to another range beginning at <em>dest</em>. Copies only the elements for which the predicate <em>f</em> returns true. The order of the elements that are not removed is preserved.</p>
<p><p>The assignments in the parallel </p>
<em>copy_if</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs not more than std::distance(begin(rng), end(rng)) assignments, exactly std::distance(begin(rng), end(rng)) applications of the predicate <em>f</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">OutIter</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an output iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>copy_if</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is an unary predicate which returns <em>true</em> for the required elements. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>InIter</em> can be dereferenced and then implicitly converted to Type. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>copy_if</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>copy_if</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::in(iterator_t&lt;Rng&gt;)</em>, tag::out(FwdIter2)&gt; &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::in(iterator_t&lt;Rng&gt;)</em>, tag::out(FwdIter2)&gt; otherwise. The <em>copy_if</em> algorithm returns the pair of the input iterator <em>last</em> and the output iterator to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v15countERR8ExPolicyRR3RngR1TRR4Proj">
<span id="_CPPv2N3hpx8parallel2v15countERR8ExPolicyRR3RngR1TRR4Proj"></span><span id="hpx::parallel::v1::count__ExPolicyRR.RngRR.TCR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> T, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1ac0f28cf5bdcce85ec824a3d5019270f6"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <em class="property">typename</em> std::iterator_traits&lt;<em class="property">typename</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_traits&lt;Rng&gt;::iterator_type&gt;::difference_type&gt;::type <code class="descname">count</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, T <em class="property">const</em> &amp;<em>value</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v15countERR8ExPolicyRR3RngR1TRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the number of elements in the range [first, last) satisfying a specific criteria. This version counts the elements that are equal to the given <em>value</em>.</p>
<p><p>The comparisons in the parallel </p>
<em>count</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>last</em> - <em>first</em> comparisons.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the comparisons. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the value to search for (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">value</span></code>: The value to search for. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The comparisons in the parallel <em>count</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</dd>
<dt><strong>Return</strong></dt>
<dd>The <em>count</em> algorithm returns a <em>hpx::future&lt;difference_type&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>difference_type</em> otherwise (where <em>difference_type</em> is defined by <em>std::iterator_traits&lt;FwdIter&gt;::difference_type</em>. The <em>count</em> algorithm returns the number of elements satisfying the given criteria. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v18count_ifERR8ExPolicyRR3RngRR1FRR4Proj">
<span id="_CPPv2N3hpx8parallel2v18count_ifERR8ExPolicyRR3RngRR1FRR4Proj"></span><span id="hpx::parallel::v1::count_if__ExPolicyRR.RngRR.FRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> F, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1aafeac1e1adb1f843fd06e796504a80b5"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <em class="property">typename</em> std::iterator_traits&lt;<em class="property">typename</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_traits&lt;Rng&gt;::iterator_type&gt;::difference_type&gt;::type <code class="descname">count_if</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, F &amp;&amp;<em>f</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v18count_ifERR8ExPolicyRR3RngRR1FRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the number of elements in the range [first, last) satisfying a specific criteria. This version counts elements for which predicate <em>f</em> returns true.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>last</em> - <em>first</em> applications of the predicate.</dd>
<dt><strong>Note</strong></dt>
<dd>The assignments in the parallel <em>count_if</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread. </dd>
<dt><strong>Note</strong></dt>
<dd>The assignments in the parallel <em>count_if</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</dd>
<dt><strong>Return</strong></dt>
<dd>The <em>count_if</em> algorithm returns <em>hpx::future&lt;difference_type&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>difference_type</em> otherwise (where <em>difference_type</em> is defined by <em>std::iterator_traits&lt;FwdIter&gt;::difference_type</em>. The <em>count</em> algorithm returns the number of elements satisfying the given criteria. </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the comparisons. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>count_if</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is an unary predicate which returns <em>true</em> for the required elements. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter</em> can be dereferenced and then implicitly converted to Type. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v14fillERR8ExPolicyRR3Rng1T">
<span id="_CPPv2N3hpx8parallel2v14fillERR8ExPolicyRR3Rng1T"></span><span id="hpx::parallel::v1::fill__ExPolicyRR.RngRR.T"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> T&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a84a9d0b04c5eaffaf3debbf7b5a2391f"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy&gt;::type <code class="descname">fill</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, T <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v14fillERR8ExPolicyRR3Rng1T" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assigns the given value to the elements in the range [first, last).</p>
<p><p>The comparisons in the parallel </p>
<em>fill</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>last</em> - <em>first</em> assignments.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the value to be assigned (deduced).</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">value</span></code>: The value to be assigned.</li>
</ul>
</dd>
</dl>
</p>
<p>The comparisons in the parallel <em>fill</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>fill</em> algorithm returns a <em>hpx::future&lt;void&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>difference_type</em> otherwise (where <em>difference_type</em> is defined by <em>void</em>. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v16fill_nERR8ExPolicyR3Rng4Size1T">
<span id="_CPPv2N3hpx8parallel2v16fill_nERR8ExPolicyR3Rng4Size1T"></span><span id="hpx::parallel::v1::fill_n__ExPolicyRR.RngR.Size.T"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> Size, <em class="property">typename</em> T&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1ab8715f3fb36d3ce5c1505ba621b9c8ac"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <em class="property">typename</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_traits&lt;Rng&gt;::iterator_type&gt;::type <code class="descname">fill_n</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;<em>rng</em>, Size <em>count</em>, T <em>value</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v16fill_nERR8ExPolicyR3Rng4Size1T" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assigns the given value value to the first count elements in the range beginning at first if count &gt; 0. Does nothing otherwise.</p>
<p><p>The comparisons in the parallel </p>
<em>fill_n</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>count</em> assignments, for count &gt; 0.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Size</span></code>: The type of the argument specifying the number of elements to apply <em>f</em> to. </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the value to be assigned (deduced).</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">count</span></code>: Refers to the number of elements starting at <em>first</em> the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">value</span></code>: The value to be assigned.</li>
</ul>
</dd>
</dl>
</p>
<p>The comparisons in the parallel <em>fill_n</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>fill_n</em> algorithm returns a <em>hpx::future&lt;void&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>difference_type</em> otherwise (where <em>difference_type</em> is defined by <em>void</em>. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v18find_endERR8ExPolicyRR3RngRR4Rng2RR4PredRR4Proj">
<span id="_CPPv2N3hpx8parallel2v18find_endERR8ExPolicyRR3RngRR4Rng2RR4PredRR4Proj"></span><span id="hpx::parallel::v1::find_end__ExPolicyRR.RngRR.Rng2RR.PredRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> Rng2, <em class="property">typename</em> Pred = detail::equal_to, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1ac1b769fadbb193028831e2f365a7c73a"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <em class="property">typename</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng&gt;::type&gt;::type <code class="descname">find_end</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, Rng2 &amp;&amp;<em>rng2</em>, Pred &amp;&amp;<em>op</em> = Pred(), Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v18find_endERR8ExPolicyRR3RngRR4Rng2RR4PredRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the last subsequence of elements <em>rng2</em> found in the range <em>rng</em> using the given predicate <em>f</em> to compare elements.</p>
<p><p>The comparison operations in the parallel </p>
<em>find_end</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: at most S*(N-S+1) comparisons where <em>S</em> = distance(begin(rng2), end(rng2)) and <em>N</em> = distance(begin(rng), end(rng)).</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the first source range (deduced). The iterators extracted from this range type must meet the requirements of a forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng2</span></code>: The type of the second source range (deduced). The iterators extracted from this range type must meet the requirements of a forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <em>replace</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::equal_to&lt;&gt; </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the first sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng2</span></code>: Refers to the second sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">op</span></code>: The binary predicate which returns <em>true</em> if the elements should be treated as equal. The signature should be equivalent to the following: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type2</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> and <em>Type2</em> must be such that objects of types <em>iterator_t&lt;Rng&gt;</em> and <em>iterator_t&lt;Rng2&gt;</em> can be dereferenced and then implicitly converted to <em>Type1</em> and <em>Type2</em> respectively. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of type dereferenced <em>iterator_t&lt;Rng&gt;</em> and dereferenced <em>iterator_t&lt;Rng2&gt;</em> as a projection operation before the function <em>op</em> is invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The comparison operations in the parallel <em>find_end</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><p>This overload of </p>
<em>find_end</em> is available if the user decides to provide the algorithm their own predicate <em>op</em>. <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>find_end</em> algorithm returns a <em>hpx::future&lt;iterator_t&lt;Rng&gt;</em> &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>iterator_t&lt;Rng&gt;</em> otherwise. The <em>find_end</em> algorithm returns an iterator to the beginning of the last subsequence <em>rng2</em> in range <em>rng</em>. If the length of the subsequence <em>rng2</em> is greater than the length of the range <em>rng</em>, <em>end(rng)</em> is returned. Additionally if the size of the subsequence is empty or no subsequence is found, <em>end(rng)</em> is also returned.</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v113find_first_ofERR8ExPolicyRR4Rng1RR4Rng2RR4PredRR5Proj1RR5Proj2">
<span id="_CPPv2N3hpx8parallel2v113find_first_ofERR8ExPolicyRR4Rng1RR4Rng2RR4PredRR5Proj1RR5Proj2"></span><span id="hpx::parallel::v1::find_first_of__ExPolicyRR.Rng1RR.Rng2RR.PredRR.Proj1RR.Proj2RR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng1, <em class="property">typename</em> Rng2, <em class="property">typename</em> Pred = detail::equal_to, <em class="property">typename</em> Proj1 = util::projection_identity, <em class="property">typename</em> Proj2 = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1afc111034ef00e843b6dbe8c436c22a69"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <em class="property">typename</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng1&gt;::type&gt;::type <code class="descname">find_first_of</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng1 &amp;&amp;<em>rng1</em>, Rng2 &amp;&amp;<em>rng2</em>, Pred &amp;&amp;<em>op</em> = Pred(), Proj1 &amp;&amp;<em>proj1</em> = Proj1(), Proj2 &amp;&amp;<em>proj2</em> = Proj2()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v113find_first_ofERR8ExPolicyRR4Rng1RR4Rng2RR4PredRR5Proj1RR5Proj2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Searches the range <em>rng1</em> for any elements in the range <em>rng2</em>. Uses binary predicate <em>p</em> to compare elements</p>
<p><p>The comparison operations in the parallel </p>
<em>find_first_of</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: at most (S*N) comparisons where <em>S</em> = distance(begin(rng2), end(rng2)) and <em>N</em> = distance(begin(rng1), end(rng1)).</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng1</span></code>: The type of the first source range (deduced). The iterators extracted from this range type must meet the requirements of a forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng2</span></code>: The type of the second source range (deduced). The iterators extracted from this range type must meet the requirements of a forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <em>replace</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::equal_to&lt;&gt; </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj1</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> and is applied to the elements in <em>rng1</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj2</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> and is applied to the elements in <em>rng2</em>.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng1</span></code>: Refers to the first sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng2</span></code>: Refers to the second sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">op</span></code>: The binary predicate which returns <em>true</em> if the elements should be treated as equal. The signature should be equivalent to the following: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type2</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> and <em>Type2</em> must be such that objects of types <em>iterator_t&lt;Rng1&gt;</em> and <em>iterator_t&lt;Rng2&gt;</em> can be dereferenced and then implicitly converted to <em>Type1</em> and <em>Type2</em> respectively. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj1</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of type dereferenced <em>iterator_t&lt;Rng1&gt;</em> before the function <em>op</em> is invoked. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj2</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of type dereferenced <em>iterator_t&lt;Rng2&gt;</em> before the function <em>op</em> is invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The comparison operations in the parallel <em>find_first_of</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><p>This overload of </p>
<em>find_first_of</em> is available if the user decides to provide the algorithm their own predicate <em>op</em>. <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>find_end</em> algorithm returns a <em>hpx::future&lt;iterator_t&lt;Rng1&gt;</em> &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>iterator_t&lt;Rng1&gt;</em> otherwise. The <em>find_first_of</em> algorithm returns an iterator to the first element in the range <em>rng1</em> that is equal to an element from the range <em>rng2</em>. If the length of the subsequence <em>rng2</em> is greater than the length of the range <em>rng1</em>, <em>end(rng1)</em> is returned. Additionally if the size of the subsequence is empty or no subsequence is found, <em>end(rng1)</em> is also returned.</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v18for_eachERR8ExPolicyRR3RngRR1FRR4Proj">
<span id="_CPPv2N3hpx8parallel2v18for_eachERR8ExPolicyRR3RngRR1FRR4Proj"></span><span id="hpx::parallel::v1::for_each__ExPolicyRR.RngRR.FRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> F, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a1a9ff31fac164930e57da0f83184aafa"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <em class="property">typename</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng&gt;::type&gt;::type <code class="descname">for_each</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, F &amp;&amp;<em>f</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v18for_eachERR8ExPolicyRR3RngRR1FRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Applies <em>f</em> to the result of dereferencing every iterator in the given range <em>rng</em>.</p>
<p><p>If </p>
<em>f</em> returns a result, the result is ignored.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Applies <em>f</em> exactly <em>size(rng)</em> times.</dd>
</dl>
</p>
<p>If the type of <em>first</em> satisfies the requirements of a mutable iterator, <em>f</em> may apply non-constant functions through the dereferenced iterator.</p>
<p>Unlike its sequential form, the parallel overload of <em>for_each</em> does not return a copy of its <em>Function</em> parameter, since parallelization may not permit efficient state accumulation.</p>
<p><p>The application of function objects in parallel algorithm invoked with an execution policy object of type </p>
<em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>for_each</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">ignored</span><span class="o">&gt;</span> <span class="n">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;. The type </p>
<em>Type</em> must be such that an object of type <em>InIter</em> can be dereferenced and then implicitly converted to Type. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>for_each</em> algorithm returns a <em>hpx::future&lt;InIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>InIter</em> otherwise. It returns <em>last</em>. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v18generateERR8ExPolicyRR3RngRR1F">
<span id="_CPPv2N3hpx8parallel2v18generateERR8ExPolicyRR3RngRR1F"></span><span id="hpx::parallel::v1::generate__ExPolicyRR.RngRR.FRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> F&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1aed290ad93f522e69befe1628b71f4e8d"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <em class="property">typename</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng&gt;::type&gt;::type <code class="descname">generate</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, F &amp;&amp;<em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v18generateERR8ExPolicyRR3RngRR1F" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Assign each element in range [first, last) a value generated by the given function object f</p>
<p><p>The assignments in the parallel </p>
<em>generate</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Exactly <em>distance(first, last)</em> invocations of <em>f</em> and assignments.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>equal</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: generator function that will be called. signature of function should be equivalent to the following: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ret</span> <span class="nf">fun</span><span class="p">();</span>
</pre></div>
</div>
 <p> The type </p>
<em>Ret</em> must be such that an object of type <em>FwdIter</em> can be dereferenced and assigned a value of type <em>Ret</em>.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>generate</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>replace_if</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter</em> otherwise. It returns <em>last</em>. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v17is_heapERR8ExPolicyRR3RngRR4CompRR4Proj">
<span id="_CPPv2N3hpx8parallel2v17is_heapERR8ExPolicyRR3RngRR4CompRR4Proj"></span><span id="hpx::parallel::v1::is_heap__ExPolicyRR.RngRR.CompRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> Comp = detail::less, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1aba109aa6f95bc25e3613e87749385d1a"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, bool&gt;::type <code class="descname">is_heap</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, Comp &amp;&amp;<em>comp</em> = Comp(), Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v17is_heapERR8ExPolicyRR3RngRR4CompRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns whether the range is max heap. That is, true if the range is max heap, false otherwise. The function uses the given comparison function object <em>comp</em> (defaults to using operator&lt;()).</p>
<p><em>comp</em> has to induce a strict weak ordering on the values.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs at most N applications of the comparison <em>comp</em>, at most 2 * N applications of the projection <em>proj</em>, where N = last - first.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an random access iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Comp</span></code>: The type of the function/function object to use (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">comp</span></code>: <em>comp</em> is a callable object. The return value of the INVOKE operation applied to an object of type <em>Comp</em>, when contextually converted to bool, yields true if the first argument of the call is less than the second, and false otherwise. It is assumed that comp will not apply any non-constant function through the dereferenced iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>is_heap</em> algorithm returns a <em>hpx::future&lt;bool&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>bool</em> otherwise. The <em>is_heap</em> algorithm returns whether the range is max heap. That is, true if the range is max heap, false otherwise. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v113is_heap_untilERR8ExPolicyRR3RngRR4CompRR4Proj">
<span id="_CPPv2N3hpx8parallel2v113is_heap_untilERR8ExPolicyRR3RngRR4CompRR4Proj"></span><span id="hpx::parallel::v1::is_heap_until__ExPolicyRR.RngRR.CompRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> Comp = detail::less, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1adea22d5ed08959243c4d1ee451912da4"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <em class="property">typename</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng&gt;::type&gt;::type <code class="descname">is_heap_until</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, Comp &amp;&amp;<em>comp</em> = Comp(), Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v113is_heap_untilERR8ExPolicyRR3RngRR4CompRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns the upper bound of the largest range beginning at <em>first</em> which is a max heap. That is, the last iterator <em>it</em> for which range [first, it) is a max heap. The function uses the given comparison function object <em>comp</em> (defaults to using operator&lt;()).</p>
<p><em>comp</em> has to induce a strict weak ordering on the values.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs at most N applications of the comparison <em>comp</em>, at most 2 * N applications of the projection <em>proj</em>, where N = last - first.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an random access iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Comp</span></code>: The type of the function/function object to use (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">comp</span></code>: <em>comp</em> is a callable object. The return value of the INVOKE operation applied to an object of type <em>Comp</em>, when contextually converted to bool, yields true if the first argument of the call is less than the second, and false otherwise. It is assumed that comp will not apply any non-constant function through the dereferenced iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>is_heap_until</em> algorithm returns a <em>hpx::future&lt;RandIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>RandIter</em> otherwise. The <em>is_heap_until</em> algorithm returns the upper bound of the largest range beginning at first which is a max heap. That is, the last iterator <em>it</em> for which range [first, it) is a max heap. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v15mergeERR8ExPolicyRR4Rng1RR4Rng29RandIter3RR4CompRR5Proj1RR5Proj2">
<span id="_CPPv2N3hpx8parallel2v15mergeERR8ExPolicyRR4Rng1RR4Rng29RandIter3RR4CompRR5Proj1RR5Proj2"></span><span id="hpx::parallel::v1::merge__ExPolicyRR.Rng1RR.Rng2RR.RandIter3.CompRR.Proj1RR.Proj2RR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng1, <em class="property">typename</em> Rng2, <em class="property">typename</em> RandIter3, <em class="property">typename</em> Comp = detail::less, <em class="property">typename</em> Proj1 = util::projection_identity, <em class="property">typename</em> Proj2 = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1ade9fe7d0b22da8edbf79f0180e956198"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_tuple&lt;tag::in1<span class="sig-paren">(</span><em class="property">typename</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng1&gt;::type<span class="sig-paren">)</span>, tag::in2<span class="sig-paren">(</span><em class="property">typename</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng2&gt;::type<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>RandIter3<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">merge</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng1 &amp;&amp;<em>rng1</em>, Rng2 &amp;&amp;<em>rng2</em>, RandIter3 <em>dest</em>, Comp &amp;&amp;<em>comp</em> = Comp(), Proj1 &amp;&amp;<em>proj1</em> = Proj1(), Proj2 &amp;&amp;<em>proj2</em> = Proj2()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v15mergeERR8ExPolicyRR4Rng1RR4Rng29RandIter3RR4CompRR5Proj1RR5Proj2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Merges two sorted ranges [first1, last1) and [first2, last2) into one sorted range beginning at <em>dest</em>. The order of equivalent elements in the each of original two ranges is preserved. For equivalent elements in the original two ranges, the elements from the first range precede the elements from the second range. The destination range cannot overlap with either of the input ranges.</p>
<p><p>The assignments in the parallel </p>
<em>merge</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs O(std::distance(first1, last1) + std::distance(first2, last2)) applications of the comparison <em>comp</em> and the each projection.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng1</span></code>: The type of the first source range used (deduced). The iterators extracted from this range type must meet the requirements of an random access iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng2</span></code>: The type of the second source range used (deduced). The iterators extracted from this range type must meet the requirements of an random access iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">RandIter3</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an random access iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Comp</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>merge</em> requires <em>Comp</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::less&lt;&gt; </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj1</span></code>: The type of an optional projection function to be used for elements of the first range. This defaults to <em>util::projection_identity</em> </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj2</span></code>: The type of an optional projection function to be used for elements of the second range. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng1</span></code>: Refers to the first range of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng2</span></code>: Refers to the second range of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">comp</span></code>: <em>comp</em> is a callable object which returns true if the first argument is less than the second, and false otherwise. The signature of this comparison should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">comp</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type2</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> and <em>Type2</em> must be such that objects of types <em>RandIter1</em> and <em>RandIter2</em> can be dereferenced and then implicitly converted to both <em>Type1</em> and <em>Type2</em> </li>
<li><code class="docutils literal notranslate"><span class="pre">proj1</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of the first range as a projection operation before the actual comparison <em>comp</em> is invoked. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj2</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of the second range as a projection operation before the actual comparison <em>comp</em> is invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>merge</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>merge</em> algorithm returns a <em>hpx::future&lt;tagged_tuple&lt;tag::in1(RandIter1), tag::in2(RandIter2), tag::out(RandIter3)&gt;</em> &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>tagged_tuple&lt;tag::in1(RandIter1), tag::in2(RandIter2), tag::out(RandIter3)&gt;</em> otherwise. The <em>merge</em> algorithm returns the tuple of the source iterator <em>last1</em>, the source iterator <em>last2</em>, the destination iterator to the end of the <em>dest</em> range. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v113inplace_mergeERR8ExPolicyRR3Rng8RandIterRR4CompRR4Proj">
<span id="_CPPv2N3hpx8parallel2v113inplace_mergeERR8ExPolicyRR3Rng8RandIterRR4CompRR4Proj"></span><span id="hpx::parallel::v1::inplace_merge__ExPolicyRR.RngRR.RandIter.CompRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> RandIter, <em class="property">typename</em> Comp = detail::less, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1aafbed5cc1d8d966f97e923fbd8f71100"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, RandIter&gt;::type <code class="descname">inplace_merge</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, RandIter <em>middle</em>, Comp &amp;&amp;<em>comp</em> = Comp(), Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v113inplace_mergeERR8ExPolicyRR3Rng8RandIterRR4CompRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Merges two consecutive sorted ranges [first, middle) and [middle, last) into one sorted range [first, last). The order of equivalent elements in the each of original two ranges is preserved. For equivalent elements in the original two ranges, the elements from the first range precede the elements from the second range.</p>
<p><p>The assignments in the parallel </p>
<em>inplace_merge</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs O(std::distance(first, last)) applications of the comparison <em>comp</em> and the each projection.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an random access iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">RandIter</span></code>: The type of the source iterators used (deduced). This iterator type must meet the requirements of an random access iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Comp</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>inplace_merge</em> requires <em>Comp</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::less&lt;&gt; </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the range of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">middle</span></code>: Refers to the end of the first sorted range and the beginning of the second sorted range the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">comp</span></code>: <em>comp</em> is a callable object which returns true if the first argument is less than the second, and false otherwise. The signature of this comparison should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">comp</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type2</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> and <em>Type2</em> must be such that objects of types <em>RandIter</em> can be dereferenced and then implicitly converted to both <em>Type1</em> and <em>Type2</em> </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>inplace_merge</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>inplace_merge</em> algorithm returns a <em>hpx::future&lt;RandIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>RandIter</em> otherwise. The <em>inplace_merge</em> algorithm returns the source iterator <em>last</em> </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v111min_elementERR8ExPolicyRR3RngRR1FRR4Proj">
<span id="_CPPv2N3hpx8parallel2v111min_elementERR8ExPolicyRR3RngRR1FRR4Proj"></span><span id="hpx::parallel::v1::min_element__ExPolicyRR.RngRR.FRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> Proj = util::projection_identity, <em class="property">typename</em> F = detail::less&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1abed743f0335718718746bf8206a7bcfb"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <em class="property">typename</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_traits&lt;Rng&gt;::iterator_type&gt;::type <code class="descname">min_element</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, F &amp;&amp;<em>f</em> = F(), Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v111min_elementERR8ExPolicyRR3RngRR1FRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Finds the smallest element in the range [first, last) using the given comparison function <em>f</em>.</p>
<p><p>The comparisons in the parallel </p>
<em>min_element</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Exactly <em>max</em>(N-1, 0) comparisons, where N = std::distance(first, last).</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>min_element</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: The binary predicate which returns true if the the left argument is less than the right element. The signature of the predicate function should be equivalent to the following: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type1</em> must be such that objects of type <em>FwdIter</em> can be dereferenced and then implicitly converted to <em>Type1</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The comparisons in the parallel <em>min_element</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>min_element</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter</em> otherwise. The <em>min_element</em> algorithm returns the iterator to the smallest element in the range [first, last). If several elements in the range are equivalent to the smallest element, returns the iterator to the first such element. Returns last if the range is empty. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v111max_elementERR8ExPolicyRR3RngRR1FRR4Proj">
<span id="_CPPv2N3hpx8parallel2v111max_elementERR8ExPolicyRR3RngRR1FRR4Proj"></span><span id="hpx::parallel::v1::max_element__ExPolicyRR.RngRR.FRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> Proj = util::projection_identity, <em class="property">typename</em> F = detail::less&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a319d10722f06d37f5f0f6abd284133b1"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <em class="property">typename</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_traits&lt;Rng&gt;::iterator_type&gt;::type <code class="descname">max_element</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, F &amp;&amp;<em>f</em> = F(), Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v111max_elementERR8ExPolicyRR3RngRR1FRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Finds the greatest element in the range [first, last) using the given comparison function <em>f</em>.</p>
<p><p>The comparisons in the parallel </p>
<em>max_element</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Exactly <em>max</em>(N-1, 0) comparisons, where N = std::distance(first, last).</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>max_element</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: The binary predicate which returns true if the This argument is optional and defaults to std::less. the left argument is less than the right element. The signature of the predicate function should be equivalent to the following: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type1</em> must be such that objects of type <em>FwdIter</em> can be dereferenced and then implicitly converted to <em>Type1</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The comparisons in the parallel <em>max_element</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>max_element</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter</em> otherwise. The <em>max_element</em> algorithm returns the iterator to the smallest element in the range [first, last). If several elements in the range are equivalent to the smallest element, returns the iterator to the first such element. Returns last if the range is empty. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v114minmax_elementERR8ExPolicyRR3RngRR1FRR4Proj">
<span id="_CPPv2N3hpx8parallel2v114minmax_elementERR8ExPolicyRR3RngRR1FRR4Proj"></span><span id="hpx::parallel::v1::minmax_element__ExPolicyRR.RngRR.FRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> Proj = util::projection_identity, <em class="property">typename</em> F = detail::less&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1ad2e21ac895d19b9689a9f7e8dd3b3fb2"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::min<span class="sig-paren">(</span><em class="property">typename</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_traits&lt;Rng&gt;::iterator_type<span class="sig-paren">)</span>, tag::max<span class="sig-paren">(</span><em class="property">typename</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_traits&lt;Rng&gt;::iterator_type<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">minmax_element</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, F &amp;&amp;<em>f</em> = F(), Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v114minmax_elementERR8ExPolicyRR3RngRR1FRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Finds the greatest element in the range [first, last) using the given comparison function <em>f</em>.</p>
<p><p>The comparisons in the parallel </p>
<em>minmax_element</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: At most <em>max</em>(floor(3/2*(N-1)), 0) applications of the predicate, where N = std::distance(first, last).</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>minmax_element</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: The binary predicate which returns true if the the left argument is less than the right element. This argument is optional and defaults to std::less. The signature of the predicate function should be equivalent to the following: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type1</em> must be such that objects of type <em>FwdIter</em> can be dereferenced and then implicitly converted to <em>Type1</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The comparisons in the parallel <em>minmax_element</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>minmax_element</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::min(FwdIter), tag::max(FwdIter)&gt;</em> &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::min(FwdIter), tag::max(FwdIter)&gt;</em> otherwise. The <em>minmax_element</em> algorithm returns a pair consisting of an iterator to the smallest element as the first element and an iterator to the greatest element as the second. Returns std::make_pair(first, first) if the range is empty. If several elements are equivalent to the smallest element, the iterator to the first such element is returned. If several elements are equivalent to the largest element, the iterator to the last such element is returned. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v19partitionERR8ExPolicyRR3RngRR4PredRR4Proj">
<span id="_CPPv2N3hpx8parallel2v19partitionERR8ExPolicyRR3RngRR4PredRR4Proj"></span><span id="hpx::parallel::v1::partition__ExPolicyRR.RngRR.PredRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> Pred, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a096d7cac5f4c00a41f3d1baa2a71ef00"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <em class="property">typename</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng&gt;::type&gt;::type <code class="descname">partition</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, Pred &amp;&amp;<em>pred</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v19partitionERR8ExPolicyRR3RngRR4PredRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Reorders the elements in the range <em>rng</em> in such a way that all elements for which the predicate <em>pred</em> returns true precede the elements for which the predicate <em>pred</em> returns false. Relative order of the elements is not preserved.</p>
<p><p>The assignments in the parallel </p>
<em>partition</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs at most 2 * N swaps, exactly N applications of the predicate and projection, where N = std::distance(begin(rng), end(rng)).</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>partition</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">pred</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by the range <em>rng</em>. This is an unary predicate for partitioning the source iterators. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter</em> can be dereferenced and then implicitly converted to <em>Type</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>partition</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>partition</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>parallel_task_policy</em> and returns <em>FwdIter</em> otherwise. The <em>partition</em> algorithm returns the iterator to the first element of the second group. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v114partition_copyERR8ExPolicyRR3Rng8FwdIter28FwdIter3RR4PredRR4Proj">
<span id="_CPPv2N3hpx8parallel2v114partition_copyERR8ExPolicyRR3Rng8FwdIter28FwdIter3RR4PredRR4Proj"></span><span id="hpx::parallel::v1::partition_copy__ExPolicyRR.RngRR.FwdIter2.FwdIter3.PredRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> FwdIter3, <em class="property">typename</em> Pred, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1aeda6e8aca718703d5e97ad7e0eabc227"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_tuple&lt;tag::in<span class="sig-paren">(</span><em class="property">typename</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng&gt;::type<span class="sig-paren">)</span>, tag::out1<span class="sig-paren">(</span>FwdIter2<span class="sig-paren">)</span>, tag::out2<span class="sig-paren">(</span>FwdIter3<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">partition_copy</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, FwdIter2 <em>dest_true</em>, FwdIter3 <em>dest_false</em>, Pred &amp;&amp;<em>pred</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v114partition_copyERR8ExPolicyRR3Rng8FwdIter28FwdIter3RR4PredRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the elements in the range <em>rng</em>, to two different ranges depending on the value returned by the predicate <em>pred</em>. The elements, that satisfy the predicate <em>pred</em>, are copied to the range beginning at <em>dest_true</em>. The rest of the elements are copied to the range beginning at <em>dest_false</em>. The order of the elements is preserved.</p>
<p><p>The assignments in the parallel </p>
<em>partition_copy</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs not more than N assignments, exactly N applications of the predicate <em>pred</em>, where N = std::distance(begin(rng), end(rng)).</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range for the elements that satisfy the predicate <em>pred</em> (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter3</span></code>: The type of the iterator representing the destination range for the elements that don’t satisfy the predicate <em>pred</em> (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>partition_copy</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest_true</span></code>: Refers to the beginning of the destination range for the elements that satisfy the predicate <em>pred</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest_false</span></code>: Refers to the beginning of the destination range for the elements that don’t satisfy the predicate <em>pred</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">pred</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by the range <em>rng</em>. This is an unary predicate for partitioning the source iterators. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter1</em> can be dereferenced and then implicitly converted to <em>Type</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>partition_copy</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>partition_copy</em> algorithm returns a <em>hpx::future&lt;tagged_tuple&lt;tag::in(InIter), tag::out1(OutIter1), tag::out2(OutIter2)&gt;</em> &gt; if the execution policy is of type <em>parallel_task_policy</em> and returns <em>tagged_tuple&lt;tag::in(InIter), tag::out1(OutIter1), tag::out2(OutIter2)&gt;</em> otherwise. The <em>partition_copy</em> algorithm returns the tuple of the source iterator <em>last</em>, the destination iterator to the end of the <em>dest_true</em> range, and the destination iterator to the end of the <em>dest_false</em> range. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v16removeERR8ExPolicyRR3RngR1TRR4Proj">
<span id="_CPPv2N3hpx8parallel2v16removeERR8ExPolicyRR3RngR1TRR4Proj"></span><span id="hpx::parallel::v1::remove__ExPolicyRR.RngRR.TCR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> T, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1ac79b147d283a89405322c1ea937ed28a"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <em class="property">typename</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng&gt;::type&gt;::type <code class="descname">remove</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, T <em class="property">const</em> &amp;<em>value</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v16removeERR8ExPolicyRR3RngR1TRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Removes all elements satisfying specific criteria from the range [first, last) and returns a past-the-end iterator for the new end of the range. This version removes all elements that are equal to <em>value</em>.</p>
<p><p>The assignments in the parallel </p>
<em>remove</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs not more than <em>last</em> - <em>first</em> assignments, exactly <em>last</em> - <em>first</em> applications of the operator==() and the projection <em>proj</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the value to remove (deduced). This value type must meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">value</span></code>: Specifies the value of elements to remove. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>remove</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>remove</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter</em> otherwise. The <em>remove</em> algorithm returns the iterator to the new end of the range. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v19remove_ifERR8ExPolicyRR3RngRR4PredRR4Proj">
<span id="_CPPv2N3hpx8parallel2v19remove_ifERR8ExPolicyRR3RngRR4PredRR4Proj"></span><span id="hpx::parallel::v1::remove_if__ExPolicyRR.RngRR.PredRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> Pred, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a1aa784b5211d2deeb7e72f53d86f64fe"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <em class="property">typename</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng&gt;::type&gt;::type <code class="descname">remove_if</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, Pred &amp;&amp;<em>pred</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v19remove_ifERR8ExPolicyRR3RngRR4PredRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Removes all elements satisfying specific criteria from the range [first, last) and returns a past-the-end iterator for the new end of the range. This version removes all elements for which predicate <em>pred</em> returns true.</p>
<p><p>The assignments in the parallel </p>
<em>remove_if</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs not more than <em>last</em> - <em>first</em> assignments, exactly <em>last</em> - <em>first</em> applications of the predicate <em>pred</em> and the projection <em>proj</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>remove_if</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">pred</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is an unary predicate which returns <em>true</em> for the required elements. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter</em> can be dereferenced and then implicitly converted to Type. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>remove_if</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>remove_if</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter</em> otherwise. The <em>remove_if</em> algorithm returns the iterator to the new end of the range. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v111remove_copyERR8ExPolicyRR3Rng7OutIterR1TRR4Proj">
<span id="_CPPv2N3hpx8parallel2v111remove_copyERR8ExPolicyRR3Rng7OutIterR1TRR4Proj"></span><span id="hpx::parallel::v1::remove_copy__ExPolicyRR.RngRR.OutIter.TCR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> OutIter, <em class="property">typename</em> T, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a502c6c257508e5a53719171a10a9da8d"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::in<span class="sig-paren">(</span><em class="property">typename</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_traits&lt;Rng&gt;::iterator_type<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>OutIter<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">remove_copy</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, OutIter <em>dest</em>, T <em class="property">const</em> &amp;<em>val</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v111remove_copyERR8ExPolicyRR3Rng7OutIterR1TRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the elements in the range, defined by [first, last), to another range beginning at <em>dest</em>. Copies only the elements for which the comparison operator returns false when compare to val. The order of the elements that are not removed is preserved.</p>
<p>Effects: Copies all the elements referred to by the iterator it in the range [first,last) for which the following corresponding conditions do not hold: INVOKE(proj, *it) == value</p>
<p><p>The assignments in the parallel </p>
<em>remove_copy</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs not more than <em>last</em> - <em>first</em> assignments, exactly <em>last</em> - <em>first</em> applications of the predicate <em>f</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">OutIter</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an output iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type that the result of dereferencing InIter is compared to. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">val</span></code>: Value to be removed. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>remove_copy</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>remove_copy</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::in(InIter), tag::out(OutIter)&gt;</em> &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::in(InIter), tag::out(OutIter)&gt;</em> otherwise. The <em>copy</em> algorithm returns the pair of the input iterator forwarded to the first element after the last in the input sequence and the output iterator to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v114remove_copy_ifERR8ExPolicyRR3Rng7OutIterRR1FRR4Proj">
<span id="_CPPv2N3hpx8parallel2v114remove_copy_ifERR8ExPolicyRR3Rng7OutIterRR1FRR4Proj"></span><span id="hpx::parallel::v1::remove_copy_if__ExPolicyRR.RngRR.OutIter.FRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> OutIter, <em class="property">typename</em> F, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1abd0452821fded9de150d1bfee84a6388"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::in<span class="sig-paren">(</span><em class="property">typename</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_traits&lt;Rng&gt;::iterator_type<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>OutIter<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">remove_copy_if</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, OutIter <em>dest</em>, F &amp;&amp;<em>f</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v114remove_copy_ifERR8ExPolicyRR3Rng7OutIterRR1FRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the elements in the range, defined by [first, last), to another range beginning at <em>dest</em>. Copies only the elements for which the predicate <em>f</em> returns false. The order of the elements that are not removed is preserved.</p>
<p>Effects: Copies all the elements referred to by the iterator it in the range [first,last) for which the following corresponding conditions do not hold: INVOKE(pred, INVOKE(proj, *it)) != false.</p>
<p><p>The assignments in the parallel </p>
<em>remove_copy_if</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs not more than <em>last</em> - <em>first</em> assignments, exactly <em>last</em> - <em>first</em> applications of the predicate <em>f</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">OutIter</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an output iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>copy_if</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is an unary predicate which returns <em>true</em> for the elements to be removed. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>InIter</em> can be dereferenced and then implicitly converted to Type. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>remove_copy_if</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>remove_copy_if</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::in(InIter), tag::out(OutIter)&gt;</em> &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::in(InIter), tag::out(OutIter)&gt;</em> otherwise. The <em>copy</em> algorithm returns the pair of the input iterator forwarded to the first element after the last in the input sequence and the output iterator to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v17replaceERR8ExPolicyRR3RngR2T1R2T2RR4Proj">
<span id="_CPPv2N3hpx8parallel2v17replaceERR8ExPolicyRR3RngR2T1R2T2RR4Proj"></span><span id="hpx::parallel::v1::replace__ExPolicyRR.RngRR.T1CR.T2CR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> T1, <em class="property">typename</em> T2, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1aefef1778072b50648bc152b6c9706046"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <em class="property">typename</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_traits&lt;Rng&gt;::iterator_type&gt;::type <code class="descname">replace</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, T1 <em class="property">const</em> &amp;<em>old_value</em>, T2 <em class="property">const</em> &amp;<em>new_value</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v17replaceERR8ExPolicyRR3RngR2T1R2T2RR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Replaces all elements satisfying specific criteria with <em>new_value</em> in the range [first, last).</p>
<p><p>Effects: Substitutes elements referred by the iterator it in the range [first,last) with new_value, when the following corresponding conditions hold: INVOKE(proj, *i) == old_value</p>
<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>last</em> - <em>first</em> assignments.</dd>
</dl>
</p>
<p><p>The assignments in the parallel </p>
<em>replace</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of a forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">T1</span></code>: The type of the old value to replace (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">T2</span></code>: The type of the new values to replace (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">old_value</span></code>: Refers to the old value of the elements to replace. </li>
<li><code class="docutils literal notranslate"><span class="pre">new_value</span></code>: Refers to the new value to use as the replacement. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>replace</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>replace</em> algorithm returns a <em>hpx::future&lt;void&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>void</em> otherwise. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v110replace_ifERR8ExPolicyRR3RngRR1FR1TRR4Proj">
<span id="_CPPv2N3hpx8parallel2v110replace_ifERR8ExPolicyRR3RngRR1FR1TRR4Proj"></span><span id="hpx::parallel::v1::replace_if__ExPolicyRR.RngRR.FRR.TCR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> F, <em class="property">typename</em> T, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1ab39c066bb39cf49738f1cf8a84a586a9"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <em class="property">typename</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_traits&lt;Rng&gt;::iterator_type&gt;::type <code class="descname">replace_if</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, F &amp;&amp;<em>f</em>, T <em class="property">const</em> &amp;<em>new_value</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v110replace_ifERR8ExPolicyRR3RngRR1FR1TRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Replaces all elements satisfying specific criteria (for which predicate <em>f</em> returns true) with <em>new_value</em> in the range [first, last).</p>
<p><p>Effects: Substitutes elements referred by the iterator it in the range [first, last) with new_value, when the following corresponding conditions hold: INVOKE(f, INVOKE(proj, *it)) != false</p>
<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>last</em> - <em>first</em> applications of the predicate.</dd>
</dl>
</p>
<p><p>The assignments in the parallel </p>
<em>replace_if</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of a forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>equal</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the new values to replace (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is an unary predicate which returns <em>true</em> for the elements which need to replaced. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter</em> can be dereferenced and then implicitly converted to <em>Type</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">new_value</span></code>: Refers to the new value to use as the replacement. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>replace_if</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>replace_if</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>void</em> otherwise. It returns <em>last</em>. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v112replace_copyERR8ExPolicyRR3Rng7OutIterR2T1R2T2RR4Proj">
<span id="_CPPv2N3hpx8parallel2v112replace_copyERR8ExPolicyRR3Rng7OutIterR2T1R2T2RR4Proj"></span><span id="hpx::parallel::v1::replace_copy__ExPolicyRR.RngRR.OutIter.T1CR.T2CR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> OutIter, <em class="property">typename</em> T1, <em class="property">typename</em> T2, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a389f87159d80eef0638c8230faeefbf2"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::in<span class="sig-paren">(</span><em class="property">typename</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_traits&lt;Rng&gt;::iterator_type<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>OutIter<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">replace_copy</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, OutIter <em>dest</em>, T1 <em class="property">const</em> &amp;<em>old_value</em>, T2 <em class="property">const</em> &amp;<em>new_value</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v112replace_copyERR8ExPolicyRR3Rng7OutIterR2T1R2T2RR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the all elements from the range [first, last) to another range beginning at <em>dest</em> replacing all elements satisfying a specific criteria with <em>new_value</em>.</p>
<p>Effects: Assigns to every iterator it in the range [result, result + (last - first)) either new_value or *(first + (it - result)) depending on whether the following corresponding condition holds: INVOKE(proj, *(first + (i - result))) == old_value</p>
<p><p>The assignments in the parallel </p>
<em>replace_copy</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>last</em> - <em>first</em> applications of the predicate.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">OutIter</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an output iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">T1</span></code>: The type of the old value to replace (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">T2</span></code>: The type of the new values to replace (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">old_value</span></code>: Refers to the old value of the elements to replace. </li>
<li><code class="docutils literal notranslate"><span class="pre">new_value</span></code>: Refers to the new value to use as the replacement. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>replace_copy</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>replace_copy</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::in(InIter), tag::out(OutIter)&gt;</em> &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::in(InIter), tag::out(OutIter)&gt;</em> otherwise. The <em>copy</em> algorithm returns the pair of the input iterator <em>last</em> and the output iterator to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v115replace_copy_ifERR8ExPolicyRR3Rng7OutIterRR1FR1TRR4Proj">
<span id="_CPPv2N3hpx8parallel2v115replace_copy_ifERR8ExPolicyRR3Rng7OutIterRR1FR1TRR4Proj"></span><span id="hpx::parallel::v1::replace_copy_if__ExPolicyRR.RngRR.OutIter.FRR.TCR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> OutIter, <em class="property">typename</em> F, <em class="property">typename</em> T, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a08cb18b548967fc8c26fa4da201f6501"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::in<span class="sig-paren">(</span><em class="property">typename</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_traits&lt;Rng&gt;::iterator_type<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>OutIter<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">replace_copy_if</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, OutIter <em>dest</em>, F &amp;&amp;<em>f</em>, T <em class="property">const</em> &amp;<em>new_value</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v115replace_copy_ifERR8ExPolicyRR3Rng7OutIterRR1FR1TRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the all elements from the range [first, last) to another range beginning at <em>dest</em> replacing all elements satisfying a specific criteria with <em>new_value</em>.</p>
<p>Effects: Assigns to every iterator it in the range [result, result + (last - first)) either new_value or *(first + (it - result)) depending on whether the following corresponding condition holds: INVOKE(f, INVOKE(proj, *(first + (i - result)))) != false</p>
<p><p>The assignments in the parallel </p>
<em>replace_copy_if</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>last</em> - <em>first</em> applications of the predicate.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">OutIter</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an output iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>equal</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The type of the new values to replace (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is an unary predicate which returns <em>true</em> for the elements which need to replaced. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter</em> can be dereferenced and then implicitly converted to <em>Type</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">new_value</span></code>: Refers to the new value to use as the replacement. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>replace_copy_if</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>replace_copy_if</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::in(InIter), tag::out(OutIter)&gt;</em> &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::in(InIter), tag::out(OutIter)&gt;</em> otherwise. The <em>replace_copy_if</em> algorithm returns the input iterator <em>last</em> and the output iterator to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v17reverseERR8ExPolicyRR3Rng">
<span id="_CPPv2N3hpx8parallel2v17reverseERR8ExPolicyRR3Rng"></span><span id="hpx::parallel::v1::reverse__ExPolicyRR.RngRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a55899d840741e9354b54b304ea515310"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <em class="property">typename</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng&gt;::type&gt;::type <code class="descname">reverse</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v17reverseERR8ExPolicyRR3Rng" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Reverses the order of the elements in the range [first, last). Behaves as if applying std::iter_swap to every pair of iterators first+i, (last-i) - 1 for each non-negative i &lt; (last-first)/2.</p>
<p><p>The assignments in the parallel </p>
<em>reverse</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Linear in the distance between <em>first</em> and <em>last</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of a bidirectional iterator.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>reverse</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>reverse</em> algorithm returns a <em>hpx::future&lt;BidirIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>BidirIter</em> otherwise. It returns <em>last</em>. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v112reverse_copyERR8ExPolicyRR3Rng7OutIter">
<span id="_CPPv2N3hpx8parallel2v112reverse_copyERR8ExPolicyRR3Rng7OutIter"></span><span id="hpx::parallel::v1::reverse_copy__ExPolicyRR.RngRR.OutIter"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> OutIter&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a88c284308fbd0d7c233d4feeb35ad35d"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::in<span class="sig-paren">(</span><em class="property">typename</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng&gt;::type<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>OutIter<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">reverse_copy</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, OutIter <em>dest_first</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v112reverse_copyERR8ExPolicyRR3Rng7OutIter" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the elements from the range [first, last) to another range beginning at dest_first in such a way that the elements in the new range are in reverse order. Behaves as if by executing the assignment *(dest_first + (last - first) - 1 - i) = *(first + i) once for each non-negative i &lt; (last - first) If the source and destination ranges (that is, [first, last) and [dest_first, dest_first+(last-first)) respectively) overlap, the behavior is undefined.</p>
<p><p>The assignments in the parallel </p>
<em>reverse_copy</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>last</em> - <em>first</em> assignments.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of a bidirectional iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">OutputIter</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an output iterator.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest_first</span></code>: Refers to the begin of the destination range.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>reverse_copy</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>reverse_copy</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::in(BidirIter), tag::out(OutIter)&gt;</em> &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::in(BidirIter), tag::out(OutIter)&gt;</em> otherwise. The <em>copy</em> algorithm returns the pair of the input iterator forwarded to the first element after the last in the input sequence and the output iterator to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v16rotateERR8ExPolicyRR3RngN3hpx6traits14range_iteratorI3RngE4typeE">
<span id="_CPPv2N3hpx8parallel2v16rotateERR8ExPolicyRR3RngN3hpx6traits14range_iteratorI3RngE4typeE"></span><span id="hpx::parallel::v1::rotate__ExPolicyRR.RngRR.hpx::traits::range_iterator:Rng:::type"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1ab4b35e2f650c01460f25f0db0d9734ab"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::begin<span class="sig-paren">(</span><em class="property">typename</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng&gt;::type<span class="sig-paren">)</span>, tag::end<span class="sig-paren">(</span><em class="property">typename</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng&gt;::type<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">rotate</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, <em class="property">typename</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng&gt;::type <em>middle</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v16rotateERR8ExPolicyRR3RngN3hpx6traits14range_iteratorI3RngE4typeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Performs a left rotation on a range of elements. Specifically, <em>rotate</em> swaps the elements in the range [first, last) in such a way that the element new_first becomes the first element of the new range and new_first - 1 becomes the last element.</p>
<p><p>The assignments in the parallel </p>
<em>rotate</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Linear in the distance between <em>first</em> and <em>last</em>.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of a forward iterator.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">middle</span></code>: Refers to the element that should appear at the beginning of the rotated range.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>rotate</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The type of dereferenced <em>FwdIter</em> must meet the requirements of <em>MoveAssignable</em> and <em>MoveConstructible</em>.</dd>
<dt><strong>Return</strong></dt>
<dd>The <em>rotate</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::begin(FwdIter), tag::end(FwdIter)&gt;</em> &gt; if the execution policy is of type <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::begin(FwdIter), tag::end(FwdIter)&gt;</em> otherwise. The <em>rotate</em> algorithm returns the iterator equal to pair(first + (last - new_first), last). </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v111rotate_copyERR8ExPolicyRR3RngN3hpx6traits14range_iteratorI3RngE4typeE7OutIter">
<span id="_CPPv2N3hpx8parallel2v111rotate_copyERR8ExPolicyRR3RngN3hpx6traits14range_iteratorI3RngE4typeE7OutIter"></span><span id="hpx::parallel::v1::rotate_copy__ExPolicyRR.RngRR.hpx::traits::range_iterator:Rng:::type.OutIter"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> OutIter&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a00b60fccffa0c06eb6befe8913fab07a"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::in<span class="sig-paren">(</span><em class="property">typename</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng&gt;::type<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>OutIter<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">rotate_copy</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, <em class="property">typename</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng&gt;::type <em>middle</em>, OutIter <em>dest_first</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v111rotate_copyERR8ExPolicyRR3RngN3hpx6traits14range_iteratorI3RngE4typeE7OutIter" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the elements from the range [first, last), to another range beginning at <em>dest_first</em> in such a way, that the element <em>new_first</em> becomes the first element of the new range and <em>new_first</em> - 1 becomes the last element.</p>
<p><p>The assignments in the parallel </p>
<em>rotate_copy</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs exactly <em>last</em> - <em>first</em> assignments.</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of a forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">OutIter</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an output iterator.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">middle</span></code>: Refers to the element that should appear at the beginning of the rotated range. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest_first</span></code>: Refers to the begin of the destination range.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>rotate_copy</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>rotate_copy</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::in(FwdIter), tag::out(OutIter)&gt;</em> &gt; if the execution policy is of type <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::in(FwdIter), tag::out(OutIter)&gt;</em> otherwise. The <em>rotate_copy</em> algorithm returns the output iterator to the element past the last element copied. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v16searchERR8ExPolicyRR4Rng1RR4Rng2RR4PredRR5Proj1RR5Proj2">
<span id="_CPPv2N3hpx8parallel2v16searchERR8ExPolicyRR4Rng1RR4Rng2RR4PredRR5Proj1RR5Proj2"></span><span id="hpx::parallel::v1::search__ExPolicyRR.Rng1RR.Rng2RR.PredRR.Proj1RR.Proj2RR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng1, <em class="property">typename</em> Rng2, <em class="property">typename</em> Pred = detail::equal_to, <em class="property">typename</em> Proj1 = util::projection_identity, <em class="property">typename</em> Proj2 = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1add319ad54d498c75dc5f5120d87e29bd"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <em class="property">typename</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng1&gt;::type&gt;::type <code class="descname">search</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng1 &amp;&amp;<em>rng1</em>, Rng2 &amp;&amp;<em>rng2</em>, Pred &amp;&amp;<em>op</em> = Pred(), Proj1 &amp;&amp;<em>proj1</em> = Proj1(), Proj2 &amp;&amp;<em>proj2</em> = Proj2()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v16searchERR8ExPolicyRR4Rng1RR4Rng2RR4PredRR5Proj1RR5Proj2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Searches the range [first, last) for any elements in the range [s_first, s_last). Uses a provided predicate to compare elements.</p>
<p><p>The comparison operations in the parallel </p>
<em>search</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: at most (S*N) comparisons where <em>S</em> = distance(s_first, s_last) and <em>N</em> = distance(first, last).</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng1</span></code>: The type of the examine range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng2</span></code>: The type of the search range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <em>adjacent_find</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::equal_to&lt;&gt; </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj1</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> and is applied to the elements of <em>Rng1</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj2</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> and is applied to the elements of <em>Rng2</em>.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng1</span></code>: Refers to the sequence of elements the algorithm will be examining. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng2</span></code>: Refers to the sequence of elements the algorithm will be searching for. </li>
<li><code class="docutils literal notranslate"><span class="pre">op</span></code>: Refers to the binary predicate which returns true if the elements should be treated as equal. the signature of the function should be equivalent to <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type2</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> and <em>Type2</em> must be such that objects of types <em>FwdIter1</em> and <em>FwdIter2</em> can be dereferenced and then implicitly converted to <em>Type1</em> and <em>Type2</em> respectively </li>
<li><code class="docutils literal notranslate"><span class="pre">proj1</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of <em>rng1</em> as a projection operation before the actual predicate <em>is</em> invoked. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj2</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of <em>rng2</em> as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The comparison operations in the parallel <em>search</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>search</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>task_execution_policy</em> and returns <em>FwdIter</em> otherwise. The <em>search</em> algorithm returns an iterator to the beginning of the first subsequence [s_first, s_last) in range [first, last). If the length of the subsequence [s_first, s_last) is greater than the length of the range [first, last), <em>last</em> is returned. Additionally if the size of the subsequence is empty <em>first</em> is returned. If no subsequence is found, <em>last</em> is returned. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v18search_nERR8ExPolicyRR4Rng1NSt6size_tERR4Rng2RR4PredRR5Proj1RR5Proj2">
<span id="_CPPv2N3hpx8parallel2v18search_nERR8ExPolicyRR4Rng1NSt6size_tERR4Rng2RR4PredRR5Proj1RR5Proj2"></span><span id="hpx::parallel::v1::search_n__ExPolicyRR.Rng1RR.std::s.Rng2RR.PredRR.Proj1RR.Proj2RR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng1, <em class="property">typename</em> Rng2, <em class="property">typename</em> Pred = detail::equal_to, <em class="property">typename</em> Proj1 = util::projection_identity, <em class="property">typename</em> Proj2 = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1ab45d57e5362f0271e121b82a378e79e4"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <em class="property">typename</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng1&gt;::type&gt;::type <code class="descname">search_n</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng1 &amp;&amp;<em>rng1</em>, std::size_t <em>count</em>, Rng2 &amp;&amp;<em>rng2</em>, Pred &amp;&amp;<em>op</em> = Pred(), Proj1 &amp;&amp;<em>proj1</em> = Proj1(), Proj2 &amp;&amp;<em>proj2</em> = Proj2()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v18search_nERR8ExPolicyRR4Rng1NSt6size_tERR4Rng2RR4PredRR5Proj1RR5Proj2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Searches the range [first, last) for any elements in the range [s_first, s_last). Uses a provided predicate to compare elements.</p>
<p><p>The comparison operations in the parallel </p>
<em>search</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: at most (S*N) comparisons where <em>S</em> = distance(s_first, s_last) and <em>N</em> = distance(first, last).</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng1</span></code>: The type of the examine range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng2</span></code>: The type of the search range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of an optional function/function object to use. Unlike its sequential form, the parallel overload of <em>adjacent_find</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::equal_to&lt;&gt; </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj1</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> and is applied to the elements of <em>Rng1</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj2</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> and is applied to the elements of <em>Rng2</em>.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng1</span></code>: Refers to the sequence of elements the algorithm will be examining. </li>
<li><code class="docutils literal notranslate"><span class="pre">count</span></code>: The number of elements to apply the algorithm on. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng2</span></code>: Refers to the sequence of elements the algorithm will be searching for. </li>
<li><code class="docutils literal notranslate"><span class="pre">op</span></code>: Refers to the binary predicate which returns true if the elements should be treated as equal. the signature of the function should be equivalent to <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type2</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const &amp;, but the function must not modify the objects passed to it. The types </p>
<em>Type1</em> and <em>Type2</em> must be such that objects of types <em>FwdIter1</em> and <em>FwdIter2</em> can be dereferenced and then implicitly converted to <em>Type1</em> and <em>Type2</em> respectively </li>
<li><code class="docutils literal notranslate"><span class="pre">proj1</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of <em>rng1</em> as a projection operation before the actual predicate <em>is</em> invoked. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj2</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of <em>rng2</em> as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The comparison operations in the parallel <em>search</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>search</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>task_execution_policy</em> and returns <em>FwdIter</em> otherwise. The <em>search</em> algorithm returns an iterator to the beginning of the first subsequence [s_first, s_last) in range [first, last). If the length of the subsequence [s_first, s_last) is greater than the length of the range [first, last), <em>last</em> is returned. Additionally if the size of the subsequence is empty <em>first</em> is returned. If no subsequence is found, <em>last</em> is returned. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v14sortERR8ExPolicyRR3RngRR7CompareRR4Proj">
<span id="_CPPv2N3hpx8parallel2v14sortERR8ExPolicyRR3RngRR7CompareRR4Proj"></span><span id="hpx::parallel::v1::sort__ExPolicyRR.RngRR.CompareRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> Proj = util::projection_identity, <em class="property">typename</em> Compare = detail::less&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a7dce6b68d414854caf498a82c8429f22"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <em class="property">typename</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng&gt;::type&gt;::type <code class="descname">sort</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, Compare &amp;&amp;<em>comp</em> = Compare(), Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v14sortERR8ExPolicyRR3RngRR7CompareRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Sorts the elements in the range <em>rng</em> in ascending order. The order of equal elements is not guaranteed to be preserved. The function uses the given comparison function object comp (defaults to using operator&lt;()).</p>
<p><p>A sequence is sorted with respect to a comparator </p>
<em>comp</em> and a projection <em>proj</em> if for every iterator i pointing to the sequence and every non-negative integer n such that i + n is a valid iterator pointing to an element of the sequence, and INVOKE(comp, INVOKE(proj, *(i + n)), INVOKE(proj, *i)) == false.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: O(Nlog(N)), where N = std::distance(begin(rng), end(rng)) comparisons.</dd>
</dl>
</p>
<p><em>comp</em> has to induce a strict weak ordering on the values.<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Comp</span></code>: The type of the function/function object to use (deduced). </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">comp</span></code>: comp is a callable object. The return value of the INVOKE operation applied to an object of type Comp, when contextually converted to bool, yields true if the first argument of the call is less than the second, and false otherwise. It is assumed that comp will not apply any non-constant function through the dereferenced iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each pair of elements as a projection operation before the actual predicate <em>comp</em> is invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.</p>
<p>The application of function objects in parallel algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>sort</em> algorithm returns a <em>hpx::future&lt;Iter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>Iter</em> otherwise. It returns <em>last</em>. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v19transformERR8ExPolicyRR3Rng7OutIterRR1FRR4Proj">
<span id="_CPPv2N3hpx8parallel2v19transformERR8ExPolicyRR3Rng7OutIterRR1FRR4Proj"></span><span id="hpx::parallel::v1::transform__ExPolicyRR.RngRR.OutIter.FRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> OutIter, <em class="property">typename</em> F, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a3f7902dd44eace6467f72702ff78c3d4"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::in<span class="sig-paren">(</span><em class="property">typename</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng&gt;::type<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>OutIter<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">transform</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, OutIter <em>dest</em>, F &amp;&amp;<em>f</em>, Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v19transformERR8ExPolicyRR3Rng7OutIterRR1FRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Applies the given function <em>f</em> to the given range <em>rng</em> and stores the result in another range, beginning at dest.</p>
<p><p>The invocations of </p>
<em>f</em> in the parallel <em>transform</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Exactly size(rng) applications of <em>f</em> </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the invocations of <em>f</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">OutIter</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an output iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>transform</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is an unary predicate. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ret</span> <span class="nf">fun</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;. The type </p>
<em>Type</em> must be such that an object of type <em>InIter</em> can be dereferenced and then implicitly converted to <em>Type</em>. The type <em>Ret</em> must be such that an object of type <em>OutIter</em> can be dereferenced and assigned a value of type <em>Ret</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>f</em> is invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The invocations of <em>f</em> in the parallel <em>transform</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>transform</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::in(InIter), tag::out(OutIter)&gt;</em> &gt; if the execution policy is of type <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::in(InIter), tag::out(OutIter)&gt;</em> otherwise. The <em>transform</em> algorithm returns a tuple holding an iterator referring to the first element after the input sequence and the output iterator to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v19transformERR8ExPolicyRR3Rng7InIter27OutIterRR1FRR5Proj1RR5Proj2">
<span id="_CPPv2N3hpx8parallel2v19transformERR8ExPolicyRR3Rng7InIter27OutIterRR1FRR5Proj1RR5Proj2"></span><span id="hpx::parallel::v1::transform__ExPolicyRR.RngRR.InIter2.OutIter.FRR.Proj1RR.Proj2RR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> InIter2, <em class="property">typename</em> OutIter, <em class="property">typename</em> F, <em class="property">typename</em> Proj1 = util::projection_identity, <em class="property">typename</em> Proj2 = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a296e7e5773d39e6c8b4a9a9ce38b00cd"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_tuple&lt;tag::in1<span class="sig-paren">(</span><em class="property">typename</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng&gt;::type<span class="sig-paren">)</span>, tag::in2<span class="sig-paren">(</span>InIter2<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>OutIter<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">transform</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, InIter2 <em>first2</em>, OutIter <em>dest</em>, F &amp;&amp;<em>f</em>, Proj1 &amp;&amp;<em>proj1</em> = Proj1(), Proj2 &amp;&amp;<em>proj2</em> = Proj2()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v19transformERR8ExPolicyRR3Rng7InIter27OutIterRR1FRR5Proj1RR5Proj2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Applies the given function <em>f</em> to pairs of elements from two ranges: one defined by <em>rng</em> and the other beginning at first2, and stores the result in another range, beginning at dest.</p>
<p><p>The invocations of </p>
<em>f</em> in the parallel <em>transform</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Exactly size(rng) applications of <em>f</em> </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the invocations of <em>f</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">InIter2</span></code>: The type of the source iterators for the second range used (deduced). This iterator type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">OutIter</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an output iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>transform</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj1</span></code>: The type of an optional projection function to be used for elements of the first sequence. This defaults to <em>util::projection_identity</em> </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj2</span></code>: The type of an optional projection function to be used for elements of the second sequence. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">first2</span></code>: Refers to the beginning of the second sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is a binary predicate. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ret</span> <span class="nf">fun</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type2</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;. The types </p>
<em>Type1</em> and <em>Type2</em> must be such that objects of types InIter1 and InIter2 can be dereferenced and then implicitly converted to <em>Type1</em> and <em>Type2</em> respectively. The type <em>Ret</em> must be such that an object of type <em>OutIter</em> can be dereferenced and assigned a value of type <em>Ret</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj1</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of the first sequence as a projection operation before the actual predicate <em>f</em> is invoked. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj2</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of the second sequence as a projection operation before the actual predicate <em>f</em> is invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The invocations of <em>f</em> in the parallel <em>transform</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>transform</em> algorithm returns a <em>hpx::future&lt;tagged_tuple&lt;tag::in1(InIter1), tag::in2(InIter2), tag::out(OutIter)&gt;</em> &gt; if the execution policy is of type <em>parallel_task_policy</em> and returns <em>tagged_tuple&lt;tag::in1(InIter1), tag::in2(InIter2), tag::out(OutIter)&gt;</em> otherwise. The <em>transform</em> algorithm returns a tuple holding an iterator referring to the first element after the first input sequence, an iterator referring to the first element after the second input sequence, and the output iterator referring to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v19transformERR8ExPolicyRR4Rng1RR4Rng27OutIterRR1FRR5Proj1RR5Proj2">
<span id="_CPPv2N3hpx8parallel2v19transformERR8ExPolicyRR4Rng1RR4Rng27OutIterRR1FRR5Proj1RR5Proj2"></span><span id="hpx::parallel::v1::transform__ExPolicyRR.Rng1RR.Rng2RR.OutIter.FRR.Proj1RR.Proj2RR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng1, <em class="property">typename</em> Rng2, <em class="property">typename</em> OutIter, <em class="property">typename</em> F, <em class="property">typename</em> Proj1 = util::projection_identity, <em class="property">typename</em> Proj2 = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a45593fc520cb2631a4957718bcf0450c"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_tuple&lt;tag::in1<span class="sig-paren">(</span><em class="property">typename</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng1&gt;::type<span class="sig-paren">)</span>, tag::in2<span class="sig-paren">(</span><em class="property">typename</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng2&gt;::type<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>OutIter<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">transform</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng1 &amp;&amp;<em>rng1</em>, Rng2 &amp;&amp;<em>rng2</em>, OutIter <em>dest</em>, F &amp;&amp;<em>f</em>, Proj1 &amp;&amp;<em>proj1</em> = Proj1(), Proj2 &amp;&amp;<em>proj2</em> = Proj2()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v19transformERR8ExPolicyRR4Rng1RR4Rng27OutIterRR1FRR5Proj1RR5Proj2" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Applies the given function <em>f</em> to pairs of elements from two ranges: one defined by [first1, last1) and the other beginning at first2, and stores the result in another range, beginning at dest.</p>
<p><p>The invocations of </p>
<em>f</em> in the parallel <em>transform</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Exactly min(last2-first2, last1-first1) applications of <em>f</em> </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the invocations of <em>f</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng1</span></code>: The type of the first source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng2</span></code>: The type of the second source range used (deduced). The iterators extracted from this range type must meet the requirements of an input iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">OutIter</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an output iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>transform</em> requires <em>F</em> to meet the requirements of <em>CopyConstructible</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj1</span></code>: The type of an optional projection function to be used for elements of the first sequence. This defaults to <em>util::projection_identity</em> </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj2</span></code>: The type of an optional projection function to be used for elements of the second sequence. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng1</span></code>: Refers to the first sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng2</span></code>: Refers to the second sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last).This is a binary predicate. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Ret</span> <span class="nf">fun</span><span class="p">(</span><span class="k">const</span> <span class="n">Type1</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type2</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;. The types </p>
<em>Type1</em> and <em>Type2</em> must be such that objects of types InIter1 and InIter2 can be dereferenced and then implicitly converted to <em>Type1</em> and <em>Type2</em> respectively. The type <em>Ret</em> must be such that an object of type <em>OutIter</em> can be dereferenced and assigned a value of type <em>Ret</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj1</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of the first sequence as a projection operation before the actual predicate <em>f</em> is invoked. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj2</span></code>: Specifies the function (or function object) which will be invoked for each of the elements of the second sequence as a projection operation before the actual predicate <em>f</em> is invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The invocations of <em>f</em> in the parallel <em>transform</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The algorithm will invoke the binary predicate until it reaches the end of the shorter of the two given input sequences</dd>
<dt><strong>Return</strong></dt>
<dd>The <em>transform</em> algorithm returns a <em>hpx::future&lt;tagged_tuple&lt;tag::in1(InIter1), tag::in2(InIter2), tag::out(OutIter)&gt;</em> &gt; if the execution policy is of type <em>parallel_task_policy</em> and returns <em>tagged_tuple&lt;tag::in1(InIter1), tag::in2(InIter2), tag::out(OutIter)&gt;</em> otherwise. The <em>transform</em> algorithm returns a tuple holding an iterator referring to the first element r the first input sequence, an iterator referring to the first element after the second input sequence, and the output iterator referring to the element in the destination range, one past the last element copied. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v16uniqueERR8ExPolicyRR3RngRR4PredRR4Proj">
<span id="_CPPv2N3hpx8parallel2v16uniqueERR8ExPolicyRR3RngRR4PredRR4Proj"></span><span id="hpx::parallel::v1::unique__ExPolicyRR.RngRR.PredRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> Pred = detail::equal_to, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a90480589220990ce8e7c13abab51b619"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <em class="property">typename</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng&gt;::type&gt;::type <code class="descname">unique</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, Pred &amp;&amp;<em>pred</em> = Pred(), Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v16uniqueERR8ExPolicyRR3RngRR4PredRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Eliminates all but the first element from every consecutive group of equivalent elements from the range <em>rng</em> and returns a past-the-end iterator for the new logical end of the range.</p>
<p><p>The assignments in the parallel </p>
<em>unique</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs not more than N assignments, exactly N - 1 applications of the predicate <em>pred</em> and no more than twice as many applications of the projection <em>proj</em>, where N = std::distance(begin(rng), end(rng)).</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>unique</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::equal_to&lt;&gt; </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">pred</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last). This is an binary predicate which returns <em>true</em> for the required elements. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter1</em> can be dereferenced and then implicitly converted to <em>Type</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>unique</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>unique</em> algorithm returns a <em>hpx::future&lt;FwdIter&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>FwdIter</em> otherwise. The <em>unique</em> algorithm returns the iterator to the new end of the range. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v111unique_copyERR8ExPolicyRR3Rng8FwdIter2RR4PredRR4Proj">
<span id="_CPPv2N3hpx8parallel2v111unique_copyERR8ExPolicyRR3Rng8FwdIter2RR4PredRR4Proj"></span><span id="hpx::parallel::v1::unique_copy__ExPolicyRR.RngRR.FwdIter2.PredRR.ProjRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> Rng, <em class="property">typename</em> FwdIter2, <em class="property">typename</em> Pred = detail::equal_to, <em class="property">typename</em> Proj = util::projection_identity&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v1_1a002f249dd112bdd7074b671d5c3f69a4"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::tagged_pair&lt;tag::in<span class="sig-paren">(</span><em class="property">typename</em> <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6traitsE" title="hpx::traits">traits</a>::range_iterator&lt;Rng&gt;::type<span class="sig-paren">)</span>, tag::out<span class="sig-paren">(</span>FwdIter2<span class="sig-paren">)</span>&gt;&gt;::type <code class="descname">unique_copy</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, Rng &amp;&amp;<em>rng</em>, FwdIter2 <em>dest</em>, Pred &amp;&amp;<em>pred</em> = Pred(), Proj &amp;&amp;<em>proj</em> = Proj()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v111unique_copyERR8ExPolicyRR3Rng8FwdIter2RR4PredRR4Proj" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Copies the elements from the range <em>rng</em>, to another range beginning at <em>dest</em> in such a way that there are no consecutive equal elements. Only the first element of each group of equal elements is copied.</p>
<p><p>The assignments in the parallel </p>
<em>unique_copy</em> algorithm invoked with an execution policy object of type <em>sequenced_policy</em> execute in sequential order in the calling thread.<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Complexity: Performs not more than N assignments, exactly N - 1 applications of the predicate <em>pred</em>, where N = std::distance(begin(rng), end(rng)).</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it executes the assignments. </li>
<li><code class="docutils literal notranslate"><span class="pre">Rng</span></code>: The type of the source range used (deduced). The iterators extracted from this range type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">FwdIter2</span></code>: The type of the iterator representing the destination range (deduced). This iterator type must meet the requirements of an forward iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">Pred</span></code>: The type of the function/function object to use (deduced). Unlike its sequential form, the parallel overload of <em>unique_copy</em> requires <em>Pred</em> to meet the requirements of <em>CopyConstructible</em>. This defaults to std::equal_to&lt;&gt; </li>
<li><code class="docutils literal notranslate"><span class="pre">Proj</span></code>: The type of an optional projection function. This defaults to <em>util::projection_identity</em> </li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">rng</span></code>: Refers to the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">dest</span></code>: Refers to the beginning of the destination range. </li>
<li><code class="docutils literal notranslate"><span class="pre">pred</span></code>: Specifies the function (or function object) which will be invoked for each of the elements in the sequence specified by the range <em>rng</em>. This is an binary predicate which returns <em>true</em> for the required elements. The signature of this predicate should be equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">pred</span><span class="p">(</span><span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;, but the function must not modify the objects passed to it. The type </p>
<em>Type</em> must be such that an object of type <em>FwdIter1</em> can be dereferenced and then implicitly converted to <em>Type</em>. </li>
<li><code class="docutils literal notranslate"><span class="pre">proj</span></code>: Specifies the function (or function object) which will be invoked for each of the elements as a projection operation before the actual predicate <em>is</em> invoked.</li>
</ul>
</dd>
</dl>
</p>
<p>The assignments in the parallel <em>unique_copy</em> algorithm invoked with an execution policy object of type <em>parallel_policy</em> or <em>parallel_task_policy</em> are permitted to execute in an unordered fashion in unspecified threads, and indeterminately sequenced within each thread.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>unique_copy</em> algorithm returns a <em>hpx::future&lt;tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</em> &gt; if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>tagged_pair&lt;tag::in(FwdIter1), tag::out(FwdIter2)&gt;</em> otherwise. The <em>unique_copy</em> algorithm returns the pair of the source iterator to <em>last</em>, and the destination iterator to the end of the <em>dest</em> range. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx8parallel2v2E">
<span id="_CPPv2N3hpx8parallel2v2E"></span><span id="hpx::parallel::v2"></span><span class="target" id="namespacehpx_1_1parallel_1_1v2"></span><em class="property">namespace </em><code class="descname">v2</code><a class="headerlink" href="#_CPPv3N3hpx8parallel2v2E" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v217define_task_blockERR8ExPolicyRR1F">
<span id="_CPPv2N3hpx8parallel2v217define_task_blockERR8ExPolicyRR1F"></span><span id="hpx::parallel::v2::define_task_block__ExPolicyRR.FRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> F&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v2_1a542a6d325f132739dbda97b8f09dce4f"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy&gt;::type <code class="descname">define_task_block</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, F &amp;&amp;<em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v217define_task_blockERR8ExPolicyRR1F" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructs a <em><a class="reference internal" href="#classhpx_1_1parallel_1_1v2_1_1task__block"><span class="std std-ref">task_block</span></a></em>, <em>tr</em>, using the given execution policy <em>policy</em>,and invokes the expression <em>f(tr)</em> on the user-provided object, <em>f</em>.</p>
<p><p>Postcondition: All tasks spawned from </p>
<em>f</em> have finished execution. A call to define_task_block may return on a different thread than that on which it was called.<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the task block may be parallelized. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the user defined function to invoke inside the define_task_block (deduced). <em>F</em> shall be MoveConstructible.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: The user defined function to invoke inside the task block. Given an lvalue <em>tr</em> of type <em><a class="reference internal" href="#classhpx_1_1parallel_1_1v2_1_1task__block"><span class="std std-ref">task_block</span></a></em>, the expression, (void)f(tr), shall be well-formed.</li>
</ul>
</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>It is expected (but not mandated) that f will (directly or indirectly) call tr.run(<em>callable_object</em>). </dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">An</span></code>: <em><a class="reference internal" href="#classhpx_1_1exception__list"><span class="std std-ref">exception_list</span></a></em>, as specified in Exception Handling.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v217define_task_blockERR1F">
<span id="_CPPv2N3hpx8parallel2v217define_task_blockERR1F"></span><span id="hpx::parallel::v2::define_task_block__FRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> F&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v2_1aa62d599bbcb85dfa6737f36a80b5555c"></span>void <code class="descname">define_task_block</code><span class="sig-paren">(</span>F &amp;&amp;<em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v217define_task_blockERR1F" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructs a <em><a class="reference internal" href="#classhpx_1_1parallel_1_1v2_1_1task__block"><span class="std std-ref">task_block</span></a></em>, tr, and invokes the expression <em>f(tr)</em> on the user-provided object, <em>f</em>. This version uses <em>parallel_policy</em> for task scheduling.</p>
<p><p>Postcondition: All tasks spawned from </p>
<em>f</em> have finished execution. A call to define_task_block may return on a different thread than that on which it was called.<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the user defined function to invoke inside the define_task_block (deduced). <em>F</em> shall be MoveConstructible.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: The user defined function to invoke inside the task block. Given an lvalue <em>tr</em> of type <em><a class="reference internal" href="#classhpx_1_1parallel_1_1v2_1_1task__block"><span class="std std-ref">task_block</span></a></em>, the expression, (void)f(tr), shall be well-formed.</li>
</ul>
</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>It is expected (but not mandated) that f will (directly or indirectly) call tr.run(<em>callable_object</em>). </dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">An</span></code>: <em><a class="reference internal" href="#classhpx_1_1exception__list"><span class="std std-ref">exception_list</span></a></em>, as specified in Exception Handling.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v232define_task_block_restore_threadERR8ExPolicyRR1F">
<span id="_CPPv2N3hpx8parallel2v232define_task_block_restore_threadERR8ExPolicyRR1F"></span><span id="hpx::parallel::v2::define_task_block_restore_thread__ExPolicyRR.FRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> F&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v2_1af89e67c431f71a9ae28e9e80c399c621"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy&gt;::type <code class="descname">define_task_block_restore_thread</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, F &amp;&amp;<em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v232define_task_block_restore_threadERR8ExPolicyRR1F" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructs a <em><a class="reference internal" href="#classhpx_1_1parallel_1_1v2_1_1task__block"><span class="std std-ref">task_block</span></a></em>, tr, and invokes the expression <em>f(tr)</em> on the user-provided object, <em>f</em>.</p>
<p><p>Postcondition: All tasks spawned from </p>
<em>f</em> have finished execution. A call to <em>define_task_block_restore_thread</em> always returns on the same thread as that on which it was called.<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the task block may be parallelized. </li>
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the user defined function to invoke inside the define_task_block (deduced). <em>F</em> shall be MoveConstructible.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: The user defined function to invoke inside the define_task_block. Given an lvalue <em>tr</em> of type <em><a class="reference internal" href="#classhpx_1_1parallel_1_1v2_1_1task__block"><span class="std std-ref">task_block</span></a></em>, the expression, (void)f(tr), shall be well-formed.</li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">An</span></code>: <em><a class="reference internal" href="#classhpx_1_1exception__list"><span class="std std-ref">exception_list</span></a></em>, as specified in Exception Handling.</li>
</ul>
</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>It is expected (but not mandated) that f will (directly or indirectly) call tr.run(<em>callable_object</em>). </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v232define_task_block_restore_threadERR1F">
<span id="_CPPv2N3hpx8parallel2v232define_task_block_restore_threadERR1F"></span><span id="hpx::parallel::v2::define_task_block_restore_thread__FRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> F&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v2_1ab676349ec457ff94ce4224d3792b72a3"></span>void <code class="descname">define_task_block_restore_thread</code><span class="sig-paren">(</span>F &amp;&amp;<em>f</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v232define_task_block_restore_threadERR1F" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Constructs a <em><a class="reference internal" href="#classhpx_1_1parallel_1_1v2_1_1task__block"><span class="std std-ref">task_block</span></a></em>, tr, and invokes the expression <em>f(tr)</em> on the user-provided object, <em>f</em>. This version uses <em>parallel_policy</em> for task scheduling.</p>
<p><p>Postcondition: All tasks spawned from </p>
<em>f</em> have finished execution. A call to <em>define_task_block_restore_thread</em> always returns on the same thread as that on which it was called.<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">F</span></code>: The type of the user defined function to invoke inside the define_task_block (deduced). <em>F</em> shall be MoveConstructible.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: The user defined function to invoke inside the define_task_block. Given an lvalue <em>tr</em> of type <em><a class="reference internal" href="#classhpx_1_1parallel_1_1v2_1_1task__block"><span class="std std-ref">task_block</span></a></em>, the expression, (void)f(tr), shall be well-formed.</li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">An</span></code>: <em><a class="reference internal" href="#classhpx_1_1exception__list"><span class="std std-ref">exception_list</span></a></em>, as specified in Exception Handling.</li>
</ul>
</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>It is expected (but not mandated) that f will (directly or indirectly) call tr.run(<em>callable_object</em>). </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v28for_loopERR8ExPolicyNSt5decayI1IE4typeE1IDpRR4Args">
<span id="_CPPv2N3hpx8parallel2v28for_loopERR8ExPolicyNSt5decayI1IE4typeE1IDpRR4Args"></span><span id="hpx::parallel::v2::for_loop__ExPolicyRR.std::decay:I:::type.I.ArgsRRDp"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> I, typename... <em>Args</em>&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v2_1a2e881d0376708a91f56835a1aa010f38"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy&gt;::type <code class="descname">for_loop</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, <em class="property">typename</em> std::decay&lt;I&gt;::type <em>first</em>, I <em>last</em>, Args&amp;&amp;... <em>args</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v28for_loopERR8ExPolicyNSt5decayI1IE4typeE1IDpRR4Args" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The for_loop implements loop functionality over a range specified by integral or iterator bounds. For the iterator case, these algorithms resemble for_each from the Parallelism TS, but leave to the programmer when and if to dereference the iterator.</p>
<p><p>Requires: </p>
<em>I</em> shall be an integral type or meet the requirements of an input iterator type. The <em>args</em> parameter pack shall have at least one element, comprising objects returned by invocations of <em>reduction</em> and/or <em>induction</em> function templates followed by exactly one element invocable element-access function, <em>f</em>. <em>f</em> shall meet the requirements of MoveConstructible.<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </li>
<li><code class="docutils literal notranslate"><span class="pre">I</span></code>: The type of the iteration variable. This could be an (forward) iterator type or an integral type. </li>
<li><code class="docutils literal notranslate"><span class="pre">Args</span></code>: A parameter pack, it’s last element is a function object to be invoked for each iteration, the others have to be either conforming to the induction or reduction concept.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">args</span></code>: The last element of this parameter pack is the function (object) to invoke, while the remaining elements of the parameter pack are instances of either induction or reduction objects. The function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last) should expose a signature equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">ignored</span><span class="o">&gt;</span> <span class="n">pred</span><span class="p">(</span><span class="n">I</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="p">...);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;. It will receive the current value of the iteration variable and one argument for each of the induction or reduction objects passed to the algorithms, representing their current values.</p>
</li>
</ul>
</dd>
</dl>
</p>
<p>Effects: Applies <em>f</em> to each element in the input sequence, with additional arguments corresponding to the reductions and inductions in the <em>args</em> parameter pack. The length of the input sequence is last - first.</p>
<p>The first element in the input sequence is specified by <em>first</em>. Each subsequent element is generated by incrementing the previous element.</p>
<p><p>Along with an element from the input sequence, for each member of the </p>
<em>args</em> parameter pack excluding <em>f</em>, an additional argument is passed to each application of <em>f</em> as follows:<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>As described in the C++ standard, arithmetic on non-random-access iterators is performed using advance and distance.</dd>
<dt><strong>Note</strong></dt>
<dd>The order of the elements of the input sequence is important for determining ordinal position of an application of <em>f</em>, even though the applications themselves may be unordered.</dd>
</dl>
</p>
<p>If the pack member is an object returned by a call to a reduction function listed in section, then the additional argument is a reference to a view of that reduction object. If the pack member is an object returned by a call to induction, then the additional argument is the induction value for that induction object corresponding to the position of the application of <em>f</em> in the input sequence.</p>
<p>Complexity: Applies <em>f</em> exactly once for each element of the input sequence.</p>
<p>Remarks: If <em>f</em> returns a result, the result is ignored.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>for_loop</em> algorithm returns a <em>hpx::future&lt;void&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>void</em> otherwise. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v28for_loopENSt5decayI1IE4typeE1IDpRR4Args">
<span id="_CPPv2N3hpx8parallel2v28for_loopENSt5decayI1IE4typeE1IDpRR4Args"></span><span id="hpx::parallel::v2::for_loop__std::decay:I:::type.I.ArgsRRDp"></span><em class="property">template </em>&lt;<em class="property">typename</em> I, typename... <em>Args</em>&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v2_1ae8a4d624a15eba516f03df8d84df9215"></span>void <code class="descname">for_loop</code><span class="sig-paren">(</span><em class="property">typename</em> std::decay&lt;I&gt;::type <em>first</em>, I <em>last</em>, Args&amp;&amp;... <em>args</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v28for_loopENSt5decayI1IE4typeE1IDpRR4Args" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The for_loop implements loop functionality over a range specified by integral or iterator bounds. For the iterator case, these algorithms resemble for_each from the Parallelism TS, but leave to the programmer when and if to dereference the iterator.</p>
<p>The execution of for_loop without specifying an execution policy is equivalent to specifying <em><a class="reference internal" href="#namespacehpx_1_1parallel_1_1execution_1aa42dc9cec2bf4586b8f5f236637db308"><span class="std std-ref">parallel::execution::seq</span></a></em> as the execution policy.</p>
<p><p>Requires: </p>
<em>I</em> shall be an integral type or meet the requirements of an input iterator type. The <em>args</em> parameter pack shall have at least one element, comprising objects returned by invocations of <em>reduction</em> and/or <em>induction</em> function templates followed by exactly one element invocable element-access function, <em>f</em>. <em>f</em> shall meet the requirements of MoveConstructible.<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">I</span></code>: The type of the iteration variable. This could be an (forward) iterator type or an integral type. </li>
<li><code class="docutils literal notranslate"><span class="pre">Args</span></code>: A parameter pack, it’s last element is a function object to be invoked for each iteration, the others have to be either conforming to the induction or reduction concept.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">args</span></code>: The last element of this parameter pack is the function (object) to invoke, while the remaining elements of the parameter pack are instances of either induction or reduction objects. The function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last) should expose a signature equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">ignored</span><span class="o">&gt;</span> <span class="n">pred</span><span class="p">(</span><span class="n">I</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="p">...);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;. It will receive the current value of the iteration variable and one argument for each of the induction or reduction objects passed to the algorithms, representing their current values.</p>
</li>
</ul>
</dd>
</dl>
</p>
<p>Effects: Applies <em>f</em> to each element in the input sequence, with additional arguments corresponding to the reductions and inductions in the <em>args</em> parameter pack. The length of the input sequence is last - first.</p>
<p>The first element in the input sequence is specified by <em>first</em>. Each subsequent element is generated by incrementing the previous element.</p>
<p><p>Along with an element from the input sequence, for each member of the </p>
<em>args</em> parameter pack excluding <em>f</em>, an additional argument is passed to each application of <em>f</em> as follows:<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>As described in the C++ standard, arithmetic on non-random-access iterators is performed using advance and distance.</dd>
<dt><strong>Note</strong></dt>
<dd>The order of the elements of the input sequence is important for determining ordinal position of an application of <em>f</em>, even though the applications themselves may be unordered.</dd>
</dl>
</p>
<p>If the pack member is an object returned by a call to a reduction function listed in section, then the additional argument is a reference to a view of that reduction object. If the pack member is an object returned by a call to induction, then the additional argument is the induction value for that induction object corresponding to the position of the application of <em>f</em> in the input sequence.</p>
<p>Complexity: Applies <em>f</em> exactly once for each element of the input sequence.</p>
<p>Remarks: If <em>f</em> returns a result, the result is ignored. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v216for_loop_stridedERR8ExPolicyNSt5decayI1IE4typeE1I1SDpRR4Args">
<span id="_CPPv2N3hpx8parallel2v216for_loop_stridedERR8ExPolicyNSt5decayI1IE4typeE1I1SDpRR4Args"></span><span id="hpx::parallel::v2::for_loop_strided__ExPolicyRR.std::decay:I:::type.I.S.ArgsRRDp"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> I, <em class="property">typename</em> S, typename... <em>Args</em>, &amp;&amp;std::is_integral&lt; S &gt;::value&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v2_1ad463dfcd2eb83e031cc403402a0d91e4"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy&gt;::type <code class="descname">for_loop_strided</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, <em class="property">typename</em> std::decay&lt;I&gt;::type <em>first</em>, I <em>last</em>, S <em>stride</em>, Args&amp;&amp;... <em>args</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v216for_loop_stridedERR8ExPolicyNSt5decayI1IE4typeE1I1SDpRR4Args" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The for_loop_strided implements loop functionality over a range specified by integral or iterator bounds. For the iterator case, these algorithms resemble for_each from the Parallelism TS, but leave to the programmer when and if to dereference the iterator.</p>
<p><p>Requires: </p>
<em>I</em> shall be an integral type or meet the requirements of an input iterator type. The <em>args</em> parameter pack shall have at least one element, comprising objects returned by invocations of <em>reduction</em> and/or <em>induction</em> function templates followed by exactly one element invocable element-access function, <em>f</em>. <em>f</em> shall meet the requirements of MoveConstructible.<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </li>
<li><code class="docutils literal notranslate"><span class="pre">I</span></code>: The type of the iteration variable. This could be an (forward) iterator type or an integral type. </li>
<li><code class="docutils literal notranslate"><span class="pre">S</span></code>: The type of the stride variable. This should be an integral type. </li>
<li><code class="docutils literal notranslate"><span class="pre">Args</span></code>: A parameter pack, it’s last element is a function object to be invoked for each iteration, the others have to be either conforming to the induction or reduction concept.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">stride</span></code>: Refers to the stride of the iteration steps. This shall have non-zero value and shall be negative only if I has integral type or meets the requirements of a bidirectional iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">args</span></code>: The last element of this parameter pack is the function (object) to invoke, while the remaining elements of the parameter pack are instances of either induction or reduction objects. The function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last) should expose a signature equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">ignored</span><span class="o">&gt;</span> <span class="n">pred</span><span class="p">(</span><span class="n">I</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="p">...);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;. It will receive the current value of the iteration variable and one argument for each of the induction or reduction objects passed to the algorithms, representing their current values.</p>
</li>
</ul>
</dd>
</dl>
</p>
<p>Effects: Applies <em>f</em> to each element in the input sequence, with additional arguments corresponding to the reductions and inductions in the <em>args</em> parameter pack. The length of the input sequence is last - first.</p>
<p>The first element in the input sequence is specified by <em>first</em>. Each subsequent element is generated by incrementing the previous element.</p>
<p><p>Along with an element from the input sequence, for each member of the </p>
<em>args</em> parameter pack excluding <em>f</em>, an additional argument is passed to each application of <em>f</em> as follows:<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>As described in the C++ standard, arithmetic on non-random-access iterators is performed using advance and distance.</dd>
<dt><strong>Note</strong></dt>
<dd>The order of the elements of the input sequence is important for determining ordinal position of an application of <em>f</em>, even though the applications themselves may be unordered.</dd>
</dl>
</p>
<p>If the pack member is an object returned by a call to a reduction function listed in section, then the additional argument is a reference to a view of that reduction object. If the pack member is an object returned by a call to induction, then the additional argument is the induction value for that induction object corresponding to the position of the application of <em>f</em> in the input sequence.</p>
<p>Complexity: Applies <em>f</em> exactly once for each element of the input sequence.</p>
<p>Remarks: If <em>f</em> returns a result, the result is ignored.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>for_loop_strided</em> algorithm returns a <em>hpx::future&lt;void&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>void</em> otherwise. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v216for_loop_stridedENSt5decayI1IE4typeE1I1SDpRR4Args">
<span id="_CPPv2N3hpx8parallel2v216for_loop_stridedENSt5decayI1IE4typeE1I1SDpRR4Args"></span><span id="hpx::parallel::v2::for_loop_strided__std::decay:I:::type.I.S.ArgsRRDp"></span><em class="property">template </em>&lt;<em class="property">typename</em> I, <em class="property">typename</em> S, typename... <em>Args</em>, &amp;&amp;std::is_integral&lt; S &gt;::value&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v2_1a1f410bcfe5d10f47c397e8676758d1b8"></span>void <code class="descname">for_loop_strided</code><span class="sig-paren">(</span><em class="property">typename</em> std::decay&lt;I&gt;::type <em>first</em>, I <em>last</em>, S <em>stride</em>, Args&amp;&amp;... <em>args</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v216for_loop_stridedENSt5decayI1IE4typeE1I1SDpRR4Args" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The for_loop_strided implements loop functionality over a range specified by integral or iterator bounds. For the iterator case, these algorithms resemble for_each from the Parallelism TS, but leave to the programmer when and if to dereference the iterator.</p>
<p>The execution of for_loop without specifying an execution policy is equivalent to specifying <em><a class="reference internal" href="#namespacehpx_1_1parallel_1_1execution_1aa42dc9cec2bf4586b8f5f236637db308"><span class="std std-ref">parallel::execution::seq</span></a></em> as the execution policy.</p>
<p><p>Requires: </p>
<em>I</em> shall be an integral type or meet the requirements of an input iterator type. The <em>args</em> parameter pack shall have at least one element, comprising objects returned by invocations of <em>reduction</em> and/or <em>induction</em> function templates followed by exactly one element invocable element-access function, <em>f</em>. <em>f</em> shall meet the requirements of MoveConstructible.<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">I</span></code>: The type of the iteration variable. This could be an (forward) iterator type or an integral type. </li>
<li><code class="docutils literal notranslate"><span class="pre">S</span></code>: The type of the stride variable. This should be an integral type. </li>
<li><code class="docutils literal notranslate"><span class="pre">Args</span></code>: A parameter pack, it’s last element is a function object to be invoked for each iteration, the others have to be either conforming to the induction or reduction concept.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">last</span></code>: Refers to the end of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">stride</span></code>: Refers to the stride of the iteration steps. This shall have non-zero value and shall be negative only if I has integral type or meets the requirements of a bidirectional iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">args</span></code>: The last element of this parameter pack is the function (object) to invoke, while the remaining elements of the parameter pack are instances of either induction or reduction objects. The function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last) should expose a signature equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">ignored</span><span class="o">&gt;</span> <span class="n">pred</span><span class="p">(</span><span class="n">I</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="p">...);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;. It will receive the current value of the iteration variable and one argument for each of the induction or reduction objects passed to the algorithms, representing their current values.</p>
</li>
</ul>
</dd>
</dl>
</p>
<p>Effects: Applies <em>f</em> to each element in the input sequence, with additional arguments corresponding to the reductions and inductions in the <em>args</em> parameter pack. The length of the input sequence is last - first.</p>
<p>The first element in the input sequence is specified by <em>first</em>. Each subsequent element is generated by incrementing the previous element.</p>
<p><p>Along with an element from the input sequence, for each member of the </p>
<em>args</em> parameter pack excluding <em>f</em>, an additional argument is passed to each application of <em>f</em> as follows:<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>As described in the C++ standard, arithmetic on non-random-access iterators is performed using advance and distance.</dd>
<dt><strong>Note</strong></dt>
<dd>The order of the elements of the input sequence is important for determining ordinal position of an application of <em>f</em>, even though the applications themselves may be unordered.</dd>
</dl>
</p>
<p>If the pack member is an object returned by a call to a reduction function listed in section, then the additional argument is a reference to a view of that reduction object. If the pack member is an object returned by a call to induction, then the additional argument is the induction value for that induction object corresponding to the position of the application of <em>f</em> in the input sequence.</p>
<p>Complexity: Applies <em>f</em> exactly once for each element of the input sequence.</p>
<p>Remarks: If <em>f</em> returns a result, the result is ignored. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v210for_loop_nERR8ExPolicy1I4SizeDpRR4Args">
<span id="_CPPv2N3hpx8parallel2v210for_loop_nERR8ExPolicy1I4SizeDpRR4Args"></span><span id="hpx::parallel::v2::for_loop_n__ExPolicyRR.I.Size.ArgsRRDp"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> I, <em class="property">typename</em> Size, typename... <em>Args</em>, &amp;&amp;std::is_integral&lt; Size &gt;::value&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v2_1a752b271ba967b563d9541c26e8758734"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy&gt;::type <code class="descname">for_loop_n</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, I <em>first</em>, Size <em>size</em>, Args&amp;&amp;... <em>args</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v210for_loop_nERR8ExPolicy1I4SizeDpRR4Args" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The for_loop_n implements loop functionality over a range specified by integral or iterator bounds. For the iterator case, these algorithms resemble for_each from the Parallelism TS, but leave to the programmer when and if to dereference the iterator.</p>
<p><p>Requires: </p>
<em>I</em> shall be an integral type or meet the requirements of an input iterator type. The <em>args</em> parameter pack shall have at least one element, comprising objects returned by invocations of <em>reduction</em> and/or <em>induction</em> function templates followed by exactly one element invocable element-access function, <em>f</em>. <em>f</em> shall meet the requirements of MoveConstructible.<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </li>
<li><code class="docutils literal notranslate"><span class="pre">I</span></code>: The type of the iteration variable. This could be an (forward) iterator type or an integral type. </li>
<li><code class="docutils literal notranslate"><span class="pre">Size</span></code>: The type of a non-negative integral value specifying the number of items to iterate over. </li>
<li><code class="docutils literal notranslate"><span class="pre">Args</span></code>: A parameter pack, it’s last element is a function object to be invoked for each iteration, the others have to be either conforming to the induction or reduction concept.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: Refers to the number of items the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">args</span></code>: The last element of this parameter pack is the function (object) to invoke, while the remaining elements of the parameter pack are instances of either induction or reduction objects. The function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last) should expose a signature equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">ignored</span><span class="o">&gt;</span> <span class="n">pred</span><span class="p">(</span><span class="n">I</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="p">...);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;. It will receive the current value of the iteration variable and one argument for each of the induction or reduction objects passed to the algorithms, representing their current values.</p>
</li>
</ul>
</dd>
</dl>
</p>
<p>Effects: Applies <em>f</em> to each element in the input sequence, with additional arguments corresponding to the reductions and inductions in the <em>args</em> parameter pack. The length of the input sequence is last - first.</p>
<p>The first element in the input sequence is specified by <em>first</em>. Each subsequent element is generated by incrementing the previous element.</p>
<p><p>Along with an element from the input sequence, for each member of the </p>
<em>args</em> parameter pack excluding <em>f</em>, an additional argument is passed to each application of <em>f</em> as follows:<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>As described in the C++ standard, arithmetic on non-random-access iterators is performed using advance and distance.</dd>
<dt><strong>Note</strong></dt>
<dd>The order of the elements of the input sequence is important for determining ordinal position of an application of <em>f</em>, even though the applications themselves may be unordered.</dd>
</dl>
</p>
<p>If the pack member is an object returned by a call to a reduction function listed in section, then the additional argument is a reference to a view of that reduction object. If the pack member is an object returned by a call to induction, then the additional argument is the induction value for that induction object corresponding to the position of the application of <em>f</em> in the input sequence.</p>
<p>Complexity: Applies <em>f</em> exactly once for each element of the input sequence.</p>
<p>Remarks: If <em>f</em> returns a result, the result is ignored.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>for_loop_n</em> algorithm returns a <em>hpx::future&lt;void&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>void</em> otherwise. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v210for_loop_nE1I4SizeDpRR4Args">
<span id="_CPPv2N3hpx8parallel2v210for_loop_nE1I4SizeDpRR4Args"></span><span id="hpx::parallel::v2::for_loop_n__I.Size.ArgsRRDp"></span><em class="property">template </em>&lt;<em class="property">typename</em> I, <em class="property">typename</em> Size, typename... <em>Args</em>, &amp;&amp;std::is_integral&lt; Size &gt;::value&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v2_1a7e65fb50c96e09d2f9ba296726d9f82d"></span>void <code class="descname">for_loop_n</code><span class="sig-paren">(</span>I <em>first</em>, Size <em>size</em>, Args&amp;&amp;... <em>args</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v210for_loop_nE1I4SizeDpRR4Args" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The for_loop implements loop functionality over a range specified by integral or iterator bounds. For the iterator case, these algorithms resemble for_each from the Parallelism TS, but leave to the programmer when and if to dereference the iterator.</p>
<p>The execution of for_loop without specifying an execution policy is equivalent to specifying <em><a class="reference internal" href="#namespacehpx_1_1parallel_1_1execution_1aa42dc9cec2bf4586b8f5f236637db308"><span class="std std-ref">parallel::execution::seq</span></a></em> as the execution policy.</p>
<p><p>Requires: </p>
<em>I</em> shall be an integral type or meet the requirements of an input iterator type. The <em>args</em> parameter pack shall have at least one element, comprising objects returned by invocations of <em>reduction</em> and/or <em>induction</em> function templates followed by exactly one element invocable element-access function, <em>f</em>. <em>f</em> shall meet the requirements of MoveConstructible.<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">I</span></code>: The type of the iteration variable. This could be an (forward) iterator type or an integral type. </li>
<li><code class="docutils literal notranslate"><span class="pre">Size</span></code>: The type of a non-negative integral value specifying the number of items to iterate over. </li>
<li><code class="docutils literal notranslate"><span class="pre">Args</span></code>: A parameter pack, it’s last element is a function object to be invoked for each iteration, the others have to be either conforming to the induction or reduction concept.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: Refers to the number of items the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">args</span></code>: The last element of this parameter pack is the function (object) to invoke, while the remaining elements of the parameter pack are instances of either induction or reduction objects. The function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last) should expose a signature equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">ignored</span><span class="o">&gt;</span> <span class="n">pred</span><span class="p">(</span><span class="n">I</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="p">...);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;. It will receive the current value of the iteration variable and one argument for each of the induction or reduction objects passed to the algorithms, representing their current values.</p>
</li>
</ul>
</dd>
</dl>
</p>
<p>Effects: Applies <em>f</em> to each element in the input sequence, with additional arguments corresponding to the reductions and inductions in the <em>args</em> parameter pack. The length of the input sequence is last - first.</p>
<p>The first element in the input sequence is specified by <em>first</em>. Each subsequent element is generated by incrementing the previous element.</p>
<p><p>Along with an element from the input sequence, for each member of the </p>
<em>args</em> parameter pack excluding <em>f</em>, an additional argument is passed to each application of <em>f</em> as follows:<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>As described in the C++ standard, arithmetic on non-random-access iterators is performed using advance and distance.</dd>
<dt><strong>Note</strong></dt>
<dd>The order of the elements of the input sequence is important for determining ordinal position of an application of <em>f</em>, even though the applications themselves may be unordered.</dd>
</dl>
</p>
<p>If the pack member is an object returned by a call to a reduction function listed in section, then the additional argument is a reference to a view of that reduction object. If the pack member is an object returned by a call to induction, then the additional argument is the induction value for that induction object corresponding to the position of the application of <em>f</em> in the input sequence.</p>
<p>Complexity: Applies <em>f</em> exactly once for each element of the input sequence.</p>
<p>Remarks: If <em>f</em> returns a result, the result is ignored. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v218for_loop_n_stridedERR8ExPolicy1I4Size1SDpRR4Args">
<span id="_CPPv2N3hpx8parallel2v218for_loop_n_stridedERR8ExPolicy1I4Size1SDpRR4Args"></span><span id="hpx::parallel::v2::for_loop_n_strided__ExPolicyRR.I.Size.S.ArgsRRDp"></span><em class="property">template </em>&lt;<em class="property">typename</em> ExPolicy, <em class="property">typename</em> I, <em class="property">typename</em> Size, <em class="property">typename</em> S, typename... <em>Args</em>, &amp;&amp;std::is_integral&lt; Size &gt;::value &amp;&amp;std::is_integral&lt; S &gt;::value&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v2_1aa4c8b229a961f9161b1dfd818309f59a"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::detail::algorithm_result&lt;ExPolicy&gt;::type <code class="descname">for_loop_n_strided</code><span class="sig-paren">(</span>ExPolicy &amp;&amp;<em>policy</em>, I <em>first</em>, Size <em>size</em>, S <em>stride</em>, Args&amp;&amp;... <em>args</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v218for_loop_n_stridedERR8ExPolicy1I4Size1SDpRR4Args" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The for_loop_n_strided implements loop functionality over a range specified by integral or iterator bounds. For the iterator case, these algorithms resemble for_each from the Parallelism TS, but leave to the programmer when and if to dereference the iterator.</p>
<p><p>Requires: </p>
<em>I</em> shall be an integral type or meet the requirements of an input iterator type. The <em>args</em> parameter pack shall have at least one element, comprising objects returned by invocations of <em>reduction</em> and/or <em>induction</em> function templates followed by exactly one element invocable element-access function, <em>f</em>. <em>f</em> shall meet the requirements of MoveConstructible.<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ExPolicy</span></code>: The type of the execution policy to use (deduced). It describes the manner in which the execution of the algorithm may be parallelized and the manner in which it applies user-provided function objects. </li>
<li><code class="docutils literal notranslate"><span class="pre">I</span></code>: The type of the iteration variable. This could be an (forward) iterator type or an integral type. </li>
<li><code class="docutils literal notranslate"><span class="pre">Size</span></code>: The type of a non-negative integral value specifying the number of items to iterate over. </li>
<li><code class="docutils literal notranslate"><span class="pre">S</span></code>: The type of the stride variable. This should be an integral type. </li>
<li><code class="docutils literal notranslate"><span class="pre">Args</span></code>: A parameter pack, it’s last element is a function object to be invoked for each iteration, the others have to be either conforming to the induction or reduction concept.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">policy</span></code>: The execution policy to use for the scheduling of the iterations. </li>
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: Refers to the number of items the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">stride</span></code>: Refers to the stride of the iteration steps. This shall have non-zero value and shall be negative only if I has integral type or meets the requirements of a bidirectional iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">args</span></code>: The last element of this parameter pack is the function (object) to invoke, while the remaining elements of the parameter pack are instances of either induction or reduction objects. The function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last) should expose a signature equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">ignored</span><span class="o">&gt;</span> <span class="n">pred</span><span class="p">(</span><span class="n">I</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="p">...);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;. It will receive the current value of the iteration variable and one argument for each of the induction or reduction objects passed to the algorithms, representing their current values.</p>
</li>
</ul>
</dd>
</dl>
</p>
<p>Effects: Applies <em>f</em> to each element in the input sequence, with additional arguments corresponding to the reductions and inductions in the <em>args</em> parameter pack. The length of the input sequence is last - first.</p>
<p>The first element in the input sequence is specified by <em>first</em>. Each subsequent element is generated by incrementing the previous element.</p>
<p><p>Along with an element from the input sequence, for each member of the </p>
<em>args</em> parameter pack excluding <em>f</em>, an additional argument is passed to each application of <em>f</em> as follows:<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>As described in the C++ standard, arithmetic on non-random-access iterators is performed using advance and distance.</dd>
<dt><strong>Note</strong></dt>
<dd>The order of the elements of the input sequence is important for determining ordinal position of an application of <em>f</em>, even though the applications themselves may be unordered.</dd>
</dl>
</p>
<p>If the pack member is an object returned by a call to a reduction function listed in section, then the additional argument is a reference to a view of that reduction object. If the pack member is an object returned by a call to induction, then the additional argument is the induction value for that induction object corresponding to the position of the application of <em>f</em> in the input sequence.</p>
<p>Complexity: Applies <em>f</em> exactly once for each element of the input sequence.</p>
<p>Remarks: If <em>f</em> returns a result, the result is ignored.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The <em>for_loop_n_strided</em> algorithm returns a <em>hpx::future&lt;void&gt;</em> if the execution policy is of type <em>sequenced_task_policy</em> or <em>parallel_task_policy</em> and returns <em>void</em> otherwise. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v218for_loop_n_stridedE1I4Size1SDpRR4Args">
<span id="_CPPv2N3hpx8parallel2v218for_loop_n_stridedE1I4Size1SDpRR4Args"></span><span id="hpx::parallel::v2::for_loop_n_strided__I.Size.S.ArgsRRDp"></span><em class="property">template </em>&lt;<em class="property">typename</em> I, <em class="property">typename</em> Size, <em class="property">typename</em> S, typename... <em>Args</em>, &amp;&amp;std::is_integral&lt; Size &gt;::value &amp;&amp;std::is_integral&lt; S &gt;::value&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v2_1ab632abf48b39fa6e2e90c588277a41d1"></span>void <code class="descname">for_loop_n_strided</code><span class="sig-paren">(</span>I <em>first</em>, Size <em>size</em>, S <em>stride</em>, Args&amp;&amp;... <em>args</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v218for_loop_n_stridedE1I4Size1SDpRR4Args" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The for_loop_n_strided implements loop functionality over a range specified by integral or iterator bounds. For the iterator case, these algorithms resemble for_each from the Parallelism TS, but leave to the programmer when and if to dereference the iterator.</p>
<p>The execution of for_loop without specifying an execution policy is equivalent to specifying <em><a class="reference internal" href="#namespacehpx_1_1parallel_1_1execution_1aa42dc9cec2bf4586b8f5f236637db308"><span class="std std-ref">parallel::execution::seq</span></a></em> as the execution policy.</p>
<p><p>Requires: </p>
<em>I</em> shall be an integral type or meet the requirements of an input iterator type. The <em>args</em> parameter pack shall have at least one element, comprising objects returned by invocations of <em>reduction</em> and/or <em>induction</em> function templates followed by exactly one element invocable element-access function, <em>f</em>. <em>f</em> shall meet the requirements of MoveConstructible.<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">I</span></code>: The type of the iteration variable. This could be an (forward) iterator type or an integral type. </li>
<li><code class="docutils literal notranslate"><span class="pre">Size</span></code>: The type of a non-negative integral value specifying the number of items to iterate over. </li>
<li><code class="docutils literal notranslate"><span class="pre">S</span></code>: The type of the stride variable. This should be an integral type. </li>
<li><code class="docutils literal notranslate"><span class="pre">Args</span></code>: A parameter pack, it’s last element is a function object to be invoked for each iteration, the others have to be either conforming to the induction or reduction concept.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">first</span></code>: Refers to the beginning of the sequence of elements the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">size</span></code>: Refers to the number of items the algorithm will be applied to. </li>
<li><code class="docutils literal notranslate"><span class="pre">stride</span></code>: Refers to the stride of the iteration steps. This shall have non-zero value and shall be negative only if I has integral type or meets the requirements of a bidirectional iterator. </li>
<li><code class="docutils literal notranslate"><span class="pre">args</span></code>: The last element of this parameter pack is the function (object) to invoke, while the remaining elements of the parameter pack are instances of either induction or reduction objects. The function (or function object) which will be invoked for each of the elements in the sequence specified by [first, last) should expose a signature equivalent to: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="o">&lt;</span><span class="n">ignored</span><span class="o">&gt;</span> <span class="n">pred</span><span class="p">(</span><span class="n">I</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="p">...);</span>
</pre></div>
</div>
 <p> The signature does not need to have const&amp;. It will receive the current value of the iteration variable and one argument for each of the induction or reduction objects passed to the algorithms, representing their current values.</p>
</li>
</ul>
</dd>
</dl>
</p>
<p>Effects: Applies <em>f</em> to each element in the input sequence, with additional arguments corresponding to the reductions and inductions in the <em>args</em> parameter pack. The length of the input sequence is last - first.</p>
<p>The first element in the input sequence is specified by <em>first</em>. Each subsequent element is generated by incrementing the previous element.</p>
<p><p>Along with an element from the input sequence, for each member of the </p>
<em>args</em> parameter pack excluding <em>f</em>, an additional argument is passed to each application of <em>f</em> as follows:<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>As described in the C++ standard, arithmetic on non-random-access iterators is performed using advance and distance.</dd>
<dt><strong>Note</strong></dt>
<dd>The order of the elements of the input sequence is important for determining ordinal position of an application of <em>f</em>, even though the applications themselves may be unordered.</dd>
</dl>
</p>
<p>If the pack member is an object returned by a call to a reduction function listed in section, then the additional argument is a reference to a view of that reduction object. If the pack member is an object returned by a call to induction, then the additional argument is the induction value for that induction object corresponding to the position of the application of <em>f</em> in the input sequence.</p>
<p>Complexity: Applies <em>f</em> exactly once for each element of the input sequence.</p>
<p>Remarks: If <em>f</em> returns a result, the result is ignored. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v29inductionERR1TNSt6size_tE">
<span id="_CPPv2N3hpx8parallel2v29inductionERR1TNSt6size_tE"></span><span id="hpx::parallel::v2::induction__TRR.std::s"></span><em class="property">template </em>&lt;<em class="property">typename</em> T&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v2_1a98dd8d7295299a30ba869b782d6bd1f8"></span>detail::induction_stride_helper&lt;T&gt; <code class="descname">induction</code><span class="sig-paren">(</span>T &amp;&amp;<em>value</em>, std::size_t <em>stride</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v29inductionERR1TNSt6size_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function template returns an induction object of unspecified type having a value type and encapsulating an initial value <em>value</em> of that type and, optionally, a stride.</p>
<p>For each element in the input range, a looping algorithm over input sequence <em>S</em> computes an induction value from an induction variable and ordinal position <em>p</em> within <em>S</em> by the formula i + p * stride if a stride was specified or i + p otherwise. This induction value is passed to the element access function.</p>
<p>If the <em>value</em> argument to <em>induction</em> is a non-const lvalue, then that lvalue becomes the live-out object for the returned induction object. For each induction object that has a live-out object, the looping algorithm assigns the value of i + n * stride to the live-out object upon return, where <em>n</em> is the number of elements in the input range.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>This returns an induction object with value type <em>T</em>, initial value <em>value</em>, and (if specified) stride <em>stride</em>. If <em>T</em> is an lvalue of non-const type, <em>value</em> is used as the live-out object for the induction object; otherwise there is no live-out object. </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The value type to be used by the induction object.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">value</span></code>: [in] The initial value to use for the induction object </li>
<li><code class="docutils literal notranslate"><span class="pre">stride</span></code>: [in] The (optional) stride to use for the induction object (default: 1)</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8parallel2v29reductionER1TR1TRR2Op">
<span id="_CPPv2N3hpx8parallel2v29reductionER1TR1TRR2Op"></span><span id="hpx::parallel::v2::reduction__TR.TCR.OpRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> T, <em class="property">typename</em> Op&gt;<br /><span class="target" id="namespacehpx_1_1parallel_1_1v2_1a91790c50467a62ae722eb502621f84dc"></span>detail::reduction_helper&lt;T, <em class="property">typename</em> std::decay&lt;Op&gt;::type&gt; <code class="descname">reduction</code><span class="sig-paren">(</span>T &amp;<em>var</em>, T <em class="property">const</em> &amp;<em>identity</em>, Op &amp;&amp;<em>combiner</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8parallel2v29reductionER1TR1TRR2Op" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function template returns a reduction object of unspecified type having a value type and encapsulating an identity value for the reduction, a combiner function object, and a live-out object from which the initial value is obtained and into which the final value is stored.</p>
<p>A parallel algorithm uses reduction objects by allocating an unspecified number of instances, called views, of the reduction’s value type. Each view is initialized with the reduction object’s identity value, except that the live-out object (which was initialized by the caller) comprises one of the views. The algorithm passes a reference to a view to each application of an element-access function, ensuring that no two concurrently-executing invocations share the same view. A view can be shared between two applications that do not execute concurrently, but initialization is performed only once per view.</p>
<p>Modifications to the view by the application of element access functions accumulate as partial results. At some point before the algorithm returns, the partial results are combined, two at a time, using the reduction object’s combiner operation until a single value remains, which is then assigned back to the live-out object.</p>
<p><p>T shall meet the requirements of CopyConstructible and MoveAssignable. The expression var = combiner(var, var) shall be well formed.</p>
<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: The value type to be used by the induction object. </li>
<li><code class="docutils literal notranslate"><span class="pre">Op</span></code>: The type of the binary function (object) used to perform the reduction operation.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">var</span></code>: [in,out] The life-out value to use for the reduction object. This will hold the reduced value after the algorithm is finished executing. </li>
<li><code class="docutils literal notranslate"><span class="pre">identity</span></code>: [in] The identity value to use for the reduction operation. </li>
<li><code class="docutils literal notranslate"><span class="pre">combiner</span></code>: [in] The binary function (object) used to perform a pairwise reduction on the elements.</li>
</ul>
</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>In order to produce useful results, modifications to the view should be limited to commutative operations closely related to the combiner operation. For example if the combiner is plus&lt;T&gt;, incrementing the view would be consistent with the combiner but doubling it or assigning to it would not.</dd>
<dt><strong>Return</strong></dt>
<dd>This returns a reduction object of unspecified type having a value type of <em>T</em>. When the return value is used by an algorithm, the reference to <em>var</em> is used as the live-out object, new views are initialized to a copy of identity, and views are combined by invoking the copy of combiner, passing it the two views to be combined. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx20performance_countersE">
<span id="_CPPv2N3hpx20performance_countersE"></span><span id="hpx::performance_counters"></span><span class="target" id="namespacehpx_1_1performance__counters"></span><em class="property">namespace </em><code class="descname">performance_counters</code><a class="headerlink" href="#_CPPv3N3hpx20performance_countersE" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx20performance_counters20install_counter_typeERNSt6stringERN3hpx4util15function_nonserIFNSt7int64_tEbEEERNSt6stringERNSt6stringER10error_code">
<span id="_CPPv2N3hpx20performance_counters20install_counter_typeERNSt6stringERN3hpx4util15function_nonserIFNSt7int64_tEbEEERNSt6stringERNSt6stringER10error_code"></span><span class="target" id="namespacehpx_1_1performance__counters_1a4145b8ec6c6b285ea708fd1ac981431f"></span>counter_status <code class="descname">install_counter_type</code><span class="sig-paren">(</span>std::string <em class="property">const</em> &amp;<em>name</em>, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::function_nonser&lt;std::int64_t<span class="sig-paren">(</span>bool<span class="sig-paren">)</span>&gt; <em class="property">const</em> &amp;<em>counter_value</em>, std::string <em class="property">const</em> &amp;<em>helptext</em> = &quot;&quot;, std::string <em class="property">const</em> &amp;<em>uom</em> = &quot;&quot;, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a>, <span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx20performance_counters20install_counter_typeERNSt6stringERN3hpx4util15function_nonserIFNSt7int64_tEbEEERNSt6stringERNSt6stringER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Install a new generic performance counter type in a way, which will uninstall it automatically during shutdown. </p>
<p>The function <em>install_counter_type</em> will register a new generic counter type based on the provided function. The counter type will be automatically unregistered during system shutdown. Any consumer querying any instance of this this counter type will cause the provided function to be called and the returned value to be exposed as the counter value.</p>
<p>The counter type is registered such that there can be one counter instance per locality. The expected naming scheme for the counter instances is: <code class="docutils literal notranslate"><span class="pre">'/objectname{locality#&lt;*&gt;/total}/countername'</span></code> where ‘&lt;*&gt;’ is a zero based integer identifying the locality the counter is created on.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>As long as <em>ec</em> is not pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> this function doesn’t throw but returns the result code using the parameter <em>ec</em>. Otherwise it throws an instance of <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a>.</dd>
<dt><strong>Return</strong></dt>
<dd>If successful, this function returns <em>status_valid_data</em>, otherwise it will either throw an exception or return an <a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">error_code</span></a> from the enum <em>counter_status</em> (also, see note related to parameter <em>ec</em>).</dd>
<dt><strong>Note</strong></dt>
<dd>The counter type registry is a locality based service. You will have to register each counter type on every locality where a corresponding performance counter will be created. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">name</span></code>: [in] The global virtual name of the counter type. This name is expected to have the format /objectname/countername. </li>
<li><code class="docutils literal notranslate"><span class="pre">counter_value</span></code>: [in] The function to call whenever the counter value is requested by a consumer. </li>
<li><code class="docutils literal notranslate"><span class="pre">helptext</span></code>: [in, optional] A longer descriptive text shown to the user to explain the nature of the counters created from this type. </li>
<li><code class="docutils literal notranslate"><span class="pre">uom</span></code>: [in] The unit of measure for the new performance counter type. </li>
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx20performance_counters20install_counter_typeERNSt6stringERN3hpx4util15function_nonserIFNSt6vectorINSt7int64_tEEEbEEERNSt6stringERNSt6stringER10error_code">
<span id="_CPPv2N3hpx20performance_counters20install_counter_typeERNSt6stringERN3hpx4util15function_nonserIFNSt6vectorINSt7int64_tEEEbEEERNSt6stringERNSt6stringER10error_code"></span><span class="target" id="namespacehpx_1_1performance__counters_1a512827b46aa77a2aeae582d74796dcdc"></span>counter_status <code class="descname">install_counter_type</code><span class="sig-paren">(</span>std::string <em class="property">const</em> &amp;<em>name</em>, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::function_nonser&lt;std::vector&lt;std::int64_t&gt;<span class="sig-paren">(</span>bool<span class="sig-paren">)</span>&gt; <em class="property">const</em> &amp;<em>counter_value</em>, std::string <em class="property">const</em> &amp;<em>helptext</em> = &quot;&quot;, std::string <em class="property">const</em> &amp;<em>uom</em> = &quot;&quot;, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a>, <span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx20performance_counters20install_counter_typeERNSt6stringERN3hpx4util15function_nonserIFNSt6vectorINSt7int64_tEEEbEEERNSt6stringERNSt6stringER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Install a new generic performance counter type returning an array of values in a way, that will uninstall it automatically during shutdown.</p>
<p>The function <em>install_counter_type</em> will register a new generic counter type that returns an array of values based on the provided function. The counter type will be automatically unregistered during system shutdown. Any consumer querying any instance of this this counter type will cause the provided function to be called and the returned array value to be exposed as the counter value.</p>
<p>The counter type is registered such that there can be one counter instance per locality. The expected naming scheme for the counter instances is: <code class="docutils literal notranslate"><span class="pre">'/objectname{locality#&lt;*&gt;/total}/countername'</span></code> where ‘&lt;*&gt;’ is a zero based integer identifying the locality the counter is created on.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>As long as <em>ec</em> is not pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> this function doesn’t throw but returns the result code using the parameter <em>ec</em>. Otherwise it throws an instance of <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a>.</dd>
<dt><strong>Return</strong></dt>
<dd>If successful, this function returns <em>status_valid_data</em>, otherwise it will either throw an exception or return an <a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">error_code</span></a> from the enum <em>counter_status</em> (also, see note related to parameter <em>ec</em>).</dd>
<dt><strong>Note</strong></dt>
<dd>The counter type registry is a locality based service. You will have to register each counter type on every locality where a corresponding performance counter will be created. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">name</span></code>: [in] The global virtual name of the counter type. This name is expected to have the format /objectname/countername. </li>
<li><code class="docutils literal notranslate"><span class="pre">counter_value</span></code>: [in] The function to call whenever the counter value (array of values) is requested by a consumer. </li>
<li><code class="docutils literal notranslate"><span class="pre">helptext</span></code>: [in, optional] A longer descriptive text shown to the user to explain the nature of the counters created from this type. </li>
<li><code class="docutils literal notranslate"><span class="pre">uom</span></code>: [in] The unit of measure for the new performance counter type. </li>
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx20performance_counters20install_counter_typeERNSt6stringE12counter_typeR10error_code">
<span id="_CPPv2N3hpx20performance_counters20install_counter_typeERNSt6stringE12counter_typeR10error_code"></span><span id="hpx::performance_counters::install_counter_type__ssCR.counter_type.error_codeR"></span><span class="target" id="namespacehpx_1_1performance__counters_1a277528fe531a67c7e27f9d006a0262c2"></span>void <code class="descname">install_counter_type</code><span class="sig-paren">(</span>std::string <em class="property">const</em> &amp;<em>name</em>, counter_type <em>type</em>, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx20performance_counters20install_counter_typeERNSt6stringE12counter_typeR10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Install a new performance counter type in a way, which will uninstall it automatically during shutdown. </p>
<p>The function <em>install_counter_type</em> will register a new counter type based on the provided <em>counter_type_info</em>. The counter type will be automatically unregistered during system shutdown.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>If successful, this function returns <em>status_valid_data</em>, otherwise it will either throw an exception or return an <a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">error_code</span></a> from the enum <em>counter_status</em> (also, see note related to parameter <em>ec</em>).</dd>
<dt><strong>Note</strong></dt>
<dd>The counter type registry is a locality based service. You will have to register each counter type on every locality where a corresponding performance counter will be created.</dd>
<dt><strong>Note</strong></dt>
<dd>As long as <em>ec</em> is not pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> this function doesn’t throw but returns the result code using the parameter <em>ec</em>. Otherwise it throws an instance of <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">name</span></code>: [in] The global virtual name of the counter type. This name is expected to have the format /objectname/countername. </li>
<li><code class="docutils literal notranslate"><span class="pre">type</span></code>: [in] The type of the counters of this counter_type. </li>
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx20performance_counters20install_counter_typeERNSt6stringE12counter_typeRNSt6stringERNSt6stringENSt8uint32_tER10error_code">
<span id="_CPPv2N3hpx20performance_counters20install_counter_typeERNSt6stringE12counter_typeRNSt6stringERNSt6stringENSt8uint32_tER10error_code"></span><span id="hpx::performance_counters::install_counter_type__ssCR.counter_type.ssCR.ssCR.std::uint32_t.error_codeR"></span><span class="target" id="namespacehpx_1_1performance__counters_1a0c073f0969350d0d1b69c78a2389b46c"></span>counter_status <code class="descname">install_counter_type</code><span class="sig-paren">(</span>std::string <em class="property">const</em> &amp;<em>name</em>, counter_type <em>type</em>, std::string <em class="property">const</em> &amp;<em>helptext</em>, std::string <em class="property">const</em> &amp;<em>uom</em> = &quot;&quot;, std::uint32_t <em>version</em> = HPX_PERFORMANCE_COUNTER_V1, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx20performance_counters20install_counter_typeERNSt6stringE12counter_typeRNSt6stringERNSt6stringENSt8uint32_tER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Install a new performance counter type in a way, which will uninstall it automatically during shutdown. </p>
<p>The function <em>install_counter_type</em> will register a new counter type based on the provided <em>counter_type_info</em>. The counter type will be automatically unregistered during system shutdown.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>If successful, this function returns <em>status_valid_data</em>, otherwise it will either throw an exception or return an <a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">error_code</span></a> from the enum <em>counter_status</em> (also, see note related to parameter <em>ec</em>).</dd>
<dt><strong>Note</strong></dt>
<dd>The counter type registry is a locality based service. You will have to register each counter type on every locality where a corresponding performance counter will be created.</dd>
<dt><strong>Note</strong></dt>
<dd>As long as <em>ec</em> is not pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> this function doesn’t throw but returns the result code using the parameter <em>ec</em>. Otherwise it throws an instance of <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">name</span></code>: [in] The global virtual name of the counter type. This name is expected to have the format /objectname/countername. </li>
<li><code class="docutils literal notranslate"><span class="pre">type</span></code>: [in] The type of the counters of this counter_type. </li>
<li><code class="docutils literal notranslate"><span class="pre">helptext</span></code>: [in] A longer descriptive text shown to the user to explain the nature of the counters created from this type. </li>
<li><code class="docutils literal notranslate"><span class="pre">uom</span></code>: [in] The unit of measure for the new performance counter type. </li>
<li><code class="docutils literal notranslate"><span class="pre">version</span></code>: [in] The version of the counter type. This is currently expected to be set to HPX_PERFORMANCE_COUNTER_V1. </li>
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx20performance_counters20install_counter_typeERNSt6stringE12counter_typeRNSt6stringER19create_counter_funcR22discover_counters_funcNSt8uint32_tERNSt6stringER10error_code">
<span id="_CPPv2N3hpx20performance_counters20install_counter_typeERNSt6stringE12counter_typeRNSt6stringER19create_counter_funcR22discover_counters_funcNSt8uint32_tERNSt6stringER10error_code"></span><span id="hpx::performance_counters::install_counter_type__ssCR.counter_type.ssCR.create_counter_funcCR.discover_counters_funcCR.std::uint32_t.ssCR.error_codeR"></span><span class="target" id="namespacehpx_1_1performance__counters_1a5ebccbe19d974595deefd7e6b89f9e11"></span>counter_status <code class="descname">install_counter_type</code><span class="sig-paren">(</span>std::string <em class="property">const</em> &amp;<em>name</em>, counter_type <em>type</em>, std::string <em class="property">const</em> &amp;<em>helptext</em>, create_counter_func <em class="property">const</em> &amp;<em>create_counter</em>, discover_counters_func <em class="property">const</em> &amp;<em>discover_counters</em>, std::uint32_t <em>version</em> = HPX_PERFORMANCE_COUNTER_V1, std::string <em class="property">const</em> &amp;<em>uom</em> = &quot;&quot;, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx20performance_counters20install_counter_typeERNSt6stringE12counter_typeRNSt6stringER19create_counter_funcR22discover_counters_funcNSt8uint32_tERNSt6stringER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Install a new generic performance counter type in a way, which will uninstall it automatically during shutdown. </p>
<p>The function <em>install_counter_type</em> will register a new generic counter type based on the provided <em>counter_type_info</em>. The counter type will be automatically unregistered during system shutdown.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>As long as <em>ec</em> is not pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> this function doesn’t throw but returns the result code using the parameter <em>ec</em>. Otherwise it throws an instance of <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a>.</dd>
<dt><strong>Return</strong></dt>
<dd>If successful, this function returns <em>status_valid_data</em>, otherwise it will either throw an exception or return an <a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">error_code</span></a> from the enum <em>counter_status</em> (also, see note related to parameter <em>ec</em>).</dd>
<dt><strong>Note</strong></dt>
<dd>The counter type registry is a locality based service. You will have to register each counter type on every locality where a corresponding performance counter will be created. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">name</span></code>: [in] The global virtual name of the counter type. This name is expected to have the format /objectname/countername. </li>
<li><code class="docutils literal notranslate"><span class="pre">type</span></code>: [in] The type of the counters of this counter_type. </li>
<li><code class="docutils literal notranslate"><span class="pre">helptext</span></code>: [in] A longer descriptive text shown to the user to explain the nature of the counters created from this type. </li>
<li><code class="docutils literal notranslate"><span class="pre">version</span></code>: [in] The version of the counter type. This is currently expected to be set to HPX_PERFORMANCE_COUNTER_V1. </li>
<li><code class="docutils literal notranslate"><span class="pre">create_counter</span></code>: [in] The function which will be called to create a new instance of this counter type. </li>
<li><code class="docutils literal notranslate"><span class="pre">discover_counters</span></code>: [in] The function will be called to discover counter instances which can be created. </li>
<li><code class="docutils literal notranslate"><span class="pre">uom</span></code>: [in] The unit of measure of the counter type (default: “”) </li>
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx8resourceE">
<span id="_CPPv2N3hpx8resourceE"></span><span id="hpx::resource"></span><span class="target" id="namespacehpx_1_1resource"></span><em class="property">namespace </em><code class="descname">resource</code><a class="headerlink" href="#_CPPv3N3hpx8resourceE" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Typedefs</p>
<dl class="type">
<dt>
<span class="target" id="namespacehpx_1_1resource_1a765bace99b609bc9611d4263dfce1ded"></span><em class="property">using </em><code class="descname">hpx::resource::scheduler_function = typedef util::function_nonser&lt; std::unique_ptr&lt;hpx::threads::thread_pool_base&gt;( hpx::threads::policies::callback_notifier&amp;, std::size_t, std::size_t, std::size_t, std::string const&amp; )&gt;</code></dt>
<dd></dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Enums</p>
<dl class="type">
<dt id="_CPPv3N3hpx8resource16partitioner_modeE">
<span id="_CPPv2N3hpx8resource16partitioner_modeE"></span><span id="hpx::resource::partitioner_mode"></span><span class="target" id="namespacehpx_1_1resource_1a6f61180f54b5c833bf76bf7651ee5e17"></span><em class="property">enum </em><code class="descname">partitioner_mode</code><a class="headerlink" href="#_CPPv3N3hpx8resource16partitioner_modeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This enumeration describes the modes available when creating a resource partitioner. </p>
<p><em>Values:</em></p>
<dl class="enumerator">
<dt id="_CPPv3N3hpx8resource12mode_defaultE">
<span id="_CPPv2N3hpx8resource12mode_defaultE"></span><span class="target" id="namespacehpx_1_1resource_1a6f61180f54b5c833bf76bf7651ee5e17aecd54760e4c2642805f16b31aad818e0"></span><code class="descname">mode_default</code> = 0<a class="headerlink" href="#_CPPv3N3hpx8resource12mode_defaultE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Default mode. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx8resource27mode_allow_oversubscriptionE">
<span id="_CPPv2N3hpx8resource27mode_allow_oversubscriptionE"></span><span class="target" id="namespacehpx_1_1resource_1a6f61180f54b5c833bf76bf7651ee5e17a7a903af8bec1ef0cdd0978b8af71f352"></span><code class="descname">mode_allow_oversubscription</code> = 1<a class="headerlink" href="#_CPPv3N3hpx8resource27mode_allow_oversubscriptionE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allow processing units to be oversubscribed, i.e. multiple worker threads to share a single processing unit. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx8resource24mode_allow_dynamic_poolsE">
<span id="_CPPv2N3hpx8resource24mode_allow_dynamic_poolsE"></span><span class="target" id="namespacehpx_1_1resource_1a6f61180f54b5c833bf76bf7651ee5e17a390b02a8c5b07d6293b844fa8f459431"></span><code class="descname">mode_allow_dynamic_pools</code> = 2<a class="headerlink" href="#_CPPv3N3hpx8resource24mode_allow_dynamic_poolsE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Allow worker threads to be added and removed from thread pools. </p>
</dd></dl>

</dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx8resource17scheduling_policyE">
<span id="_CPPv2N3hpx8resource17scheduling_policyE"></span><span id="hpx::resource::scheduling_policy"></span><span class="target" id="namespacehpx_1_1resource_1a5a5a53174b67a94ce5249fa22f6d9b50"></span><em class="property">enum </em><code class="descname">scheduling_policy</code><a class="headerlink" href="#_CPPv3N3hpx8resource17scheduling_policyE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This enumeration lists the available scheduling policies (or schedulers) when creating thread pools. </p>
<p><em>Values:</em></p>
<dl class="enumerator">
<dt id="_CPPv3N3hpx8resource12user_definedE">
<span id="_CPPv2N3hpx8resource12user_definedE"></span><span class="target" id="namespacehpx_1_1resource_1a5a5a53174b67a94ce5249fa22f6d9b50ae7f5e4f7ce2920a53215324d5eb19a20"></span><code class="descname">user_defined</code> = -2<a class="headerlink" href="#_CPPv3N3hpx8resource12user_definedE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx8resource11unspecifiedE">
<span id="_CPPv2N3hpx8resource11unspecifiedE"></span><span class="target" id="namespacehpx_1_1resource_1a5a5a53174b67a94ce5249fa22f6d9b50aaaa1db2d00638fe119ab1108290efbaa"></span><code class="descname">unspecified</code> = -1<a class="headerlink" href="#_CPPv3N3hpx8resource11unspecifiedE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx8resource5localE">
<span id="_CPPv2N3hpx8resource5localE"></span><span class="target" id="namespacehpx_1_1resource_1a5a5a53174b67a94ce5249fa22f6d9b50ab1576160f2dccb8e0e3ee8df403ab652"></span><code class="descname">local</code> = 0<a class="headerlink" href="#_CPPv3N3hpx8resource5localE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx8resource19local_priority_fifoE">
<span id="_CPPv2N3hpx8resource19local_priority_fifoE"></span><span class="target" id="namespacehpx_1_1resource_1a5a5a53174b67a94ce5249fa22f6d9b50a5091f42000a2c161ecca1298f3e3f981"></span><code class="descname">local_priority_fifo</code> = 1<a class="headerlink" href="#_CPPv3N3hpx8resource19local_priority_fifoE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx8resource19local_priority_lifoE">
<span id="_CPPv2N3hpx8resource19local_priority_lifoE"></span><span class="target" id="namespacehpx_1_1resource_1a5a5a53174b67a94ce5249fa22f6d9b50a61d5c91c74c4ab67be1921469e32923b"></span><code class="descname">local_priority_lifo</code> = 2<a class="headerlink" href="#_CPPv3N3hpx8resource19local_priority_lifoE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx8resource7static_E">
<span id="_CPPv2N3hpx8resource7static_E"></span><span class="target" id="namespacehpx_1_1resource_1a5a5a53174b67a94ce5249fa22f6d9b50a7b8b21789851c7957beafdbfc9804773"></span><code class="descname">static_</code> = 3<a class="headerlink" href="#_CPPv3N3hpx8resource7static_E" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx8resource15static_priorityE">
<span id="_CPPv2N3hpx8resource15static_priorityE"></span><span class="target" id="namespacehpx_1_1resource_1a5a5a53174b67a94ce5249fa22f6d9b50afdabcc9635bf8ac27c3d7810f3cc1d03"></span><code class="descname">static_priority</code> = 4<a class="headerlink" href="#_CPPv3N3hpx8resource15static_priorityE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx8resource17abp_priority_fifoE">
<span id="_CPPv2N3hpx8resource17abp_priority_fifoE"></span><span class="target" id="namespacehpx_1_1resource_1a5a5a53174b67a94ce5249fa22f6d9b50a23d8e17519771e45c0b2200b687fcafa"></span><code class="descname">abp_priority_fifo</code> = 5<a class="headerlink" href="#_CPPv3N3hpx8resource17abp_priority_fifoE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx8resource17abp_priority_lifoE">
<span id="_CPPv2N3hpx8resource17abp_priority_lifoE"></span><span class="target" id="namespacehpx_1_1resource_1a5a5a53174b67a94ce5249fa22f6d9b50a0fb77b319d1058d533412930cddce22a"></span><code class="descname">abp_priority_lifo</code> = 6<a class="headerlink" href="#_CPPv3N3hpx8resource17abp_priority_lifoE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx8resource15shared_priorityE">
<span id="_CPPv2N3hpx8resource15shared_priorityE"></span><span class="target" id="namespacehpx_1_1resource_1a5a5a53174b67a94ce5249fa22f6d9b50a290e905215af96b8623f6083a65160da"></span><code class="descname">shared_priority</code> = 7<a class="headerlink" href="#_CPPv3N3hpx8resource15shared_priorityE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx8resource15get_partitionerEv">
<span id="_CPPv2N3hpx8resource15get_partitionerEv"></span><span id="hpx::resource::get_partitioner"></span><span class="target" id="namespacehpx_1_1resource_1af9f5edcd5a638906e9142b7ffbc297ce"></span>detail::partitioner &amp;<code class="descname">get_partitioner</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8resource15get_partitionerEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>May be used anywhere in code and returns a reference to the single, global resource partitioner. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx8resource20is_partitioner_validEv">
<span id="_CPPv2N3hpx8resource20is_partitioner_validEv"></span><span id="hpx::resource::is_partitioner_valid"></span><span class="target" id="namespacehpx_1_1resource_1a074877fd09122474c614d3c58eefa606"></span>bool <code class="descname">is_partitioner_valid</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx8resource20is_partitioner_validEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns true if the resource partitioner has been initialized. Returns false otherwise. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx11this_threadE">
<span id="_CPPv2N3hpx11this_threadE"></span><span id="hpx::this_thread"></span><span class="target" id="namespacehpx_1_1this__thread"></span><em class="property">namespace </em><code class="descname">this_thread</code><a class="headerlink" href="#_CPPv3N3hpx11this_threadE" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx11this_thread7suspendEN7threads17thread_state_enumERN7threads14thread_id_typeERN4util18thread_descriptionER10error_code">
<span id="_CPPv2N3hpx11this_thread7suspendEN7threads17thread_state_enumERN7threads14thread_id_typeERN4util18thread_descriptionER10error_code"></span><span id="hpx::this_thread::suspend__threads::thread_state_enum.threads::thread_id_typeCR.util::thread_descriptionCR.error_codeR"></span><span class="target" id="namespacehpx_1_1this__thread_1aca220026fb3014c0881d129fe31c0073"></span><a class="reference internal" href="#_CPPv3N3hpx7threadsE" title="hpx::threads">threads</a>::<a class="reference internal" href="#_CPPv3N3hpx7threads20thread_state_ex_enumE" title="hpx::threads::thread_state_ex_enum">thread_state_ex_enum</a> <code class="descname">suspend</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx7threadsE" title="hpx::threads">threads</a>::<a class="reference internal" href="#_CPPv3N3hpx7threads17thread_state_enumE" title="hpx::threads::thread_state_enum">thread_state_enum</a> <em>state</em>, <a class="reference internal" href="#_CPPv3N3hpx7threadsE" title="hpx::threads">threads</a>::thread_id_type <em class="property">const</em> &amp;<em>id</em>, <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::thread_description <em class="property">const</em> &amp;<em>description</em> = <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::thread_description(&quot;this_thread::suspend&quot;), <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx11this_thread7suspendEN7threads17thread_state_enumERN7threads14thread_id_typeERN4util18thread_descriptionER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>suspend</em> will return control to the thread manager (suspends the current thread). It sets the new state of this thread to the thread state passed as the parameter.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Must be called from within a HPX-thread.</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">If</span></code>: <code class="docutils literal notranslate"><span class="pre">&amp;ec</span> <span class="pre">!=</span> <span class="pre">&amp;throws</span></code>, never throws, but will set <em>ec</em> to an appropriate value when an error occurs. Otherwise, this function will throw an <em><a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a></em> with an error code of <em><a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663adaabe7896fcf922ad9d1b1dd252bdb8c"><span class="std std-ref">hpx::yield_aborted</span></a></em> if it is signaled with <em>wait_aborted</em>. If called outside of a HPX-thread, this function will throw an <em><a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a></em> with an error code of <em><a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663a05ec9382bba0a20ecfa536cc11e52288"><span class="std std-ref">hpx::null_thread_id</span></a></em>. If this function is called while the thread-manager is not running, it will throw an <em><a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a></em> with an error code of <em><a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663abfb0c9b0ab71f8bcbe9a40c88b6b6959"><span class="std std-ref">hpx::invalid_status</span></a></em>. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx11this_thread7suspendEN7threads17thread_state_enumERN4util18thread_descriptionER10error_code">
<span id="_CPPv2N3hpx11this_thread7suspendEN7threads17thread_state_enumERN4util18thread_descriptionER10error_code"></span><span id="hpx::this_thread::suspend__threads::thread_state_enum.util::thread_descriptionCR.error_codeR"></span><span class="target" id="namespacehpx_1_1this__thread_1a13faad4167a300676b16c76733aac1df"></span><a class="reference internal" href="#_CPPv3N3hpx7threadsE" title="hpx::threads">threads</a>::<a class="reference internal" href="#_CPPv3N3hpx7threads20thread_state_ex_enumE" title="hpx::threads::thread_state_ex_enum">thread_state_ex_enum</a> <code class="descname">suspend</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx7threadsE" title="hpx::threads">threads</a>::<a class="reference internal" href="#_CPPv3N3hpx7threads17thread_state_enumE" title="hpx::threads::thread_state_enum">thread_state_enum</a> <em>state</em> = <a class="reference internal" href="#_CPPv3N3hpx7threadsE" title="hpx::threads">threads</a>::<a class="reference internal" href="#_CPPv3N3hpx7threads7pendingE" title="hpx::threads::pending">pending</a>, <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::thread_description <em class="property">const</em> &amp;<em>description</em> = <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::thread_description(&quot;this_thread::suspend&quot;), <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx11this_thread7suspendEN7threads17thread_state_enumERN4util18thread_descriptionER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>suspend</em> will return control to the thread manager (suspends the current thread). It sets the new state of this thread to the thread state passed as the parameter.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Must be called from within a HPX-thread.</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">If</span></code>: <code class="docutils literal notranslate"><span class="pre">&amp;ec</span> <span class="pre">!=</span> <span class="pre">&amp;throws</span></code>, never throws, but will set <em>ec</em> to an appropriate value when an error occurs. Otherwise, this function will throw an <em><a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a></em> with an error code of <em><a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663adaabe7896fcf922ad9d1b1dd252bdb8c"><span class="std std-ref">hpx::yield_aborted</span></a></em> if it is signaled with <em>wait_aborted</em>. If called outside of a HPX-thread, this function will throw an <em><a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a></em> with an error code of <em><a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663a05ec9382bba0a20ecfa536cc11e52288"><span class="std std-ref">hpx::null_thread_id</span></a></em>. If this function is called while the thread-manager is not running, it will throw an <em><a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a></em> with an error code of <em><a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663abfb0c9b0ab71f8bcbe9a40c88b6b6959"><span class="std std-ref">hpx::invalid_status</span></a></em>. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx11this_thread7suspendERN4util17steady_time_pointERN7threads14thread_id_typeERN4util18thread_descriptionER10error_code">
<span id="_CPPv2N3hpx11this_thread7suspendERN4util17steady_time_pointERN7threads14thread_id_typeERN4util18thread_descriptionER10error_code"></span><span id="hpx::this_thread::suspend__util::steady_time_pointCR.threads::thread_id_typeCR.util::thread_descriptionCR.error_codeR"></span><span class="target" id="namespacehpx_1_1this__thread_1ad047e81948ed186b6d6eca879e825e1c"></span><a class="reference internal" href="#_CPPv3N3hpx7threadsE" title="hpx::threads">threads</a>::<a class="reference internal" href="#_CPPv3N3hpx7threads20thread_state_ex_enumE" title="hpx::threads::thread_state_ex_enum">thread_state_ex_enum</a> <code class="descname">suspend</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::steady_time_point <em class="property">const</em> &amp;<em>abs_time</em>, <a class="reference internal" href="#_CPPv3N3hpx7threadsE" title="hpx::threads">threads</a>::thread_id_type <em class="property">const</em> &amp;<em>id</em>, <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::thread_description <em class="property">const</em> &amp;<em>description</em> = <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::thread_description(&quot;this_thread::suspend&quot;), <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx11this_thread7suspendERN4util17steady_time_pointERN7threads14thread_id_typeERN4util18thread_descriptionER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>suspend</em> will return control to the thread manager (suspends the current thread). It sets the new state of this thread to <em>suspended</em> and schedules a wakeup for this threads at the given time.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Must be called from within a HPX-thread.</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">If</span></code>: <code class="docutils literal notranslate"><span class="pre">&amp;ec</span> <span class="pre">!=</span> <span class="pre">&amp;throws</span></code>, never throws, but will set <em>ec</em> to an appropriate value when an error occurs. Otherwise, this function will throw an <em><a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a></em> with an error code of <em><a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663adaabe7896fcf922ad9d1b1dd252bdb8c"><span class="std std-ref">hpx::yield_aborted</span></a></em> if it is signaled with <em>wait_aborted</em>. If called outside of a HPX-thread, this function will throw an <em><a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a></em> with an error code of <em><a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663a05ec9382bba0a20ecfa536cc11e52288"><span class="std std-ref">hpx::null_thread_id</span></a></em>. If this function is called while the thread-manager is not running, it will throw an <em><a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a></em> with an error code of <em><a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663abfb0c9b0ab71f8bcbe9a40c88b6b6959"><span class="std std-ref">hpx::invalid_status</span></a></em>. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx11this_thread7suspendERN4util17steady_time_pointERN4util18thread_descriptionER10error_code">
<span id="_CPPv2N3hpx11this_thread7suspendERN4util17steady_time_pointERN4util18thread_descriptionER10error_code"></span><span id="hpx::this_thread::suspend__util::steady_time_pointCR.util::thread_descriptionCR.error_codeR"></span><span class="target" id="namespacehpx_1_1this__thread_1ab62e88f72590367154ea6d9b1f625541"></span><a class="reference internal" href="#_CPPv3N3hpx7threadsE" title="hpx::threads">threads</a>::<a class="reference internal" href="#_CPPv3N3hpx7threads20thread_state_ex_enumE" title="hpx::threads::thread_state_ex_enum">thread_state_ex_enum</a> <code class="descname">suspend</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::steady_time_point <em class="property">const</em> &amp;<em>abs_time</em>, <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::thread_description <em class="property">const</em> &amp;<em>description</em> = <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::thread_description(&quot;this_thread::suspend&quot;), <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx11this_thread7suspendERN4util17steady_time_pointERN4util18thread_descriptionER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>suspend</em> will return control to the thread manager (suspends the current thread). It sets the new state of this thread to <em>suspended</em> and schedules a wakeup for this threads at the given time.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Must be called from within a HPX-thread.</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">If</span></code>: <code class="docutils literal notranslate"><span class="pre">&amp;ec</span> <span class="pre">!=</span> <span class="pre">&amp;throws</span></code>, never throws, but will set <em>ec</em> to an appropriate value when an error occurs. Otherwise, this function will throw an <em><a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a></em> with an error code of <em><a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663adaabe7896fcf922ad9d1b1dd252bdb8c"><span class="std std-ref">hpx::yield_aborted</span></a></em> if it is signaled with <em>wait_aborted</em>. If called outside of a HPX-thread, this function will throw an <em><a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a></em> with an error code of <em><a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663a05ec9382bba0a20ecfa536cc11e52288"><span class="std std-ref">hpx::null_thread_id</span></a></em>. If this function is called while the thread-manager is not running, it will throw an <em><a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a></em> with an error code of <em><a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663abfb0c9b0ab71f8bcbe9a40c88b6b6959"><span class="std std-ref">hpx::invalid_status</span></a></em>. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx11this_thread7suspendERN4util15steady_durationERN4util18thread_descriptionER10error_code">
<span id="_CPPv2N3hpx11this_thread7suspendERN4util15steady_durationERN4util18thread_descriptionER10error_code"></span><span id="hpx::this_thread::suspend__util::steady_durationCR.util::thread_descriptionCR.error_codeR"></span><span class="target" id="namespacehpx_1_1this__thread_1ab42360039c42a2cb413ae51a06f3ffb2"></span><a class="reference internal" href="#_CPPv3N3hpx7threadsE" title="hpx::threads">threads</a>::<a class="reference internal" href="#_CPPv3N3hpx7threads20thread_state_ex_enumE" title="hpx::threads::thread_state_ex_enum">thread_state_ex_enum</a> <code class="descname">suspend</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::steady_duration <em class="property">const</em> &amp;<em>rel_time</em>, <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::thread_description <em class="property">const</em> &amp;<em>description</em> = <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::thread_description(&quot;this_thread::suspend&quot;), <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx11this_thread7suspendERN4util15steady_durationERN4util18thread_descriptionER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>suspend</em> will return control to the thread manager (suspends the current thread). It sets the new state of this thread to <em>suspended</em> and schedules a wakeup for this threads after the given duration.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Must be called from within a HPX-thread.</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">If</span></code>: <code class="docutils literal notranslate"><span class="pre">&amp;ec</span> <span class="pre">!=</span> <span class="pre">&amp;throws</span></code>, never throws, but will set <em>ec</em> to an appropriate value when an error occurs. Otherwise, this function will throw an <em><a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a></em> with an error code of <em><a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663adaabe7896fcf922ad9d1b1dd252bdb8c"><span class="std std-ref">hpx::yield_aborted</span></a></em> if it is signaled with <em>wait_aborted</em>. If called outside of a HPX-thread, this function will throw an <em><a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a></em> with an error code of <em><a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663a05ec9382bba0a20ecfa536cc11e52288"><span class="std std-ref">hpx::null_thread_id</span></a></em>. If this function is called while the thread-manager is not running, it will throw an <em><a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a></em> with an error code of <em><a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663abfb0c9b0ab71f8bcbe9a40c88b6b6959"><span class="std std-ref">hpx::invalid_status</span></a></em>. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx11this_thread7suspendERN4util15steady_durationERN7threads14thread_id_typeERN4util18thread_descriptionER10error_code">
<span id="_CPPv2N3hpx11this_thread7suspendERN4util15steady_durationERN7threads14thread_id_typeERN4util18thread_descriptionER10error_code"></span><span id="hpx::this_thread::suspend__util::steady_durationCR.threads::thread_id_typeCR.util::thread_descriptionCR.error_codeR"></span><span class="target" id="namespacehpx_1_1this__thread_1a9d53eeb0788cf47b0881c89965d51b14"></span><a class="reference internal" href="#_CPPv3N3hpx7threadsE" title="hpx::threads">threads</a>::<a class="reference internal" href="#_CPPv3N3hpx7threads20thread_state_ex_enumE" title="hpx::threads::thread_state_ex_enum">thread_state_ex_enum</a> <code class="descname">suspend</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::steady_duration <em class="property">const</em> &amp;<em>rel_time</em>, <a class="reference internal" href="#_CPPv3N3hpx7threadsE" title="hpx::threads">threads</a>::thread_id_type <em class="property">const</em> &amp;<em>id</em>, <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::thread_description <em class="property">const</em> &amp;<em>description</em> = <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::thread_description(&quot;this_thread::suspend&quot;), <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx11this_thread7suspendERN4util15steady_durationERN7threads14thread_id_typeERN4util18thread_descriptionER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>suspend</em> will return control to the thread manager (suspends the current thread). It sets the new state of this thread to <em>suspended</em> and schedules a wakeup for this threads after the given duration.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Must be called from within a HPX-thread.</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">If</span></code>: <code class="docutils literal notranslate"><span class="pre">&amp;ec</span> <span class="pre">!=</span> <span class="pre">&amp;throws</span></code>, never throws, but will set <em>ec</em> to an appropriate value when an error occurs. Otherwise, this function will throw an <em><a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a></em> with an error code of <em><a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663adaabe7896fcf922ad9d1b1dd252bdb8c"><span class="std std-ref">hpx::yield_aborted</span></a></em> if it is signaled with <em>wait_aborted</em>. If called outside of a HPX-thread, this function will throw an <em><a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a></em> with an error code of <em><a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663a05ec9382bba0a20ecfa536cc11e52288"><span class="std std-ref">hpx::null_thread_id</span></a></em>. If this function is called while the thread-manager is not running, it will throw an <em><a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a></em> with an error code of <em><a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663abfb0c9b0ab71f8bcbe9a40c88b6b6959"><span class="std std-ref">hpx::invalid_status</span></a></em>. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx11this_thread7suspendENSt8uint64_tERN4util18thread_descriptionER10error_code">
<span id="_CPPv2N3hpx11this_thread7suspendENSt8uint64_tERN4util18thread_descriptionER10error_code"></span><span id="hpx::this_thread::suspend__std::uint64_t.util::thread_descriptionCR.error_codeR"></span><span class="target" id="namespacehpx_1_1this__thread_1a15c12bd6b0b99c9a65e1a3669492805d"></span><a class="reference internal" href="#_CPPv3N3hpx7threadsE" title="hpx::threads">threads</a>::<a class="reference internal" href="#_CPPv3N3hpx7threads20thread_state_ex_enumE" title="hpx::threads::thread_state_ex_enum">thread_state_ex_enum</a> <code class="descname">suspend</code><span class="sig-paren">(</span>std::uint64_t <em>ms</em>, <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::thread_description <em class="property">const</em> &amp;<em>description</em> = <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::thread_description(&quot;this_thread::suspend&quot;), <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx11this_thread7suspendENSt8uint64_tERN4util18thread_descriptionER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>suspend</em> will return control to the thread manager (suspends the current thread). It sets the new state of this thread to <em>suspended</em> and schedules a wakeup for this threads after the given time (specified in milliseconds).</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Must be called from within a HPX-thread.</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">If</span></code>: <code class="docutils literal notranslate"><span class="pre">&amp;ec</span> <span class="pre">!=</span> <span class="pre">&amp;throws</span></code>, never throws, but will set <em>ec</em> to an appropriate value when an error occurs. Otherwise, this function will throw an <em><a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a></em> with an error code of <em><a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663adaabe7896fcf922ad9d1b1dd252bdb8c"><span class="std std-ref">hpx::yield_aborted</span></a></em> if it is signaled with <em>wait_aborted</em>. If called outside of a HPX-thread, this function will throw an <em><a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a></em> with an error code of <em><a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663a05ec9382bba0a20ecfa536cc11e52288"><span class="std std-ref">hpx::null_thread_id</span></a></em>. If this function is called while the thread-manager is not running, it will throw an <em><a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a></em> with an error code of <em><a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663abfb0c9b0ab71f8bcbe9a40c88b6b6959"><span class="std std-ref">hpx::invalid_status</span></a></em>. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx11this_thread12get_executorER10error_code">
<span id="_CPPv2N3hpx11this_thread12get_executorER10error_code"></span><span id="hpx::this_thread::get_executor__error_codeR"></span><span class="target" id="namespacehpx_1_1this__thread_1a7e846a11cf19a7079c98c1e1ae24a61d"></span><a class="reference internal" href="#_CPPv3N3hpx7threadsE" title="hpx::threads">threads</a>::executors::current_executor <code class="descname">get_executor</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx11this_thread12get_executorER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns a reference to the executor which was used to create the current thread.</p>
<p><dl class="docutils">
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">If</span></code>: <code class="docutils literal notranslate"><span class="pre">&amp;ec</span> <span class="pre">!=</span> <span class="pre">&amp;throws</span></code>, never throws, but will set <em>ec</em> to an appropriate value when an error occurs. Otherwise, this function will throw an <em><a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a></em> with an error code of <em><a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663adaabe7896fcf922ad9d1b1dd252bdb8c"><span class="std std-ref">hpx::yield_aborted</span></a></em> if it is signaled with <em>wait_aborted</em>. If called outside of a HPX-thread, this function will throw an <em><a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a></em> with an error code of <em><a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663a05ec9382bba0a20ecfa536cc11e52288"><span class="std std-ref">hpx::null_thread_id</span></a></em>. If this function is called while the thread-manager is not running, it will throw an <em><a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a></em> with an error code of <em><a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663abfb0c9b0ab71f8bcbe9a40c88b6b6959"><span class="std std-ref">hpx::invalid_status</span></a></em>. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx11this_thread8get_poolER10error_code">
<span id="_CPPv2N3hpx11this_thread8get_poolER10error_code"></span><span id="hpx::this_thread::get_pool__error_codeR"></span><span class="target" id="namespacehpx_1_1this__thread_1a09e41b8f250c72e5d192524c4f9cbc8d"></span><a class="reference internal" href="#_CPPv3N3hpx7threadsE" title="hpx::threads">threads</a>::<a class="reference internal" href="#_CPPv3N3hpx7threads16thread_pool_baseE" title="hpx::threads::thread_pool_base">thread_pool_base</a> *<code class="descname">get_pool</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx11this_thread8get_poolER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns a pointer to the pool that was used to run the current thread</p>
<p><dl class="docutils">
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">If</span></code>: <code class="docutils literal notranslate"><span class="pre">&amp;ec</span> <span class="pre">!=</span> <span class="pre">&amp;throws</span></code>, never throws, but will set <em>ec</em> to an appropriate value when an error occurs. Otherwise, this function will throw an <em><a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a></em> with an error code of <em><a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663adaabe7896fcf922ad9d1b1dd252bdb8c"><span class="std std-ref">hpx::yield_aborted</span></a></em> if it is signaled with <em>wait_aborted</em>. If called outside of a HPX-thread, this function will throw an <em><a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a></em> with an error code of <em><a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663a05ec9382bba0a20ecfa536cc11e52288"><span class="std std-ref">hpx::null_thread_id</span></a></em>. If this function is called while the thread-manager is not running, it will throw an <em><a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a></em> with an error code of <em><a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663abfb0c9b0ab71f8bcbe9a40c88b6b6959"><span class="std std-ref">hpx::invalid_status</span></a></em>. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx7threadsE">
<span id="_CPPv2N3hpx7threadsE"></span><span id="hpx::threads"></span><span class="target" id="namespacehpx_1_1threads"></span><em class="property">namespace </em><code class="descname">threads</code><a class="headerlink" href="#_CPPv3N3hpx7threadsE" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Enums</p>
<dl class="type">
<dt id="_CPPv3N3hpx7threads17thread_state_enumE">
<span id="_CPPv2N3hpx7threads17thread_state_enumE"></span><span id="hpx::threads::thread_state_enum"></span><span class="target" id="namespacehpx_1_1threads_1a2b4f23e851fbe362ea23cbd39233ae48"></span><em class="property">enum </em><code class="descname">thread_state_enum</code><a class="headerlink" href="#_CPPv3N3hpx7threads17thread_state_enumE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The <em>thread_state_enum</em> enumerator encodes the current state of a <em>thread</em> instance </p>
<p><em>Values:</em></p>
<dl class="enumerator">
<dt id="_CPPv3N3hpx7threads7unknownE">
<span id="_CPPv2N3hpx7threads7unknownE"></span><span class="target" id="namespacehpx_1_1threads_1a2b4f23e851fbe362ea23cbd39233ae48a2135a317d33934cd66ad0d96dba0f150"></span><code class="descname">unknown</code> = 0<a class="headerlink" href="#_CPPv3N3hpx7threads7unknownE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx7threads6activeE">
<span id="_CPPv2N3hpx7threads6activeE"></span><span class="target" id="namespacehpx_1_1threads_1a2b4f23e851fbe362ea23cbd39233ae48a922f599d07a942666c6d08b3cf99231f"></span><code class="descname">active</code> = 1<a class="headerlink" href="#_CPPv3N3hpx7threads6activeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>thread is currently active (running, has resources) </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx7threads7pendingE">
<span id="_CPPv2N3hpx7threads7pendingE"></span><span class="target" id="namespacehpx_1_1threads_1a2b4f23e851fbe362ea23cbd39233ae48a01123b12d896b13ced81cf85b67191e2"></span><code class="descname">pending</code> = 2<a class="headerlink" href="#_CPPv3N3hpx7threads7pendingE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>thread is pending (ready to run, but no hardware resource available) </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx7threads9suspendedE">
<span id="_CPPv2N3hpx7threads9suspendedE"></span><span class="target" id="namespacehpx_1_1threads_1a2b4f23e851fbe362ea23cbd39233ae48a85673dcf8be2d61669feaa92f606ffa9"></span><code class="descname">suspended</code> = 3<a class="headerlink" href="#_CPPv3N3hpx7threads9suspendedE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>thread has been suspended (waiting for synchronization event, but still known and under control of the thread-manager) </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx7threads8depletedE">
<span id="_CPPv2N3hpx7threads8depletedE"></span><span class="target" id="namespacehpx_1_1threads_1a2b4f23e851fbe362ea23cbd39233ae48a93e1b8029202384f295ab5633639679c"></span><code class="descname">depleted</code> = 4<a class="headerlink" href="#_CPPv3N3hpx7threads8depletedE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>thread has been depleted (deeply suspended, it is not known to the thread-manager) </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx7threads10terminatedE">
<span id="_CPPv2N3hpx7threads10terminatedE"></span><span class="target" id="namespacehpx_1_1threads_1a2b4f23e851fbe362ea23cbd39233ae48a3ab34aedce40dce0acc6676ac803d63b"></span><code class="descname">terminated</code> = 5<a class="headerlink" href="#_CPPv3N3hpx7threads10terminatedE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>thread has been stopped an may be garbage collected </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx7threads6stagedE">
<span id="_CPPv2N3hpx7threads6stagedE"></span><span class="target" id="namespacehpx_1_1threads_1a2b4f23e851fbe362ea23cbd39233ae48a8ae6ae113316304f00d965608f06d537"></span><code class="descname">staged</code> = 6<a class="headerlink" href="#_CPPv3N3hpx7threads6stagedE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>this is not a real thread state, but allows to reference staged task descriptions, which eventually will be converted into thread objects </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx7threads23pending_do_not_scheduleE">
<span id="_CPPv2N3hpx7threads23pending_do_not_scheduleE"></span><span class="target" id="namespacehpx_1_1threads_1a2b4f23e851fbe362ea23cbd39233ae48af71c5d1ed8040fc740b99a27632d3ede"></span><code class="descname">pending_do_not_schedule</code> = 7<a class="headerlink" href="#_CPPv3N3hpx7threads23pending_do_not_scheduleE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx7threads13pending_boostE">
<span id="_CPPv2N3hpx7threads13pending_boostE"></span><span class="target" id="namespacehpx_1_1threads_1a2b4f23e851fbe362ea23cbd39233ae48afc1ecfae2fd50a84bb0e9d753ff65b11"></span><code class="descname">pending_boost</code> = 8<a class="headerlink" href="#_CPPv3N3hpx7threads13pending_boostE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx7threads15thread_priorityE">
<span id="_CPPv2N3hpx7threads15thread_priorityE"></span><span id="hpx::threads::thread_priority"></span><span class="target" id="namespacehpx_1_1threads_1ac9ea71df1a6e7c564da9d1724432790a"></span><em class="property">enum </em><code class="descname">thread_priority</code><a class="headerlink" href="#_CPPv3N3hpx7threads15thread_priorityE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This enumeration lists all possible thread-priorities for HPX threads. </p>
<p><em>Values:</em></p>
<dl class="enumerator">
<dt id="_CPPv3N3hpx7threads23thread_priority_unknownE">
<span id="_CPPv2N3hpx7threads23thread_priority_unknownE"></span><span class="target" id="namespacehpx_1_1threads_1ac9ea71df1a6e7c564da9d1724432790aab2db1a3cde0ff35d502e08bb63b8084c"></span><code class="descname">thread_priority_unknown</code> = -1<a class="headerlink" href="#_CPPv3N3hpx7threads23thread_priority_unknownE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx7threads23thread_priority_defaultE">
<span id="_CPPv2N3hpx7threads23thread_priority_defaultE"></span><span class="target" id="namespacehpx_1_1threads_1ac9ea71df1a6e7c564da9d1724432790aae41645acc119ecf695886dbcf849e916"></span><code class="descname">thread_priority_default</code> = 0<a class="headerlink" href="#_CPPv3N3hpx7threads23thread_priority_defaultE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Will assign the priority of the task to the default (normal) priority. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx7threads19thread_priority_lowE">
<span id="_CPPv2N3hpx7threads19thread_priority_lowE"></span><span class="target" id="namespacehpx_1_1threads_1ac9ea71df1a6e7c564da9d1724432790aab5e93f0663cdaf0753451c9c2a529715"></span><code class="descname">thread_priority_low</code> = 1<a class="headerlink" href="#_CPPv3N3hpx7threads19thread_priority_lowE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Task goes onto a special low priority queue and will not be executed until all high/normal priority tasks are done, even if they are added after the low priority task. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx7threads22thread_priority_normalE">
<span id="_CPPv2N3hpx7threads22thread_priority_normalE"></span><span class="target" id="namespacehpx_1_1threads_1ac9ea71df1a6e7c564da9d1724432790aa345d08359faca000dfb7cbe377a9b1c3"></span><code class="descname">thread_priority_normal</code> = 2<a class="headerlink" href="#_CPPv3N3hpx7threads22thread_priority_normalE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Task will be executed when it is taken from the normal priority queue, this is usually a first in-first-out ordering of tasks (depending on scheduler choice). This is the default priority. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx7threads30thread_priority_high_recursiveE">
<span id="_CPPv2N3hpx7threads30thread_priority_high_recursiveE"></span><span class="target" id="namespacehpx_1_1threads_1ac9ea71df1a6e7c564da9d1724432790aa2b2cb407a0b3a67a9ff832508164e828"></span><code class="descname">thread_priority_high_recursive</code> = 3<a class="headerlink" href="#_CPPv3N3hpx7threads30thread_priority_high_recursiveE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The task is a high priority task and any child tasks spawned by this task will be made high priority as well - unless they are specifically flagged as non default priority. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx7threads21thread_priority_boostE">
<span id="_CPPv2N3hpx7threads21thread_priority_boostE"></span><span class="target" id="namespacehpx_1_1threads_1ac9ea71df1a6e7c564da9d1724432790aae13b992c06fa1c29118be87a5890aa47"></span><code class="descname">thread_priority_boost</code> = 4<a class="headerlink" href="#_CPPv3N3hpx7threads21thread_priority_boostE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Same as <em>thread_priority_high</em> except that the thread will fall back to <em>thread_priority_normal</em> if resumed after being suspended. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx7threads20thread_priority_highE">
<span id="_CPPv2N3hpx7threads20thread_priority_highE"></span><span class="target" id="namespacehpx_1_1threads_1ac9ea71df1a6e7c564da9d1724432790aa63c6ba6959ac255ab0723cdc4c74f035"></span><code class="descname">thread_priority_high</code> = 5<a class="headerlink" href="#_CPPv3N3hpx7threads20thread_priority_highE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Task goes onto a special high priority queue and will be executed before normal/low priority tasks are taken (some schedulers modify the behavior slightly and the documentation for those should be consulted). </p>
</dd></dl>

</dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx7threads20thread_state_ex_enumE">
<span id="_CPPv2N3hpx7threads20thread_state_ex_enumE"></span><span id="hpx::threads::thread_state_ex_enum"></span><span class="target" id="namespacehpx_1_1threads_1aa55297caca57a2d7beaa2e818bf5f147"></span><em class="property">enum </em><code class="descname">thread_state_ex_enum</code><a class="headerlink" href="#_CPPv3N3hpx7threads20thread_state_ex_enumE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The <em>thread_state_ex_enum</em> enumerator encodes the reason why a thread is being restarted </p>
<p><em>Values:</em></p>
<dl class="enumerator">
<dt id="_CPPv3N3hpx7threads12wait_unknownE">
<span id="_CPPv2N3hpx7threads12wait_unknownE"></span><span class="target" id="namespacehpx_1_1threads_1aa55297caca57a2d7beaa2e818bf5f147a5643e425f64f406816265d381c98705a"></span><code class="descname">wait_unknown</code> = 0<a class="headerlink" href="#_CPPv3N3hpx7threads12wait_unknownE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx7threads13wait_signaledE">
<span id="_CPPv2N3hpx7threads13wait_signaledE"></span><span class="target" id="namespacehpx_1_1threads_1aa55297caca57a2d7beaa2e818bf5f147afc84b95e86a3ccc7cde28f1447e97333"></span><code class="descname">wait_signaled</code> = 1<a class="headerlink" href="#_CPPv3N3hpx7threads13wait_signaledE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The thread has been signaled. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx7threads12wait_timeoutE">
<span id="_CPPv2N3hpx7threads12wait_timeoutE"></span><span class="target" id="namespacehpx_1_1threads_1aa55297caca57a2d7beaa2e818bf5f147aec03d6be9d8d622e06b7b446c68dbc7f"></span><code class="descname">wait_timeout</code> = 2<a class="headerlink" href="#_CPPv3N3hpx7threads12wait_timeoutE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The thread has been reactivated after a timeout. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx7threads14wait_terminateE">
<span id="_CPPv2N3hpx7threads14wait_terminateE"></span><span class="target" id="namespacehpx_1_1threads_1aa55297caca57a2d7beaa2e818bf5f147a0c3c663d8770b1023c0409bda54d15b2"></span><code class="descname">wait_terminate</code> = 3<a class="headerlink" href="#_CPPv3N3hpx7threads14wait_terminateE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The thread needs to be terminated. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx7threads10wait_abortE">
<span id="_CPPv2N3hpx7threads10wait_abortE"></span><span class="target" id="namespacehpx_1_1threads_1aa55297caca57a2d7beaa2e818bf5f147a2f4fbf42015f5e18ee5c6e516afd6442"></span><code class="descname">wait_abort</code> = 4<a class="headerlink" href="#_CPPv3N3hpx7threads10wait_abortE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The thread needs to be aborted. </p>
</dd></dl>

</dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx7threads16thread_stacksizeE">
<span id="_CPPv2N3hpx7threads16thread_stacksizeE"></span><span id="hpx::threads::thread_stacksize"></span><span class="target" id="namespacehpx_1_1threads_1a27eef609b06d5b8b1f47c9a7c33a3843"></span><em class="property">enum </em><code class="descname">thread_stacksize</code><a class="headerlink" href="#_CPPv3N3hpx7threads16thread_stacksizeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A <em>thread_stacksize</em> references any of the possible stack-sizes for HPX threads. </p>
<p><em>Values:</em></p>
<dl class="enumerator">
<dt id="_CPPv3N3hpx7threads24thread_stacksize_unknownE">
<span id="_CPPv2N3hpx7threads24thread_stacksize_unknownE"></span><span class="target" id="namespacehpx_1_1threads_1a27eef609b06d5b8b1f47c9a7c33a3843a604203d40547e54fb84e628808dac362"></span><code class="descname">thread_stacksize_unknown</code> = -1<a class="headerlink" href="#_CPPv3N3hpx7threads24thread_stacksize_unknownE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx7threads22thread_stacksize_smallE">
<span id="_CPPv2N3hpx7threads22thread_stacksize_smallE"></span><span class="target" id="namespacehpx_1_1threads_1a27eef609b06d5b8b1f47c9a7c33a3843aacc8bea53b4543a6f56403f3e210945b"></span><code class="descname">thread_stacksize_small</code> = 1<a class="headerlink" href="#_CPPv3N3hpx7threads22thread_stacksize_smallE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>use small stack size </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx7threads23thread_stacksize_mediumE">
<span id="_CPPv2N3hpx7threads23thread_stacksize_mediumE"></span><span class="target" id="namespacehpx_1_1threads_1a27eef609b06d5b8b1f47c9a7c33a3843ad14cce033e7ed81272037e737af91096"></span><code class="descname">thread_stacksize_medium</code> = 2<a class="headerlink" href="#_CPPv3N3hpx7threads23thread_stacksize_mediumE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>use medium sized stack size </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx7threads22thread_stacksize_largeE">
<span id="_CPPv2N3hpx7threads22thread_stacksize_largeE"></span><span class="target" id="namespacehpx_1_1threads_1a27eef609b06d5b8b1f47c9a7c33a3843aaac53c9592d3a5079ff8ee4fa5164e38"></span><code class="descname">thread_stacksize_large</code> = 3<a class="headerlink" href="#_CPPv3N3hpx7threads22thread_stacksize_largeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>use large stack size </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx7threads21thread_stacksize_hugeE">
<span id="_CPPv2N3hpx7threads21thread_stacksize_hugeE"></span><span class="target" id="namespacehpx_1_1threads_1a27eef609b06d5b8b1f47c9a7c33a3843a724aa61b92e010079a83f2dc8e194b71"></span><code class="descname">thread_stacksize_huge</code> = 4<a class="headerlink" href="#_CPPv3N3hpx7threads21thread_stacksize_hugeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>use very large stack size </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx7threads24thread_stacksize_currentE">
<span id="_CPPv2N3hpx7threads24thread_stacksize_currentE"></span><span class="target" id="namespacehpx_1_1threads_1a27eef609b06d5b8b1f47c9a7c33a3843a5ca2fa74f7541ea321942fece4c91aa1"></span><code class="descname">thread_stacksize_current</code> = 5<a class="headerlink" href="#_CPPv3N3hpx7threads24thread_stacksize_currentE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>use size of current thread’s stack </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx7threads24thread_stacksize_defaultE">
<span id="_CPPv2N3hpx7threads24thread_stacksize_defaultE"></span><span class="target" id="namespacehpx_1_1threads_1a27eef609b06d5b8b1f47c9a7c33a3843a3b7b00ec88e7e39e9db689b34d26d551"></span><code class="descname">thread_stacksize_default</code> = thread_stacksize_small<a class="headerlink" href="#_CPPv3N3hpx7threads24thread_stacksize_defaultE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>use default stack size </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx7threads24thread_stacksize_minimalE">
<span id="_CPPv2N3hpx7threads24thread_stacksize_minimalE"></span><span class="target" id="namespacehpx_1_1threads_1a27eef609b06d5b8b1f47c9a7c33a3843a2293daddc8f3fae60371ca181a03703b"></span><code class="descname">thread_stacksize_minimal</code> = thread_stacksize_small<a class="headerlink" href="#_CPPv3N3hpx7threads24thread_stacksize_minimalE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>use minimally stack size </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx7threads24thread_stacksize_maximalE">
<span id="_CPPv2N3hpx7threads24thread_stacksize_maximalE"></span><span class="target" id="namespacehpx_1_1threads_1a27eef609b06d5b8b1f47c9a7c33a3843ac7ee34b10ff26d61028f5d1abcf7a4b9"></span><code class="descname">thread_stacksize_maximal</code> = thread_stacksize_huge<a class="headerlink" href="#_CPPv3N3hpx7threads24thread_stacksize_maximalE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>use maximally stack size </p>
</dd></dl>

</dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx7threads25thread_schedule_hint_modeE">
<span id="_CPPv2N3hpx7threads25thread_schedule_hint_modeE"></span><span id="hpx::threads::thread_schedule_hint_mode"></span><span class="target" id="namespacehpx_1_1threads_1a74bebf9391ba5e2676a520fea30b90af"></span><em class="property">enum </em><code class="descname">thread_schedule_hint_mode</code><a class="headerlink" href="#_CPPv3N3hpx7threads25thread_schedule_hint_modeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The type of hint given when creating new tasks. </p>
<p><em>Values:</em></p>
<dl class="enumerator">
<dt id="_CPPv3N3hpx7threads30thread_schedule_hint_mode_noneE">
<span id="_CPPv2N3hpx7threads30thread_schedule_hint_mode_noneE"></span><span class="target" id="namespacehpx_1_1threads_1a74bebf9391ba5e2676a520fea30b90afa351634c4b0688a2467c4fd5dfa4c8100"></span><code class="descname">thread_schedule_hint_mode_none</code> = 0<a class="headerlink" href="#_CPPv3N3hpx7threads30thread_schedule_hint_mode_noneE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx7threads32thread_schedule_hint_mode_threadE">
<span id="_CPPv2N3hpx7threads32thread_schedule_hint_mode_threadE"></span><span class="target" id="namespacehpx_1_1threads_1a74bebf9391ba5e2676a520fea30b90afaf8333ff101f76ef368cb11475086177b"></span><code class="descname">thread_schedule_hint_mode_thread</code> = 1<a class="headerlink" href="#_CPPv3N3hpx7threads32thread_schedule_hint_mode_threadE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx7threads30thread_schedule_hint_mode_numaE">
<span id="_CPPv2N3hpx7threads30thread_schedule_hint_mode_numaE"></span><span class="target" id="namespacehpx_1_1threads_1a74bebf9391ba5e2676a520fea30b90afa3537f33fec757e35f90dbd35a0a40999"></span><code class="descname">thread_schedule_hint_mode_numa</code> = 2<a class="headerlink" href="#_CPPv3N3hpx7threads30thread_schedule_hint_mode_numaE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx7threads21get_thread_state_nameE17thread_state_enum">
<span id="_CPPv2N3hpx7threads21get_thread_state_nameE17thread_state_enum"></span><span id="hpx::threads::get_thread_state_name__thread_state_enum"></span><span class="target" id="namespacehpx_1_1threads_1aa4c18c4cf981c5c6817544b1097f98b6"></span>char <em class="property">const</em> *<code class="descname">get_thread_state_name</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx7threads17thread_state_enumE" title="hpx::threads::thread_state_enum">thread_state_enum</a> <em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx7threads21get_thread_state_nameE17thread_state_enum" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the readable string representing the name of the given thread_state constant. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7threads24get_thread_priority_nameE15thread_priority">
<span id="_CPPv2N3hpx7threads24get_thread_priority_nameE15thread_priority"></span><span id="hpx::threads::get_thread_priority_name__thread_priority"></span><span class="target" id="namespacehpx_1_1threads_1a2681da0f43a6b72b8b15bf56fe201392"></span>char <em class="property">const</em> *<code class="descname">get_thread_priority_name</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx7threads15thread_priorityE" title="hpx::threads::thread_priority">thread_priority</a> <em>priority</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx7threads24get_thread_priority_nameE15thread_priority" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the readable string representing the name of the given thread_priority constant. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7threads24get_thread_state_ex_nameE20thread_state_ex_enum">
<span id="_CPPv2N3hpx7threads24get_thread_state_ex_nameE20thread_state_ex_enum"></span><span id="hpx::threads::get_thread_state_ex_name__thread_state_ex_enum"></span><span class="target" id="namespacehpx_1_1threads_1a58f56602091632657e6d73c7ffb040c5"></span>char <em class="property">const</em> *<code class="descname">get_thread_state_ex_name</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx7threads20thread_state_ex_enumE" title="hpx::threads::thread_state_ex_enum">thread_state_ex_enum</a> <em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx7threads24get_thread_state_ex_nameE20thread_state_ex_enum" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the readable string representing the name of the given thread_state_ex_enum constant. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7threads21get_thread_state_nameE12thread_state">
<span id="_CPPv2N3hpx7threads21get_thread_state_nameE12thread_state"></span><span id="hpx::threads::get_thread_state_name__thread_state"></span><span class="target" id="namespacehpx_1_1threads_1ad53166e46d411744e5fccce9dfee4672"></span>char <em class="property">const</em> *<code class="descname">get_thread_state_name</code><span class="sig-paren">(</span>thread_state <em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx7threads21get_thread_state_nameE12thread_state" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the readable string representing the name of the given thread_state constant. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7threads19get_stack_size_nameENSt9ptrdiff_tE">
<span id="_CPPv2N3hpx7threads19get_stack_size_nameENSt9ptrdiff_tE"></span><span id="hpx::threads::get_stack_size_name__std::ptrdiff_t"></span><span class="target" id="namespacehpx_1_1threads_1a1f3d452ebf962e499d2d86c8686bb455"></span>char <em class="property">const</em> *<code class="descname">get_stack_size_name</code><span class="sig-paren">(</span>std::ptrdiff_t <em>size</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx7threads19get_stack_size_nameENSt9ptrdiff_tE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Get the readable string representing the given stack size constant. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7threads8get_selfEv">
<span id="_CPPv2N3hpx7threads8get_selfEv"></span><span id="hpx::threads::get_self"></span><span class="target" id="namespacehpx_1_1threads_1a77859d42e81ecf27277b6c7bc166ae49"></span>thread_self &amp;<code class="descname">get_self</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx7threads8get_selfEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>get_self</em> returns a reference to the (OS thread specific) self reference to the current HPX thread. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7threads12get_self_ptrEv">
<span id="_CPPv2N3hpx7threads12get_self_ptrEv"></span><span id="hpx::threads::get_self_ptr"></span><span class="target" id="namespacehpx_1_1threads_1a45510897ddaea6512f6c00bf89802a9a"></span>thread_self *<code class="descname">get_self_ptr</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx7threads12get_self_ptrEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>get_self_ptr</em> returns a pointer to the (OS thread specific) self reference to the current HPX thread. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7threads11get_ctx_ptrEv">
<span id="_CPPv2N3hpx7threads11get_ctx_ptrEv"></span><span id="hpx::threads::get_ctx_ptr"></span><span class="target" id="namespacehpx_1_1threads_1a62107deb3ee8749e4cab29d7c657f47c"></span>thread_self_impl_type *<code class="descname">get_ctx_ptr</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx7threads11get_ctx_ptrEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>get_ctx_ptr</em> returns a pointer to the internal data associated with each coroutine. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7threads20get_self_ptr_checkedER10error_code">
<span id="_CPPv2N3hpx7threads20get_self_ptr_checkedER10error_code"></span><span id="hpx::threads::get_self_ptr_checked__error_codeR"></span><span class="target" id="namespacehpx_1_1threads_1a69fe8464ce5d183ccc0297b1f2345ad3"></span>thread_self *<code class="descname">get_self_ptr_checked</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx7threads20get_self_ptr_checkedER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>get_self_ptr_checked</em> returns a pointer to the (OS thread specific) self reference to the current HPX thread. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7threads11get_self_idEv">
<span id="_CPPv2N3hpx7threads11get_self_idEv"></span><span id="hpx::threads::get_self_id"></span><span class="target" id="namespacehpx_1_1threads_1afafe0f900b9fac3d4ed3c747625c1cfe"></span>thread_id_type <code class="descname">get_self_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx7threads11get_self_idEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>get_self_id</em> returns the HPX thread id of the current thread (or zero if the current thread is not a HPX thread). </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7threads13get_parent_idEv">
<span id="_CPPv2N3hpx7threads13get_parent_idEv"></span><span id="hpx::threads::get_parent_id"></span><span class="target" id="namespacehpx_1_1threads_1a3be8ab17cbcf2b2d1fe0df0be9b373dd"></span>thread_id_type <code class="descname">get_parent_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx7threads13get_parent_idEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>get_parent_id</em> returns the HPX thread id of the current thread’s parent (or zero if the current thread is not a HPX thread).</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function will return a meaningful value only if the code was compiled with HPX_HAVE_THREAD_PARENT_REFERENCE being defined. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7threads16get_parent_phaseEv">
<span id="_CPPv2N3hpx7threads16get_parent_phaseEv"></span><span id="hpx::threads::get_parent_phase"></span><span class="target" id="namespacehpx_1_1threads_1a91fbafda8b0e7c377d349d8032078714"></span>std::size_t <code class="descname">get_parent_phase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx7threads16get_parent_phaseEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>get_parent_phase</em> returns the HPX phase of the current thread’s parent (or zero if the current thread is not a HPX thread).</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function will return a meaningful value only if the code was compiled with HPX_HAVE_THREAD_PARENT_REFERENCE being defined. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7threads18get_self_stacksizeEv">
<span id="_CPPv2N3hpx7threads18get_self_stacksizeEv"></span><span id="hpx::threads::get_self_stacksize"></span><span class="target" id="namespacehpx_1_1threads_1a151264fbf7d066507ef1a342309bd3a9"></span>std::size_t <code class="descname">get_self_stacksize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx7threads18get_self_stacksizeEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>get_self_stacksize</em> returns the stack size of the current thread (or zero if the current thread is not a HPX thread). </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7threads22get_parent_locality_idEv">
<span id="_CPPv2N3hpx7threads22get_parent_locality_idEv"></span><span id="hpx::threads::get_parent_locality_id"></span><span class="target" id="namespacehpx_1_1threads_1a19fe383da3491eceac32720c89ae8f7d"></span>std::uint32_t <code class="descname">get_parent_locality_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx7threads22get_parent_locality_idEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>get_parent_locality_id</em> returns the id of the locality of the current thread’s parent (or zero if the current thread is not a HPX thread).</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function will return a meaningful value only if the code was compiled with HPX_HAVE_THREAD_PARENT_REFERENCE being defined. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7threads21get_self_component_idEv">
<span id="_CPPv2N3hpx7threads21get_self_component_idEv"></span><span id="hpx::threads::get_self_component_id"></span><span class="target" id="namespacehpx_1_1threads_1aaf3979d5ae152739784f946eaab044c3"></span>std::uint64_t <code class="descname">get_self_component_id</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx7threads21get_self_component_idEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>get_self_component_id</em> returns the lva of the component the current thread is acting on</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function will return a meaningful value only if the code was compiled with HPX_HAVE_THREAD_TARGET_ADDRESS being defined. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7threads16get_thread_countE17thread_state_enum">
<span id="_CPPv2N3hpx7threads16get_thread_countE17thread_state_enum"></span><span id="hpx::threads::get_thread_count__thread_state_enum"></span><span class="target" id="namespacehpx_1_1threads_1ae2b675b9517381442c7201c041033680"></span>std::int64_t <code class="descname">get_thread_count</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx7threads17thread_state_enumE" title="hpx::threads::thread_state_enum">thread_state_enum</a> <em>state</em> = <a class="reference internal" href="#_CPPv3N3hpx7threads7unknownE" title="hpx::threads::unknown">unknown</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx7threads16get_thread_countE17thread_state_enum" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>get_thread_count</em> returns the number of currently known threads.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>If state == unknown this function will not only return the number of currently existing threads, but will add the number of registered task descriptions (which have not been converted into threads yet). </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">state</span></code>: [in] This specifies the thread-state for which the number of threads should be retrieved.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7threads16get_thread_countE15thread_priority17thread_state_enum">
<span id="_CPPv2N3hpx7threads16get_thread_countE15thread_priority17thread_state_enum"></span><span id="hpx::threads::get_thread_count__thread_priority.thread_state_enum"></span><span class="target" id="namespacehpx_1_1threads_1ae68a0d7159b5722ede72602f38cc83cf"></span>std::int64_t <code class="descname">get_thread_count</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx7threads15thread_priorityE" title="hpx::threads::thread_priority">thread_priority</a> <em>priority</em>, <a class="reference internal" href="#_CPPv3N3hpx7threads17thread_state_enumE" title="hpx::threads::thread_state_enum">thread_state_enum</a> <em>state</em> = <a class="reference internal" href="#_CPPv3N3hpx7threads7unknownE" title="hpx::threads::unknown">unknown</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx7threads16get_thread_countE15thread_priority17thread_state_enum" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>get_thread_count</em> returns the number of currently known threads.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>If state == unknown this function will not only return the number of currently existing threads, but will add the number of registered task descriptions (which have not been converted into threads yet). </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">priority</span></code>: [in] This specifies the thread-priority for which the number of threads should be retrieved. </li>
<li><code class="docutils literal notranslate"><span class="pre">state</span></code>: [in] This specifies the thread-state for which the number of threads should be retrieved.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7threads17enumerate_threadsERN4util15function_nonserIFb14thread_id_typeEEE17thread_state_enum">
<span id="_CPPv2N3hpx7threads17enumerate_threadsERN4util15function_nonserIFb14thread_id_typeEEE17thread_state_enum"></span><span class="target" id="namespacehpx_1_1threads_1a5dd2cea272f81a19d4f61470851a29cf"></span>bool <code class="descname">enumerate_threads</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::function_nonser&lt;bool<span class="sig-paren">(</span>thread_id_type<span class="sig-paren">)</span>&gt; <em class="property">const</em> &amp;<em>f</em>, <a class="reference internal" href="#_CPPv3N3hpx7threads17thread_state_enumE" title="hpx::threads::thread_state_enum">thread_state_enum</a> <em>state</em> = <a class="reference internal" href="#_CPPv3N3hpx7threads7unknownE" title="hpx::threads::unknown">unknown</a>, <span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx7threads17enumerate_threadsERN4util15function_nonserIFb14thread_id_typeEEE17thread_state_enum" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function <em>enumerate_threads</em> will invoke the given function <em>f</em> for each thread with a matching thread state.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: [in] The function which should be called for each matching thread. Returning ‘false’ from this function will stop the enumeration process. </li>
<li><code class="docutils literal notranslate"><span class="pre">state</span></code>: [in] This specifies the thread-state for which the threads should be enumerated. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7threads16set_thread_stateER14thread_id_type17thread_state_enum20thread_state_ex_enum15thread_priorityRN3hpx10error_codeE">
<span id="_CPPv2N3hpx7threads16set_thread_stateER14thread_id_type17thread_state_enum20thread_state_ex_enum15thread_priorityRN3hpx10error_codeE"></span><span id="hpx::threads::set_thread_state__thread_id_typeCR.thread_state_enum.thread_state_ex_enum.thread_priority.hpx::error_codeR"></span><span class="target" id="namespacehpx_1_1threads_1ac0690ad16ad778bcc79dcd727cc33025"></span>thread_state <code class="descname">set_thread_state</code><span class="sig-paren">(</span>thread_id_type <em class="property">const</em> &amp;<em>id</em>, <a class="reference internal" href="#_CPPv3N3hpx7threads17thread_state_enumE" title="hpx::threads::thread_state_enum">thread_state_enum</a> <em>state</em> = <a class="reference internal" href="#_CPPv3N3hpx7threads7pendingE" title="hpx::threads::pending">pending</a>, <a class="reference internal" href="#_CPPv3N3hpx7threads20thread_state_ex_enumE" title="hpx::threads::thread_state_ex_enum">thread_state_ex_enum</a> <em>stateex</em> = <a class="reference internal" href="#_CPPv3N3hpx7threads13wait_signaledE" title="hpx::threads::wait_signaled">wait_signaled</a>, <a class="reference internal" href="#_CPPv3N3hpx7threads15thread_priorityE" title="hpx::threads::thread_priority">thread_priority</a> <em>priority</em> = <a class="reference internal" href="#_CPPv3N3hpx7threads22thread_priority_normalE" title="hpx::threads::thread_priority_normal">thread_priority_normal</a>, <a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx7threads16set_thread_stateER14thread_id_type17thread_state_enum20thread_state_ex_enum15thread_priorityRN3hpx10error_codeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the thread state of the <em>thread</em> referenced by the thread_id <em>id</em>. </p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>If the thread referenced by the parameter <em>id</em> is in <em>thread_state::active</em> state this function schedules a new thread which will set the state of the thread as soon as its not active anymore. The function returns <em>thread_state::active</em> in this case.</dd>
<dt><strong>Return</strong></dt>
<dd>This function returns the previous state of the thread referenced by the <em>id</em> parameter. It will return one of the values as defined by the <em>thread_state</em> enumeration. If the thread is not known to the thread-manager the return value will be <em>thread_state::unknown</em>.</dd>
<dt><strong>Note</strong></dt>
<dd>As long as <em>ec</em> is not pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> this function doesn’t throw but returns the result code using the parameter <em>ec</em>. Otherwise it throws an instance of <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">id</span></code>: [in] The thread id of the thread the state should be modified for. </li>
<li><code class="docutils literal notranslate"><span class="pre">state</span></code>: [in] The new state to be set for the thread referenced by the <em>id</em> parameter. </li>
<li><code class="docutils literal notranslate"><span class="pre">stateex</span></code>: [in] The new extended state to be set for the thread referenced by the <em>id</em> parameter. </li>
<li><code class="docutils literal notranslate"><span class="pre">priority</span></code>: </li>
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7threads16set_thread_stateER14thread_id_typeRN4util17steady_time_pointEPNSt6atomicIbEE17thread_state_enum20thread_state_ex_enum15thread_priorityR10error_code">
<span id="_CPPv2N3hpx7threads16set_thread_stateER14thread_id_typeRN4util17steady_time_pointEPNSt6atomicIbEE17thread_state_enum20thread_state_ex_enum15thread_priorityR10error_code"></span><span id="hpx::threads::set_thread_state__thread_id_typeCR.util::steady_time_pointCR.std::atomic:b:P.thread_state_enum.thread_state_ex_enum.thread_priority.error_codeR"></span><span class="target" id="namespacehpx_1_1threads_1a69526bfb58918d9926eabf0ab24c3a1d"></span>thread_id_type <code class="descname">set_thread_state</code><span class="sig-paren">(</span>thread_id_type <em class="property">const</em> &amp;<em>id</em>, <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::steady_time_point <em class="property">const</em> &amp;<em>abs_time</em>, std::atomic&lt;bool&gt; *<em>started</em>, <a class="reference internal" href="#_CPPv3N3hpx7threads17thread_state_enumE" title="hpx::threads::thread_state_enum">thread_state_enum</a> <em>state</em> = <a class="reference internal" href="#_CPPv3N3hpx7threads7pendingE" title="hpx::threads::pending">pending</a>, <a class="reference internal" href="#_CPPv3N3hpx7threads20thread_state_ex_enumE" title="hpx::threads::thread_state_ex_enum">thread_state_ex_enum</a> <em>stateex</em> = <a class="reference internal" href="#_CPPv3N3hpx7threads12wait_timeoutE" title="hpx::threads::wait_timeout">wait_timeout</a>, <a class="reference internal" href="#_CPPv3N3hpx7threads15thread_priorityE" title="hpx::threads::thread_priority">thread_priority</a> <em>priority</em> = <a class="reference internal" href="#_CPPv3N3hpx7threads22thread_priority_normalE" title="hpx::threads::thread_priority_normal">thread_priority_normal</a>, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx7threads16set_thread_stateER14thread_id_typeRN4util17steady_time_pointEPNSt6atomicIbEE17thread_state_enum20thread_state_ex_enum15thread_priorityR10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the thread state of the <em>thread</em> referenced by the thread_id <em>id</em>. </p>
<p>Set a timer to set the state of the given <em>thread</em> to the given new value after it expired (at the given time)</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd></dd>
<dt><strong>Note</strong></dt>
<dd>As long as <em>ec</em> is not pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> this function doesn’t throw but returns the result code using the parameter <em>ec</em>. Otherwise it throws an instance of <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">id</span></code>: [in] The thread id of the thread the state should be modified for. </li>
<li><code class="docutils literal notranslate"><span class="pre">abs_time</span></code>: [in] Absolute point in time for the new thread to be run </li>
<li><code class="docutils literal notranslate"><span class="pre">started</span></code>: [in,out] A helper variable allowing to track the state of the timer helper thread </li>
<li><code class="docutils literal notranslate"><span class="pre">state</span></code>: [in] The new state to be set for the thread referenced by the <em>id</em> parameter. </li>
<li><code class="docutils literal notranslate"><span class="pre">stateex</span></code>: [in] The new extended state to be set for the thread referenced by the <em>id</em> parameter. </li>
<li><code class="docutils literal notranslate"><span class="pre">priority</span></code>: </li>
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7threads16set_thread_stateER14thread_id_typeRN4util17steady_time_pointE17thread_state_enum20thread_state_ex_enum15thread_priorityR10error_code">
<span id="_CPPv2N3hpx7threads16set_thread_stateER14thread_id_typeRN4util17steady_time_pointE17thread_state_enum20thread_state_ex_enum15thread_priorityR10error_code"></span><span id="hpx::threads::set_thread_state__thread_id_typeCR.util::steady_time_pointCR.thread_state_enum.thread_state_ex_enum.thread_priority.error_codeR"></span><span class="target" id="namespacehpx_1_1threads_1a44c6c84714e4314cee053731858d014b"></span>thread_id_type <code class="descname">set_thread_state</code><span class="sig-paren">(</span>thread_id_type <em class="property">const</em> &amp;<em>id</em>, <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::steady_time_point <em class="property">const</em> &amp;<em>abs_time</em>, <a class="reference internal" href="#_CPPv3N3hpx7threads17thread_state_enumE" title="hpx::threads::thread_state_enum">thread_state_enum</a> <em>state</em> = <a class="reference internal" href="#_CPPv3N3hpx7threads7pendingE" title="hpx::threads::pending">pending</a>, <a class="reference internal" href="#_CPPv3N3hpx7threads20thread_state_ex_enumE" title="hpx::threads::thread_state_ex_enum">thread_state_ex_enum</a> <em>stateex</em> = <a class="reference internal" href="#_CPPv3N3hpx7threads12wait_timeoutE" title="hpx::threads::wait_timeout">wait_timeout</a>, <a class="reference internal" href="#_CPPv3N3hpx7threads15thread_priorityE" title="hpx::threads::thread_priority">thread_priority</a> <em>priority</em> = <a class="reference internal" href="#_CPPv3N3hpx7threads22thread_priority_normalE" title="hpx::threads::thread_priority_normal">thread_priority_normal</a>, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a>&amp; = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx7threads16set_thread_stateER14thread_id_typeRN4util17steady_time_pointE17thread_state_enum20thread_state_ex_enum15thread_priorityR10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7threads16set_thread_stateER14thread_id_typeRN4util15steady_durationE17thread_state_enum20thread_state_ex_enum15thread_priorityR10error_code">
<span id="_CPPv2N3hpx7threads16set_thread_stateER14thread_id_typeRN4util15steady_durationE17thread_state_enum20thread_state_ex_enum15thread_priorityR10error_code"></span><span id="hpx::threads::set_thread_state__thread_id_typeCR.util::steady_durationCR.thread_state_enum.thread_state_ex_enum.thread_priority.error_codeR"></span><span class="target" id="namespacehpx_1_1threads_1a6cbf4d996ae9166d232f8d06dd80a916"></span>thread_id_type <code class="descname">set_thread_state</code><span class="sig-paren">(</span>thread_id_type <em class="property">const</em> &amp;<em>id</em>, <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::steady_duration <em class="property">const</em> &amp;<em>rel_time</em>, <a class="reference internal" href="#_CPPv3N3hpx7threads17thread_state_enumE" title="hpx::threads::thread_state_enum">thread_state_enum</a> <em>state</em> = <a class="reference internal" href="#_CPPv3N3hpx7threads7pendingE" title="hpx::threads::pending">pending</a>, <a class="reference internal" href="#_CPPv3N3hpx7threads20thread_state_ex_enumE" title="hpx::threads::thread_state_ex_enum">thread_state_ex_enum</a> <em>stateex</em> = <a class="reference internal" href="#_CPPv3N3hpx7threads12wait_timeoutE" title="hpx::threads::wait_timeout">wait_timeout</a>, <a class="reference internal" href="#_CPPv3N3hpx7threads15thread_priorityE" title="hpx::threads::thread_priority">thread_priority</a> <em>priority</em> = <a class="reference internal" href="#_CPPv3N3hpx7threads22thread_priority_normalE" title="hpx::threads::thread_priority_normal">thread_priority_normal</a>, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx7threads16set_thread_stateER14thread_id_typeRN4util15steady_durationE17thread_state_enum20thread_state_ex_enum15thread_priorityR10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set the thread state of the <em>thread</em> referenced by the thread_id <em>id</em>. </p>
<p>Set a timer to set the state of the given <em>thread</em> to the given new value after it expired (after the given duration)</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd></dd>
<dt><strong>Note</strong></dt>
<dd>As long as <em>ec</em> is not pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> this function doesn’t throw but returns the result code using the parameter <em>ec</em>. Otherwise it throws an instance of <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">id</span></code>: [in] The thread id of the thread the state should be modified for. </li>
<li><code class="docutils literal notranslate"><span class="pre">rel_time</span></code>: [in] Time duration after which the new thread should be run </li>
<li><code class="docutils literal notranslate"><span class="pre">state</span></code>: [in] The new state to be set for the thread referenced by the <em>id</em> parameter. </li>
<li><code class="docutils literal notranslate"><span class="pre">stateex</span></code>: [in] The new extended state to be set for the thread referenced by the <em>id</em> parameter. </li>
<li><code class="docutils literal notranslate"><span class="pre">priority</span></code>: </li>
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7threads22get_thread_descriptionER14thread_id_typeR10error_code">
<span id="_CPPv2N3hpx7threads22get_thread_descriptionER14thread_id_typeR10error_code"></span><span id="hpx::threads::get_thread_description__thread_id_typeCR.error_codeR"></span><span class="target" id="namespacehpx_1_1threads_1a42fc18a7a680f4e8bc633a4b4c956701"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::thread_description <code class="descname">get_thread_description</code><span class="sig-paren">(</span>thread_id_type <em class="property">const</em> &amp;<em>id</em>, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx7threads22get_thread_descriptionER14thread_id_typeR10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function get_thread_description is part of the thread related API allows to query the description of one of the threads known to the thread-manager.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>This function returns the description of the thread referenced by the <em>id</em> parameter. If the thread is not known to the thread-manager the return value will be the string “&lt;unknown&gt;”.</dd>
<dt><strong>Note</strong></dt>
<dd>As long as <em>ec</em> is not pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> this function doesn’t throw but returns the result code using the parameter <em>ec</em>. Otherwise it throws an instance of <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">id</span></code>: [in] The thread id of the thread being queried. </li>
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7threads22set_thread_descriptionER14thread_id_typeRN4util18thread_descriptionER10error_code">
<span id="_CPPv2N3hpx7threads22set_thread_descriptionER14thread_id_typeRN4util18thread_descriptionER10error_code"></span><span id="hpx::threads::set_thread_description__thread_id_typeCR.util::thread_descriptionCR.error_codeR"></span><span class="target" id="namespacehpx_1_1threads_1a55d8618440b2770d27c9a3b0409cc458"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::thread_description <code class="descname">set_thread_description</code><span class="sig-paren">(</span>thread_id_type <em class="property">const</em> &amp;<em>id</em>, <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::thread_description <em class="property">const</em> &amp;<em>desc</em> = <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::thread_description(), <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx7threads22set_thread_descriptionER14thread_id_typeRN4util18thread_descriptionER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7threads26get_thread_lco_descriptionER14thread_id_typeR10error_code">
<span id="_CPPv2N3hpx7threads26get_thread_lco_descriptionER14thread_id_typeR10error_code"></span><span id="hpx::threads::get_thread_lco_description__thread_id_typeCR.error_codeR"></span><span class="target" id="namespacehpx_1_1threads_1a8ceba68dc535c85cbbcee3c7813843c6"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::thread_description <code class="descname">get_thread_lco_description</code><span class="sig-paren">(</span>thread_id_type <em class="property">const</em> &amp;<em>id</em>, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx7threads26get_thread_lco_descriptionER14thread_id_typeR10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7threads26set_thread_lco_descriptionER14thread_id_typeRN4util18thread_descriptionER10error_code">
<span id="_CPPv2N3hpx7threads26set_thread_lco_descriptionER14thread_id_typeRN4util18thread_descriptionER10error_code"></span><span id="hpx::threads::set_thread_lco_description__thread_id_typeCR.util::thread_descriptionCR.error_codeR"></span><span class="target" id="namespacehpx_1_1threads_1a8462132c85ffc9637f5df1a661fcd060"></span><a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::thread_description <code class="descname">set_thread_lco_description</code><span class="sig-paren">(</span>thread_id_type <em class="property">const</em> &amp;<em>id</em>, <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::thread_description <em class="property">const</em> &amp;<em>desc</em> = <a class="reference internal" href="#_CPPv3N3hpx4utilE" title="hpx::util">util</a>::thread_description(), <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx7threads26set_thread_lco_descriptionER14thread_id_typeRN4util18thread_descriptionER10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7threads16get_thread_stateER14thread_id_typeR10error_code">
<span id="_CPPv2N3hpx7threads16get_thread_stateER14thread_id_typeR10error_code"></span><span id="hpx::threads::get_thread_state__thread_id_typeCR.error_codeR"></span><span class="target" id="namespacehpx_1_1threads_1ae9d77763cbd8ba11b92d7c4bc81fc218"></span>thread_state <code class="descname">get_thread_state</code><span class="sig-paren">(</span>thread_id_type <em class="property">const</em> &amp;<em>id</em>, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx7threads16get_thread_stateER14thread_id_typeR10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function get_thread_backtrace is part of the thread related API allows to query the currently stored thread back trace (which is captured during thread suspension).</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>This function returns the currently captured stack back trace of the thread referenced by the <em>id</em> parameter. If the thread is not known to the thread-manager the return value will be the zero.</dd>
<dt><strong>Note</strong></dt>
<dd>As long as <em>ec</em> is not pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> this function doesn’t throw but returns the result code using the parameter <em>ec</em>. Otherwise it throws an instance of <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a>. The function get_thread_state is part of the thread related API. It queries the state of one of the threads known to the thread-manager.</dd>
<dt><strong>Return</strong></dt>
<dd>This function returns the thread state of the thread referenced by the <em>id</em> parameter. If the thread is not known to the thread-manager the return value will be <em>terminated</em>.</dd>
<dt><strong>Note</strong></dt>
<dd>As long as <em>ec</em> is not pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> this function doesn’t throw but returns the result code using the parameter <em>ec</em>. Otherwise it throws an instance of <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">id</span></code>: [in] The thread id of the thread being queried. </li>
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">id</span></code>: [in] The thread id of the thread the state should be modified for. </li>
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7threads16get_thread_phaseER14thread_id_typeR10error_code">
<span id="_CPPv2N3hpx7threads16get_thread_phaseER14thread_id_typeR10error_code"></span><span id="hpx::threads::get_thread_phase__thread_id_typeCR.error_codeR"></span><span class="target" id="namespacehpx_1_1threads_1a3ce97cba2f2807d8ffe0eda6ade58b93"></span>std::size_t <code class="descname">get_thread_phase</code><span class="sig-paren">(</span>thread_id_type <em class="property">const</em> &amp;<em>id</em>, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx7threads16get_thread_phaseER14thread_id_typeR10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The function get_thread_phase is part of the thread related API. It queries the phase of one of the threads known to the thread-manager.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>This function returns the thread phase of the thread referenced by the <em>id</em> parameter. If the thread is not known to the thread-manager the return value will be ~0.</dd>
<dt><strong>Note</strong></dt>
<dd>As long as <em>ec</em> is not pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> this function doesn’t throw but returns the result code using the parameter <em>ec</em>. Otherwise it throws an instance of <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">id</span></code>: [in] The thread id of the thread the phase should be modified for. </li>
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7threads20get_numa_node_numberEv">
<span id="_CPPv2N3hpx7threads20get_numa_node_numberEv"></span><span id="hpx::threads::get_numa_node_number"></span><span class="target" id="namespacehpx_1_1threads_1adebeb57ed3c254e6e8e4b381ce0fe9f9"></span>std::size_t <code class="descname">get_numa_node_number</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx7threads20get_numa_node_numberEv" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7threads31get_thread_interruption_enabledER14thread_id_typeR10error_code">
<span id="_CPPv2N3hpx7threads31get_thread_interruption_enabledER14thread_id_typeR10error_code"></span><span id="hpx::threads::get_thread_interruption_enabled__thread_id_typeCR.error_codeR"></span><span class="target" id="namespacehpx_1_1threads_1a4d9791470b5f5e2d1b9c0a0157aa7cf1"></span>bool <code class="descname">get_thread_interruption_enabled</code><span class="sig-paren">(</span>thread_id_type <em class="property">const</em> &amp;<em>id</em>, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx7threads31get_thread_interruption_enabledER14thread_id_typeR10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns whether the given thread can be interrupted at this point.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>This function returns <em>true</em> if the given thread can be interrupted at this point in time. It will return <em>false</em> otherwise.</dd>
<dt><strong>Note</strong></dt>
<dd>As long as <em>ec</em> is not pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> this function doesn’t throw but returns the result code using the parameter <em>ec</em>. Otherwise it throws an instance of <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">id</span></code>: [in] The thread id of the thread which should be queried. </li>
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7threads31set_thread_interruption_enabledER14thread_id_typebR10error_code">
<span id="_CPPv2N3hpx7threads31set_thread_interruption_enabledER14thread_id_typebR10error_code"></span><span id="hpx::threads::set_thread_interruption_enabled__thread_id_typeCR.b.error_codeR"></span><span class="target" id="namespacehpx_1_1threads_1a75500847880b479bb6944f5a6bee64ad"></span>bool <code class="descname">set_thread_interruption_enabled</code><span class="sig-paren">(</span>thread_id_type <em class="property">const</em> &amp;<em>id</em>, bool <em>enable</em>, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx7threads31set_thread_interruption_enabledER14thread_id_typebR10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Set whether the given thread can be interrupted at this point.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>This function returns the previous value of whether the given thread could have been interrupted.</dd>
<dt><strong>Note</strong></dt>
<dd>As long as <em>ec</em> is not pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> this function doesn’t throw but returns the result code using the parameter <em>ec</em>. Otherwise it throws an instance of <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">id</span></code>: [in] The thread id of the thread which should receive the new value. </li>
<li><code class="docutils literal notranslate"><span class="pre">enable</span></code>: [in] This value will determine the new interruption enabled status for the given thread. </li>
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7threads33get_thread_interruption_requestedER14thread_id_typeR10error_code">
<span id="_CPPv2N3hpx7threads33get_thread_interruption_requestedER14thread_id_typeR10error_code"></span><span id="hpx::threads::get_thread_interruption_requested__thread_id_typeCR.error_codeR"></span><span class="target" id="namespacehpx_1_1threads_1ae64a7fdb8b5c8bac7be0c8282672a03b"></span>bool <code class="descname">get_thread_interruption_requested</code><span class="sig-paren">(</span>thread_id_type <em class="property">const</em> &amp;<em>id</em>, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx7threads33get_thread_interruption_requestedER14thread_id_typeR10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns whether the given thread has been flagged for interruption.</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>This function returns <em>true</em> if the given thread was flagged for interruption. It will return <em>false</em> otherwise.</dd>
<dt><strong>Note</strong></dt>
<dd>As long as <em>ec</em> is not pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> this function doesn’t throw but returns the result code using the parameter <em>ec</em>. Otherwise it throws an instance of <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">id</span></code>: [in] The thread id of the thread which should be queried. </li>
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7threads16interrupt_threadER14thread_id_typebR10error_code">
<span id="_CPPv2N3hpx7threads16interrupt_threadER14thread_id_typebR10error_code"></span><span id="hpx::threads::interrupt_thread__thread_id_typeCR.b.error_codeR"></span><span class="target" id="namespacehpx_1_1threads_1a6bdda1a2aab61b9b13d274b5155d7e73"></span>void <code class="descname">interrupt_thread</code><span class="sig-paren">(</span>thread_id_type <em class="property">const</em> &amp;<em>id</em>, bool <em>flag</em>, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx7threads16interrupt_threadER14thread_id_typebR10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Flag the given thread for interruption.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>As long as <em>ec</em> is not pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> this function doesn’t throw but returns the result code using the parameter <em>ec</em>. Otherwise it throws an instance of <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">id</span></code>: [in] The thread id of the thread which should be interrupted. </li>
<li><code class="docutils literal notranslate"><span class="pre">flag</span></code>: [in] The flag encodes whether the thread should be interrupted (if it is <em>true</em>), or ‘uninterrupted’ (if it is <em>false</em>). </li>
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7threads16interrupt_threadER14thread_id_typeR10error_code">
<span id="_CPPv2N3hpx7threads16interrupt_threadER14thread_id_typeR10error_code"></span><span id="hpx::threads::interrupt_thread__thread_id_typeCR.error_codeR"></span><span class="target" id="namespacehpx_1_1threads_1ae3f683ad072d61249bf20c67134d604c"></span>void <code class="descname">interrupt_thread</code><span class="sig-paren">(</span>thread_id_type <em class="property">const</em> &amp;<em>id</em>, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx7threads16interrupt_threadER14thread_id_typeR10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7threads18interruption_pointER14thread_id_typeR10error_code">
<span id="_CPPv2N3hpx7threads18interruption_pointER14thread_id_typeR10error_code"></span><span id="hpx::threads::interruption_point__thread_id_typeCR.error_codeR"></span><span class="target" id="namespacehpx_1_1threads_1ada6ec56a12b050707311d8c628089059"></span>void <code class="descname">interruption_point</code><span class="sig-paren">(</span>thread_id_type <em class="property">const</em> &amp;<em>id</em>, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx7threads18interruption_pointER14thread_id_typeR10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Interrupt the current thread at this point if it was canceled. This will throw a <a class="reference internal" href="#structhpx_1_1thread__interrupted"><span class="std std-ref">thread_interrupted</span></a> exception, which will cancel the thread.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>As long as <em>ec</em> is not pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> this function doesn’t throw but returns the result code using the parameter <em>ec</em>. Otherwise it throws an instance of <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">id</span></code>: [in] The thread id of the thread which should be interrupted. </li>
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7threads19get_thread_priorityER14thread_id_typeR10error_code">
<span id="_CPPv2N3hpx7threads19get_thread_priorityER14thread_id_typeR10error_code"></span><span id="hpx::threads::get_thread_priority__thread_id_typeCR.error_codeR"></span><span class="target" id="namespacehpx_1_1threads_1ac200e4ded92585c732c4d8bd5a0c8d5f"></span><a class="reference internal" href="#_CPPv3N3hpx7threadsE" title="hpx::threads">threads</a>::<a class="reference internal" href="#_CPPv3N3hpx7threads15thread_priorityE" title="hpx::threads::thread_priority">thread_priority</a> <code class="descname">get_thread_priority</code><span class="sig-paren">(</span>thread_id_type <em class="property">const</em> &amp;<em>id</em>, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx7threads19get_thread_priorityER14thread_id_typeR10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return priority of the given thread</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>As long as <em>ec</em> is not pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> this function doesn’t throw but returns the result code using the parameter <em>ec</em>. Otherwise it throws an instance of <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">id</span></code>: [in] The thread id of the thread whose priority is queried. </li>
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7threads14get_stack_sizeER14thread_id_typeR10error_code">
<span id="_CPPv2N3hpx7threads14get_stack_sizeER14thread_id_typeR10error_code"></span><span id="hpx::threads::get_stack_size__thread_id_typeCR.error_codeR"></span><span class="target" id="namespacehpx_1_1threads_1a3cd27631705ce7c218c7271005f13406"></span>std::ptrdiff_t <code class="descname">get_stack_size</code><span class="sig-paren">(</span>thread_id_type <em class="property">const</em> &amp;<em>id</em>, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx7threads14get_stack_sizeER14thread_id_typeR10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Return stack size of the given thread</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>As long as <em>ec</em> is not pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> this function doesn’t throw but returns the result code using the parameter <em>ec</em>. Otherwise it throws an instance of <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a>. </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">id</span></code>: [in] The thread id of the thread whose priority is queried. </li>
<li><code class="docutils literal notranslate"><span class="pre">ec</span></code>: [in,out] this represents the error status on exit, if this is pre-initialized to <em><a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a></em> the function will throw on error instead.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7threads12get_executorER14thread_id_typeR10error_code">
<span id="_CPPv2N3hpx7threads12get_executorER14thread_id_typeR10error_code"></span><span id="hpx::threads::get_executor__thread_id_typeCR.error_codeR"></span><span class="target" id="namespacehpx_1_1threads_1acefa17e3769a7d725ecb410e88d96a49"></span><a class="reference internal" href="#_CPPv3N3hpx7threadsE" title="hpx::threads">threads</a>::executors::current_executor <code class="descname">get_executor</code><span class="sig-paren">(</span>thread_id_type <em class="property">const</em> &amp;<em>id</em>, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx7threads12get_executorER14thread_id_typeR10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns a reference to the executor which was used to create the given thread.</p>
<p><dl class="docutils">
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">If</span></code>: <code class="docutils literal notranslate"><span class="pre">&amp;ec</span> <span class="pre">!=</span> <span class="pre">&amp;throws</span></code>, never throws, but will set <em>ec</em> to an appropriate value when an error occurs. Otherwise, this function will throw an <em><a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a></em> with an error code of <em><a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663adaabe7896fcf922ad9d1b1dd252bdb8c"><span class="std std-ref">hpx::yield_aborted</span></a></em> if it is signaled with <em>wait_aborted</em>. If called outside of a HPX-thread, this function will throw an <em><a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a></em> with an error code of <em><a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663a05ec9382bba0a20ecfa536cc11e52288"><span class="std std-ref">hpx::null_thread_id</span></a></em>. If this function is called while the thread-manager is not running, it will throw an <em><a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a></em> with an error code of <em><a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663abfb0c9b0ab71f8bcbe9a40c88b6b6959"><span class="std std-ref">hpx::invalid_status</span></a></em>. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx7threads8get_poolER14thread_id_typeR10error_code">
<span id="_CPPv2N3hpx7threads8get_poolER14thread_id_typeR10error_code"></span><span id="hpx::threads::get_pool__thread_id_typeCR.error_codeR"></span><span class="target" id="namespacehpx_1_1threads_1af03daba94c6dcbce39dc2eeac3785c0d"></span><a class="reference internal" href="#_CPPv3N3hpx7threadsE" title="hpx::threads">threads</a>::<a class="reference internal" href="#_CPPv3N3hpx7threads16thread_pool_baseE" title="hpx::threads::thread_pool_base">thread_pool_base</a> *<code class="descname">get_pool</code><span class="sig-paren">(</span>thread_id_type <em class="property">const</em> &amp;<em>id</em>, <a class="reference internal" href="#_CPPv3N3hpx10error_codeE" title="hpx::error_code">error_code</a> &amp;<em>ec</em> = <a class="reference internal" href="#_CPPv3N3hpx6throwsE" title="hpx::throws">throws</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx7threads8get_poolER14thread_id_typeR10error_code" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns a pointer to the pool that was used to run the current thread</p>
<p><dl class="docutils">
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">If</span></code>: <code class="docutils literal notranslate"><span class="pre">&amp;ec</span> <span class="pre">!=</span> <span class="pre">&amp;throws</span></code>, never throws, but will set <em>ec</em> to an appropriate value when an error occurs. Otherwise, this function will throw an <em><a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a></em> with an error code of <em><a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663adaabe7896fcf922ad9d1b1dd252bdb8c"><span class="std std-ref">hpx::yield_aborted</span></a></em> if it is signaled with <em>wait_aborted</em>. If called outside of a HPX-thread, this function will throw an <em><a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a></em> with an error code of <em><a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663a05ec9382bba0a20ecfa536cc11e52288"><span class="std std-ref">hpx::null_thread_id</span></a></em>. If this function is called while the thread-manager is not running, it will throw an <em><a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a></em> with an error code of <em><a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663abfb0c9b0ab71f8bcbe9a40c88b6b6959"><span class="std std-ref">hpx::invalid_status</span></a></em>. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx7threads8policiesE">
<span id="_CPPv2N3hpx7threads8policiesE"></span><span id="hpx::threads::policies"></span><span class="target" id="namespacehpx_1_1threads_1_1policies"></span><em class="property">namespace </em><code class="descname">policies</code><a class="headerlink" href="#_CPPv3N3hpx7threads8policiesE" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Enums</p>
<dl class="type">
<dt id="_CPPv3N3hpx7threads8policies14scheduler_modeE">
<span id="_CPPv2N3hpx7threads8policies14scheduler_modeE"></span><span id="hpx::threads::policies::scheduler_mode"></span><span class="target" id="namespacehpx_1_1threads_1_1policies_1a69bdc4ea03e29d7326c155278b0fc386"></span><em class="property">enum </em><code class="descname">scheduler_mode</code><a class="headerlink" href="#_CPPv3N3hpx7threads8policies14scheduler_modeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This enumeration describes the possible modes of a scheduler. </p>
<p><em>Values:</em></p>
<dl class="enumerator">
<dt id="_CPPv3N3hpx7threads8policies15nothing_specialE">
<span id="_CPPv2N3hpx7threads8policies15nothing_specialE"></span><span class="target" id="namespacehpx_1_1threads_1_1policies_1a69bdc4ea03e29d7326c155278b0fc386aaa96d91611607d9efc031d528bd74f3a"></span><code class="descname">nothing_special</code> = 0<a class="headerlink" href="#_CPPv3N3hpx7threads8policies15nothing_specialE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>As the name suggests, this option can be used to disable all other options. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx7threads8policies18do_background_workE">
<span id="_CPPv2N3hpx7threads8policies18do_background_workE"></span><span class="target" id="namespacehpx_1_1threads_1_1policies_1a69bdc4ea03e29d7326c155278b0fc386a9b9907ef13cfd847a7e29d07bcdff6f5"></span><code class="descname">do_background_work</code> = 0x1<a class="headerlink" href="#_CPPv3N3hpx7threads8policies18do_background_workE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The scheduler will periodically call a provided callback function from a special HPX thread to enable performing background-work, for instance driving networking progress or garbage-collect AGAS. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx7threads8policies22reduce_thread_priorityE">
<span id="_CPPv2N3hpx7threads8policies22reduce_thread_priorityE"></span><span class="target" id="namespacehpx_1_1threads_1_1policies_1a69bdc4ea03e29d7326c155278b0fc386a48da50256881295935d9bb119daa440b"></span><code class="descname">reduce_thread_priority</code> = 0x02<a class="headerlink" href="#_CPPv3N3hpx7threads8policies22reduce_thread_priorityE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The kernel priority of the os-thread driving the scheduler will be reduced below normal. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx7threads8policies10delay_exitE">
<span id="_CPPv2N3hpx7threads8policies10delay_exitE"></span><span class="target" id="namespacehpx_1_1threads_1_1policies_1a69bdc4ea03e29d7326c155278b0fc386a11874dbf45cd476d0f3053b8c1c9cfd1"></span><code class="descname">delay_exit</code> = 0x04<a class="headerlink" href="#_CPPv3N3hpx7threads8policies10delay_exitE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>The scheduler will wait for some unspecified amount of time before exiting the scheduling loop while being terminated to make sure no other work is being scheduled during processing the shutdown request. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx7threads8policies14fast_idle_modeE">
<span id="_CPPv2N3hpx7threads8policies14fast_idle_modeE"></span><span class="target" id="namespacehpx_1_1threads_1_1policies_1a69bdc4ea03e29d7326c155278b0fc386acd086983ec6f845ab7a1597e38850451"></span><code class="descname">fast_idle_mode</code> = 0x08<a class="headerlink" href="#_CPPv3N3hpx7threads8policies14fast_idle_modeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Some schedulers have the capability to act as ‘embedded’ schedulers. In this case it needs to periodically invoke a provided callback into the outer scheduler more frequently than normal. This option enables this behavior. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx7threads8policies17enable_elasticityE">
<span id="_CPPv2N3hpx7threads8policies17enable_elasticityE"></span><span class="target" id="namespacehpx_1_1threads_1_1policies_1a69bdc4ea03e29d7326c155278b0fc386a4f494c1a6b130fa4d79673a0fe753208"></span><code class="descname">enable_elasticity</code> = 0x10<a class="headerlink" href="#_CPPv3N3hpx7threads8policies17enable_elasticityE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This option allows for the scheduler to dynamically increase and reduce the number of processing units it runs on. Setting this value not succeed for schedulers that do not support this functionality. </p>
</dd></dl>

<dl class="enumerator">
<dt id="_CPPv3N3hpx7threads8policies12default_modeE">
<span id="_CPPv2N3hpx7threads8policies12default_modeE"></span><span class="target" id="namespacehpx_1_1threads_1_1policies_1a69bdc4ea03e29d7326c155278b0fc386aa98d9e6e0d3dae3e20c4828935bc600f"></span><code class="descname">default_mode</code> = do_background_work | reduce_thread_priority | delay_exit<a class="headerlink" href="#_CPPv3N3hpx7threads8policies12default_modeE" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>This option represents the default mode. </p>
</dd></dl>

</dd></dl>

</div>
</dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx6traitsE">
<span id="_CPPv2N3hpx6traitsE"></span><span id="hpx::traits"></span><span class="target" id="namespacehpx_1_1traits"></span><em class="property">namespace </em><code class="descname">traits</code><a class="headerlink" href="#_CPPv3N3hpx6traitsE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx4utilE">
<span id="_CPPv2N3hpx4utilE"></span><span id="hpx::util"></span><span class="target" id="namespacehpx_1_1util"></span><em class="property">namespace </em><code class="descname">util</code><a class="headerlink" href="#_CPPv3N3hpx4utilE" title="Permalink to this definition">¶</a><br /></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Functions</p>
<dl class="function">
<dt id="_CPPv3N3hpx4utillsERNSt7ostreamER10checkpoint">
<span id="_CPPv2N3hpx4utillsERNSt7ostreamER10checkpoint"></span><span id="hpx::util::lshift-operator__osR.checkpointCR"></span><span class="target" id="namespacehpx_1_1util_1a1bd050426e811a324853146573d39c0b"></span>std::ostream &amp;<code class="descname">operator&lt;&lt;</code><span class="sig-paren">(</span>std::ostream &amp;<em>ost</em>, <a class="reference internal" href="#_CPPv3N3hpx4util10checkpointE" title="hpx::util::checkpoint">checkpoint</a> <em class="property">const</em> &amp;<em>ckp</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4utillsERNSt7ostreamER10checkpoint" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Operator&lt;&lt; Overload</p>
<p><p>This overload is the main way to write data from a checkpoint to an object such as a file. Inside the function, the size of the checkpoint will be written to the stream before the checkpoint’s data. The operator&gt;&gt; overload uses this to read the correct number of bytes. Be mindful of this additional write and read when you use different facilities to write out or read in data to a checkpoint!</p>
<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ost</span></code>: Output stream to write to.</li>
<li><code class="docutils literal notranslate"><span class="pre">ckp</span></code>: Checkpoint to copy from.</li>
</ul>
</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Operator&lt;&lt; returns the ostream object. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4utilrsERNSt7istreamER10checkpoint">
<span id="_CPPv2N3hpx4utilrsERNSt7istreamER10checkpoint"></span><span id="hpx::util::rshift-operator__isR.checkpointR"></span><span class="target" id="namespacehpx_1_1util_1a9f7d6820696ba0ccff45125664b1cebc"></span>std::istream &amp;<code class="descname">operator&gt;&gt;</code><span class="sig-paren">(</span>std::istream &amp;<em>ist</em>, <a class="reference internal" href="#_CPPv3N3hpx4util10checkpointE" title="hpx::util::checkpoint">checkpoint</a> &amp;<em>ckp</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4utilrsERNSt7istreamER10checkpoint" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Operator&gt;&gt; Overload</p>
<p><p>This overload is the main way to read in data from an object such as a file to a checkpoint. It is important to note that inside the function, the first variable to be read is the size of the checkpoint. This size variable is written to the stream before the checkpoint’s data in the operator&lt;&lt; overload. Be mindful of this additional read and write when you use different facilities to read in or write out data from a checkpoint!</p>
<dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">ist</span></code>: Input stream to write from.</li>
<li><code class="docutils literal notranslate"><span class="pre">ckp</span></code>: Checkpoint to write to.</li>
</ul>
</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Operator&gt;&gt; returns the ostream object. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4util15save_checkpointERR1TDpRR2Ts">
<span id="_CPPv2N3hpx4util15save_checkpointERR1TDpRR2Ts"></span><span id="hpx::util::save_checkpoint__TRR.TsRRDp"></span><em class="property">template </em>&lt;<em class="property">typename</em> T, typename... <em>Ts</em>, <em class="property">typename</em> U = typename std::enable_if&lt;!hpx::traits::is_launch_policy&lt;T&gt;::value &amp;&amp;                !std::is_same&lt;typename std::decay&lt;T&gt;::type,                    checkpoint&gt;::value&gt;::type&gt;<br /><span class="target" id="namespacehpx_1_1util_1a9026c6688d04d1a48068e32468036336"></span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::future&lt;<a class="reference internal" href="#_CPPv3N3hpx4util10checkpointE" title="hpx::util::checkpoint">checkpoint</a>&gt; <code class="descname">save_checkpoint</code><span class="sig-paren">(</span>T &amp;&amp;<em>t</em>, Ts&amp;&amp;... <em>ts</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4util15save_checkpointERR1TDpRR2Ts" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Save_checkpoint</p>
<p><p>Save_checkpoint takes any number of objects which a user may wish to store and returns a future to a checkpoint object. Additionally the function can take a policy as a first object which changes its behavior depending on the policy passed to it. Most notably, if a sync policy is used save_checkpoint will simply return a checkpoint object.</p>
<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: Containers passed to save_checkpoint to be serialized and placed into a checkpoint object.</li>
<li><code class="docutils literal notranslate"><span class="pre">Ts</span></code>: More containers passed to save_checkpoint to be serialized and placed into a checkpoint object.</li>
<li><code class="docutils literal notranslate"><span class="pre">U</span></code>: This parameter is used to make sure that T is not a launch policy or a checkpoint. This forces the compiler to choose the correct overload.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">t</span></code>: A container to restore.</li>
<li><code class="docutils literal notranslate"><span class="pre">ts</span></code>: Other containers to restore Containers must be in the same order that they were inserted into the checkpoint.</li>
</ul>
</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Save_checkpoint returns a future to a checkpoint with one exception: if you pass <a class="reference internal" href="#structhpx_1_1launch_1a63234dfc5eb5ddbd51fe2d0de1ecfa3c"><span class="std std-ref">hpx::launch::sync</span></a> as the first argument. In this case save_checkpoint will simply return a checkpoint. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4util15save_checkpointERR10checkpointRR1TDpRR2Ts">
<span id="_CPPv2N3hpx4util15save_checkpointERR10checkpointRR1TDpRR2Ts"></span><span id="hpx::util::save_checkpoint__checkpointRR.TRR.TsRRDp"></span><em class="property">template </em>&lt;<em class="property">typename</em> T, typename... <em>Ts</em>&gt;<br /><span class="target" id="namespacehpx_1_1util_1a4f60d562081d278b87073dba958bef83"></span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::future&lt;<a class="reference internal" href="#_CPPv3N3hpx4util10checkpointE" title="hpx::util::checkpoint">checkpoint</a>&gt; <code class="descname">save_checkpoint</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx4util10checkpointE" title="hpx::util::checkpoint">checkpoint</a> &amp;&amp;<em>c</em>, T &amp;&amp;<em>t</em>, Ts&amp;&amp;... <em>ts</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4util15save_checkpointERR10checkpointRR1TDpRR2Ts" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Save_checkpoint - Take a pre-initialized checkpoint</p>
<p><p>Save_checkpoint takes any number of objects which a user may wish to store and returns a future to a checkpoint object. Additionally the function can take a policy as a first object which changes its behavior depending on the policy passed to it. Most notably, if a sync policy is used save_checkpoint will simply return a checkpoint object.</p>
<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: Containers passed to save_checkpoint to be serialized and placed into a checkpoint object.</li>
<li><code class="docutils literal notranslate"><span class="pre">Ts</span></code>: More containers passed to save_checkpoint to be serialized and placed into a checkpoint object.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">c</span></code>: Takes a pre-initialized checkpoint to copy data into.</li>
<li><code class="docutils literal notranslate"><span class="pre">t</span></code>: A container to restore.</li>
<li><code class="docutils literal notranslate"><span class="pre">ts</span></code>: Other containers to restore Containers must be in the same order that they were inserted into the checkpoint.</li>
</ul>
</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Save_checkpoint returns a future to a checkpoint with one exception: if you pass <a class="reference internal" href="#structhpx_1_1launch_1a63234dfc5eb5ddbd51fe2d0de1ecfa3c"><span class="std std-ref">hpx::launch::sync</span></a> as the first argument. In this case save_checkpoint will simply return a checkpoint. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4util15save_checkpointEN3hpx6launchERR1TDpRR2Ts">
<span id="_CPPv2N3hpx4util15save_checkpointEN3hpx6launchERR1TDpRR2Ts"></span><span id="hpx::util::save_checkpoint__hpx::launch.TRR.TsRRDp"></span><em class="property">template </em>&lt;<em class="property">typename</em> T, typename... <em>Ts</em>&gt;<br /><span class="target" id="namespacehpx_1_1util_1a1be65fd5914ba68bd22969b3da59ad4e"></span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::future&lt;<a class="reference internal" href="#_CPPv3N3hpx4util10checkpointE" title="hpx::util::checkpoint">checkpoint</a>&gt; <code class="descname">save_checkpoint</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6launchE" title="hpx::launch">launch</a> <em>p</em>, T &amp;&amp;<em>t</em>, Ts&amp;&amp;... <em>ts</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4util15save_checkpointEN3hpx6launchERR1TDpRR2Ts" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Save_checkpoint - Policy overload</p>
<p><p>Save_checkpoint takes any number of objects which a user may wish to store and returns a future to a checkpoint object. Additionally the function can take a policy as a first object which changes its behavior depending on the policy passed to it. Most notably, if a sync policy is used save_checkpoint will simply return a checkpoint object.</p>
<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: Containers passed to save_checkpoint to be serialized and placed into a checkpoint object.</li>
<li><code class="docutils literal notranslate"><span class="pre">Ts</span></code>: More containers passed to save_checkpoint to be serialized and placed into a checkpoint object.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">p</span></code>: Takes an HPX launch policy. Allows the user to change the way the function is launched i.e. async, sync, etc.</li>
<li><code class="docutils literal notranslate"><span class="pre">t</span></code>: A container to restore.</li>
<li><code class="docutils literal notranslate"><span class="pre">ts</span></code>: Other containers to restore Containers must be in the same order that they were inserted into the checkpoint.</li>
</ul>
</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Save_checkpoint returns a future to a checkpoint with one exception: if you pass <a class="reference internal" href="#structhpx_1_1launch_1a63234dfc5eb5ddbd51fe2d0de1ecfa3c"><span class="std std-ref">hpx::launch::sync</span></a> as the first argument. In this case save_checkpoint will simply return a checkpoint. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4util15save_checkpointEN3hpx6launchERR10checkpointRR1TDpRR2Ts">
<span id="_CPPv2N3hpx4util15save_checkpointEN3hpx6launchERR10checkpointRR1TDpRR2Ts"></span><span id="hpx::util::save_checkpoint__hpx::launch.checkpointRR.TRR.TsRRDp"></span><em class="property">template </em>&lt;<em class="property">typename</em> T, typename... <em>Ts</em>&gt;<br /><span class="target" id="namespacehpx_1_1util_1a094238683d20fda25fa5e5a961f8c81a"></span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::future&lt;<a class="reference internal" href="#_CPPv3N3hpx4util10checkpointE" title="hpx::util::checkpoint">checkpoint</a>&gt; <code class="descname">save_checkpoint</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6launchE" title="hpx::launch">launch</a> <em>p</em>, <a class="reference internal" href="#_CPPv3N3hpx4util10checkpointE" title="hpx::util::checkpoint">checkpoint</a> &amp;&amp;<em>c</em>, T &amp;&amp;<em>t</em>, Ts&amp;&amp;... <em>ts</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4util15save_checkpointEN3hpx6launchERR10checkpointRR1TDpRR2Ts" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Save_checkpoint - Policy overload &amp; pre-initialized checkpoint</p>
<p><p>Save_checkpoint takes any number of objects which a user may wish to store and returns a future to a checkpoint object. Additionally the function can take a policy as a first object which changes its behavior depending on the policy passed to it. Most notably, if a sync policy is used save_checkpoint will simply return a checkpoint object.</p>
<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: Containers passed to save_checkpoint to be serialized and placed into a checkpoint object.</li>
<li><code class="docutils literal notranslate"><span class="pre">Ts</span></code>: More containers passed to save_checkpoint to be serialized and placed into a checkpoint object.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">p</span></code>: Takes an HPX launch policy. Allows the user to change the way the function is launched i.e. async, sync, etc.</li>
<li><code class="docutils literal notranslate"><span class="pre">c</span></code>: Takes a pre-initialized checkpoint to copy data into.</li>
<li><code class="docutils literal notranslate"><span class="pre">t</span></code>: A container to restore.</li>
<li><code class="docutils literal notranslate"><span class="pre">ts</span></code>: Other containers to restore Containers must be in the same order that they were inserted into the checkpoint.</li>
</ul>
</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Save_checkpoint returns a future to a checkpoint with one exception: if you pass <a class="reference internal" href="#structhpx_1_1launch_1a63234dfc5eb5ddbd51fe2d0de1ecfa3c"><span class="std std-ref">hpx::launch::sync</span></a> as the first argument. In this case save_checkpoint will simply return a checkpoint. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4util15save_checkpointEN3hpx6launch11sync_policyERR1TDpRR2Ts">
<span id="_CPPv2N3hpx4util15save_checkpointEN3hpx6launch11sync_policyERR1TDpRR2Ts"></span><span id="hpx::util::save_checkpoint__hpx::launch::sync_policy.TRR.TsRRDp"></span><em class="property">template </em>&lt;<em class="property">typename</em> T, typename... <em>Ts</em>, <em class="property">typename</em> U = typename std::enable_if&lt;!std::is_same&lt;            typename std::decay&lt;T&gt;::type, checkpoint&gt;::value&gt;::type&gt;<br /><span class="target" id="namespacehpx_1_1util_1a07600540eecdc965db102235aa7c9935"></span><a class="reference internal" href="#_CPPv3N3hpx4util10checkpointE" title="hpx::util::checkpoint">checkpoint</a> <code class="descname">save_checkpoint</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6launchE" title="hpx::launch">launch</a>::sync_policy <em>sync_p</em>, T &amp;&amp;<em>t</em>, Ts&amp;&amp;... <em>ts</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4util15save_checkpointEN3hpx6launch11sync_policyERR1TDpRR2Ts" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Save_checkpoint - Sync_policy overload</p>
<p><p>Save_checkpoint takes any number of objects which a user may wish to store and returns a future to a checkpoint object. Additionally the function can take a policy as a first object which changes its behavior depending on the policy passed to it. Most notably, if a sync policy is used save_checkpoint will simply return a checkpoint object.</p>
<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: Containers passed to save_checkpoint to be serialized and placed into a checkpoint object.</li>
<li><code class="docutils literal notranslate"><span class="pre">Ts</span></code>: More containers passed to save_checkpoint to be serialized and placed into a checkpoint object.</li>
<li><code class="docutils literal notranslate"><span class="pre">U</span></code>: This parameter is used to make sure that T is not a checkpoint. This forces the compiler to choose the correct overload.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">sync_p</span></code>: hpx::launch::sync_policy</li>
<li><code class="docutils literal notranslate"><span class="pre">t</span></code>: A container to restore.</li>
<li><code class="docutils literal notranslate"><span class="pre">ts</span></code>: Other containers to restore Containers must be in the same order that they were inserted into the checkpoint.</li>
</ul>
</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Save_checkpoint which is passed hpx::launch::sync_policy will return a checkpoint which contains the serialized values checkpoint. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4util15save_checkpointEN3hpx6launch11sync_policyERR10checkpointRR1TDpRR2Ts">
<span id="_CPPv2N3hpx4util15save_checkpointEN3hpx6launch11sync_policyERR10checkpointRR1TDpRR2Ts"></span><span id="hpx::util::save_checkpoint__hpx::launch::sync_policy.checkpointRR.TRR.TsRRDp"></span><em class="property">template </em>&lt;<em class="property">typename</em> T, typename... <em>Ts</em>&gt;<br /><span class="target" id="namespacehpx_1_1util_1a2336322e49b8dc02c73d3b5234470d1c"></span><a class="reference internal" href="#_CPPv3N3hpx4util10checkpointE" title="hpx::util::checkpoint">checkpoint</a> <code class="descname">save_checkpoint</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv33hpx" title="hpx">hpx</a>::<a class="reference internal" href="#_CPPv3N3hpx6launchE" title="hpx::launch">launch</a>::sync_policy <em>sync_p</em>, <a class="reference internal" href="#_CPPv3N3hpx4util10checkpointE" title="hpx::util::checkpoint">checkpoint</a> &amp;&amp;<em>c</em>, T &amp;&amp;<em>t</em>, Ts&amp;&amp;... <em>ts</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4util15save_checkpointEN3hpx6launch11sync_policyERR10checkpointRR1TDpRR2Ts" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Save_checkpoint - Sync_policy overload &amp; pre-init. checkpoint</p>
<p><p>Save_checkpoint takes any number of objects which a user may wish to store and returns a future to a checkpoint object. Additionally the function can take a policy as a first object which changes its behavior depending on the policy passed to it. Most notably, if a sync policy is used save_checkpoint will simply return a checkpoint object.</p>
<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: Containers passed to save_checkpoint to be serialized and placed into a checkpoint object.</li>
<li><code class="docutils literal notranslate"><span class="pre">Ts</span></code>: More containers passed to save_checkpoint to be serialized and placed into a checkpoint object.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">sync_p</span></code>: hpx::launch::sync_policy</li>
<li><code class="docutils literal notranslate"><span class="pre">c</span></code>: Takes a pre-initialized checkpoint to copy data into.</li>
<li><code class="docutils literal notranslate"><span class="pre">t</span></code>: A container to restore.</li>
<li><code class="docutils literal notranslate"><span class="pre">ts</span></code>: Other containers to restore Containers must be in the same order that they were inserted into the checkpoint.</li>
</ul>
</dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Save_checkpoint which is passed hpx::launch::sync_policy will return a checkpoint which contains the serialized values checkpoint. </dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4util18restore_checkpointER10checkpointR1TDpR2Ts">
<span id="_CPPv2N3hpx4util18restore_checkpointER10checkpointR1TDpR2Ts"></span><span id="hpx::util::restore_checkpoint__checkpointCR.TR.TsRDp"></span><em class="property">template </em>&lt;<em class="property">typename</em> T, typename... <em>Ts</em>&gt;<br /><span class="target" id="namespacehpx_1_1util_1a5f1bc74c756dd18e238a61787cd067a3"></span>void <code class="descname">restore_checkpoint</code><span class="sig-paren">(</span><a class="reference internal" href="#_CPPv3N3hpx4util10checkpointE" title="hpx::util::checkpoint">checkpoint</a> <em class="property">const</em> &amp;<em>c</em>, T &amp;<em>t</em>, Ts&amp;... <em>ts</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4util18restore_checkpointER10checkpointR1TDpR2Ts" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Resurrect</p>
<p>Restore_checkpoint takes a checkpoint object as a first argument and the containers which will be filled from the byte stream (in the same order as they were placed in save_checkpoint).</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>Restore_checkpoint returns void. </dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">T</span></code>: A container to restore.</li>
<li><code class="docutils literal notranslate"><span class="pre">Ts</span></code>: Other containers to restore. Containers must be in the same order that they were inserted into the checkpoint.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">c</span></code>: The checkpoint to restore.</li>
<li><code class="docutils literal notranslate"><span class="pre">t</span></code>: A container to restore.</li>
<li><code class="docutils literal notranslate"><span class="pre">ts</span></code>: Other containers to restore Containers must be in the same order that they were inserted into the checkpoint.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4util15attach_debuggerEv">
<span id="_CPPv2N3hpx4util15attach_debuggerEv"></span><span id="hpx::util::attach_debugger"></span><span class="target" id="namespacehpx_1_1util_1a4d53a5f5c04d022a87d71b19af5d14f3"></span>void <code class="descname">attach_debugger</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4util15attach_debuggerEv" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Tries to break an attached debugger, if not supported a loop is invoked which gives enough time to attach a debugger manually. </p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> F, <em class="property">typename</em> … <em>Ts</em>&gt;</dt>
<dt>
<span class="target" id="namespacehpx_1_1util_1a2cf4b0f46eb58f6eb21dc3905236b981"></span><code class="descname">HPX_HOST_DEVICE util::invoke_result&lt;F, Ts...&gt;::type hpx::util::invoke(F &amp;&amp; f, Ts &amp;&amp;... vs)</code></dt>
<dd><p>Invokes the given callable object f with the content of the argument pack vs</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The result of the callable object when it’s called with the given argument types.</dd>
<dt><strong>Note</strong></dt>
<dd>This function is similar to <code class="docutils literal notranslate"><span class="pre">std::invoke</span></code> (C++17) </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Requires to be a callable object. If f is a member function pointer, the first argument in the pack will be treated as the callee (this object).</li>
<li><code class="docutils literal notranslate"><span class="pre">vs</span></code>: An arbitrary pack of arguments</li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">std::exception</span></code>: like objects thrown by call to object f with the argument types vs.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> R, <em class="property">typename</em> F, <em class="property">typename</em> … <em>Ts</em>&gt;</dt>
<dt>
<span class="target" id="namespacehpx_1_1util_1a57d910197ceaa23d9255affae39bc8a4"></span><code class="descname">HPX_HOST_DEVICE R hpx::util::invoke_r(F &amp;&amp; f, Ts &amp;&amp;... vs)</code></dt>
<dd><p>Invokes the given callable object f with the content of the argument pack vs</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The result of the callable object when it’s called with the given argument types.</dd>
<dt><strong>Note</strong></dt>
<dd>This function is similar to <code class="docutils literal notranslate"><span class="pre">std::invoke</span></code> (C++17)</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Requires to be a callable object. If f is a member function pointer, the first argument in the pack will be treated as the callee (this object).</li>
<li><code class="docutils literal notranslate"><span class="pre">vs</span></code>: An arbitrary pack of arguments</li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">std::exception</span></code>: like objects thrown by call to object f with the argument types vs.</li>
</ul>
</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">R</span></code>: The result type of the function when it’s called with the content of the given argument types vs. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> F, <em class="property">typename</em> Tuple&gt;</dt>
<dt>
<span class="target" id="namespacehpx_1_1util_1a67ca97209fcad96869b3efcd1ccc7aa8"></span><code class="descname">HPX_HOST_DEVICE detail::invoke_fused_result&lt;F, Tuple&gt;::type hpx::util::invoke_fused(F &amp;&amp; f, Tuple &amp;&amp; t)</code></dt>
<dd><p>Invokes the given callable object f with the content of the sequenced type t (tuples, pairs)</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The result of the callable object when it’s called with the content of the given sequenced type.</dd>
<dt><strong>Note</strong></dt>
<dd>This function is similar to <code class="docutils literal notranslate"><span class="pre">std::apply</span></code> (C++17) </dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Must be a callable object. If f is a member function pointer, the first argument in the sequenced type will be treated as the callee (this object).</li>
<li><code class="docutils literal notranslate"><span class="pre">t</span></code>: A type which is content accessible through a call to hpx::util::get.</li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">std::exception</span></code>: like objects thrown by call to object f with the arguments contained in the sequenceable type t.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> R, <em class="property">typename</em> F, <em class="property">typename</em> Tuple&gt;</dt>
<dt>
<span class="target" id="namespacehpx_1_1util_1aaa8145b7927372b51d28c87f29cea994"></span><code class="descname">HPX_HOST_DEVICE R hpx::util::invoke_fused_r(F &amp;&amp; f, Tuple &amp;&amp; t)</code></dt>
<dd><p>Invokes the given callable object f with the content of the sequenced type t (tuples, pairs)</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The result of the callable object when it’s called with the content of the given sequenced type.</dd>
<dt><strong>Note</strong></dt>
<dd>This function is similar to <code class="docutils literal notranslate"><span class="pre">std::apply</span></code> (C++17)</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">f</span></code>: Must be a callable object. If f is a member function pointer, the first argument in the sequenced type will be treated as the callee (this object).</li>
<li><code class="docutils literal notranslate"><span class="pre">t</span></code>: A type which is content accessible through a call to hpx::util::get.</li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">std::exception</span></code>: like objects thrown by call to object f with the arguments contained in the sequenceable type t.</li>
</ul>
</dd>
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">R</span></code>: The result type of the function when it’s called with the content of the given sequenced type. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt>
<em class="property">template </em>&lt;<em class="property">typename</em> Mapper, typename… <em>T</em>&gt;</dt>
<dt>
<span class="target" id="namespacehpx_1_1util_1a00dc09958eb28cdf31d74de35cb54b68"></span><code class="descname">&lt;unspecified&gt; hpx::util::map_pack(Mapper &amp;&amp; mapper, T &amp;&amp;... pack)</code></dt>
<dd><p>Maps the pack with the given mapper.</p>
<p>This function tries to visit all plain elements which may be wrapped in:<ul class="simple">
<li>homogeneous containers (<code class="docutils literal notranslate"><span class="pre">std::vector</span></code>, <code class="docutils literal notranslate"><span class="pre">std::list</span></code>)</li>
<li>heterogenous containers <code class="docutils literal notranslate"><span class="pre">(hpx::tuple</span></code>, <code class="docutils literal notranslate"><span class="pre">std::pair</span></code>, <code class="docutils literal notranslate"><span class="pre">std::array</span></code>) and re-assembles the pack with the result of the mapper. Mapping from one type to a different one is supported.</li>
</ul>
</p>
<p>Elements that aren’t accepted by the mapper are routed through and preserved through the hierarchy.</p>
<p><div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Maps all integers to floats</span>
<span class="n">map_pack</span><span class="p">([](</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kt">float</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
<span class="p">},</span>
<span class="mi">1</span><span class="p">,</span> <span class="n">hpx</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">make_tuple</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}),</span> <span class="mi">5</span><span class="p">);</span>
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>The mapped element or in case the pack contains multiple elements, the pack is wrapped into a <code class="docutils literal notranslate"><span class="pre">hpx::tuple</span></code>. </dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">std::exception</span></code>: like objects which are thrown by an invocation to the mapper.</li>
</ul>
</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">mapper</span></code>: A callable object, which accept an arbitrary type and maps it to another type or the same one.</li>
<li><code class="docutils literal notranslate"><span class="pre">pack</span></code>: An arbitrary variadic pack which may contain any type.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4util19traverse_pack_asyncERR7VisitorDpRR1T">
<span id="_CPPv2N3hpx4util19traverse_pack_asyncERR7VisitorDpRR1T"></span><span id="hpx::util::traverse_pack_async__VisitorRR.TRRDp"></span><em class="property">template </em>&lt;<em class="property">typename</em> Visitor, typename... <em>T</em>&gt;<br /><span class="target" id="namespacehpx_1_1util_1a1f6868cf0eddd78ed96b2f12edf69624"></span>auto <code class="descname">traverse_pack_async</code><span class="sig-paren">(</span>Visitor &amp;&amp;<em>visitor</em>, T&amp;&amp;... <em>pack</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4util19traverse_pack_asyncERR7VisitorDpRR1T" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Traverses the pack with the given visitor in an asynchronous way.</p>
<p>This function works in the same way as <code class="docutils literal notranslate"><span class="pre">traverse_pack</span></code>, however, we are able to suspend and continue the traversal at later time. Thus we require a visitor callable object which provides three <code class="docutils literal notranslate"><span class="pre">operator()</span></code> overloads as depicted by the code sample below: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">my_async_visitor</span>
<span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="n">async_traverse_visit_tag</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">element</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">N</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="n">async_traverse_detach_tag</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">element</span><span class="p">,</span> <span class="n">N</span><span class="o">&amp;&amp;</span> <span class="n">next</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="n">async_traverse_complete_tag</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">pack</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</p>
<p><p>See </p>
<code class="docutils literal notranslate"><span class="pre">traverse_pack</span></code> for a detailed description about the traversal behavior and capabilities. <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>A boost::intrusive_ptr that references an instance of the given visitor object.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">visitor</span></code>: A visitor object which provides the three <code class="docutils literal notranslate"><span class="pre">operator()</span></code> overloads that were described above. Additionally the visitor must be compatible for referencing it from a <code class="docutils literal notranslate"><span class="pre">boost::intrusive_ptr</span></code>. The visitor should must have a virtual destructor!</li>
<li><code class="docutils literal notranslate"><span class="pre">pack</span></code>: The arbitrary parameter pack which is traversed asynchronously. Nested objects inside containers and tuple like types are traversed recursively.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4util29traverse_pack_async_allocatorER9AllocatorRR7VisitorDpRR1T">
<span id="_CPPv2N3hpx4util29traverse_pack_async_allocatorER9AllocatorRR7VisitorDpRR1T"></span><span id="hpx::util::traverse_pack_async_allocator__AllocatorCR.VisitorRR.TRRDp"></span><em class="property">template </em>&lt;<em class="property">typename</em> Allocator, <em class="property">typename</em> Visitor, typename... <em>T</em>&gt;<br /><span class="target" id="namespacehpx_1_1util_1aca39208be80bca9134517d844d412936"></span>auto <code class="descname">traverse_pack_async_allocator</code><span class="sig-paren">(</span>Allocator <em class="property">const</em> &amp;<em>alloc</em>, Visitor &amp;&amp;<em>visitor</em>, T&amp;&amp;... <em>pack</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4util29traverse_pack_async_allocatorER9AllocatorRR7VisitorDpRR1T" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Traverses the pack with the given visitor in an asynchronous way.</p>
<p>This function works in the same way as <code class="docutils literal notranslate"><span class="pre">traverse_pack</span></code>, however, we are able to suspend and continue the traversal at later time. Thus we require a visitor callable object which provides three <code class="docutils literal notranslate"><span class="pre">operator()</span></code> overloads as depicted by the code sample below: <div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">my_async_visitor</span>
<span class="p">{</span>
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="n">async_traverse_visit_tag</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">element</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">N</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="n">async_traverse_detach_tag</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">element</span><span class="p">,</span> <span class="n">N</span><span class="o">&amp;&amp;</span> <span class="n">next</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="n">async_traverse_complete_tag</span><span class="p">,</span> <span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">pack</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</p>
<p><p>See </p>
<code class="docutils literal notranslate"><span class="pre">traverse_pack</span></code> for a detailed description about the traversal behavior and capabilities. <dl class="docutils">
<dt><strong>Return</strong></dt>
<dd>A boost::intrusive_ptr that references an instance of the given visitor object.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">visitor</span></code>: A visitor object which provides the three <code class="docutils literal notranslate"><span class="pre">operator()</span></code> overloads that were described above. Additionally the visitor must be compatible for referencing it from a <code class="docutils literal notranslate"><span class="pre">boost::intrusive_ptr</span></code>. The visitor should must have a virtual destructor!</li>
<li><code class="docutils literal notranslate"><span class="pre">pack</span></code>: The arbitrary parameter pack which is traversed asynchronously. Nested objects inside containers and tuple like types are traversed recursively. </li>
<li><code class="docutils literal notranslate"><span class="pre">alloc</span></code>: Allocator instance to use to create the traversal frame.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4util6unwrapEDpRR4Args">
<span id="_CPPv2N3hpx4util6unwrapEDpRR4Args"></span><span id="hpx::util::unwrap__ArgsRRDp"></span><em class="property">template </em>&lt;typename... <em>Args</em>&gt;<br /><span class="target" id="namespacehpx_1_1util_1a687bc9b163ccbdaaa82764b171b7f0c0"></span>auto <code class="descname">unwrap</code><span class="sig-paren">(</span>Args&amp;&amp;... <em>args</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4util6unwrapEDpRR4Args" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>A helper function for retrieving the actual result of any hpx::lcos::future like type which is wrapped in an arbitrary way.</p>
<p>Unwraps the given pack of arguments, so that any hpx::lcos::future object is replaced by its future result type in the argument pack:<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">hpx::future&lt;int&gt;</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">int</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">hpx::future&lt;std::vector&lt;float&gt;&gt;</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">std::vector&lt;float&gt;</span></code></li>
<li><code class="docutils literal notranslate"><span class="pre">std::vector&lt;future&lt;float&gt;&gt;</span></code> -&gt; <code class="docutils literal notranslate"><span class="pre">std::vector&lt;float&gt;</span></code></li>
</ul>
</p>
<p>The function is capable of unwrapping hpx::lcos::future like objects that are wrapped inside any container or tuple like type, see <a class="reference internal" href="#namespacehpx_1_1util_1a00dc09958eb28cdf31d74de35cb54b68"><span class="std std-ref">hpx::util::map_pack()</span></a> for a detailed description about which surrounding types are supported. Non hpx::lcos::future like types are permitted as arguments and passed through.</p>
<p><div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Single arguments</span>
<span class="kt">int</span> <span class="n">i1</span> <span class="o">=</span> <span class="nl">hpx</span><span class="p">:</span><span class="n">util</span><span class="o">::</span><span class="n">unwrap</span><span class="p">(</span><span class="n">hpx</span><span class="o">::</span><span class="n">lcos</span><span class="o">::</span><span class="n">make_ready_future</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>

<span class="c1">// Multiple arguments</span>
<span class="n">hpx</span><span class="o">::</span><span class="n">tuple</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">i2</span> <span class="o">=</span>
    <span class="nl">hpx</span><span class="p">:</span><span class="n">util</span><span class="o">::</span><span class="n">unwrap</span><span class="p">(</span><span class="n">hpx</span><span class="o">::</span><span class="n">lcos</span><span class="o">::</span><span class="n">make_ready_future</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
                     <span class="n">hpx</span><span class="o">::</span><span class="n">lcos</span><span class="o">::</span><span class="n">make_ready_future</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
</pre></div>
</div>
</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This function unwraps the given arguments until the first traversed nested hpx::lcos::future which corresponds to an unwrapping depth of one. See <a class="reference internal" href="#namespacehpx_1_1util_1a916ca91b9993c4f1e77feeed738631bb"><span class="std std-ref">hpx::util::unwrap_n()</span></a> for a function which unwraps the given arguments to a particular depth or <a class="reference internal" href="#namespacehpx_1_1util_1a72dc824c1b2fe406b75984d0f3c131d5"><span class="std std-ref">hpx::util::unwrap_all()</span></a> that unwraps all future like objects recursively which are contained in the arguments.</dd>
<dt><strong>Return</strong></dt>
<dd>Depending on the count of arguments this function returns a hpx::util::tuple containing the unwrapped arguments if multiple arguments are given. In case the function is called with a single argument, the argument is unwrapped and returned.</dd>
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">args</span></code>: the arguments that are unwrapped which may contain any arbitrary future or non future type.</li>
</ul>
</dd>
<dt><strong>Exceptions</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">std::exception</span></code>: like objects in case any of the given wrapped hpx::lcos::future objects were resolved through an exception. See hpx::lcos::future::get() for details. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4util8unwrap_nEDpRR4Args">
<span id="_CPPv2N3hpx4util8unwrap_nEDpRR4Args"></span><span id="hpx::util::unwrap_n__ArgsRRDp"></span><em class="property">template </em>&lt;std::size_t <em>Depth</em>, typename... <em>Args</em>&gt;<br /><span class="target" id="namespacehpx_1_1util_1a916ca91b9993c4f1e77feeed738631bb"></span>auto <code class="descname">unwrap_n</code><span class="sig-paren">(</span>Args&amp;&amp;... <em>args</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4util8unwrap_nEDpRR4Args" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>An alterntive version of <a class="reference internal" href="#namespacehpx_1_1util_1a687bc9b163ccbdaaa82764b171b7f0c0"><span class="std std-ref">hpx::util::unwrap()</span></a>, which unwraps the given arguments to a certain depth of hpx::lcos::future like objects.</p>
<p><p>See unwrap for a detailed description. </p>
<dl class="docutils">
<dt><strong>Template Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">Depth</span></code>: The count of hpx::lcos::future like objects which are unwrapped maximally.</li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4util10unwrap_allEDpRR4Args">
<span id="_CPPv2N3hpx4util10unwrap_allEDpRR4Args"></span><span id="hpx::util::unwrap_all__ArgsRRDp"></span><em class="property">template </em>&lt;typename... <em>Args</em>&gt;<br /><span class="target" id="namespacehpx_1_1util_1a72dc824c1b2fe406b75984d0f3c131d5"></span>auto <code class="descname">unwrap_all</code><span class="sig-paren">(</span>Args&amp;&amp;... <em>args</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4util10unwrap_allEDpRR4Args" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>An alterntive version of <a class="reference internal" href="#namespacehpx_1_1util_1a687bc9b163ccbdaaa82764b171b7f0c0"><span class="std std-ref">hpx::util::unwrap()</span></a>, which unwraps the given arguments recursively so that all contained hpx::lcos::future like objects are replaced by their actual value.</p>
<p>See <a class="reference internal" href="#namespacehpx_1_1util_1a687bc9b163ccbdaaa82764b171b7f0c0"><span class="std std-ref">hpx::util::unwrap()</span></a> for a detailed description. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4util10unwrappingERR1T">
<span id="_CPPv2N3hpx4util10unwrappingERR1T"></span><span id="hpx::util::unwrapping__TRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> T&gt;<br /><span class="target" id="namespacehpx_1_1util_1a7529d9ac687684c33403cdd1f9cef8e4"></span>auto <code class="descname">unwrapping</code><span class="sig-paren">(</span>T &amp;&amp;<em>callable</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4util10unwrappingERR1T" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns a callable object which unwraps its arguments upon invocation using the <a class="reference internal" href="#namespacehpx_1_1util_1a687bc9b163ccbdaaa82764b171b7f0c0"><span class="std std-ref">hpx::util::unwrap()</span></a> function and then passes the result to the given callable object.</p>
<p><div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">auto</span> <span class="n">callable</span> <span class="o">=</span> <span class="n">hpx</span><span class="o">::</span><span class="n">util</span><span class="o">::</span><span class="n">unwrapping</span><span class="p">([](</span><span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">;</span>
<span class="p">});</span>

<span class="kt">int</span> <span class="n">i1</span> <span class="o">=</span> <span class="n">callable</span><span class="p">(</span><span class="n">hpx</span><span class="o">::</span><span class="n">lcos</span><span class="o">::</span><span class="n">make_ready_future</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
                  <span class="n">hpx</span><span class="o">::</span><span class="n">lcos</span><span class="o">::</span><span class="n">make_ready_future</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
</pre></div>
</div>
</p>
<p>See <a class="reference internal" href="#namespacehpx_1_1util_1a687bc9b163ccbdaaa82764b171b7f0c0"><span class="std std-ref">hpx::util::unwrap()</span></a> for a detailed description.</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">callable</span></code>: the callable object which which is called with the result of the corresponding unwrap function. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4util12unwrapping_nERR1T">
<span id="_CPPv2N3hpx4util12unwrapping_nERR1T"></span><span id="hpx::util::unwrapping_n__TRR"></span><em class="property">template </em>&lt;std::size_t <em>Depth</em>, <em class="property">typename</em> T&gt;<br /><span class="target" id="namespacehpx_1_1util_1a66e52fc8f88ccfb7d9215836eab5249e"></span>auto <code class="descname">unwrapping_n</code><span class="sig-paren">(</span>T &amp;&amp;<em>callable</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4util12unwrapping_nERR1T" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns a callable object which unwraps its arguments upon invocation using the <a class="reference internal" href="#namespacehpx_1_1util_1a916ca91b9993c4f1e77feeed738631bb"><span class="std std-ref">hpx::util::unwrap_n()</span></a> function and then passes the result to the given callable object.</p>
<p>See <a class="reference internal" href="#namespacehpx_1_1util_1a7529d9ac687684c33403cdd1f9cef8e4"><span class="std std-ref">hpx::util::unwrapping()</span></a> for a detailed description. </p>
</dd></dl>

<dl class="function">
<dt id="_CPPv3N3hpx4util14unwrapping_allERR1T">
<span id="_CPPv2N3hpx4util14unwrapping_allERR1T"></span><span id="hpx::util::unwrapping_all__TRR"></span><em class="property">template </em>&lt;<em class="property">typename</em> T&gt;<br /><span class="target" id="namespacehpx_1_1util_1ad32bada7cd9794dcb256df84610733f8"></span>auto <code class="descname">unwrapping_all</code><span class="sig-paren">(</span>T &amp;&amp;<em>callable</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv3N3hpx4util14unwrapping_allERR1T" title="Permalink to this definition">¶</a><br /></dt>
<dd><p>Returns a callable object which unwraps its arguments upon invocation using the <a class="reference internal" href="#namespacehpx_1_1util_1a72dc824c1b2fe406b75984d0f3c131d5"><span class="std std-ref">hpx::util::unwrap_all()</span></a> function and then passes the result to the given callable object.</p>
<p>See <a class="reference internal" href="#namespacehpx_1_1util_1a7529d9ac687684c33403cdd1f9cef8e4"><span class="std std-ref">hpx::util::unwrapping()</span></a> for a detailed description. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="type">
<dt id="_CPPv3N3hpx4util10functionalE">
<span id="_CPPv2N3hpx4util10functionalE"></span><span id="hpx::util::functional"></span><span class="target" id="namespacehpx_1_1util_1_1functional"></span><em class="property">namespace </em><code class="descname">functional</code><a class="headerlink" href="#_CPPv3N3hpx4util10functionalE" title="Permalink to this definition">¶</a><br /></dt>
<dd></dd></dl>

<dl class="file">
<dt>
<span class="target" id="migrate__from__storage_8hpp"></span><em>file</em> <code class="descname">migrate_from_storage.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/lcos/future.hpp&gt;</em><em>#include &lt;hpx/error_code.hpp&gt;</em><em>#include &lt;hpx/lcos/detail/future_data.hpp&gt;</em><em>#include &lt;hpx/lcos/local/detail/condition_variable.hpp&gt;</em><em>#include &lt;hpx/lcos/local/spinlock.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/thread_data_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/thread_enums.hpp&gt;</em><em>#include &lt;hpx/util/steady_clock.hpp&gt;</em><em>#include &lt;boost/intrusive/slist.hpp&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;mutex&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;hpx/runtime/launch_policy.hpp&gt;</em><em>#include &lt;hpx/runtime/serialization/serialization_fwd.hpp&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;hpx/runtime/threads/coroutines/detail/get_stack_pointer.hpp&gt;</em><em>#include &lt;limits&gt;</em><em>#include &lt;hpx/runtime/threads/thread_executor.hpp&gt;</em><em>#include &lt;hpx/runtime/get_os_thread_count.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/cpu_mask.hpp&gt;</em><em>#include &lt;hpx/util/assert.hpp&gt;</em><em>#include &lt;climits&gt;</em><em>#include &lt;cstdint&gt;</em><em>#include &lt;string&gt;</em><em>#include &lt;hpx/runtime/threads/policies/scheduler_mode.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/topology.hpp&gt;</em><em>#include &lt;hpx/compat/thread.hpp&gt;</em><em>#include &lt;thread&gt;</em><em>#include &lt;hpx/exception_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/naming_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/resource/partitioner_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/policies/callback_notifier.hpp&gt;</em><em>#include &lt;hpx/runtime/threads_fwd.hpp&gt;</em><em>#include &lt;hpx/util/function.hpp&gt;</em><em>#include &lt;exception&gt;</em><em>#include &lt;hpx/config/warnings_prefix.hpp&gt;</em><em>#include &lt;hpx/config/warnings_suffix.hpp&gt;</em><em>#include &lt;memory&gt;</em><em>#include &lt;hpx/util/thread_specific_ptr.hpp&gt;</em><em>#include &lt;cstdlib&gt;</em><em>#include &lt;boost/thread/tss.hpp&gt;</em><em>#include &lt;hpx/util/spinlock.hpp&gt;</em><em>#include &lt;hpx/util/itt_notify.hpp&gt;</em><em>#include &lt;hpx/util/register_locks.hpp&gt;</em><em>#include &lt;boost/smart_ptr/detail/spinlock.hpp&gt;</em><em>#include &lt;hpx/util/static.hpp&gt;</em><em>#include &lt;hpx/compat/mutex.hpp&gt;</em><em>#include &lt;iosfwd&gt;</em><em>#include &lt;vector&gt;</em><em>#include &lt;hwloc.h&gt;</em><em>#include &lt;hpx/util/atomic_count.hpp&gt;</em><em>#include &lt;atomic&gt;</em><em>#include &lt;hpx/util/thread_description.hpp&gt;</em><em>#include &lt;hpx/util/unique_function.hpp&gt;</em><em>#include &lt;boost/intrusive_ptr.hpp&gt;</em><em>#include &lt;chrono&gt;</em><em>#include &lt;hpx/runtime/threads/thread_helpers.hpp&gt;</em><em>#include &lt;hpx/throw_exception.hpp&gt;</em><em>#include &lt;hpx/traits/future_access.hpp&gt;</em><em>#include &lt;hpx/traits/future_traits.hpp&gt;</em><em>#include &lt;hpx/traits/is_future.hpp&gt;</em><em>#include &lt;boost/ref.hpp&gt;</em><em>#include &lt;functional&gt;</em><em>#include &lt;hpx/traits/get_remote_result.hpp&gt;</em><em>#include &lt;hpx/util/annotated_function.hpp&gt;</em><em>#include &lt;hpx/util/assert_owns_lock.hpp&gt;</em><em>#include &lt;hpx/traits/has_member_xxx.hpp&gt;</em><em>#include &lt;hpx/util/bind.hpp&gt;</em><em>#include &lt;hpx/traits/get_function_address.hpp&gt;</em><em>#include &lt;hpx/traits/get_function_annotation.hpp&gt;</em><em>#include &lt;hpx/traits/is_action.hpp&gt;</em><em>#include &lt;hpx/traits/is_bind_expression.hpp&gt;</em><em>#include &lt;hpx/traits/is_placeholder.hpp&gt;</em><em>#include &lt;boost/bind/arg.hpp&gt;</em><em>#include &lt;hpx/util/decay.hpp&gt;</em><em>#include &lt;hpx/util/detail/pack.hpp&gt;</em><em>#include &lt;hpx/util/invoke.hpp&gt;</em><em>#include &lt;hpx/util/invoke_fused.hpp&gt;</em><em>#include &lt;hpx/util/result_of.hpp&gt;</em><em>#include &lt;hpx/util/tuple.hpp&gt;</em><em>#include &lt;hpx/util/void_guard.hpp&gt;</em><em>#include &lt;hpx/util/unused.hpp&gt;</em><em>#include &lt;hpx/lcos/detail/future_traits.hpp&gt;</em><em>#include &lt;hpx/util/always_void.hpp&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;hpx/lcos_fwd.hpp&gt;</em><em>#include &lt;hpx/traits/is_component.hpp&gt;</em><em>#include &lt;hpx/traits/promise_local_result.hpp&gt;</em><em>#include &lt;hpx/traits/promise_remote_result.hpp&gt;</em><em>#include &lt;hpx/runtime/actions/continuation_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/serialization/detail/polymorphic_nonintrusive_factory.hpp&gt;</em><em>#include &lt;hpx/runtime/serialization/detail/non_default_constructible.hpp&gt;</em><em>#include &lt;hpx/traits/needs_automatic_registration.hpp&gt;</em><em>#include &lt;hpx/traits/polymorphic_traits.hpp&gt;</em><em>#include &lt;hpx/traits/has_xxx.hpp&gt;</em><em>#include &lt;hpx/util/detail/pp/cat.hpp&gt;</em><em>#include &lt;hpx/util/detail/pp/strip_parens.hpp&gt;</em><em>#include &lt;hpx/util/debug/demangle_helper.hpp&gt;</em><em>#include &lt;hpx/util/detail/pp/stringize.hpp&gt;</em><em>#include &lt;hpx/util/jenkins_hash.hpp&gt;</em><em>#include &lt;typeinfo&gt;</em><em>#include &lt;unordered_map&gt;</em><em>#include &lt;hpx/traits/acquire_shared_state.hpp&gt;</em><em>#include &lt;hpx/util/range.hpp&gt;</em><em>#include &lt;hpx/traits/detail/reserve.hpp&gt;</em><em>#include &lt;hpx/traits/is_range.hpp&gt;</em><em>#include &lt;hpx/traits/is_future_range.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;hpx/traits/concepts.hpp&gt;</em><em>#include &lt;hpx/traits/future_then_result.hpp&gt;</em><em>#include &lt;hpx/util/identity.hpp&gt;</em><em>#include &lt;hpx/util/lazy_conditional.hpp&gt;</em><em>#include &lt;hpx/traits/is_executor.hpp&gt;</em><em>#include &lt;hpx/traits/is_callable.hpp&gt;</em><em>#include &lt;hpx/traits/is_launch_policy.hpp&gt;</em><em>#include &lt;hpx/traits/executor_traits.hpp&gt;</em><em>#include &lt;hpx/util/detected.hpp&gt;</em><em>#include &lt;hpx/util/allocator_deleter.hpp&gt;</em><em>#include &lt;hpx/util/internal_allocator.hpp&gt;</em><em>#include &lt;hpx/util/lazy_enable_if.hpp&gt;</em><em>#include &lt;hpx/util/serialize_exception.hpp&gt;</em><em>#include &lt;hpx/lcos/local/packaged_continuation.hpp&gt;</em><em>#include &lt;hpx/util/deferred_call.hpp&gt;</em><em>#include &lt;hpx/parallel/executors/execution.hpp&gt;</em><em>#include &lt;hpx/parallel/executors/execution_fwd.hpp&gt;</em><em>#include &lt;hpx/exception_list.hpp&gt;</em><em>#include &lt;hpx/exception.hpp&gt;</em><em>#include &lt;boost/system/error_code.hpp&gt;</em><em>#include &lt;list&gt;</em><em>#include &lt;hpx/lcos/dataflow.hpp&gt;</em><em>#include &lt;hpx/lcos/detail/future_transforms.hpp&gt;</em><em>#include &lt;hpx/traits/acquire_future.hpp&gt;</em><em>#include &lt;array&gt;</em><em>#include &lt;hpx/runtime/get_worker_thread_num.hpp&gt;</em><em>#include &lt;hpx/traits/extract_action.hpp&gt;</em><em>#include &lt;hpx/util/pack_traversal_async.hpp&gt;</em><em>#include &lt;hpx/util/detail/pack_traversal_async_impl.hpp&gt;</em><em>#include &lt;hpx/util/detail/container_category.hpp&gt;</em><em>#include &lt;hpx/traits/is_tuple_like.hpp&gt;</em><em>#include &lt;hpx/parallel/executors/parallel_executor.hpp&gt;</em><em>#include &lt;hpx/async_launch_policy_dispatch.hpp&gt;</em><em>#include &lt;hpx/lcos/async_fwd.hpp&gt;</em><em>#include &lt;hpx/lcos/local/futures_factory.hpp&gt;</em><em>#include &lt;hpx/lcos/when_all_fwd.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/predicates.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;boost/iterator/iterator_categories.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/is_negative.hpp&gt;</em><em>#include &lt;hpx/parallel/executors/post_policy_dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/executors/static_chunk_size.hpp&gt;</em><em>#include &lt;hpx/runtime/serialization/serialize.hpp&gt;</em><em>#include &lt;hpx/runtime/serialization/access.hpp&gt;</em><em>#include &lt;hpx/runtime/serialization/input_archive.hpp&gt;</em><em>#include &lt;hpx/runtime/serialization/basic_archive.hpp&gt;</em><em>#include &lt;iostream&gt;</em><em>#include &lt;map&gt;</em><em>#include &lt;hpx/runtime/serialization/detail/raw_ptr.hpp&gt;</em><em>#include &lt;hpx/runtime/serialization/detail/pointer.hpp&gt;</em><em>#include &lt;hpx/runtime/serialization/detail/polymorphic_id_factory.hpp&gt;</em><em>#include &lt;hpx/runtime/serialization/detail/polymorphic_intrusive_factory.hpp&gt;</em><em>#include &lt;hpx/runtime/serialization/string.hpp&gt;</em><em>#include &lt;hpx/runtime/serialization/input_container.hpp&gt;</em><em>#include &lt;hpx/runtime/serialization/binary_filter.hpp&gt;</em><em>#include &lt;hpx/runtime/serialization/container.hpp&gt;</em><em>#include &lt;hpx/runtime/naming/name.hpp&gt;</em><em>#include &lt;hpx/lcos/local/spinlock_pool.hpp&gt;</em><em>#include &lt;hpx/runtime/naming/id_type.hpp&gt;</em><em>#include &lt;hpx/traits/is_bitwise_serializable.hpp&gt;</em><em>#include &lt;hpx/util/detail/yield_k.hpp&gt;</em><em>#include &lt;hpx/runtime/naming/id_type_impl.hpp&gt;</em><em>#include &lt;hpx/runtime/serialization/serialization_chunk.hpp&gt;</em><em>#include &lt;cstring&gt;</em><em>#include &lt;hpx/traits/serialization_access_data.hpp&gt;</em><em>#include &lt;boost/cstdint.hpp&gt;</em><em>#include &lt;hpx/runtime/serialization/output_archive.hpp&gt;</em><em>#include &lt;hpx/runtime/serialization/output_container.hpp&gt;</em><em>#include &lt;hpx/runtime/serialization/detail/polymorphic_nonintrusive_factory_impl.hpp&gt;</em><em>#include &lt;hpx/traits/is_executor_parameters.hpp&gt;</em><em>#include &lt;hpx/parallel/executors/execution_parameters_fwd.hpp&gt;</em><em>#include &lt;hpx/lcos/wait_all.hpp&gt;</em><em>#include &lt;hpx/traits/detail/wrap_int.hpp&gt;</em><em>#include &lt;hpx/util/bind_back.hpp&gt;</em><em>#include &lt;hpx/util/optional.hpp&gt;</em><em>#include &lt;stdexcept&gt;</em><em>#include &lt;hpx/util/unwrap.hpp&gt;</em><em>#include &lt;hpx/util/detail/unwrap_impl.hpp&gt;</em><em>#include &lt;hpx/util/pack_traversal.hpp&gt;</em><em>#include &lt;hpx/util/detail/pack_traversal_impl.hpp&gt;</em><em>#include &lt;hpx/components/component_storage/server/migrate_from_storage.hpp&gt;</em><em>#include &lt;hpx/runtime/components/runtime_support.hpp&gt;</em><em>#include &lt;hpx/runtime/applier/applier.hpp&gt;</em><em>#include &lt;hpx/runtime/agas_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/applier_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/components/component_type.hpp&gt;</em><em>#include &lt;hpx/traits/component_type_database.hpp&gt;</em><em>#include &lt;hpx/util/detail/pp/expand.hpp&gt;</em><em>#include &lt;hpx/util/detail/pp/nargs.hpp&gt;</em><em>#include &lt;hpx/runtime/naming/address.hpp&gt;</em><em>#include &lt;hpx/runtime/parcelset/parcel.hpp&gt;</em><em>#include &lt;hpx/runtime/actions_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/parcelset_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/components/stubs/runtime_support.hpp&gt;</em><em>#include &lt;hpx/async.hpp&gt;</em><em>#include &lt;hpx/lcos/async.hpp&gt;</em><em>#include &lt;hpx/lcos/detail/async_implementations.hpp&gt;</em><em>#include &lt;hpx/lcos/detail/async_implementations_fwd.hpp&gt;</em><em>#include &lt;hpx/lcos/packaged_action.hpp&gt;</em><em>#include &lt;hpx/lcos/promise.hpp&gt;</em><em>#include &lt;hpx/lcos/detail/promise_base.hpp&gt;</em><em>#include &lt;hpx/lcos/detail/promise_lco.hpp&gt;</em><em>#include &lt;hpx/lcos/base_lco_with_value.hpp&gt;</em><em>#include &lt;hpx/lcos/base_lco.hpp&gt;</em><em>#include &lt;hpx/runtime/actions/basic_action.hpp&gt;</em><em>#include &lt;hpx/lcos/sync_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/actions/action_support.hpp&gt;</em><em>#include &lt;hpx/runtime/components/pinned_ptr.hpp&gt;</em><em>#include &lt;hpx/runtime/get_lva.hpp&gt;</em><em>#include &lt;hpx/runtime/components_fwd.hpp&gt;</em><em>#include &lt;hpx/traits/managed_component_policies.hpp&gt;</em><em>#include &lt;hpx/traits/action_decorate_function.hpp&gt;</em><em>#include &lt;hpx/traits/component_pin_support.hpp&gt;</em><em>#include &lt;hpx/runtime/serialization/base_object.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/thread_init_data.hpp&gt;</em><em>#include &lt;hpx/traits/action_remote_result.hpp&gt;</em><em>#include &lt;hpx/runtime/actions/basic_action_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/actions/continuation.hpp&gt;</em><em>#include &lt;hpx/runtime/actions/action_priority.hpp&gt;</em><em>#include &lt;hpx/traits/action_priority.hpp&gt;</em><em>#include &lt;hpx/runtime/actions/trigger.hpp&gt;</em><em>#include &lt;hpx/runtime/agas/interface.hpp&gt;</em><em>#include &lt;boost/dynamic_bitset.hpp&gt;</em><em>#include &lt;hpx/runtime/trigger_lco.hpp&gt;</em><em>#include &lt;hpx/runtime/applier/detail/apply_implementations_fwd.hpp&gt;</em><em>#include &lt;hpx/traits/is_continuation.hpp&gt;</em><em>#include &lt;hpx/util/logging.hpp&gt;</em><em>#include &lt;hpx/runtime/actions/detail/action_factory.hpp&gt;</em><em>#include &lt;hpx/runtime/actions/detail/invocation_count_registry.hpp&gt;</em><em>#include &lt;hpx/performance_counters/counters_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/actions/transfer_action.hpp&gt;</em><em>#include &lt;hpx/runtime/actions/transfer_base_action.hpp&gt;</em><em>#include &lt;hpx/runtime/actions/base_action.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/thread_id_type.hpp&gt;</em><em>#include &lt;hpx/runtime/serialization/unique_ptr.hpp&gt;</em><em>#include &lt;hpx/traits/action_does_termination_detection.hpp&gt;</em><em>#include &lt;hpx/traits/action_message_handler.hpp&gt;</em><em>#include &lt;hpx/traits/action_schedule_thread.hpp&gt;</em><em>#include &lt;hpx/traits/action_serialization_filter.hpp&gt;</em><em>#include &lt;hpx/traits/action_stacksize.hpp&gt;</em><em>#include &lt;hpx/traits/action_was_object_migrated.hpp&gt;</em><em>#include &lt;hpx/util/get_and_reset_value.hpp&gt;</em><em>#include &lt;hpx/runtime/applier/apply_helper.hpp&gt;</em><em>#include &lt;hpx/runtime_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/basename_registration_fwd.hpp&gt;</em><em>#include &lt;hpx/components_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/components/make_client.hpp&gt;</em><em>#include &lt;hpx/traits/is_client.hpp&gt;</em><em>#include &lt;hpx/runtime/config_entry.hpp&gt;</em><em>#include &lt;hpx/util_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/find_localities.hpp&gt;</em><em>#include &lt;hpx/runtime/get_colocation_id.hpp&gt;</em><em>#include &lt;hpx/runtime/get_locality_id.hpp&gt;</em><em>#include &lt;hpx/runtime/get_locality_name.hpp&gt;</em><em>#include &lt;hpx/runtime/get_num_localities.hpp&gt;</em><em>#include &lt;hpx/runtime/get_thread_name.hpp&gt;</em><em>#include &lt;hpx/runtime/report_error.hpp&gt;</em><em>#include &lt;hpx/runtime/runtime_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/runtime_mode.hpp&gt;</em><em>#include &lt;hpx/runtime/set_parcel_write_handler.hpp&gt;</em><em>#include &lt;hpx/runtime/shutdown_function.hpp&gt;</em><em>#include &lt;hpx/runtime/startup_function.hpp&gt;</em><em>#include &lt;hpx/state.hpp&gt;</em><em>#include &lt;hpx/traits/action_continuation.hpp&gt;</em><em>#include &lt;hpx/traits/action_decorate_continuation.hpp&gt;</em><em>#include &lt;hpx/traits/action_select_direct_execution.hpp&gt;</em><em>#include &lt;hpx/runtime/parcelset/detail/per_action_data_counter_registry.hpp&gt;</em><em>#include &lt;hpx/runtime/actions/transfer_continuation_action.hpp&gt;</em><em>#include &lt;hpx/traits/is_distribution_policy.hpp&gt;</em><em>#include &lt;sstream&gt;</em><em>#include &lt;hpx/runtime/actions/component_action.hpp&gt;</em><em>#include &lt;hpx/runtime/components/console_error_sink.hpp&gt;</em><em>#include &lt;hpx/runtime/components/server/managed_component_base.hpp&gt;</em><em>#include &lt;hpx/runtime/components/server/create_component_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/components/server/component_heap.hpp&gt;</em><em>#include &lt;hpx/util/reinitializable_static.hpp&gt;</em><em>#include &lt;hpx/util/static_reinit.hpp&gt;</em><em>#include &lt;hpx/runtime/components/server/wrapper_heap.hpp&gt;</em><em>#include &lt;hpx/util/generate_unique_ids.hpp&gt;</em><em>#include &lt;hpx/util/wrapper_heap_base.hpp&gt;</em><em>#include &lt;new&gt;</em><em>#include &lt;hpx/runtime/components/server/wrapper_heap_list.hpp&gt;</em><em>#include &lt;hpx/util/one_size_heap_list.hpp&gt;</em><em>#include &lt;hpx/util/unlock_guard.hpp&gt;</em><em>#include &lt;hpx/plugins/parcel/coalescing_message_handler_registration.hpp&gt;</em><em>#include &lt;hpx/runtime/components/server/component_base.hpp&gt;</em><em>#include &lt;hpx/util/ini.hpp&gt;</em><em>#include &lt;boost/lexical_cast.hpp&gt;</em><em>#include &lt;hpx/lcos/local/promise.hpp&gt;</em><em>#include &lt;boost/utility/swap.hpp&gt;</em><em>#include &lt;hpx/runtime/applier/apply.hpp&gt;</em><em>#include &lt;hpx/runtime/applier/detail/apply_implementations.hpp&gt;</em><em>#include &lt;hpx/traits/action_is_target_valid.hpp&gt;</em><em>#include &lt;hpx/traits/component_supports_migration.hpp&gt;</em><em>#include &lt;hpx/util/format.hpp&gt;</em><em>#include &lt;boost/utility/string_ref.hpp&gt;</em><em>#include &lt;cctype&gt;</em><em>#include &lt;cstdio&gt;</em><em>#include &lt;ostream&gt;</em><em>#include &lt;hpx/runtime/components/client_base.hpp&gt;</em><em>#include &lt;hpx/runtime/components/stubs/stub_base.hpp&gt;</em><em>#include &lt;hpx/lcos/detail/async_colocated_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/naming/unmanaged.hpp&gt;</em><em>#include &lt;hpx/runtime/parcelset/detail/parcel_await.hpp&gt;</em><em>#include &lt;hpx/runtime/parcelset/put_parcel.hpp&gt;</em><em>#include &lt;hpx/runtime.hpp&gt;</em><em>#include &lt;hpx/performance_counters/counters.hpp&gt;</em><em>#include &lt;hpx/runtime/parcelset/locality.hpp&gt;</em><em>#include &lt;hpx/runtime/serialization/map.hpp&gt;</em><em>#include &lt;hpx/runtime/thread_hooks.hpp&gt;</em><em>#include &lt;hpx/util/runtime_configuration.hpp&gt;</em><em>#include &lt;hpx/runtime/components/static_factory_data.hpp&gt;</em><em>#include &lt;hpx/util/plugin/export_plugin.hpp&gt;</em><em>#include &lt;hpx/util/plugin/abstract_factory.hpp&gt;</em><em>#include &lt;hpx/util/plugin/virtual_constructor.hpp&gt;</em><em>#include &lt;hpx/util/plugin/config.hpp&gt;</em><em>#include &lt;boost/any.hpp&gt;</em><em>#include &lt;boost/shared_ptr.hpp&gt;</em><em>#include &lt;hpx/util/plugin/concrete_factory.hpp&gt;</em><em>#include &lt;hpx/util/plugin/plugin_wrapper.hpp&gt;</em><em>#include &lt;boost/algorithm/string/case_conv.hpp&gt;</em><em>#include &lt;hpx/util/plugin/dll.hpp&gt;</em><em>#include &lt;hpx/util/plugin/detail/dll_dlopen.hpp&gt;</em><em>#include &lt;boost/filesystem/convenience.hpp&gt;</em><em>#include &lt;boost/filesystem/path.hpp&gt;</em><em>#include &lt;link.h&gt;</em><em>#include &lt;dlfcn.h&gt;</em><em>#include &lt;limits.h&gt;</em><em>#include &lt;hpx/plugins/plugin_registry_base.hpp&gt;</em><em>#include &lt;hpx/util/plugin.hpp&gt;</em><em>#include &lt;hpx/util/plugin/plugin_factory.hpp&gt;</em><em>#include &lt;boost/smart_ptr/scoped_ptr.hpp&gt;</em><em>#include &lt;hpx/runtime/naming/split_gid.hpp&gt;</em><em>#include &lt;hpx/runtime/parcelset/parcelhandler.hpp&gt;</em><em>#include &lt;hpx/runtime/parcelset/parcelport.hpp&gt;</em><em>#include &lt;hpx/performance_counters/parcels/data_point.hpp&gt;</em><em>#include &lt;hpx/performance_counters/parcels/gatherer.hpp&gt;</em><em>#include &lt;hpx/lcos/local/no_mutex.hpp&gt;</em><em>#include &lt;hpx/runtime/parcelset/detail/per_action_data_counter.hpp&gt;</em><em>#include &lt;set&gt;</em><em>#include &lt;hpx/util/bind_front.hpp&gt;</em><em>#include &lt;hpx/util/high_resolution_timer.hpp&gt;</em><em>#include &lt;hpx/util/high_resolution_clock.hpp&gt;</em><em>#include &lt;hpx/plugins/parcelport_factory_base.hpp&gt;</em><em>#include &lt;hpx/traits/component_type_is_compatible.hpp&gt;</em><em>#include &lt;hpx/traits/is_valid_action.hpp&gt;</em><em>#include &lt;hpx/runtime/applier/apply_callback.hpp&gt;</em><em>#include &lt;hpx/util/protect.hpp&gt;</em><em>#include &lt;boost/asio/error.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/thread.hpp&gt;</em><em>#include &lt;hpx/lcos/sync.hpp&gt;</em><em>#include &lt;hpx/lcos/detail/sync_implementations.hpp&gt;</em><em>#include &lt;hpx/lcos/detail/sync_implementations_fwd.hpp&gt;</em><em>#include &lt;hpx/lcos/async_continue.hpp&gt;</em><em>#include &lt;hpx/lcos/async_continue_fwd.hpp&gt;</em><em>#include &lt;hpx/util/bind_action.hpp&gt;</em><em>#include &lt;hpx/runtime/actions/manage_object_action.hpp&gt;</em><em>#include &lt;hpx/runtime/serialization/array.hpp&gt;</em><em>#include &lt;boost/array.hpp&gt;</em><em>#include &lt;hpx/runtime/serialization/serialize_buffer.hpp&gt;</em><em>#include &lt;hpx/traits/supports_streaming_with_any.hpp&gt;</em><em>#include &lt;boost/shared_array.hpp&gt;</em><em>#include &lt;hpx/runtime/components/server/runtime_support.hpp&gt;</em><em>#include &lt;hpx/compat/condition_variable.hpp&gt;</em><em>#include &lt;condition_variable&gt;</em><em>#include &lt;hpx/lcos/local/condition_variable.hpp&gt;</em><em>#include &lt;hpx/lcos/local/mutex.hpp&gt;</em><em>#include &lt;hpx/plugins/plugin_factory_base.hpp&gt;</em><em>#include &lt;hpx/runtime/components/server/create_component.hpp&gt;</em><em>#include &lt;hpx/runtime/find_here.hpp&gt;</em><em>#include &lt;boost/program_options/options_description.hpp&gt;</em><em>#include &lt;hpx/runtime/serialization/vector.hpp&gt;</em><em>#include &lt;hpx/runtime/serialization/detail/serialize_collection.hpp&gt;</em><em>#include &lt;hpx/runtime/components/server/migrate_component.hpp&gt;</em><em>#include &lt;hpx/runtime/actions/plain_action.hpp&gt;</em><em>#include &lt;hpx/runtime/get_ptr.hpp&gt;</em><em>#include &lt;hpx/runtime/agas/gva.hpp&gt;</em><em>#include &lt;boost/io/ios_state.hpp&gt;</em><em>#include &lt;hpx/components/component_storage/export_definitions.hpp&gt;</em><em>#include &lt;hpx/config/export_definitions.hpp&gt;</em><em>#include &lt;hpx/components/component_storage/server/component_storage.hpp&gt;</em><em>#include &lt;hpx/components/containers/unordered/unordered_map.hpp&gt;</em><em>#include &lt;hpx/runtime/components/copy_component.hpp&gt;</em><em>#include &lt;hpx/lcos/detail/async_colocated.hpp&gt;</em><em>#include &lt;hpx/runtime/agas/primary_namespace.hpp&gt;</em><em>#include &lt;hpx/runtime/agas/server/primary_namespace.hpp&gt;</em><em>#include &lt;hpx/runtime/components/server/fixed_component_base.hpp&gt;</em><em>#include &lt;hpx/runtime/applier/bind_naming_wrappers.hpp&gt;</em><em>#include &lt;hpx/util/functional/colocated_helpers.hpp&gt;</em><em>#include &lt;hpx/runtime/components/server/copy_component.hpp&gt;</em><em>#include &lt;hpx/runtime/components/new.hpp&gt;</em><em>#include &lt;hpx/runtime/components/default_distribution_policy.hpp&gt;</em><em>#include &lt;hpx/runtime/serialization/shared_ptr.hpp&gt;</em><em>#include &lt;hpx/runtime/components/server/distributed_metadata_base.hpp&gt;</em><em>#include &lt;hpx/runtime/components/server/simple_component_base.hpp&gt;</em><em>#include &lt;hpx/runtime/components/server/component.hpp&gt;</em><em>#include &lt;hpx/runtime/serialization/unordered_map.hpp&gt;</em><em>#include &lt;hpx/components/containers/container_distribution_policy.hpp&gt;</em><em>#include &lt;hpx/components/containers/unordered/partition_unordered_map_component.hpp&gt;</em><em>#include &lt;hpx/lcos/reduce.hpp&gt;</em><em>#include &lt;hpx/runtime/components/component_factory.hpp&gt;</em><em>#include &lt;hpx/runtime/components/server/locking_hook.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/coroutines/coroutine.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/coroutines/coroutine_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/coroutines/detail/coroutine_accessor.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/coroutines/detail/coroutine_impl.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/coroutines/detail/context_base.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/coroutines/detail/context_impl.hpp&gt;</em><em>#include &lt;boost/version.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/coroutines/detail/swap_context.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/coroutines/detail/tss.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/coroutines/exception.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/coroutines/detail/coroutine_self.hpp&gt;</em><em>#include &lt;tuple&gt;</em><em>#include &lt;hpx/components/containers/unordered/unordered_map_segmented_iterator.hpp&gt;</em><em>#include &lt;hpx/util/iterator_adaptor.hpp&gt;</em><em>#include &lt;hpx/util/iterator_facade.hpp&gt;</em><em>#include &lt;boost/integer.hpp&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="migrate__to__storage_8hpp"></span><em>file</em> <code class="descname">migrate_to_storage.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/lcos/future.hpp&gt;</em><em>#include &lt;hpx/runtime/components/client_base.hpp&gt;</em><em>#include &lt;hpx/runtime/naming/id_type.hpp&gt;</em><em>#include &lt;hpx/traits/is_component.hpp&gt;</em><em>#include &lt;hpx/components/component_storage/component_storage.hpp&gt;</em><em>#include &lt;hpx/runtime/launch_policy.hpp&gt;</em><em>#include &lt;hpx/runtime/naming/address.hpp&gt;</em><em>#include &lt;hpx/runtime/naming/name.hpp&gt;</em><em>#include &lt;hpx/components/component_storage/server/component_storage.hpp&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;vector&gt;</em><em>#include &lt;hpx/components/component_storage/server/migrate_to_storage.hpp&gt;</em><em>#include &lt;hpx/throw_exception.hpp&gt;</em><em>#include &lt;hpx/util/bind.hpp&gt;</em><em>#include &lt;hpx/components/component_storage/export_definitions.hpp&gt;</em><em>#include &lt;cstdint&gt;</em><em>#include &lt;memory&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;type_traits&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="error_8hpp"></span><em>file</em> <code class="descname">error.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;boost/system/error_code.hpp&gt;</em><em>#include &lt;string&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="error__code_8hpp"></span><em>file</em> <code class="descname">error_code.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/error.hpp&gt;</em><em>#include &lt;hpx/exception_fwd.hpp&gt;</em><em>#include &lt;boost/system/error_code.hpp&gt;</em><em>#include &lt;exception&gt;</em><em>#include &lt;stdexcept&gt;</em><em>#include &lt;string&gt;</em><em>#include &lt;hpx/throw_exception.hpp&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="exception_8hpp"></span><em>file</em> <code class="descname">exception.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/error.hpp&gt;</em><em>#include &lt;hpx/error_code.hpp&gt;</em><em>#include &lt;hpx/error.hpp&gt;</em><em>#include &lt;hpx/exception_fwd.hpp&gt;</em><em>#include &lt;boost/system/error_code.hpp&gt;</em><em>#include &lt;exception&gt;</em><em>#include &lt;stdexcept&gt;</em><em>#include &lt;string&gt;</em><em>#include &lt;hpx/throw_exception.hpp&gt;</em><em>#include &lt;hpx/exception_fwd.hpp&gt;</em><em>#include &lt;hpx/exception_info.hpp&gt;</em><em>#include &lt;hpx/error_code.hpp&gt;</em><em>#include &lt;hpx/util/detail/pack.hpp&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;hpx/util/tuple.hpp&gt;</em><em>#include &lt;hpx/runtime/serialization/detail/non_default_constructible.hpp&gt;</em><em>#include &lt;memory&gt;</em><em>#include &lt;hpx/traits/is_bitwise_serializable.hpp&gt;</em><em>#include &lt;hpx/util/decay.hpp&gt;</em><em>#include &lt;boost/ref.hpp&gt;</em><em>#include &lt;/home/simbergm/src/hpx-worktrees/release/build/docs/hpx/util/functional&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;boost/array.hpp&gt;</em><em>#include &lt;array&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;typeinfo&gt;</em><em>#include &lt;hpx/runtime/naming_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/agas_fwd.hpp&gt;</em><em>#include &lt;hpx/util/function.hpp&gt;</em><em>#include &lt;cstdint&gt;</em><em>#include &lt;boost/system/system_error.hpp&gt;</em><em>#include &lt;hpx/config/warnings_prefix.hpp&gt;</em><em>#include &lt;hpx/throw_exception.hpp&gt;</em><em>#include &lt;hpx/config/warnings_suffix.hpp&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="exception__fwd_8hpp"></span><em>file</em> <code class="descname">exception_fwd.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/error.hpp&gt;</em><em>#include &lt;hpx/throw_exception.hpp&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="exception__list_8hpp"></span><em>file</em> <code class="descname">exception_list.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/exception.hpp&gt;</em><em>#include &lt;hpx/error.hpp&gt;</em><em>#include &lt;hpx/error_code.hpp&gt;</em><em>#include &lt;hpx/exception_fwd.hpp&gt;</em><em>#include &lt;hpx/exception_info.hpp&gt;</em><em>#include &lt;hpx/runtime/naming_fwd.hpp&gt;</em><em>#include &lt;boost/system/error_code.hpp&gt;</em><em>#include &lt;boost/system/system_error.hpp&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;cstdint&gt;</em><em>#include &lt;exception&gt;</em><em>#include &lt;string&gt;</em><em>#include &lt;hpx/config/warnings_prefix.hpp&gt;</em><em>#include &lt;hpx/throw_exception.hpp&gt;</em><em>#include &lt;hpx/config/warnings_suffix.hpp&gt;</em><em>#include &lt;hpx/lcos/local/spinlock.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/thread_helpers.hpp&gt;</em><em>#include &lt;hpx/runtime/threads_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/thread_data_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/coroutines/coroutine_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/thread_enums.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/detail/combined_tagged_state.hpp&gt;</em><em>#include &lt;hpx/util/assert.hpp&gt;</em><em>#include &lt;assert.h&gt;</em><em>#include &lt;boost/current_function.hpp&gt;</em><em>#include &lt;cstdlib&gt;</em><em>#include &lt;iostream&gt;</em><em>#include &lt;hpx/runtime/threads/thread_id_type.hpp&gt;</em><em>#include &lt;hpx/config/constexpr.hpp&gt;</em><em>#include &lt;hpx/config/export_definitions.hpp&gt;</em><em>#include &lt;functional&gt;</em><em>#include &lt;iosfwd&gt;</em><em>#include &lt;hpx/util_fwd.hpp&gt;</em><em>#include &lt;hpx/util/function.hpp&gt;</em><em>#include &lt;hpx/util/unique_function.hpp&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;memory&gt;</em><em>#include &lt;hpx/runtime/thread_pool_helpers.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/policies/scheduler_mode.hpp&gt;</em><em>#include &lt;hpx/util/register_locks.hpp&gt;</em><em>#include &lt;hpx/traits/has_member_xxx.hpp&gt;</em><em>#include &lt;hpx/util/detail/pp/cat.hpp&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;hpx/util/steady_clock.hpp&gt;</em><em>#include &lt;chrono&gt;</em><em>#include &lt;hpx/util/thread_description.hpp&gt;</em><em>#include &lt;hpx/runtime/actions/basic_action_fwd.hpp&gt;</em><em>#include &lt;hpx/traits/get_function_address.hpp&gt;</em><em>#include &lt;hpx/traits/get_function_annotation.hpp&gt;</em><em>#include &lt;hpx/traits/is_action.hpp&gt;</em><em>#include &lt;hpx/util/always_void.hpp&gt;</em><em>#include &lt;hpx/util/decay.hpp&gt;</em><em>#include &lt;atomic&gt;</em><em>#include &lt;hpx/util/detail/yield_k.hpp&gt;</em><em>#include &lt;sched.h&gt;</em><em>#include &lt;time.h&gt;</em><em>#include &lt;hpx/util/itt_notify.hpp&gt;</em><em>#include &lt;boost/smart_ptr/detail/spinlock.hpp&gt;</em><em>#include &lt;list&gt;</em><em>#include &lt;mutex&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="hpx__finalize_8hpp"></span><em>file</em> <code class="descname">hpx_finalize.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/exception_fwd.hpp&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="hpx__init_8hpp"></span><em>file</em> <code class="descname">hpx_init.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/config/attributes.hpp&gt;</em><em>#include &lt;hpx/config/defines.hpp&gt;</em><em>#include &lt;hpx/config/compiler_specific.hpp&gt;</em><em>#include &lt;hpx/config/branch_hints.hpp&gt;</em><em>#include &lt;hpx/config/compiler_fence.hpp&gt;</em><em>#include &lt;hpx/config/compiler_native_tls.hpp&gt;</em><em>#include &lt;ciso646&gt;</em><em>#include &lt;hpx/config/constexpr.hpp&gt;</em><em>#include &lt;hpx/config/debug.hpp&gt;</em><em>#include &lt;hpx/config/emulate_deleted.hpp&gt;</em><em>#include &lt;hpx/config/export_definitions.hpp&gt;</em><em>#include &lt;hpx/config/forceinline.hpp&gt;</em><em>#include &lt;hpx/config/lambda_capture.hpp&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;hpx/config/manual_profiling.hpp&gt;</em><em>#include &lt;hpx/config/threads_stack.hpp&gt;</em><em>#include &lt;hpx/config/version.hpp&gt;</em><em>#include &lt;hpx/util/detail/pp/cat.hpp&gt;</em><em>#include &lt;hpx/util/detail/pp/config.hpp&gt;</em><em>#include &lt;boost/version.hpp&gt;</em><em>#include &lt;hpx/config/weak_symbol.hpp&gt;</em><em>#include &lt;hpx/util/detail/pp/stringize.hpp&gt;</em><em>#include &lt;hpx/hpx_finalize.hpp&gt;</em><em>#include &lt;hpx/exception_fwd.hpp&gt;</em><em>#include &lt;hpx/error.hpp&gt;</em><em>#include &lt;boost/system/error_code.hpp&gt;</em><em>#include &lt;string&gt;</em><em>#include &lt;hpx/throw_exception.hpp&gt;</em><em>#include &lt;hpx/util/detail/pp/expand.hpp&gt;</em><em>#include &lt;hpx/util/detail/pp/nargs.hpp&gt;</em><em>#include &lt;boost/current_function.hpp&gt;</em><em>#include &lt;exception&gt;</em><em>#include &lt;hpx/config/warnings_prefix.hpp&gt;</em><em>#include &lt;hpx/config/warnings_suffix.hpp&gt;</em><em>#include &lt;hpx/hpx_suspend.hpp&gt;</em><em>#include &lt;hpx/runtime/runtime_mode.hpp&gt;</em><em>#include &lt;hpx/runtime/shutdown_function.hpp&gt;</em><em>#include &lt;hpx/util/unique_function.hpp&gt;</em><em>#include &lt;hpx/runtime/serialization/serialization_fwd.hpp&gt;</em><em>#include &lt;hpx/util/detail/pp/strip_parens.hpp&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;hpx/traits/get_function_address.hpp&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;memory&gt;</em><em>#include &lt;hpx/traits/get_function_annotation.hpp&gt;</em><em>#include &lt;hpx/util/itt_notify.hpp&gt;</em><em>#include &lt;cstdint&gt;</em><em>#include &lt;cstring&gt;</em><em>#include &lt;hpx/traits/is_callable.hpp&gt;</em><em>#include &lt;hpx/util/always_void.hpp&gt;</em><em>#include &lt;hpx/util/result_of.hpp&gt;</em><em>#include &lt;boost/ref.hpp&gt;</em><em>#include &lt;hpx/util/detail/basic_function.hpp&gt;</em><em>#include &lt;hpx/util/detail/empty_function.hpp&gt;</em><em>#include &lt;hpx/util/detail/function_registration.hpp&gt;</em><em>#include &lt;hpx/util/debug/demangle_helper.hpp&gt;</em><em>#include &lt;typeinfo&gt;</em><em>#include &lt;cstdlib&gt;</em><em>#include &lt;hpx/util/detail/vtable/serializable_function_vtable.hpp&gt;</em><em>#include &lt;hpx/runtime/serialization/detail/polymorphic_intrusive_factory.hpp&gt;</em><em>#include &lt;hpx/util/jenkins_hash.hpp&gt;</em><em>#include &lt;random&gt;</em><em>#include &lt;unordered_map&gt;</em><em>#include &lt;hpx/util/detail/vtable/serializable_vtable.hpp&gt;</em><em>#include &lt;hpx/util/detail/vtable/vtable.hpp&gt;</em><em>#include &lt;hpx/util/detail/vtable/unique_function_vtable.hpp&gt;</em><em>#include &lt;hpx/util/detail/vtable/callable_vtable.hpp&gt;</em><em>#include &lt;hpx/util/invoke.hpp&gt;</em><em>#include &lt;hpx/util/void_guard.hpp&gt;</em><em>#include &lt;hpx/util_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/startup_function.hpp&gt;</em><em>#include &lt;hpx/util/function.hpp&gt;</em><em>#include &lt;hpx/util/detail/vtable/function_vtable.hpp&gt;</em><em>#include &lt;hpx/util/detail/vtable/copyable_vtable.hpp&gt;</em><em>#include &lt;boost/program_options/options_description.hpp&gt;</em><em>#include &lt;boost/program_options/variables_map.hpp&gt;</em><em>#include &lt;vector&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="hpx__start_8hpp"></span><em>file</em> <code class="descname">hpx_start.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/hpx_finalize.hpp&gt;</em><em>#include &lt;hpx/runtime/runtime_mode.hpp&gt;</em><em>#include &lt;hpx/runtime/shutdown_function.hpp&gt;</em><em>#include &lt;hpx/runtime/startup_function.hpp&gt;</em><em>#include &lt;hpx/util/function.hpp&gt;</em><em>#include &lt;boost/program_options/options_description.hpp&gt;</em><em>#include &lt;boost/program_options/variables_map.hpp&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;string&gt;</em><em>#include &lt;vector&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="hpx__suspend_8hpp"></span><em>file</em> <code class="descname">hpx_suspend.hpp</code></dt>
<dd><em>#include &lt;hpx/exception_fwd.hpp&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="barrier_8hpp"></span><em>file</em> <code class="descname">barrier.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/lcos/future.hpp&gt;</em><em>#include &lt;hpx/runtime/components/server/managed_component_base.hpp&gt;</em><em>#include &lt;hpx/runtime/launch_policy.hpp&gt;</em><em>#include &lt;boost/intrusive_ptr.hpp&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;string&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;hpx/config/warnings_prefix.hpp&gt;</em><em>#include &lt;hpx/config/warnings_suffix.hpp&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="broadcast_8hpp"></span><em>file</em> <code class="descname">broadcast.hpp</code></dt>
<dd></dd></dl>

<dl class="file">
<dt>
<span class="target" id="fold_8hpp"></span><em>file</em> <code class="descname">fold.hpp</code></dt>
<dd></dd></dl>

<dl class="file">
<dt>
<span class="target" id="gather_8hpp"></span><em>file</em> <code class="descname">gather.hpp</code></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Defines</p>
<dl class="macro">
<dt id="c.HPX_REGISTER_GATHER_DECLARATION">
<span class="target" id="gather_8hpp_1adfcca81f48b2211d823719d8be09de3f"></span><code class="descname">HPX_REGISTER_GATHER_DECLARATION</code><span class="sig-paren">(</span>type, name<span class="sig-paren">)</span><a class="headerlink" href="#c.HPX_REGISTER_GATHER_DECLARATION" title="Permalink to this definition">¶</a></dt>
<dd><p>Declare a gather object named <em>name</em> for a given data type <em>type</em>. </p>
<p>The macro <em>HPX_REGISTER_GATHER_DECLARATION</em> can be used to declare all facilities necessary for a (possibly remote) gather operation.</p>
<p>The parameter <em>type</em> specifies for which data type the gather operations should be enabled.</p>
<p>The (optional) parameter <em>name</em> should be a unique C-style identifier which will be internally used to identify a particular gather operation. If this defaults to <em>&lt;type&gt;_gather</em> if not specified.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The macro <em>HPX_REGISTER_GATHER_DECLARATION</em> can be used with 1 or 2 arguments. The second argument is optional and defaults to <em>&lt;type&gt;_gather</em>. </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.HPX_REGISTER_GATHER">
<span class="target" id="gather_8hpp_1af6233296895d1832e437b5160b584393"></span><code class="descname">HPX_REGISTER_GATHER</code><span class="sig-paren">(</span>type, name<span class="sig-paren">)</span><a class="headerlink" href="#c.HPX_REGISTER_GATHER" title="Permalink to this definition">¶</a></dt>
<dd><p>Define a gather object named <em>name</em> for a given data type <em>type</em>. </p>
<p>The macro <em>HPX_REGISTER_GATHER</em> can be used to define all facilities necessary for a (possibly remote) gather operation.</p>
<p>The parameter <em>type</em> specifies for which data type the gather operations should be enabled.</p>
<p>The (optional) parameter <em>name</em> should be a unique C-style identifier which will be internally used to identify a particular gather operation. If this defaults to <em>&lt;type&gt;_gather</em> if not specified.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The macro <em>HPX_REGISTER_GATHER</em> can be used with 1 or 2 arguments. The second argument is optional and defaults to <em>&lt;type&gt;_gather</em>. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

<dl class="file">
<dt>
<span class="target" id="split__future_8hpp"></span><em>file</em> <code class="descname">split_future.hpp</code></dt>
<dd></dd></dl>

<dl class="file">
<dt>
<span class="target" id="wait__all_8hpp"></span><em>file</em> <code class="descname">wait_all.hpp</code></dt>
<dd></dd></dl>

<dl class="file">
<dt>
<span class="target" id="wait__any_8hpp"></span><em>file</em> <code class="descname">wait_any.hpp</code></dt>
<dd></dd></dl>

<dl class="file">
<dt>
<span class="target" id="wait__each_8hpp"></span><em>file</em> <code class="descname">wait_each.hpp</code></dt>
<dd></dd></dl>

<dl class="file">
<dt>
<span class="target" id="wait__some_8hpp"></span><em>file</em> <code class="descname">wait_some.hpp</code></dt>
<dd></dd></dl>

<dl class="file">
<dt>
<span class="target" id="when__all_8hpp"></span><em>file</em> <code class="descname">when_all.hpp</code></dt>
<dd></dd></dl>

<dl class="file">
<dt>
<span class="target" id="when__any_8hpp"></span><em>file</em> <code class="descname">when_any.hpp</code></dt>
<dd></dd></dl>

<dl class="file">
<dt>
<span class="target" id="when__each_8hpp"></span><em>file</em> <code class="descname">when_each.hpp</code></dt>
<dd></dd></dl>

<dl class="file">
<dt>
<span class="target" id="when__some_8hpp"></span><em>file</em> <code class="descname">when_some.hpp</code></dt>
<dd></dd></dl>

<dl class="file">
<dt>
<span class="target" id="algorithm_8hpp"></span><em>file</em> <code class="descname">algorithm.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;hpx/parallel/algorithms/adjacent_find.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/lcos/future.hpp&gt;</em><em>#include &lt;hpx/runtime/serialization/serialization_fwd.hpp&gt;</em><em>#include &lt;hpx/throw_exception.hpp&gt;</em><em>#include &lt;hpx/traits/segmented_iterator_traits.hpp&gt;</em><em>#include &lt;hpx/util/decay.hpp&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;hpx/parallel/exception_list.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/datapar/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy_fwd.hpp&gt;</em><em>#include &lt;hpx/parallel/executors/execution.hpp&gt;</em><em>#include &lt;hpx/parallel/executors/execution_parameters.hpp&gt;</em><em>#include &lt;hpx/parallel/executors/parallel_executor.hpp&gt;</em><em>#include &lt;hpx/parallel/executors/rebind_executor.hpp&gt;</em><em>#include &lt;hpx/parallel/executors/sequenced_executor.hpp&gt;</em><em>#include &lt;hpx/runtime/serialization/serialize.hpp&gt;</em><em>#include &lt;hpx/traits/executor_traits.hpp&gt;</em><em>#include &lt;hpx/traits/is_execution_policy.hpp&gt;</em><em>#include &lt;hpx/traits/is_executor.hpp&gt;</em><em>#include &lt;hpx/traits/is_executor_parameters.hpp&gt;</em><em>#include &lt;hpx/traits/is_launch_policy.hpp&gt;</em><em>#include &lt;memory&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;hpx/traits/concepts.hpp&gt;</em><em>#include &lt;hpx/util/invoke.hpp&gt;</em><em>#include &lt;hpx/util/unused.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/scoped_executor_parameters.hpp&gt;</em><em>#include &lt;hpx/util/tuple.hpp&gt;</em><em>#include &lt;string&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/predicates.hpp&gt;</em><em>#include &lt;hpx/parallel/util/loop.hpp&gt;</em><em>#include &lt;hpx/parallel/util/cancellation_token.hpp&gt;</em><em>#include &lt;atomic&gt;</em><em>#include &lt;functional&gt;</em><em>#include &lt;hpx/parallel/util/projection_identity.hpp&gt;</em><em>#include &lt;hpx/util/assert.hpp&gt;</em><em>#include &lt;hpx/util/result_of.hpp&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;vector&gt;</em><em>#include &lt;hpx/parallel/util/partitioner.hpp&gt;</em><em>#include &lt;hpx/dataflow.hpp&gt;</em><em>#include &lt;hpx/lcos/dataflow.hpp&gt;</em><em>#include &lt;hpx/exception_list.hpp&gt;</em><em>#include &lt;hpx/lcos/wait_all.hpp&gt;</em><em>#include &lt;hpx/util/deferred_call.hpp&gt;</em><em>#include &lt;hpx/util/range.hpp&gt;</em><em>#include &lt;hpx/parallel/traits/extract_partitioner.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/chunk_size.hpp&gt;</em><em>#include &lt;hpx/util/iterator_range.hpp&gt;</em><em>#include &lt;hpx/traits/is_range.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/is_negative.hpp&gt;</em><em>#include &lt;hpx/parallel/executors/execution_information.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/topology.hpp&gt;</em><em>#include &lt;hpx/traits/detail/wrap_int.hpp&gt;</em><em>#include &lt;hpx/parallel/executors/execution_information_fwd.hpp&gt;</em><em>#include &lt;hpx/parallel/executors/execution_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/thread_data_fwd.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/chunk_size_iterator.hpp&gt;</em><em>#include &lt;hpx/util/iterator_facade.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/handle_local_exceptions.hpp&gt;</em><em>#include &lt;hpx/async.hpp&gt;</em><em>#include &lt;hpx/hpx_finalize.hpp&gt;</em><em>#include &lt;exception&gt;</em><em>#include &lt;list&gt;</em><em>#include &lt;hpx/parallel/util/detail/partitioner_iteration.hpp&gt;</em><em>#include &lt;hpx/util/invoke_fused.hpp&gt;</em><em>#include &lt;hpx/parallel/util/zip_iterator.hpp&gt;</em><em>#include &lt;hpx/util/tagged_pair.hpp&gt;</em><em>#include &lt;hpx/util/tagged.hpp&gt;</em><em>#include &lt;hpx/util/detail/pack.hpp&gt;</em><em>#include &lt;/home/simbergm/src/hpx-worktrees/release/build/docs/hpx/util/functional&gt;</em><em>#include &lt;hpx/util/zip_iterator.hpp&gt;</em><em>#include &lt;hpx/runtime/naming/id_type.hpp&gt;</em><em>#include &lt;hpx/util/functional/segmented_iterator_helpers.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/all_any_none.hpp&gt;</em><em>#include &lt;hpx/util/void_guard.hpp&gt;</em><em>#include &lt;hpx/parallel/traits/projected.hpp&gt;</em><em>#include &lt;hpx/parallel/traits/vector_pack_load_store.hpp&gt;</em><em>#include &lt;hpx/parallel/traits/vector_pack_type.hpp&gt;</em><em>#include &lt;hpx/traits/is_callable.hpp&gt;</em><em>#include &lt;hpx/util/always_void.hpp&gt;</em><em>#include &lt;hpx/parallel/util/invoke_projected.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/copy.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/transfer.hpp&gt;</em><em>#include &lt;hpx/parallel/segmented_algorithms/detail/transfer.hpp&gt;</em><em>#include &lt;hpx/parallel/segmented_algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/runtime/actions/plain_action.hpp&gt;</em><em>#include &lt;hpx/runtime/components/colocating_distribution_policy.hpp&gt;</em><em>#include &lt;hpx/lcos/detail/async_colocated.hpp&gt;</em><em>#include &lt;hpx/lcos/detail/async_colocated_callback.hpp&gt;</em><em>#include &lt;hpx/runtime/agas/primary_namespace.hpp&gt;</em><em>#include &lt;hpx/runtime/agas/server/primary_namespace.hpp&gt;</em><em>#include &lt;hpx/lcos/async_continue_callback.hpp&gt;</em><em>#include &lt;hpx/lcos/async_callback_fwd.hpp&gt;</em><em>#include &lt;hpx/lcos/async_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/actions/basic_action_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/launch_policy.hpp&gt;</em><em>#include &lt;hpx/lcos/async_continue.hpp&gt;</em><em>#include &lt;hpx/runtime/applier/apply_callback.hpp&gt;</em><em>#include &lt;hpx/traits/extract_action.hpp&gt;</em><em>#include &lt;hpx/traits/is_distribution_policy.hpp&gt;</em><em>#include &lt;hpx/traits/promise_local_result.hpp&gt;</em><em>#include &lt;hpx/traits/promise_remote_result.hpp&gt;</em><em>#include &lt;hpx/lcos/detail/async_colocated_callback_fwd.hpp&gt;</em><em>#include &lt;hpx/lcos/detail/async_colocated_fwd.hpp&gt;</em><em>#include &lt;hpx/lcos/detail/async_implementations.hpp&gt;</em><em>#include &lt;hpx/runtime/applier/detail/apply_colocated_callback_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/actions/action_support.hpp&gt;</em><em>#include &lt;hpx/runtime/applier/detail/apply_colocated_fwd.hpp&gt;</em><em>#include &lt;hpx/traits/is_continuation.hpp&gt;</em><em>#include &lt;hpx/runtime/applier/detail/apply_implementations.hpp&gt;</em><em>#include &lt;hpx/runtime/components/client_base.hpp&gt;</em><em>#include &lt;hpx/runtime/components/stubs/stub_base.hpp&gt;</em><em>#include &lt;hpx/runtime/find_here.hpp&gt;</em><em>#include &lt;hpx/runtime/naming/name.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/handle_remote_exceptions.hpp&gt;</em><em>#include &lt;hpx/parallel/tagspec.hpp&gt;</em><em>#include &lt;hpx/parallel/util/foreach_partitioner.hpp&gt;</em><em>#include &lt;hpx/parallel/util/scan_partitioner.hpp&gt;</em><em>#include &lt;hpx/util/bind.hpp&gt;</em><em>#include &lt;hpx/parallel/util/transfer.hpp&gt;</em><em>#include &lt;hpx/traits/pointer_category.hpp&gt;</em><em>#include &lt;cstring&gt;</em><em>#include &lt;boost/shared_array.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/count.hpp&gt;</em><em>#include &lt;hpx/util/bind_back.hpp&gt;</em><em>#include &lt;hpx/util/unwrap.hpp&gt;</em><em>#include &lt;hpx/parallel/traits/vector_pack_count_bits.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/equal.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/fill.hpp&gt;</em><em>#include &lt;hpx/traits/is_value_proxy.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/for_each.hpp&gt;</em><em>#include &lt;hpx/util/annotated_function.hpp&gt;</em><em>#include &lt;hpx/util/identity.hpp&gt;</em><em>#include &lt;cstdint&gt;</em><em>#include &lt;hpx/parallel/algorithms/find.hpp&gt;</em><em>#include &lt;hpx/parallel/util/compare_projected.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/for_each.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/generate.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/includes.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/is_heap.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/is_partitioned.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/is_sorted.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/lexicographical_compare.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/mismatch.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/merge.hpp&gt;</em><em>#include &lt;hpx/util/tagged_tuple.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/minmax.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/mismatch.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/move.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/partition.hpp&gt;</em><em>#include &lt;hpx/lcos/local/spinlock.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/remove.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/remove_copy.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/copy.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/replace.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/reverse.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/rotate.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/reverse.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/search.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/set_difference.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/set_operation.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/set_intersection.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/set_symmetric_difference.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/set_union.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/sort.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/swap_ranges.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/unique.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/for_loop.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/for_loop_induction.hpp&gt;</em><em>#include &lt;cstdlib&gt;</em><em>#include &lt;hpx/parallel/algorithms/for_loop_reduction.hpp&gt;</em><em>#include &lt;hpx/runtime/get_os_thread_count.hpp&gt;</em><em>#include &lt;hpx/runtime/get_worker_thread_num.hpp&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="adjacent__difference_8hpp"></span><em>file</em> <code class="descname">adjacent_difference.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/util/zip_iterator.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;hpx/parallel/util/loop.hpp&gt;</em><em>#include &lt;hpx/parallel/util/partitioner.hpp&gt;</em><em>#include &lt;hpx/util/unused.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;numeric&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;vector&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="adjacent__find_8hpp"></span><em>file</em> <code class="descname">adjacent_find.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/predicates.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;hpx/parallel/util/loop.hpp&gt;</em><em>#include &lt;hpx/parallel/util/partitioner.hpp&gt;</em><em>#include &lt;hpx/parallel/util/zip_iterator.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;vector&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="algorithms_2all__any__none_8hpp"></span><em>file</em> <code class="descname">all_any_none.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/util/range.hpp&gt;</em><em>#include &lt;hpx/util/void_guard.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/traits/projected.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;hpx/parallel/util/invoke_projected.hpp&gt;</em><em>#include &lt;hpx/parallel/util/loop.hpp&gt;</em><em>#include &lt;hpx/parallel/util/partitioner.hpp&gt;</em><em>#include &lt;hpx/util/unused.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;vector&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="container__algorithms_2all__any__none_8hpp"></span><em>file</em> <code class="descname">all_any_none.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/concepts.hpp&gt;</em><em>#include &lt;hpx/traits/is_range.hpp&gt;</em><em>#include &lt;hpx/util/range.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/all_any_none.hpp&gt;</em><em>#include &lt;hpx/parallel/traits/projected_range.hpp&gt;</em><em>#include &lt;hpx/util/decay.hpp&gt;</em><em>#include &lt;hpx/util/result_of.hpp&gt;</em><em>#include &lt;hpx/parallel/traits/projected.hpp&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;hpx/parallel/util/projection_identity.hpp&gt;</em><em>#include &lt;utility&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="algorithms_2copy_8hpp"></span><em>file</em> <code class="descname">copy.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/concepts.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/util/invoke.hpp&gt;</em><em>#include &lt;hpx/util/tagged_pair.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/is_negative.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/predicates.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/transfer.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/tagspec.hpp&gt;</em><em>#include &lt;hpx/parallel/traits/projected.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;hpx/parallel/util/foreach_partitioner.hpp&gt;</em><em>#include &lt;hpx/parallel/util/loop.hpp&gt;</em><em>#include &lt;hpx/parallel/util/projection_identity.hpp&gt;</em><em>#include &lt;hpx/parallel/util/scan_partitioner.hpp&gt;</em><em>#include &lt;hpx/parallel/util/transfer.hpp&gt;</em><em>#include &lt;hpx/parallel/util/zip_iterator.hpp&gt;</em><em>#include &lt;hpx/util/unused.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;cstring&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;memory&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;vector&gt;</em><em>#include &lt;boost/shared_array.hpp&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="container__algorithms_2copy_8hpp"></span><em>file</em> <code class="descname">copy.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/concepts.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/traits/is_range.hpp&gt;</em><em>#include &lt;hpx/util/range.hpp&gt;</em><em>#include &lt;hpx/util/tagged_pair.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/copy.hpp&gt;</em><em>#include &lt;hpx/parallel/traits/projected.hpp&gt;</em><em>#include &lt;hpx/parallel/traits/projected_range.hpp&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="algorithms_2count_8hpp"></span><em>file</em> <code class="descname">count.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/traits/segmented_iterator_traits.hpp&gt;</em><em>#include &lt;hpx/util/bind_back.hpp&gt;</em><em>#include &lt;hpx/util/range.hpp&gt;</em><em>#include &lt;hpx/util/unwrap.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/traits/projected.hpp&gt;</em><em>#include &lt;hpx/parallel/traits/vector_pack_count_bits.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;hpx/parallel/util/invoke_projected.hpp&gt;</em><em>#include &lt;hpx/parallel/util/loop.hpp&gt;</em><em>#include &lt;hpx/parallel/util/partitioner.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;functional&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;vector&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="container__algorithms_2count_8hpp"></span><em>file</em> <code class="descname">count.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/concepts.hpp&gt;</em><em>#include &lt;hpx/traits/is_range.hpp&gt;</em><em>#include &lt;hpx/util/range.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/count.hpp&gt;</em><em>#include &lt;hpx/parallel/traits/projected_range.hpp&gt;</em><em>#include &lt;hpx/parallel/util/projection_identity.hpp&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="destroy_8hpp"></span><em>file</em> <code class="descname">destroy.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/util/void_guard.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/is_negative.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;hpx/parallel/util/loop.hpp&gt;</em><em>#include &lt;hpx/parallel/util/foreach_partitioner.hpp&gt;</em><em>#include &lt;hpx/parallel/util/projection_identity.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;memory&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;vector&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="equal_8hpp"></span><em>file</em> <code class="descname">equal.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/util/range.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/predicates.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;hpx/parallel/util/loop.hpp&gt;</em><em>#include &lt;hpx/parallel/util/partitioner.hpp&gt;</em><em>#include &lt;hpx/parallel/util/zip_iterator.hpp&gt;</em><em>#include &lt;hpx/util/unused.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;vector&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="exclusive__scan_8hpp"></span><em>file</em> <code class="descname">exclusive_scan.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/util/invoke.hpp&gt;</em><em>#include &lt;hpx/util/unwrap.hpp&gt;</em><em>#include &lt;hpx/util/zip_iterator.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/inclusive_scan.hpp&gt;</em><em>#include &lt;hpx/util/invoke.hpp&gt;</em><em>#include &lt;hpx/util/unwrap.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;hpx/parallel/util/loop.hpp&gt;</em><em>#include &lt;hpx/parallel/util/partitioner.hpp&gt;</em><em>#include &lt;hpx/parallel/util/scan_partitioner.hpp&gt;</em><em>#include &lt;hpx/parallel/util/projection_identity.hpp&gt;</em><em>#include &lt;hpx/util/unused.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;numeric&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;vector&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="algorithms_2fill_8hpp"></span><em>file</em> <code class="descname">fill.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/traits/is_value_proxy.hpp&gt;</em><em>#include &lt;hpx/util/void_guard.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/for_each.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/is_negative.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;hpx/parallel/util/projection_identity.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="container__algorithms_2fill_8hpp"></span><em>file</em> <code class="descname">fill.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/is_execution_policy.hpp&gt;</em><em>#include &lt;hpx/traits/is_range.hpp&gt;</em><em>#include &lt;hpx/util/range.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/fill.hpp&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="algorithms_2find_8hpp"></span><em>file</em> <code class="descname">find.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/util/invoke.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/predicates.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/traits/projected.hpp&gt;</em><em>#include &lt;hpx/parallel/util/compare_projected.hpp&gt;</em><em>#include &lt;hpx/parallel/util/invoke_projected.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;hpx/parallel/util/projection_identity.hpp&gt;</em><em>#include &lt;hpx/parallel/util/loop.hpp&gt;</em><em>#include &lt;hpx/parallel/util/partitioner.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;vector&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="container__algorithms_2find_8hpp"></span><em>file</em> <code class="descname">find.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/concepts.hpp&gt;</em><em>#include &lt;hpx/traits/is_execution_policy.hpp&gt;</em><em>#include &lt;hpx/traits/is_range.hpp&gt;</em><em>#include &lt;hpx/util/range.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/find.hpp&gt;</em><em>#include &lt;hpx/parallel/traits/projected.hpp&gt;</em><em>#include &lt;hpx/parallel/traits/projected_range.hpp&gt;</em><em>#include &lt;hpx/parallel/util/projection_identity.hpp&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="algorithms_2for__each_8hpp"></span><em>file</em> <code class="descname">for_each.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/concepts.hpp&gt;</em><em>#include &lt;hpx/traits/is_callable.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/traits/is_value_proxy.hpp&gt;</em><em>#include &lt;hpx/traits/segmented_iterator_traits.hpp&gt;</em><em>#include &lt;hpx/util/annotated_function.hpp&gt;</em><em>#include &lt;hpx/util/identity.hpp&gt;</em><em>#include &lt;hpx/util/invoke.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/is_negative.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/traits/projected.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;hpx/parallel/util/foreach_partitioner.hpp&gt;</em><em>#include &lt;hpx/parallel/util/loop.hpp&gt;</em><em>#include &lt;hpx/parallel/util/projection_identity.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;cstdint&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="container__algorithms_2for__each_8hpp"></span><em>file</em> <code class="descname">for_each.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/concepts.hpp&gt;</em><em>#include &lt;hpx/traits/is_range.hpp&gt;</em><em>#include &lt;hpx/util/range.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/for_each.hpp&gt;</em><em>#include &lt;hpx/parallel/traits/projected_range.hpp&gt;</em><em>#include &lt;hpx/parallel/util/projection_identity.hpp&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="for__loop_8hpp"></span><em>file</em> <code class="descname">for_loop.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/concepts.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/util/annotated_function.hpp&gt;</em><em>#include &lt;hpx/util/assert.hpp&gt;</em><em>#include &lt;hpx/util/decay.hpp&gt;</em><em>#include &lt;hpx/util/detail/pack.hpp&gt;</em><em>#include &lt;hpx/util/invoke.hpp&gt;</em><em>#include &lt;hpx/util/tuple.hpp&gt;</em><em>#include &lt;hpx/util/unused.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/predicates.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/for_loop_induction.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/for_loop_reduction.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;hpx/parallel/util/loop.hpp&gt;</em><em>#include &lt;hpx/parallel/util/partitioner.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;cstdint&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;vector&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="for__loop__induction_8hpp"></span><em>file</em> <code class="descname">for_loop_induction.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/util/decay.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/predicates.hpp&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;cstdlib&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="for__loop__reduction_8hpp"></span><em>file</em> <code class="descname">for_loop_reduction.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/runtime/get_os_thread_count.hpp&gt;</em><em>#include &lt;hpx/runtime/get_worker_thread_num.hpp&gt;</em><em>#include &lt;hpx/util/assert.hpp&gt;</em><em>#include &lt;hpx/util/decay.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/predicates.hpp&gt;</em><em>#include &lt;boost/shared_array.hpp&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;cstdlib&gt;</em><em>#include &lt;functional&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="algorithms_2generate_8hpp"></span><em>file</em> <code class="descname">generate.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/concepts.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/traits/segmented_iterator_traits.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/is_negative.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/for_each.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;hpx/parallel/util/projection_identity.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="container__algorithms_2generate_8hpp"></span><em>file</em> <code class="descname">generate.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/concepts.hpp&gt;</em><em>#include &lt;hpx/traits/is_range.hpp&gt;</em><em>#include &lt;hpx/util/range.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/generate.hpp&gt;</em><em>#include &lt;hpx/parallel/traits/projected_range.hpp&gt;</em><em>#include &lt;hpx/parallel/util/projection_identity.hpp&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="includes_8hpp"></span><em>file</em> <code class="descname">includes.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/util/range.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/predicates.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/util/cancellation_token.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;hpx/parallel/util/partitioner.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;vector&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="inclusive__scan_8hpp"></span><em>file</em> <code class="descname">inclusive_scan.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/util/invoke.hpp&gt;</em><em>#include &lt;hpx/util/unwrap.hpp&gt;</em><em>#include &lt;hpx/util/zip_iterator.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;hpx/parallel/util/loop.hpp&gt;</em><em>#include &lt;hpx/parallel/util/partitioner.hpp&gt;</em><em>#include &lt;hpx/parallel/util/scan_partitioner.hpp&gt;</em><em>#include &lt;hpx/parallel/util/projection_identity.hpp&gt;</em><em>#include &lt;hpx/util/unused.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;numeric&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;vector&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="algorithms_2is__heap_8hpp"></span><em>file</em> <code class="descname">is_heap.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/async.hpp&gt;</em><em>#include &lt;hpx/lcos/future.hpp&gt;</em><em>#include &lt;hpx/traits/concepts.hpp&gt;</em><em>#include &lt;hpx/traits/is_callable.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/util/invoke.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/executors/execution.hpp&gt;</em><em>#include &lt;hpx/parallel/traits/projected.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;hpx/parallel/util/projection_identity.hpp&gt;</em><em>#include &lt;hpx/parallel/util/loop.hpp&gt;</em><em>#include &lt;hpx/parallel/util/partitioner.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;list&gt;</em><em>#include &lt;vector&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="container__algorithms_2is__heap_8hpp"></span><em>file</em> <code class="descname">is_heap.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/concepts.hpp&gt;</em><em>#include &lt;hpx/traits/is_range.hpp&gt;</em><em>#include &lt;hpx/util/range.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/is_heap.hpp&gt;</em><em>#include &lt;hpx/parallel/traits/projected_range.hpp&gt;</em><em>#include &lt;hpx/parallel/util/projection_identity.hpp&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="is__partitioned_8hpp"></span><em>file</em> <code class="descname">is_partitioned.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/lcos/future.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/util/invoke.hpp&gt;</em><em>#include &lt;hpx/util/unused.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/util/cancellation_token.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;hpx/parallel/util/loop.hpp&gt;</em><em>#include &lt;hpx/parallel/util/partitioner.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;functional&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;vector&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="is__sorted_8hpp"></span><em>file</em> <code class="descname">is_sorted.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/util/invoke.hpp&gt;</em><em>#include &lt;hpx/util/range.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/util/cancellation_token.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;hpx/parallel/util/loop.hpp&gt;</em><em>#include &lt;hpx/parallel/util/partitioner.hpp&gt;</em><em>#include &lt;hpx/util/unused.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;functional&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;vector&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="lexicographical__compare_8hpp"></span><em>file</em> <code class="descname">lexicographical_compare.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/util/invoke.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/predicates.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/for_each.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/mismatch.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;hpx/parallel/util/loop.hpp&gt;</em><em>#include &lt;hpx/parallel/util/partitioner.hpp&gt;</em><em>#include &lt;hpx/parallel/util/zip_iterator.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;vector&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="algorithms_2merge_8hpp"></span><em>file</em> <code class="descname">merge.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/concepts.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/util/assert.hpp&gt;</em><em>#include &lt;hpx/util/invoke.hpp&gt;</em><em>#include &lt;hpx/util/tagged_tuple.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/is_negative.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/predicates.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/transfer.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/tagspec.hpp&gt;</em><em>#include &lt;hpx/parallel/traits/projected.hpp&gt;</em><em>#include &lt;hpx/parallel/util/compare_projected.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/handle_local_exceptions.hpp&gt;</em><em>#include &lt;hpx/parallel/util/loop.hpp&gt;</em><em>#include &lt;hpx/parallel/util/projection_identity.hpp&gt;</em><em>#include &lt;hpx/parallel/util/transfer.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;exception&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;list&gt;</em><em>#include &lt;memory&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;vector&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="container__algorithms_2merge_8hpp"></span><em>file</em> <code class="descname">merge.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/concepts.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/traits/is_range.hpp&gt;</em><em>#include &lt;hpx/util/range.hpp&gt;</em><em>#include &lt;hpx/util/tagged_tuple.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/merge.hpp&gt;</em><em>#include &lt;hpx/parallel/tagspec.hpp&gt;</em><em>#include &lt;hpx/parallel/traits/projected.hpp&gt;</em><em>#include &lt;hpx/parallel/traits/projected_range.hpp&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="algorithms_2minmax_8hpp"></span><em>file</em> <code class="descname">minmax.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/concepts.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/traits/segmented_iterator_traits.hpp&gt;</em><em>#include &lt;hpx/util/assert.hpp&gt;</em><em>#include &lt;hpx/util/invoke.hpp&gt;</em><em>#include &lt;hpx/util/tagged_pair.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/tagspec.hpp&gt;</em><em>#include &lt;hpx/parallel/traits/projected.hpp&gt;</em><em>#include &lt;hpx/parallel/util/compare_projected.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;hpx/parallel/util/loop.hpp&gt;</em><em>#include &lt;hpx/parallel/util/partitioner.hpp&gt;</em><em>#include &lt;hpx/parallel/util/projection_identity.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;vector&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="container__algorithms_2minmax_8hpp"></span><em>file</em> <code class="descname">minmax.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/concepts.hpp&gt;</em><em>#include &lt;hpx/traits/is_range.hpp&gt;</em><em>#include &lt;hpx/util/range.hpp&gt;</em><em>#include &lt;hpx/util/tagged_pair.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/minmax.hpp&gt;</em><em>#include &lt;hpx/parallel/traits/projected.hpp&gt;</em><em>#include &lt;hpx/parallel/traits/projected_range.hpp&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="mismatch_8hpp"></span><em>file</em> <code class="descname">mismatch.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/util/invoke.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/predicates.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;hpx/parallel/util/loop.hpp&gt;</em><em>#include &lt;hpx/parallel/util/partitioner.hpp&gt;</em><em>#include &lt;hpx/parallel/util/zip_iterator.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;vector&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="move_8hpp"></span><em>file</em> <code class="descname">move.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/transfer.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;hpx/parallel/util/foreach_partitioner.hpp&gt;</em><em>#include &lt;hpx/parallel/util/transfer.hpp&gt;</em><em>#include &lt;hpx/parallel/util/zip_iterator.hpp&gt;</em><em>#include &lt;hpx/traits/segmented_iterator_traits.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="algorithms_2partition_8hpp"></span><em>file</em> <code class="descname">partition.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/async.hpp&gt;</em><em>#include &lt;hpx/lcos/dataflow.hpp&gt;</em><em>#include &lt;hpx/lcos/future.hpp&gt;</em><em>#include &lt;hpx/lcos/local/spinlock.hpp&gt;</em><em>#include &lt;hpx/traits/concepts.hpp&gt;</em><em>#include &lt;hpx/traits/is_callable.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/util/assert.hpp&gt;</em><em>#include &lt;hpx/util/invoke.hpp&gt;</em><em>#include &lt;hpx/util/tagged_tuple.hpp&gt;</em><em>#include &lt;hpx/util/unused.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/exception_list.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/executors/execution.hpp&gt;</em><em>#include &lt;hpx/parallel/executors/execution_information.hpp&gt;</em><em>#include &lt;hpx/parallel/executors/execution_parameters.hpp&gt;</em><em>#include &lt;hpx/parallel/tagspec.hpp&gt;</em><em>#include &lt;hpx/parallel/traits/projected.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/handle_local_exceptions.hpp&gt;</em><em>#include &lt;hpx/parallel/util/invoke_projected.hpp&gt;</em><em>#include &lt;hpx/parallel/util/loop.hpp&gt;</em><em>#include &lt;hpx/parallel/util/projection_identity.hpp&gt;</em><em>#include &lt;hpx/parallel/util/scan_partitioner.hpp&gt;</em><em>#include &lt;hpx/parallel/util/zip_iterator.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;cstdint&gt;</em><em>#include &lt;exception&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;list&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;vector&gt;</em><em>#include &lt;boost/shared_array.hpp&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="container__algorithms_2partition_8hpp"></span><em>file</em> <code class="descname">partition.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/concepts.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/traits/is_range.hpp&gt;</em><em>#include &lt;hpx/util/range.hpp&gt;</em><em>#include &lt;hpx/util/tagged_tuple.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/partition.hpp&gt;</em><em>#include &lt;hpx/parallel/tagspec.hpp&gt;</em><em>#include &lt;hpx/parallel/traits/projected.hpp&gt;</em><em>#include &lt;hpx/parallel/traits/projected_range.hpp&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="parallel_2algorithms_2reduce_8hpp"></span><em>file</em> <code class="descname">reduce.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/util/range.hpp&gt;</em><em>#include &lt;hpx/util/unwrap.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;hpx/parallel/util/loop.hpp&gt;</em><em>#include &lt;hpx/parallel/util/partitioner.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;numeric&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;vector&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="lcos_2reduce_8hpp"></span><em>file</em> <code class="descname">reduce.hpp</code></dt>
<dd></dd></dl>

<dl class="file">
<dt>
<span class="target" id="reduce__by__key_8hpp"></span><em>file</em> <code class="descname">reduce_by_key.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/parallel/executors/execution.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/copy.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/for_each.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/inclusive_scan.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/sort.hpp&gt;</em><em>#include &lt;hpx/parallel/util/zip_iterator.hpp&gt;</em><em>#include &lt;hpx/util/range.hpp&gt;</em><em>#include &lt;hpx/util/transform_iterator.hpp&gt;</em><em>#include &lt;hpx/util/result_of.hpp&gt;</em><em>#include &lt;hpx/util/iterator_adaptor.hpp&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;hpx/util/tuple.hpp&gt;</em><em>#include &lt;cstdint&gt;</em><em>#include &lt;functional&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;vector&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="algorithms_2remove_8hpp"></span><em>file</em> <code class="descname">remove.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/concepts.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/util/invoke.hpp&gt;</em><em>#include &lt;hpx/util/tagged_pair.hpp&gt;</em><em>#include &lt;hpx/util/unused.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/is_negative.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/predicates.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/transfer.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/tagspec.hpp&gt;</em><em>#include &lt;hpx/parallel/traits/projected.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;hpx/parallel/util/foreach_partitioner.hpp&gt;</em><em>#include &lt;hpx/parallel/util/invoke_projected.hpp&gt;</em><em>#include &lt;hpx/parallel/util/loop.hpp&gt;</em><em>#include &lt;hpx/parallel/util/projection_identity.hpp&gt;</em><em>#include &lt;hpx/parallel/util/scan_partitioner.hpp&gt;</em><em>#include &lt;hpx/parallel/util/transfer.hpp&gt;</em><em>#include &lt;hpx/parallel/util/zip_iterator.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;cstring&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;memory&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;vector&gt;</em><em>#include &lt;boost/shared_array.hpp&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="container__algorithms_2remove_8hpp"></span><em>file</em> <code class="descname">remove.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/concepts.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/traits/is_range.hpp&gt;</em><em>#include &lt;hpx/util/range.hpp&gt;</em><em>#include &lt;hpx/util/tagged_pair.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/remove.hpp&gt;</em><em>#include &lt;hpx/parallel/tagspec.hpp&gt;</em><em>#include &lt;hpx/parallel/traits/projected.hpp&gt;</em><em>#include &lt;hpx/parallel/traits/projected_range.hpp&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="algorithms_2remove__copy_8hpp"></span><em>file</em> <code class="descname">remove_copy.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/concepts.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/util/invoke.hpp&gt;</em><em>#include &lt;hpx/util/tagged_pair.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/copy.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/tagspec.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;hpx/parallel/util/projection_identity.hpp&gt;</em><em>#include &lt;hpx/util/unused.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="container__algorithms_2remove__copy_8hpp"></span><em>file</em> <code class="descname">remove_copy.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/concepts.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/traits/is_range.hpp&gt;</em><em>#include &lt;hpx/util/range.hpp&gt;</em><em>#include &lt;hpx/util/tagged_pair.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/remove_copy.hpp&gt;</em><em>#include &lt;hpx/parallel/tagspec.hpp&gt;</em><em>#include &lt;hpx/parallel/traits/projected.hpp&gt;</em><em>#include &lt;hpx/parallel/traits/projected_range.hpp&gt;</em><em>#include &lt;hpx/parallel/util/projection_identity.hpp&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="algorithms_2replace_8hpp"></span><em>file</em> <code class="descname">replace.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/concepts.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/util/invoke.hpp&gt;</em><em>#include &lt;hpx/util/tagged_pair.hpp&gt;</em><em>#include &lt;hpx/util/unused.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/for_each.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/tagspec.hpp&gt;</em><em>#include &lt;hpx/parallel/traits/projected.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;hpx/parallel/util/projection_identity.hpp&gt;</em><em>#include &lt;hpx/parallel/util/zip_iterator.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="container__algorithms_2replace_8hpp"></span><em>file</em> <code class="descname">replace.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/concepts.hpp&gt;</em><em>#include &lt;hpx/traits/is_range.hpp&gt;</em><em>#include &lt;hpx/util/range.hpp&gt;</em><em>#include &lt;hpx/util/tagged_pair.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/replace.hpp&gt;</em><em>#include &lt;hpx/parallel/tagspec.hpp&gt;</em><em>#include &lt;hpx/parallel/traits/projected_range.hpp&gt;</em><em>#include &lt;hpx/parallel/util/projection_identity.hpp&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="algorithms_2reverse_8hpp"></span><em>file</em> <code class="descname">reverse.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/concepts.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/util/tagged_pair.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/copy.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/for_each.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/tagspec.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;hpx/parallel/util/projection_identity.hpp&gt;</em><em>#include &lt;hpx/parallel/util/zip_iterator.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="container__algorithms_2reverse_8hpp"></span><em>file</em> <code class="descname">reverse.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/concepts.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/traits/is_range.hpp&gt;</em><em>#include &lt;hpx/util/range.hpp&gt;</em><em>#include &lt;hpx/util/tagged_pair.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/reverse.hpp&gt;</em><em>#include &lt;hpx/parallel/tagspec.hpp&gt;</em><em>#include &lt;hpx/parallel/traits/projected_range.hpp&gt;</em><em>#include &lt;hpx/parallel/util/projection_identity.hpp&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="algorithms_2rotate_8hpp"></span><em>file</em> <code class="descname">rotate.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/dataflow.hpp&gt;</em><em>#include &lt;hpx/traits/concepts.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/util/tagged_pair.hpp&gt;</em><em>#include &lt;hpx/util/unwrap.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/copy.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/reverse.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/tagspec.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;hpx/parallel/util/transfer.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="container__algorithms_2rotate_8hpp"></span><em>file</em> <code class="descname">rotate.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/concepts.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/traits/is_range.hpp&gt;</em><em>#include &lt;hpx/util/range.hpp&gt;</em><em>#include &lt;hpx/util/tagged_pair.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/rotate.hpp&gt;</em><em>#include &lt;hpx/parallel/tagspec.hpp&gt;</em><em>#include &lt;hpx/parallel/traits/projected_range.hpp&gt;</em><em>#include &lt;hpx/parallel/util/projection_identity.hpp&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="algorithms_2search_8hpp"></span><em>file</em> <code class="descname">search.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/predicates.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/for_each.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;hpx/parallel/util/compare_projected.hpp&gt;</em><em>#include &lt;hpx/parallel/util/zip_iterator.hpp&gt;</em><em>#include &lt;hpx/parallel/util/loop.hpp&gt;</em><em>#include &lt;hpx/parallel/util/partitioner.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;vector&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="container__algorithms_2search_8hpp"></span><em>file</em> <code class="descname">search.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/is_execution_policy.hpp&gt;</em><em>#include &lt;hpx/traits/is_range.hpp&gt;</em><em>#include &lt;hpx/util/range.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/search.hpp&gt;</em><em>#include &lt;hpx/parallel/traits/projected.hpp&gt;</em><em>#include &lt;hpx/parallel/traits/projected_range.hpp&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="set__difference_8hpp"></span><em>file</em> <code class="descname">set_difference.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/util/decay.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/copy.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/set_operation.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;hpx/parallel/util/loop.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="set__intersection_8hpp"></span><em>file</em> <code class="descname">set_intersection.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/util/decay.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/copy.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/set_operation.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;hpx/parallel/util/loop.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="set__symmetric__difference_8hpp"></span><em>file</em> <code class="descname">set_symmetric_difference.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/util/decay.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/copy.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/set_operation.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;hpx/parallel/util/loop.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="set__union_8hpp"></span><em>file</em> <code class="descname">set_union.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/util/decay.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/copy.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/set_operation.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;hpx/parallel/util/loop.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="algorithms_2sort_8hpp"></span><em>file</em> <code class="descname">sort.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/dataflow.hpp&gt;</em><em>#include &lt;hpx/traits/concepts.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/util/assert.hpp&gt;</em><em>#include &lt;hpx/util/decay.hpp&gt;</em><em>#include &lt;hpx/util/invoke.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/predicates.hpp&gt;</em><em>#include &lt;hpx/parallel/exception_list.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/executors/execution.hpp&gt;</em><em>#include &lt;hpx/parallel/traits/projected.hpp&gt;</em><em>#include &lt;hpx/parallel/util/compare_projected.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;hpx/parallel/util/projection_identity.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;exception&gt;</em><em>#include &lt;functional&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;list&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="container__algorithms_2sort_8hpp"></span><em>file</em> <code class="descname">sort.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/concepts.hpp&gt;</em><em>#include &lt;hpx/traits/is_range.hpp&gt;</em><em>#include &lt;hpx/util/range.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/sort.hpp&gt;</em><em>#include &lt;hpx/parallel/traits/projected_range.hpp&gt;</em><em>#include &lt;hpx/parallel/util/projection_identity.hpp&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="sort__by__key_8hpp"></span><em>file</em> <code class="descname">sort_by_key.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/util/tagged_pair.hpp&gt;</em><em>#include &lt;hpx/util/tuple.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/sort.hpp&gt;</em><em>#include &lt;hpx/parallel/tagspec.hpp&gt;</em><em>#include &lt;hpx/parallel/util/zip_iterator.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="swap__ranges_8hpp"></span><em>file</em> <code class="descname">swap_ranges.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/for_each.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;hpx/parallel/util/projection_identity.hpp&gt;</em><em>#include &lt;hpx/parallel/util/zip_iterator.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="algorithms_2transform_8hpp"></span><em>file</em> <code class="descname">transform.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/concepts.hpp&gt;</em><em>#include &lt;hpx/traits/is_callable.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/traits/segmented_iterator_traits.hpp&gt;</em><em>#include &lt;hpx/util/annotated_function.hpp&gt;</em><em>#include &lt;hpx/util/invoke.hpp&gt;</em><em>#include &lt;hpx/util/tagged_pair.hpp&gt;</em><em>#include &lt;hpx/util/tagged_tuple.hpp&gt;</em><em>#include &lt;hpx/util/tuple.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/tagspec.hpp&gt;</em><em>#include &lt;hpx/parallel/traits/projected.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;hpx/parallel/util/foreach_partitioner.hpp&gt;</em><em>#include &lt;hpx/parallel/util/projection_identity.hpp&gt;</em><em>#include &lt;hpx/parallel/util/transform_loop.hpp&gt;</em><em>#include &lt;hpx/parallel/util/cancellation_token.hpp&gt;</em><em>#include &lt;hpx/traits/is_execution_policy.hpp&gt;</em><em>#include &lt;hpx/util/invoke.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;hpx/parallel/util/zip_iterator.hpp&gt;</em><em>#include &lt;cstdint&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="container__algorithms_2transform_8hpp"></span><em>file</em> <code class="descname">transform.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/concepts.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/traits/is_range.hpp&gt;</em><em>#include &lt;hpx/util/range.hpp&gt;</em><em>#include &lt;hpx/util/tagged_pair.hpp&gt;</em><em>#include &lt;hpx/util/tagged_tuple.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/transform.hpp&gt;</em><em>#include &lt;hpx/traits/is_callable.hpp&gt;</em><em>#include &lt;hpx/traits/segmented_iterator_traits.hpp&gt;</em><em>#include &lt;hpx/util/annotated_function.hpp&gt;</em><em>#include &lt;hpx/util/invoke.hpp&gt;</em><em>#include &lt;hpx/util/tuple.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/tagspec.hpp&gt;</em><em>#include &lt;hpx/parallel/traits/projected.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;hpx/parallel/util/foreach_partitioner.hpp&gt;</em><em>#include &lt;hpx/parallel/util/projection_identity.hpp&gt;</em><em>#include &lt;hpx/parallel/util/transform_loop.hpp&gt;</em><em>#include &lt;hpx/parallel/util/zip_iterator.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;cstdint&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;hpx/parallel/traits/projected_range.hpp&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="transform__exclusive__scan_8hpp"></span><em>file</em> <code class="descname">transform_exclusive_scan.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/concepts.hpp&gt;</em><em>#include &lt;hpx/traits/is_callable.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/util/invoke.hpp&gt;</em><em>#include &lt;hpx/util/result_of.hpp&gt;</em><em>#include &lt;hpx/util/unused.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/transform_inclusive_scan.hpp&gt;</em><em>#include &lt;hpx/util/invoke.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/inclusive_scan.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;hpx/parallel/util/loop.hpp&gt;</em><em>#include &lt;hpx/parallel/util/partitioner.hpp&gt;</em><em>#include &lt;hpx/parallel/util/scan_partitioner.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;numeric&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;vector&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="transform__inclusive__scan_8hpp"></span><em>file</em> <code class="descname">transform_inclusive_scan.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/concepts.hpp&gt;</em><em>#include &lt;hpx/traits/is_callable.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/util/invoke.hpp&gt;</em><em>#include &lt;hpx/util/result_of.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/inclusive_scan.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;hpx/parallel/util/loop.hpp&gt;</em><em>#include &lt;hpx/parallel/util/partitioner.hpp&gt;</em><em>#include &lt;hpx/parallel/util/scan_partitioner.hpp&gt;</em><em>#include &lt;hpx/util/unused.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;numeric&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;vector&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="transform__reduce_8hpp"></span><em>file</em> <code class="descname">transform_reduce.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/concepts.hpp&gt;</em><em>#include &lt;hpx/traits/is_callable.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/traits/segmented_iterator_traits.hpp&gt;</em><em>#include &lt;hpx/util/range.hpp&gt;</em><em>#include &lt;hpx/util/result_of.hpp&gt;</em><em>#include &lt;hpx/util/unwrap.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/predicates.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;hpx/parallel/util/loop.hpp&gt;</em><em>#include &lt;hpx/parallel/util/partitioner.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;numeric&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;vector&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="transform__reduce__binary_8hpp"></span><em>file</em> <code class="descname">transform_reduce_binary.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/concepts.hpp&gt;</em><em>#include &lt;hpx/traits/is_callable.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/util/invoke.hpp&gt;</em><em>#include &lt;hpx/util/result_of.hpp&gt;</em><em>#include &lt;hpx/util/zip_iterator.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;hpx/parallel/util/loop.hpp&gt;</em><em>#include &lt;hpx/parallel/util/partitioner.hpp&gt;</em><em>#include &lt;hpx/util/unused.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;numeric&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;vector&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="uninitialized__copy_8hpp"></span><em>file</em> <code class="descname">uninitialized_copy.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/is_negative.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;hpx/parallel/util/loop.hpp&gt;</em><em>#include &lt;hpx/parallel/util/partitioner_with_cleanup.hpp&gt;</em><em>#include &lt;hpx/dataflow.hpp&gt;</em><em>#include &lt;hpx/exception_list.hpp&gt;</em><em>#include &lt;hpx/lcos/wait_all.hpp&gt;</em><em>#include &lt;hpx/util/decay.hpp&gt;</em><em>#include &lt;hpx/util/deferred_call.hpp&gt;</em><em>#include &lt;hpx/util/unused.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/executors/execution.hpp&gt;</em><em>#include &lt;hpx/parallel/executors/execution_parameters.hpp&gt;</em><em>#include &lt;hpx/parallel/traits/extract_partitioner.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/chunk_size.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/handle_local_exceptions.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/partitioner_iteration.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/scoped_executor_parameters.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;exception&gt;</em><em>#include &lt;list&gt;</em><em>#include &lt;memory&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;vector&gt;</em><em>#include &lt;hpx/parallel/util/zip_iterator.hpp&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;type_traits&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="uninitialized__default__construct_8hpp"></span><em>file</em> <code class="descname">uninitialized_default_construct.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/util/void_guard.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/is_negative.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;hpx/parallel/util/loop.hpp&gt;</em><em>#include &lt;hpx/parallel/util/partitioner_with_cleanup.hpp&gt;</em><em>#include &lt;hpx/parallel/util/zip_iterator.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;memory&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;vector&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="uninitialized__fill_8hpp"></span><em>file</em> <code class="descname">uninitialized_fill.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/is_negative.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;hpx/parallel/util/loop.hpp&gt;</em><em>#include &lt;hpx/parallel/util/partitioner_with_cleanup.hpp&gt;</em><em>#include &lt;hpx/parallel/util/zip_iterator.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;memory&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;vector&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="uninitialized__move_8hpp"></span><em>file</em> <code class="descname">uninitialized_move.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/concepts.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/util/tagged_pair.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/is_negative.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/tagspec.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;hpx/parallel/util/loop.hpp&gt;</em><em>#include &lt;hpx/parallel/util/partitioner_with_cleanup.hpp&gt;</em><em>#include &lt;hpx/parallel/util/zip_iterator.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;memory&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;vector&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="uninitialized__value__construct_8hpp"></span><em>file</em> <code class="descname">uninitialized_value_construct.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/util/void_guard.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/is_negative.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;hpx/parallel/util/loop.hpp&gt;</em><em>#include &lt;hpx/parallel/util/partitioner_with_cleanup.hpp&gt;</em><em>#include &lt;hpx/parallel/util/zip_iterator.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;memory&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;vector&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="algorithms_2unique_8hpp"></span><em>file</em> <code class="descname">unique.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/concepts.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/util/invoke.hpp&gt;</em><em>#include &lt;hpx/util/tagged_pair.hpp&gt;</em><em>#include &lt;hpx/util/unused.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/is_negative.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/predicates.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/transfer.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/tagspec.hpp&gt;</em><em>#include &lt;hpx/parallel/traits/projected.hpp&gt;</em><em>#include &lt;hpx/parallel/util/compare_projected.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;hpx/parallel/util/foreach_partitioner.hpp&gt;</em><em>#include &lt;hpx/parallel/util/loop.hpp&gt;</em><em>#include &lt;hpx/parallel/util/projection_identity.hpp&gt;</em><em>#include &lt;hpx/parallel/util/scan_partitioner.hpp&gt;</em><em>#include &lt;hpx/parallel/util/transfer.hpp&gt;</em><em>#include &lt;hpx/parallel/util/zip_iterator.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;cstring&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;memory&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;vector&gt;</em><em>#include &lt;boost/shared_array.hpp&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="container__algorithms_2unique_8hpp"></span><em>file</em> <code class="descname">unique.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/concepts.hpp&gt;</em><em>#include &lt;hpx/traits/is_iterator.hpp&gt;</em><em>#include &lt;hpx/traits/is_range.hpp&gt;</em><em>#include &lt;hpx/util/range.hpp&gt;</em><em>#include &lt;hpx/util/tagged_pair.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/unique.hpp&gt;</em><em>#include &lt;hpx/parallel/tagspec.hpp&gt;</em><em>#include &lt;hpx/parallel/traits/projected.hpp&gt;</em><em>#include &lt;hpx/parallel/traits/projected_range.hpp&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="execution__policy_8hpp"></span><em>file</em> <code class="descname">execution_policy.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/parallel/datapar/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy_fwd.hpp&gt;</em><em>#include &lt;hpx/parallel/executors/execution.hpp&gt;</em><em>#include &lt;hpx/parallel/executors/execution_parameters.hpp&gt;</em><em>#include &lt;hpx/lcos/future.hpp&gt;</em><em>#include &lt;hpx/runtime/serialization/base_object.hpp&gt;</em><em>#include &lt;hpx/traits/detail/wrap_int.hpp&gt;</em><em>#include &lt;hpx/traits/has_member_xxx.hpp&gt;</em><em>#include &lt;hpx/traits/is_executor.hpp&gt;</em><em>#include &lt;hpx/traits/is_executor_parameters.hpp&gt;</em><em>#include &lt;hpx/traits/is_launch_policy.hpp&gt;</em><em>#include &lt;hpx/util/decay.hpp&gt;</em><em>#include &lt;hpx/util/detail/pack.hpp&gt;</em><em>#include &lt;hpx/util/detail/pp/cat.hpp&gt;</em><em>#include &lt;hpx/util/detail/pp/stringize.hpp&gt;</em><em>#include &lt;hpx/parallel/executors/execution_parameters_fwd.hpp&gt;</em><em>#include &lt;boost/ref.hpp&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;functional&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;vector&gt;</em><em>#include &lt;hpx/parallel/executors/parallel_executor.hpp&gt;</em><em>#include &lt;hpx/parallel/executors/rebind_executor.hpp&gt;</em><em>#include &lt;hpx/parallel/executors/execution_fwd.hpp&gt;</em><em>#include &lt;hpx/traits/executor_traits.hpp&gt;</em><em>#include &lt;hpx/parallel/executors/sequenced_executor.hpp&gt;</em><em>#include &lt;hpx/async_launch_policy_dispatch.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/thread_executor.hpp&gt;</em><em>#include &lt;hpx/util/deferred_call.hpp&gt;</em><em>#include &lt;hpx/util/invoke.hpp&gt;</em><em>#include &lt;hpx/util/unwrap.hpp&gt;</em><em>#include &lt;hpx/parallel/exception_list.hpp&gt;</em><em>#include &lt;hpx/exception_list.hpp&gt;</em><em>#include &lt;hpx/hpx_finalize.hpp&gt;</em><em>#include &lt;hpx/util/assert.hpp&gt;</em><em>#include &lt;exception&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;hpx/runtime/serialization/serialize.hpp&gt;</em><em>#include &lt;hpx/traits/is_execution_policy.hpp&gt;</em><em>#include &lt;memory&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="auto__chunk__size_8hpp"></span><em>file</em> <code class="descname">auto_chunk_size.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/runtime/serialization/serialize.hpp&gt;</em><em>#include &lt;hpx/traits/is_executor_parameters.hpp&gt;</em><em>#include &lt;hpx/util/high_resolution_clock.hpp&gt;</em><em>#include &lt;hpx/util/steady_clock.hpp&gt;</em><em>#include &lt;hpx/parallel/executors/execution_parameters.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;cstdint&gt;</em><em>#include &lt;type_traits&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="dynamic__chunk__size_8hpp"></span><em>file</em> <code class="descname">dynamic_chunk_size.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/runtime/serialization/serialize.hpp&gt;</em><em>#include &lt;hpx/traits/is_executor_parameters.hpp&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;type_traits&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="execution__fwd_8hpp"></span><em>file</em> <code class="descname">execution_fwd.hpp</code></dt>
<dd><em>#include &lt;utility&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/traits/executor_traits.hpp&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="execution__information__fwd_8hpp"></span><em>file</em> <code class="descname">execution_information_fwd.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/parallel/executors/execution_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/thread_data_fwd.hpp&gt;</em><em>#include &lt;hpx/traits/executor_traits.hpp&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="guided__chunk__size_8hpp"></span><em>file</em> <code class="descname">guided_chunk_size.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/runtime/serialization/serialize.hpp&gt;</em><em>#include &lt;hpx/traits/is_executor_parameters.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;type_traits&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="parallel__executor_8hpp"></span><em>file</em> <code class="descname">parallel_executor.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/async_launch_policy_dispatch.hpp&gt;</em><em>#include &lt;hpx/lcos/future.hpp&gt;</em><em>#include &lt;hpx/lcos/when_all_fwd.hpp&gt;</em><em>#include &lt;hpx/parallel/algorithms/detail/predicates.hpp&gt;</em><em>#include &lt;hpx/parallel/executors/post_policy_dispatch.hpp&gt;</em><em>#include &lt;hpx/parallel/executors/static_chunk_size.hpp&gt;</em><em>#include &lt;hpx/runtime/get_worker_thread_num.hpp&gt;</em><em>#include &lt;hpx/runtime/launch_policy.hpp&gt;</em><em>#include &lt;hpx/runtime/serialization/serialize.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/thread_helpers.hpp&gt;</em><em>#include &lt;hpx/traits/future_traits.hpp&gt;</em><em>#include &lt;hpx/traits/is_executor.hpp&gt;</em><em>#include &lt;hpx/util/assert.hpp&gt;</em><em>#include &lt;hpx/util/bind.hpp&gt;</em><em>#include &lt;hpx/util/range.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;functional&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;vector&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="persistent__auto__chunk__size_8hpp"></span><em>file</em> <code class="descname">persistent_auto_chunk_size.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/runtime/serialization/serialize.hpp&gt;</em><em>#include &lt;hpx/traits/is_executor_parameters.hpp&gt;</em><em>#include &lt;hpx/util/high_resolution_clock.hpp&gt;</em><em>#include &lt;hpx/util/steady_clock.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;cstdint&gt;</em><em>#include &lt;type_traits&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="sequenced__executor_8hpp"></span><em>file</em> <code class="descname">sequenced_executor.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/async_launch_policy_dispatch.hpp&gt;</em><em>#include &lt;hpx/lcos/future.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/thread_executor.hpp&gt;</em><em>#include &lt;hpx/traits/is_executor.hpp&gt;</em><em>#include &lt;hpx/util/deferred_call.hpp&gt;</em><em>#include &lt;hpx/util/invoke.hpp&gt;</em><em>#include &lt;hpx/util/unwrap.hpp&gt;</em><em>#include &lt;hpx/parallel/exception_list.hpp&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;vector&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="service__executors_8hpp"></span><em>file</em> <code class="descname">service_executors.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/lcos/future.hpp&gt;</em><em>#include &lt;hpx/parallel/executors/static_chunk_size.hpp&gt;</em><em>#include &lt;hpx/parallel/executors/thread_execution.hpp&gt;</em><em>#include &lt;hpx/lcos/dataflow.hpp&gt;</em><em>#include &lt;hpx/lcos/local/futures_factory.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/thread_executor.hpp&gt;</em><em>#include &lt;hpx/traits/future_access.hpp&gt;</em><em>#include &lt;hpx/traits/is_launch_policy.hpp&gt;</em><em>#include &lt;hpx/util/bind.hpp&gt;</em><em>#include &lt;hpx/util/bind_back.hpp&gt;</em><em>#include &lt;hpx/util/detail/pack.hpp&gt;</em><em>#include &lt;hpx/util/deferred_call.hpp&gt;</em><em>#include &lt;hpx/util/range.hpp&gt;</em><em>#include &lt;hpx/util/tuple.hpp&gt;</em><em>#include &lt;hpx/util/unwrap.hpp&gt;</em><em>#include &lt;hpx/parallel/executors/execution.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;vector&gt;</em><em>#include &lt;hpx/runtime/threads/executors/service_executors.hpp&gt;</em><em>#include &lt;hpx/compat/condition_variable.hpp&gt;</em><em>#include &lt;hpx/compat/mutex.hpp&gt;</em><em>#include &lt;hpx/exception_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/thread_enums.hpp&gt;</em><em>#include &lt;hpx/throw_exception.hpp&gt;</em><em>#include &lt;hpx/util/atomic_count.hpp&gt;</em><em>#include &lt;hpx/util/steady_clock.hpp&gt;</em><em>#include &lt;hpx/util/thread_description.hpp&gt;</em><em>#include &lt;hpx/util/unique_function.hpp&gt;</em><em>#include &lt;atomic&gt;</em><em>#include &lt;chrono&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;cstdint&gt;</em><em>#include &lt;hpx/config/warnings_prefix.hpp&gt;</em><em>#include &lt;hpx/config/warnings_suffix.hpp&gt;</em><em>#include &lt;hpx/traits/executor_traits.hpp&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="static__chunk__size_8hpp"></span><em>file</em> <code class="descname">static_chunk_size.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/runtime/serialization/serialize.hpp&gt;</em><em>#include &lt;hpx/traits/is_executor_parameters.hpp&gt;</em><em>#include &lt;hpx/parallel/executors/execution_parameters_fwd.hpp&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;type_traits&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="thread__pool__executors_8hpp"></span><em>file</em> <code class="descname">thread_pool_executors.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/lcos/future.hpp&gt;</em><em>#include &lt;hpx/parallel/executors/execution_parameters.hpp&gt;</em><em>#include &lt;hpx/parallel/executors/thread_execution.hpp&gt;</em><em>#include &lt;hpx/parallel/executors/thread_execution_information.hpp&gt;</em><em>#include &lt;hpx/runtime/get_os_thread_count.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/policies/scheduler_mode.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/thread_executor.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/topology.hpp&gt;</em><em>#include &lt;hpx/traits/is_launch_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/executors/execution_information.hpp&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;hpx/parallel/executors/thread_timed_execution.hpp&gt;</em><em>#include &lt;hpx/lcos/local/packaged_task.hpp&gt;</em><em>#include &lt;hpx/lcos/detail/future_data.hpp&gt;</em><em>#include &lt;hpx/lcos/local/promise.hpp&gt;</em><em>#include &lt;hpx/throw_exception.hpp&gt;</em><em>#include &lt;hpx/traits/is_callable.hpp&gt;</em><em>#include &lt;hpx/util/annotated_function.hpp&gt;</em><em>#include &lt;hpx/util/thread_description.hpp&gt;</em><em>#include &lt;hpx/util/unique_function.hpp&gt;</em><em>#include &lt;exception&gt;</em><em>#include &lt;memory&gt;</em><em>#include &lt;hpx/util/deferred_call.hpp&gt;</em><em>#include &lt;hpx/util/steady_clock.hpp&gt;</em><em>#include &lt;hpx/parallel/executors/timed_execution.hpp&gt;</em><em>#include &lt;hpx/parallel/executors/timed_execution_fwd.hpp&gt;</em><em>#include &lt;hpx/parallel/executors/execution_fwd.hpp&gt;</em><em>#include &lt;hpx/parallel/executors/timed_executors.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/thread.hpp&gt;</em><em>#include &lt;hpx/traits/detail/wrap_int.hpp&gt;</em><em>#include &lt;hpx/traits/executor_traits.hpp&gt;</em><em>#include &lt;hpx/util/bind.hpp&gt;</em><em>#include &lt;hpx/util/decay.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/executors/execution.hpp&gt;</em><em>#include &lt;hpx/parallel/executors/parallel_executor.hpp&gt;</em><em>#include &lt;hpx/parallel/executors/sequenced_executor.hpp&gt;</em><em>#include &lt;chrono&gt;</em><em>#include &lt;functional&gt;</em><em>#include &lt;hpx/traits/is_executor.hpp&gt;</em><em>#include &lt;vector&gt;</em><em>#include &lt;hpx/runtime/threads/executors/thread_pool_executors.hpp&gt;</em><em>#include &lt;hpx/lcos/local/counting_semaphore.hpp&gt;</em><em>#include &lt;hpx/lcos/local/detail/counting_semaphore.hpp&gt;</em><em>#include &lt;hpx/lcos/local/detail/condition_variable.hpp&gt;</em><em>#include &lt;hpx/lcos/local/spinlock.hpp&gt;</em><em>#include &lt;hpx/util/assert.hpp&gt;</em><em>#include &lt;hpx/util/assert_owns_lock.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;cstdint&gt;</em><em>#include &lt;mutex&gt;</em><em>#include &lt;hpx/runtime/resource/detail/partitioner.hpp&gt;</em><em>#include &lt;hpx/runtime/resource/partitioner.hpp&gt;</em><em>#include &lt;hpx/runtime/resource/partitioner_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/resource/detail/create_partitioner.hpp&gt;</em><em>#include &lt;hpx/runtime/runtime_mode.hpp&gt;</em><em>#include &lt;hpx/util/bind_back.hpp&gt;</em><em>#include &lt;hpx/util/find_prefix.hpp&gt;</em><em>#include &lt;string&gt;</em><em>#include &lt;hpx/util/function.hpp&gt;</em><em>#include &lt;boost/program_options.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/cpu_mask.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/policies/affinity_data.hpp&gt;</em><em>#include &lt;atomic&gt;</em><em>#include &lt;hpx/config/warnings_prefix.hpp&gt;</em><em>#include &lt;hpx/config/warnings_suffix.hpp&gt;</em><em>#include &lt;hpx/util/command_line_handling.hpp&gt;</em><em>#include &lt;hpx/hpx_init.hpp&gt;</em><em>#include &lt;hpx/hpx_finalize.hpp&gt;</em><em>#include &lt;hpx/hpx_suspend.hpp&gt;</em><em>#include &lt;hpx/runtime/shutdown_function.hpp&gt;</em><em>#include &lt;hpx/runtime/startup_function.hpp&gt;</em><em>#include &lt;boost/program_options/options_description.hpp&gt;</em><em>#include &lt;boost/program_options/variables_map.hpp&gt;</em><em>#include &lt;hpx/util/manage_config.hpp&gt;</em><em>#include &lt;hpx/util/safe_lexical_cast.hpp&gt;</em><em>#include &lt;boost/lexical_cast.hpp&gt;</em><em>#include &lt;map&gt;</em><em>#include &lt;hpx/util/runtime_configuration.hpp&gt;</em><em>#include &lt;hpx/util/tuple.hpp&gt;</em><em>#include &lt;iosfwd&gt;</em><em>#include &lt;hpx/runtime/threads/thread_enums.hpp&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="task__block_8hpp"></span><em>file</em> <code class="descname">task_block.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/async.hpp&gt;</em><em>#include &lt;hpx/exception.hpp&gt;</em><em>#include &lt;hpx/lcos/dataflow.hpp&gt;</em><em>#include &lt;hpx/lcos/future.hpp&gt;</em><em>#include &lt;hpx/lcos/local/spinlock.hpp&gt;</em><em>#include &lt;hpx/lcos/when_all.hpp&gt;</em><em>#include &lt;hpx/traits/is_future.hpp&gt;</em><em>#include &lt;hpx/util/bind.hpp&gt;</em><em>#include &lt;hpx/util/bind_back.hpp&gt;</em><em>#include &lt;hpx/util/decay.hpp&gt;</em><em>#include &lt;hpx/parallel/exception_list.hpp&gt;</em><em>#include &lt;hpx/parallel/execution_policy.hpp&gt;</em><em>#include &lt;hpx/parallel/executors/execution.hpp&gt;</em><em>#include &lt;hpx/parallel/util/detail/algorithm_result.hpp&gt;</em><em>#include &lt;boost/utility/addressof.hpp&gt;</em><em>#include &lt;memory&gt;</em><em>#include &lt;exception&gt;</em><em>#include &lt;mutex&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;vector&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="manage__counter__type_8hpp"></span><em>file</em> <code class="descname">manage_counter_type.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/error_code.hpp&gt;</em><em>#include &lt;hpx/performance_counters/counters_fwd.hpp&gt;</em><em>#include &lt;hpx/util/function.hpp&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;cstdint&gt;</em><em>#include &lt;string&gt;</em><em>#include &lt;vector&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="basic__action_8hpp"></span><em>file</em> <code class="descname">basic_action.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/exception.hpp&gt;</em><em>#include &lt;hpx/lcos/sync_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/actions/action_support.hpp&gt;</em><em>#include &lt;hpx/runtime/actions/basic_action_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/actions/continuation.hpp&gt;</em><em>#include &lt;hpx/runtime/actions/detail/action_factory.hpp&gt;</em><em>#include &lt;hpx/runtime/actions/detail/invocation_count_registry.hpp&gt;</em><em>#include &lt;hpx/runtime/actions/transfer_action.hpp&gt;</em><em>#include &lt;hpx/runtime/actions/transfer_continuation_action.hpp&gt;</em><em>#include &lt;hpx/runtime/launch_policy.hpp&gt;</em><em>#include &lt;hpx/runtime/naming/address.hpp&gt;</em><em>#include &lt;hpx/runtime/naming/id_type.hpp&gt;</em><em>#include &lt;hpx/runtime/parcelset/detail/per_action_data_counter_registry.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/thread_data_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/thread_enums.hpp&gt;</em><em>#include &lt;hpx/runtime_fwd.hpp&gt;</em><em>#include &lt;hpx/traits/action_decorate_function.hpp&gt;</em><em>#include &lt;hpx/traits/action_priority.hpp&gt;</em><em>#include &lt;hpx/traits/action_remote_result.hpp&gt;</em><em>#include &lt;hpx/traits/action_stacksize.hpp&gt;</em><em>#include &lt;hpx/traits/is_action.hpp&gt;</em><em>#include &lt;hpx/traits/is_distribution_policy.hpp&gt;</em><em>#include &lt;hpx/traits/is_future.hpp&gt;</em><em>#include &lt;hpx/traits/promise_local_result.hpp&gt;</em><em>#include &lt;hpx/util/bind.hpp&gt;</em><em>#include &lt;hpx/util/detail/pack.hpp&gt;</em><em>#include &lt;hpx/util/detail/pp/cat.hpp&gt;</em><em>#include &lt;hpx/util/detail/pp/expand.hpp&gt;</em><em>#include &lt;hpx/util/detail/pp/nargs.hpp&gt;</em><em>#include &lt;hpx/util/detail/pp/stringize.hpp&gt;</em><em>#include &lt;hpx/util/get_and_reset_value.hpp&gt;</em><em>#include &lt;hpx/util/logging.hpp&gt;</em><em>#include &lt;hpx/util/tuple.hpp&gt;</em><em>#include &lt;atomic&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;cstdint&gt;</em><em>#include &lt;exception&gt;</em><em>#include &lt;memory&gt;</em><em>#include &lt;sstream&gt;</em><em>#include &lt;string&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Defines</p>
<dl class="macro">
<dt id="c.HPX_REGISTER_ACTION_DECLARATION">
<span class="target" id="basic__action_8hpp_1ac13b639396c1d3476c04033b29ae3835"></span><code class="descname">HPX_REGISTER_ACTION_DECLARATION</code><span class="sig-paren">(</span>...<span class="sig-paren">)</span><a class="headerlink" href="#c.HPX_REGISTER_ACTION_DECLARATION" title="Permalink to this definition">¶</a></dt>
<dd><p>Declare the necessary component action boilerplate code. </p>
<p>The macro <em>HPX_REGISTER_ACTION_DECLARATION</em> can be used to declare all the boilerplate code which is required for proper functioning of component actions in the context of HPX.</p>
<p>The parameter <em>action</em> is the type of the action to declare the boilerplate for.</p>
<p>This macro can be invoked with an optional second parameter. This parameter specifies a unique name of the action to be used for serialization purposes. The second parameter has to be specified if the first parameter is not usable as a plain (non-qualified) C++ identifier, i.e. the first parameter contains special characters which cannot be part of a C++ identifier, such as ‘&lt;’, ‘&gt;’, or ‘:’.</p>
<p><div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">app</span>
<span class="p">{</span>
    <span class="c1">// Define a simple component exposing one action &#39;print_greeting&#39;</span>
    <span class="k">class</span> <span class="nc">HPX_COMPONENT_EXPORT</span> <span class="nl">server</span>
      <span class="p">:</span> <span class="k">public</span> <span class="n">hpx</span><span class="o">::</span><span class="n">components</span><span class="o">::</span><span class="n">simple_component_base</span><span class="o">&lt;</span><span class="n">server</span><span class="o">&gt;</span>
    <span class="p">{</span>
        <span class="kt">void</span> <span class="n">print_greeting</span> <span class="p">()</span>
        <span class="p">{</span>
            <span class="n">hpx</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Hey, how are you?</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">hpx</span><span class="o">::</span><span class="n">flush</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// Component actions need to be declared, this also defines the</span>
        <span class="c1">// type &#39;print_greeting_action&#39; representing the action.</span>
        <span class="n">HPX_DEFINE_COMPONENT_ACTION</span><span class="p">(</span><span class="n">server</span><span class="p">,</span>
            <span class="n">print_greeting</span><span class="p">,</span> <span class="n">print_greeting_action</span><span class="p">);</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="c1">// Declare boilerplate code required for each of the component actions.</span>
<span class="n">HPX_REGISTER_ACTION_DECLARATION</span><span class="p">(</span><span class="n">app</span><span class="o">::</span><span class="n">server</span><span class="o">::</span><span class="n">print_greeting_action</span><span class="p">);</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>Example:</strong></dt>
<dd></dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This macro has to be used once for each of the component actions defined using one of the <em>HPX_DEFINE_COMPONENT_ACTION</em> macros. It has to be visible in all translation units using the action, thus it is recommended to place it into the header file defining the component. </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.HPX_REGISTER_ACTION">
<span class="target" id="basic__action_8hpp_1ad240c212ef96c34ca97009cba49d8c72"></span><code class="descname">HPX_REGISTER_ACTION</code><span class="sig-paren">(</span>...<span class="sig-paren">)</span><a class="headerlink" href="#c.HPX_REGISTER_ACTION" title="Permalink to this definition">¶</a></dt>
<dd><p>Define the necessary component action boilerplate code. </p>
<p>The macro <em>HPX_REGISTER_ACTION</em> can be used to define all the boilerplate code which is required for proper functioning of component actions in the context of HPX.</p>
<p>The parameter <em>action</em> is the type of the action to define the boilerplate for.</p>
<p>This macro can be invoked with an optional second parameter. This parameter specifies a unique name of the action to be used for serialization purposes. The second parameter has to be specified if the first parameter is not usable as a plain (non-qualified) C++ identifier, i.e. the first parameter contains special characters which cannot be part of a C++ identifier, such as ‘&lt;’, ‘&gt;’, or ‘:’.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This macro has to be used once for each of the component actions defined using one of the <em>HPX_DEFINE_COMPONENT_ACTION</em> or <em>HPX_DEFINE_PLAIN_ACTION</em> macros. It has to occur exactly once for each of the actions, thus it is recommended to place it into the source file defining the component.</dd>
<dt><strong>Note</strong></dt>
<dd>Only one of the forms of this macro <em>HPX_REGISTER_ACTION</em> or <em>HPX_REGISTER_ACTION_ID</em> should be used for a particular action, never both. </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.HPX_REGISTER_ACTION_ID">
<span class="target" id="basic__action_8hpp_1aea27e008c9f5d2191177431c5b351841"></span><code class="descname">HPX_REGISTER_ACTION_ID</code><span class="sig-paren">(</span>action, actionname, actionid<span class="sig-paren">)</span><a class="headerlink" href="#c.HPX_REGISTER_ACTION_ID" title="Permalink to this definition">¶</a></dt>
<dd><p>Define the necessary component action boilerplate code and assign a predefined unique id to the action. </p>
<p>The macro <em>HPX_REGISTER_ACTION</em> can be used to define all the boilerplate code which is required for proper functioning of component actions in the context of HPX.</p>
<p>The parameter <em>action</em> is the type of the action to define the boilerplate for.</p>
<p>The parameter <em>actionname</em> specifies an unique name of the action to be used for serialization purposes. The second parameter has to be usable as a plain (non-qualified) C++ identifier, it should not contain special characters which cannot be part of a C++ identifier, such as ‘&lt;’, ‘&gt;’, or ‘:’.</p>
<p>The parameter <em>actionid</em> specifies an unique integer value which will be used to represent the action during serialization.</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>This macro has to be used once for each of the component actions defined using one of the <em>HPX_DEFINE_COMPONENT_ACTION</em> or global actions <em>HPX_DEFINE_PLAIN_ACTION</em> macros. It has to occur exactly once for each of the actions, thus it is recommended to place it into the source file defining the component.</dd>
<dt><strong>Note</strong></dt>
<dd>Only one of the forms of this macro <em>HPX_REGISTER_ACTION</em> or <em>HPX_REGISTER_ACTION_ID</em> should be used for a particular action, never both. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

<dl class="file">
<dt>
<span class="target" id="component__action_8hpp"></span><em>file</em> <code class="descname">component_action.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/runtime/actions/basic_action.hpp&gt;</em><em>#include &lt;hpx/runtime/actions/continuation.hpp&gt;</em><em>#include &lt;hpx/runtime/components/console_error_sink.hpp&gt;</em><em>#include &lt;hpx/runtime/components/pinned_ptr.hpp&gt;</em><em>#include &lt;hpx/runtime/naming/address.hpp&gt;</em><em>#include &lt;hpx/traits/is_future.hpp&gt;</em><em>#include &lt;hpx/util/detail/pp/cat.hpp&gt;</em><em>#include &lt;hpx/util/detail/pp/expand.hpp&gt;</em><em>#include &lt;hpx/util/detail/pp/nargs.hpp&gt;</em><em>#include &lt;hpx/util/detail/pp/strip_parens.hpp&gt;</em><em>#include &lt;hpx/util/unused.hpp&gt;</em><em>#include &lt;cstdlib&gt;</em><em>#include &lt;sstream&gt;</em><em>#include &lt;stdexcept&gt;</em><em>#include &lt;string&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;hpx/config/warnings_prefix.hpp&gt;</em><em>#include &lt;hpx/config/warnings_suffix.hpp&gt;</em><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Defines</p>
<dl class="macro">
<dt id="c.HPX_DEFINE_COMPONENT_ACTION">
<span class="target" id="component__action_8hpp_1a155152f9f75f6aa5cae3f0434b84540f"></span><code class="descname">HPX_DEFINE_COMPONENT_ACTION</code><span class="sig-paren">(</span>...<span class="sig-paren">)</span><a class="headerlink" href="#c.HPX_DEFINE_COMPONENT_ACTION" title="Permalink to this definition">¶</a></dt>
<dd><p>Registers a member function of a component as an action type with HPX. </p>
<p>The macro <em>HPX_DEFINE_COMPONENT_ACTION</em> can be used to register a member function of a component as an action type named <em>action_type</em>.</p>
<p>The parameter <em>component</em> is the type of the component exposing the member function <em>func</em> which should be associated with the newly defined action type. The parameter <code class="docutils literal notranslate"><span class="pre">action_type</span></code> is the name of the action type to register with HPX.</p>
<p><div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">app</span>
<span class="p">{</span>
    <span class="c1">// Define a simple component exposing one action &#39;print_greeting&#39;</span>
    <span class="k">class</span> <span class="nc">HPX_COMPONENT_EXPORT</span> <span class="nl">server</span>
      <span class="p">:</span> <span class="k">public</span> <span class="n">hpx</span><span class="o">::</span><span class="n">components</span><span class="o">::</span><span class="n">simple_component_base</span><span class="o">&lt;</span><span class="n">server</span><span class="o">&gt;</span>
    <span class="p">{</span>
        <span class="kt">void</span> <span class="n">print_greeting</span><span class="p">()</span> <span class="k">const</span>
        <span class="p">{</span>
            <span class="n">hpx</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Hey, how are you?</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">hpx</span><span class="o">::</span><span class="n">flush</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// Component actions need to be declared, this also defines the</span>
        <span class="c1">// type &#39;print_greeting_action&#39; representing the action.</span>
        <span class="n">HPX_DEFINE_COMPONENT_ACTION</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="n">print_greeting</span><span class="p">,</span>
            <span class="n">print_greeting_action</span><span class="p">);</span>
    <span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>Example:</strong></dt>
<dd></dd>
</dl>
</p>
<p>The first argument must provide the type name of the component the action is defined for.</p>
<p>The second argument must provide the member function name the action should wrap.</p>
<p><p>The default value for the third argument (the typename of the defined action) is derived from the name of the function (as passed as the second argument) by appending ‘_action’. The third argument can be omitted only if the second argument with an appended suffix ‘_action’ resolves to a valid, unqualified C++ type name. </p>
<dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The macro <em>HPX_DEFINE_COMPONENT_ACTION</em> can be used with 2 or 3 arguments. The third argument is optional.</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

<dl class="file">
<dt>
<span class="target" id="plain__action_8hpp"></span><em>file</em> <code class="descname">plain_action.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/runtime/actions/basic_action.hpp&gt;</em><em>#include &lt;hpx/runtime/actions/continuation.hpp&gt;</em><em>#include &lt;hpx/runtime/naming/address.hpp&gt;</em><em>#include &lt;hpx/traits/component_type_database.hpp&gt;</em><em>#include &lt;hpx/util/assert.hpp&gt;</em><em>#include &lt;hpx/util/detail/pp/cat.hpp&gt;</em><em>#include &lt;hpx/util/detail/pp/expand.hpp&gt;</em><em>#include &lt;hpx/util/detail/pp/nargs.hpp&gt;</em><em>#include &lt;hpx/util/detail/pack.hpp&gt;</em><em>#include &lt;hpx/util/detail/pp/strip_parens.hpp&gt;</em><em>#include &lt;hpx/util/unused.hpp&gt;</em><em>#include &lt;cstdlib&gt;</em><em>#include &lt;sstream&gt;</em><em>#include &lt;stdexcept&gt;</em><em>#include &lt;string&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;hpx/config/warnings_prefix.hpp&gt;</em><em>#include &lt;hpx/config/warnings_suffix.hpp&gt;</em><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Defines</p>
<dl class="macro">
<dt id="c.HPX_DEFINE_PLAIN_ACTION">
<span class="target" id="plain__action_8hpp_1a8c78d9a115479f073aac617f2020956e"></span><code class="descname">HPX_DEFINE_PLAIN_ACTION</code><span class="sig-paren">(</span>...<span class="sig-paren">)</span><a class="headerlink" href="#c.HPX_DEFINE_PLAIN_ACTION" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines a plain action type. </p>
<p><div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">app</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">some_global_function</span><span class="p">(</span><span class="kt">double</span> <span class="n">d</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">d</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// This will define the action type &#39;app::some_global_action&#39; which</span>
    <span class="c1">// represents the function &#39;app::some_global_function&#39;.</span>
    <span class="n">HPX_DEFINE_PLAIN_ACTION</span><span class="p">(</span><span class="n">some_global_function</span><span class="p">,</span> <span class="n">some_global_action</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>Example:</strong></dt>
<dd></dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>Usually this macro will not be used in user code unless the intent is to avoid defining the action_type in global namespace. Normally, the use of the macro <em>HPX_PLAIN_ACTION</em> is recommended.</dd>
<dt><strong>Note</strong></dt>
<dd>The macro <em>HPX_DEFINE_PLAIN_ACTION</em> can be used with 1 or 2 arguments. The second argument is optional. The default value for the second argument (the typename of the defined action) is derived from the name of the function (as passed as the first argument) by appending ‘_action’. The second argument can be omitted only if the first argument with an appended suffix ‘_action’ resolves to a valid, unqualified C++ type name. </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.HPX_DECLARE_PLAIN_ACTION">
<span class="target" id="plain__action_8hpp_1affeaad07c1a009b85c3260d6262e3038"></span><code class="descname">HPX_DECLARE_PLAIN_ACTION</code><span class="sig-paren">(</span>...<span class="sig-paren">)</span><a class="headerlink" href="#c.HPX_DECLARE_PLAIN_ACTION" title="Permalink to this definition">¶</a></dt>
<dd><p>Declares a plain action type. </p>
</dd></dl>

<dl class="macro">
<dt id="c.HPX_PLAIN_ACTION">
<span class="target" id="plain__action_8hpp_1a1b32262e97e6b341e400ad2f74de7ac5"></span><code class="descname">HPX_PLAIN_ACTION</code><span class="sig-paren">(</span>...<span class="sig-paren">)</span><a class="headerlink" href="#c.HPX_PLAIN_ACTION" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines a plain action type based on the given function <em>func</em> and registers it with HPX. </p>
<p>The macro <em>HPX_PLAIN_ACTION</em> can be used to define a plain action (e.g. an action encapsulating a global or free function) based on the given function <em>func</em>. It defines the action type <em>name</em> representing the given function. This macro additionally registers the newly define action type with HPX.</p>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">func</span></code> is a global or free (non-member) function which should be encapsulated into a plain action. The parameter <code class="docutils literal notranslate"><span class="pre">name</span></code> is the name of the action type defined by this macro.</p>
<p><div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">app</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">some_global_function</span><span class="p">(</span><span class="kt">double</span> <span class="n">d</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">d</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// This will define the action type &#39;some_global_action&#39; which represents</span>
<span class="c1">// the function &#39;app::some_global_function&#39;.</span>
<span class="n">HPX_PLAIN_ACTION</span><span class="p">(</span><span class="n">app</span><span class="o">::</span><span class="n">some_global_function</span><span class="p">,</span> <span class="n">some_global_action</span><span class="p">);</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>Example:</strong></dt>
<dd></dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The macro <em>HPX_PLAIN_ACTION</em> has to be used at global namespace even if the wrapped function is located in some other namespace. The newly defined action type is placed into the global namespace as well.</dd>
<dt><strong>Note</strong></dt>
<dd>The macro <em>HPX_PLAIN_ACTION_ID</em> can be used with 1, 2, or 3 arguments. The second and third arguments are optional. The default value for the second argument (the typename of the defined action) is derived from the name of the function (as passed as the first argument) by appending ‘_action’. The second argument can be omitted only if the first argument with an appended suffix ‘_action’ resolves to a valid, unqualified C++ type name. The default value for the third argument is <em>hpx::components::factory_check</em>.</dd>
<dt><strong>Note</strong></dt>
<dd>Only one of the forms of this macro <em>HPX_PLAIN_ACTION</em> or <em>HPX_PLAIN_ACTION_ID</em> should be used for a particular action, never both. </dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.HPX_PLAIN_ACTION_ID">
<span class="target" id="plain__action_8hpp_1a3151acb6c4793d0472079e21f0fca05b"></span><code class="descname">HPX_PLAIN_ACTION_ID</code><span class="sig-paren">(</span>func, name, id<span class="sig-paren">)</span><a class="headerlink" href="#c.HPX_PLAIN_ACTION_ID" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines a plain action type based on the given function <em>func</em> and registers it with HPX. </p>
<p>The macro <em>HPX_PLAIN_ACTION_ID</em> can be used to define a plain action (e.g. an action encapsulating a global or free function) based on the given function <em>func</em>. It defines the action type <em>actionname</em> representing the given function. The parameter <em>actionid</em> </p>
<p>The parameter <em>actionid</em> specifies an unique integer value which will be used to represent the action during serialization.</p>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">func</span></code> is a global or free (non-member) function which should be encapsulated into a plain action. The parameter <code class="docutils literal notranslate"><span class="pre">name</span></code> is the name of the action type defined by this macro.</p>
<p>The second parameter has to be usable as a plain (non-qualified) C++ identifier, it should not contain special characters which cannot be part of a C++ identifier, such as ‘&lt;’, ‘&gt;’, or ‘:’.</p>
<p><div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">app</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="n">some_global_function</span><span class="p">(</span><span class="kt">double</span> <span class="n">d</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">d</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// This will define the action type &#39;some_global_action&#39; which represents</span>
<span class="c1">// the function &#39;app::some_global_function&#39;.</span>
<span class="n">HPX_PLAIN_ACTION_ID</span><span class="p">(</span><span class="n">app</span><span class="o">::</span><span class="n">some_global_function</span><span class="p">,</span> <span class="n">some_global_action</span><span class="p">,</span>
  <span class="n">some_unique_id</span><span class="p">);</span>
</pre></div>
</div>
<dl class="docutils">
<dt><strong>Example:</strong></dt>
<dd></dd>
</dl>
</p>
<p><dl class="docutils">
<dt><strong>Note</strong></dt>
<dd>The macro <em>HPX_PLAIN_ACTION_ID</em> has to be used at global namespace even if the wrapped function is located in some other namespace. The newly defined action type is placed into the global namespace as well.</dd>
<dt><strong>Note</strong></dt>
<dd>Only one of the forms of this macro <em>HPX_PLAIN_ACTION</em> or <em>HPX_PLAIN_ACTION_ID</em> should be used for a particular action, never both. </dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

<dl class="file">
<dt>
<span class="target" id="applier__fwd_8hpp"></span><em>file</em> <code class="descname">applier_fwd.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="basename__registration__fwd_8hpp"></span><em>file</em> <code class="descname">basename_registration_fwd.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/components_fwd.hpp&gt;</em><em>#include &lt;hpx/lcos_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/components/make_client.hpp&gt;</em><em>#include &lt;hpx/runtime/naming/id_type.hpp&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;string&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;vector&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="binpacking__distribution__policy_8hpp"></span><em>file</em> <code class="descname">binpacking_distribution_policy.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/dataflow.hpp&gt;</em><em>#include &lt;hpx/lcos/future.hpp&gt;</em><em>#include &lt;hpx/performance_counters/performance_counter.hpp&gt;</em><em>#include &lt;hpx/runtime/components/client_base.hpp&gt;</em><em>#include &lt;hpx/runtime/launch_policy.hpp&gt;</em><em>#include &lt;hpx/util/bind_front.hpp&gt;</em><em>#include &lt;hpx/performance_counters/counters_fwd.hpp&gt;</em><em>#include &lt;hpx/performance_counters/stubs/performance_counter.hpp&gt;</em><em>#include &lt;hpx/performance_counters/server/base_performance_counter.hpp&gt;</em><em>#include &lt;hpx/lcos/base_lco_with_value.hpp&gt;</em><em>#include &lt;hpx/performance_counters/counters.hpp&gt;</em><em>#include &lt;hpx/performance_counters/performance_counter_base.hpp&gt;</em><em>#include &lt;hpx/runtime/actions/component_action.hpp&gt;</em><em>#include &lt;hpx/runtime/components/component_type.hpp&gt;</em><em>#include &lt;hpx/runtime/components/server/component.hpp&gt;</em><em>#include &lt;hpx/throw_exception.hpp&gt;</em><em>#include &lt;hpx/util/atomic_count.hpp&gt;</em><em>#include &lt;hpx/runtime/components/stubs/stub_base.hpp&gt;</em><em>#include &lt;string&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;vector&gt;</em><em>#include &lt;hpx/runtime/find_here.hpp&gt;</em><em>#include &lt;hpx/runtime/naming/id_type.hpp&gt;</em><em>#include &lt;hpx/runtime/naming/name.hpp&gt;</em><em>#include &lt;hpx/runtime/serialization/serialization_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/serialization/string.hpp&gt;</em><em>#include &lt;hpx/runtime/serialization/vector.hpp&gt;</em><em>#include &lt;hpx/traits/is_distribution_policy.hpp&gt;</em><em>#include &lt;hpx/util/assert.hpp&gt;</em><em>#include &lt;hpx/util/bind_back.hpp&gt;</em><em>#include &lt;hpx/util/unwrap.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;cstdint&gt;</em><em>#include &lt;iterator&gt;</em><em>#include &lt;type_traits&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="colocating__distribution__policy_8hpp"></span><em>file</em> <code class="descname">colocating_distribution_policy.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/lcos/detail/async_colocated.hpp&gt;</em><em>#include &lt;hpx/lcos/detail/async_colocated_callback.hpp&gt;</em><em>#include &lt;hpx/lcos/detail/async_implementations.hpp&gt;</em><em>#include &lt;hpx/lcos/future.hpp&gt;</em><em>#include &lt;hpx/runtime/applier/detail/apply_colocated_callback_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/applier/detail/apply_colocated_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/applier/detail/apply_implementations.hpp&gt;</em><em>#include &lt;hpx/runtime/components/client_base.hpp&gt;</em><em>#include &lt;hpx/runtime/components/stubs/stub_base.hpp&gt;</em><em>#include &lt;hpx/runtime/launch_policy.hpp&gt;</em><em>#include &lt;hpx/runtime/find_here.hpp&gt;</em><em>#include &lt;hpx/runtime/naming/id_type.hpp&gt;</em><em>#include &lt;hpx/runtime/naming/name.hpp&gt;</em><em>#include &lt;hpx/runtime/serialization/serialization_fwd.hpp&gt;</em><em>#include &lt;hpx/traits/extract_action.hpp&gt;</em><em>#include &lt;hpx/traits/is_distribution_policy.hpp&gt;</em><em>#include &lt;hpx/traits/promise_local_result.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;vector&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="component__factory_8hpp"></span><em>file</em> <code class="descname">component_factory.hpp</code></dt>
<dd><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Defines</p>
<dl class="macro">
<dt id="c.HPX_REGISTER_COMPONENT">
<span class="target" id="component__factory_8hpp_1aa5c7e53743fa686c893c732f826dad93"></span><code class="descname">HPX_REGISTER_COMPONENT</code><span class="sig-paren">(</span>type, name, mode<span class="sig-paren">)</span><a class="headerlink" href="#c.HPX_REGISTER_COMPONENT" title="Permalink to this definition">¶</a></dt>
<dd><p>Define a component factory for a component type. </p>
<p>This macro is used create and to register a minimal component factory for a component type which allows it to be remotely created using the <em><a class="reference internal" href="#namespacehpx_1aa43897833f0f0ed2afc53006fc80dad5"><span class="std std-ref">hpx::new_&lt;&gt;</span></a></em> function.</p>
<p>This macro can be invoked with one, two or three arguments</p>
<p><dl class="docutils">
<dt><strong>Parameters</strong></dt>
<dd><ul class="breatheparameterlist first last simple">
<li><code class="docutils literal notranslate"><span class="pre">type</span></code>: The <em>type</em> parameter is a (fully decorated) type of the component type for which a factory should be defined.</li>
<li><code class="docutils literal notranslate"><span class="pre">name</span></code>: The <em>name</em> parameter specifies the name to use to register the factory. This should uniquely (system-wide) identify the component type. The <em>name</em> parameter must conform to the C++ identifier rules (without any namespace). If this parameter is not given, the first parameter is used.</li>
<li><code class="docutils literal notranslate"><span class="pre">mode</span></code>: The <em>mode</em> parameter has to be one of the defined enumeration values of the enumeration <em>hpx::components::factory_state_enum</em>. The default for this parameter is <em>hpx::components::factory_enabled</em>. </li>
</ul>
</dd>
</dl>
</p>
</dd></dl>

</div>
</dd></dl>

<dl class="file">
<dt>
<span class="target" id="copy__component_8hpp"></span><em>file</em> <code class="descname">copy_component.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/lcos/async.hpp&gt;</em><em>#include &lt;hpx/lcos/detail/async_colocated.hpp&gt;</em><em>#include &lt;hpx/lcos/future.hpp&gt;</em><em>#include &lt;hpx/runtime/actions/plain_action.hpp&gt;</em><em>#include &lt;hpx/runtime/components/server/copy_component.hpp&gt;</em><em>#include &lt;hpx/runtime/naming/name.hpp&gt;</em><em>#include &lt;hpx/traits/is_component.hpp&gt;</em><em>#include &lt;type_traits&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="default__distribution__policy_8hpp"></span><em>file</em> <code class="descname">default_distribution_policy.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/lcos/dataflow.hpp&gt;</em><em>#include &lt;hpx/lcos/future.hpp&gt;</em><em>#include &lt;hpx/lcos/packaged_action.hpp&gt;</em><em>#include &lt;hpx/runtime/actions/action_support.hpp&gt;</em><em>#include &lt;hpx/runtime/applier/apply.hpp&gt;</em><em>#include &lt;hpx/runtime/components/stubs/stub_base.hpp&gt;</em><em>#include &lt;hpx/runtime/launch_policy.hpp&gt;</em><em>#include &lt;hpx/runtime/find_here.hpp&gt;</em><em>#include &lt;hpx/runtime/naming/id_type.hpp&gt;</em><em>#include &lt;hpx/runtime/naming/name.hpp&gt;</em><em>#include &lt;hpx/runtime/serialization/serialization_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/serialization/vector.hpp&gt;</em><em>#include &lt;hpx/runtime/serialization/shared_ptr.hpp&gt;</em><em>#include &lt;hpx/traits/extract_action.hpp&gt;</em><em>#include &lt;hpx/traits/is_distribution_policy.hpp&gt;</em><em>#include &lt;hpx/traits/promise_local_result.hpp&gt;</em><em>#include &lt;hpx/util/assert.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;memory&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;vector&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="migrate__component_8hpp"></span><em>file</em> <code class="descname">migrate_component.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/lcos/async.hpp&gt;</em><em>#include &lt;hpx/lcos/detail/async_colocated.hpp&gt;</em><em>#include &lt;hpx/lcos/future.hpp&gt;</em><em>#include &lt;hpx/runtime/actions/plain_action.hpp&gt;</em><em>#include &lt;hpx/runtime/components/client_base.hpp&gt;</em><em>#include &lt;hpx/runtime/components/server/migrate_component.hpp&gt;</em><em>#include &lt;hpx/runtime/components/target_distribution_policy.hpp&gt;</em><em>#include &lt;hpx/lcos/dataflow.hpp&gt;</em><em>#include &lt;hpx/lcos/detail/async_implementations_fwd.hpp&gt;</em><em>#include &lt;hpx/lcos/packaged_action.hpp&gt;</em><em>#include &lt;hpx/runtime/actions/action_support.hpp&gt;</em><em>#include &lt;hpx/runtime/agas/interface.hpp&gt;</em><em>#include &lt;hpx/runtime/applier/detail/apply_implementations_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/components/stubs/stub_base.hpp&gt;</em><em>#include &lt;hpx/runtime/find_here.hpp&gt;</em><em>#include &lt;hpx/runtime/launch_policy.hpp&gt;</em><em>#include &lt;hpx/runtime/naming/id_type.hpp&gt;</em><em>#include &lt;hpx/runtime/naming/name.hpp&gt;</em><em>#include &lt;hpx/runtime/serialization/serialization_fwd.hpp&gt;</em><em>#include &lt;hpx/traits/extract_action.hpp&gt;</em><em>#include &lt;hpx/traits/is_distribution_policy.hpp&gt;</em><em>#include &lt;hpx/traits/promise_local_result.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;vector&gt;</em><em>#include &lt;hpx/traits/is_component.hpp&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="new_8hpp"></span><em>file</em> <code class="descname">new.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/lcos/future.hpp&gt;</em><em>#include &lt;hpx/runtime/components/client_base.hpp&gt;</em><em>#include &lt;hpx/runtime/components/default_distribution_policy.hpp&gt;</em><em>#include &lt;hpx/runtime/components/server/create_component.hpp&gt;</em><em>#include &lt;hpx/runtime/components/stubs/stub_base.hpp&gt;</em><em>#include &lt;hpx/runtime/naming/name.hpp&gt;</em><em>#include &lt;hpx/traits/is_client.hpp&gt;</em><em>#include &lt;hpx/traits/is_component.hpp&gt;</em><em>#include &lt;hpx/traits/is_distribution_policy.hpp&gt;</em><em>#include &lt;hpx/util/lazy_enable_if.hpp&gt;</em><em>#include &lt;algorithm&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;vector&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="find__here_8hpp"></span><em>file</em> <code class="descname">find_here.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/exception_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/naming/id_type.hpp&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="find__localities_8hpp"></span><em>file</em> <code class="descname">find_localities.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/exception_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/components/component_type.hpp&gt;</em><em>#include &lt;hpx/runtime/naming/id_type.hpp&gt;</em><em>#include &lt;vector&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="get__colocation__id_8hpp"></span><em>file</em> <code class="descname">get_colocation_id.hpp</code></dt>
<dd><em>#include &lt;hpx/exception_fwd.hpp&gt;</em><em>#include &lt;hpx/lcos_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/launch_policy.hpp&gt;</em><em>#include &lt;hpx/runtime/naming/id_type.hpp&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="get__locality__id_8hpp"></span><em>file</em> <code class="descname">get_locality_id.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/exception_fwd.hpp&gt;</em><em>#include &lt;cstdint&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="get__locality__name_8hpp"></span><em>file</em> <code class="descname">get_locality_name.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/lcos_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/naming/id_type.hpp&gt;</em><em>#include &lt;string&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="get__num__localities_8hpp"></span><em>file</em> <code class="descname">get_num_localities.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/exception_fwd.hpp&gt;</em><em>#include &lt;hpx/lcos_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/launch_policy.hpp&gt;</em><em>#include &lt;hpx/runtime/components/component_type.hpp&gt;</em><em>#include &lt;cstdint&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="get__os__thread__count_8hpp"></span><em>file</em> <code class="descname">get_os_thread_count.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/thread_data_fwd.hpp&gt;</em><em>#include &lt;cstddef&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="get__ptr_8hpp"></span><em>file</em> <code class="descname">get_ptr.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/runtime_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/agas/gva.hpp&gt;</em><em>#include &lt;hpx/runtime/components/client_base.hpp&gt;</em><em>#include &lt;hpx/runtime/components/component_type.hpp&gt;</em><em>#include &lt;hpx/runtime/get_lva.hpp&gt;</em><em>#include &lt;hpx/runtime/launch_policy.hpp&gt;</em><em>#include &lt;hpx/runtime/naming/address.hpp&gt;</em><em>#include &lt;hpx/runtime/naming/name.hpp&gt;</em><em>#include &lt;hpx/throw_exception.hpp&gt;</em><em>#include &lt;hpx/traits/component_pin_support.hpp&gt;</em><em>#include &lt;hpx/traits/component_type_is_compatible.hpp&gt;</em><em>#include &lt;hpx/util/assert.hpp&gt;</em><em>#include &lt;hpx/util/bind_back.hpp&gt;</em><em>#include &lt;memory&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="get__thread__name_8hpp"></span><em>file</em> <code class="descname">get_thread_name.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/util/itt_notify.hpp&gt;</em><em>#include &lt;string&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="get__worker__thread__num_8hpp"></span><em>file</em> <code class="descname">get_worker_thread_num.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/error_code.hpp&gt;</em><em>#include &lt;cstddef&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="launch__policy_8hpp"></span><em>file</em> <code class="descname">launch_policy.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/thread_enums.hpp&gt;</em><em>#include &lt;hpx/runtime/serialization/serialization_fwd.hpp&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="unmanaged_8hpp"></span><em>file</em> <code class="descname">unmanaged.hpp</code></dt>
<dd><em>#include &lt;hpx/runtime/naming/name.hpp&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="report__error_8hpp"></span><em>file</em> <code class="descname">report_error.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;exception&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="partitioner_8hpp"></span><em>file</em> <code class="descname">partitioner.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/runtime/resource/partitioner_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/resource/detail/create_partitioner.hpp&gt;</em><em>#include &lt;hpx/runtime/runtime_mode.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/policies/scheduler_mode.hpp&gt;</em><em>#include &lt;hpx/util/function.hpp&gt;</em><em>#include &lt;boost/program_options.hpp&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;string&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;vector&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="partitioner__fwd_8hpp"></span><em>file</em> <code class="descname">partitioner_fwd.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/policies/callback_notifier.hpp&gt;</em><em>#include &lt;hpx/runtime/threads_fwd.hpp&gt;</em><em>#include &lt;hpx/util/function.hpp&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;memory&gt;</em><em>#include &lt;string&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="runtime__mode_8hpp"></span><em>file</em> <code class="descname">runtime_mode.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;string&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="set__parcel__write__handler_8hpp"></span><em>file</em> <code class="descname">set_parcel_write_handler.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/exception_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/parcelset_fwd.hpp&gt;</em><em>#include &lt;hpx/util/function.hpp&gt;</em><em>#include &lt;boost/system/error_code.hpp&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="shutdown__function_8hpp"></span><em>file</em> <code class="descname">shutdown_function.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/util/unique_function.hpp&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="startup__function_8hpp"></span><em>file</em> <code class="descname">startup_function.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/util/unique_function.hpp&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="scheduler__mode_8hpp"></span><em>file</em> <code class="descname">scheduler_mode.hpp</code></dt>
<dd></dd></dl>

<dl class="file">
<dt>
<span class="target" id="thread__data__fwd_8hpp"></span><em>file</em> <code class="descname">thread_data_fwd.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/exception_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/coroutines/coroutine_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/thread_enums.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/thread_id_type.hpp&gt;</em><em>#include &lt;hpx/util_fwd.hpp&gt;</em><em>#include &lt;hpx/util/function.hpp&gt;</em><em>#include &lt;hpx/util/unique_function.hpp&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;cstdint&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;memory&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="thread__enums_8hpp"></span><em>file</em> <code class="descname">thread_enums.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/detail/combined_tagged_state.hpp&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;cstdint&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="thread__helpers_8hpp"></span><em>file</em> <code class="descname">thread_helpers.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/exception_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/naming_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/threads_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/thread_pool_helpers.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/policies/scheduler_mode.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/thread_data_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/thread_enums.hpp&gt;</em><em>#include &lt;hpx/util_fwd.hpp&gt;</em><em>#include &lt;hpx/util/unique_function.hpp&gt;</em><em>#include &lt;hpx/util/register_locks.hpp&gt;</em><em>#include &lt;hpx/util/steady_clock.hpp&gt;</em><em>#include &lt;hpx/util/thread_description.hpp&gt;</em><em>#include &lt;atomic&gt;</em><em>#include &lt;chrono&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;cstdint&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="thread__pool__base_8hpp"></span><em>file</em> <code class="descname">thread_pool_base.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/compat/barrier.hpp&gt;</em><em>#include &lt;hpx/compat/condition_variable.hpp&gt;</em><em>#include &lt;hpx/compat/mutex.hpp&gt;</em><em>#include &lt;climits&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;hpx/config/warnings_prefix.hpp&gt;</em><em>#include &lt;hpx/config/warnings_suffix.hpp&gt;</em><em>#include &lt;hpx/compat/thread.hpp&gt;</em><em>#include &lt;hpx/error_code.hpp&gt;</em><em>#include &lt;hpx/exception_fwd.hpp&gt;</em><em>#include &lt;hpx/lcos/future.hpp&gt;</em><em>#include &lt;hpx/lcos/local/no_mutex.hpp&gt;</em><em>#include &lt;hpx/lcos/local/spinlock.hpp&gt;</em><em>#include &lt;hpx/runtime/thread_pool_helpers.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/cpu_mask.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/policies/affinity_data.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/policies/callback_notifier.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/policies/scheduler_mode.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/thread_executor.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/thread_init_data.hpp&gt;</em><em>#include &lt;hpx/runtime/threads/topology.hpp&gt;</em><em>#include &lt;hpx/state.hpp&gt;</em><em>#include &lt;hpx/util/steady_clock.hpp&gt;</em><em>#include &lt;hpx/util_fwd.hpp&gt;</em><em>#include &lt;cstdint&gt;</em><em>#include &lt;exception&gt;</em><em>#include &lt;functional&gt;</em><em>#include &lt;iosfwd&gt;</em><em>#include &lt;memory&gt;</em><em>#include &lt;mutex&gt;</em><em>#include &lt;string&gt;</em><em>#include &lt;vector&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="trigger__lco_8hpp"></span><em>file</em> <code class="descname">trigger_lco.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/lcos_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/actions/continuation_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/actions/action_priority.hpp&gt;</em><em>#include &lt;hpx/runtime/applier/detail/apply_implementations_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/naming/address.hpp&gt;</em><em>#include &lt;hpx/runtime/naming/name.hpp&gt;</em><em>#include &lt;hpx/util/assert.hpp&gt;</em><em>#include &lt;hpx/util/decay.hpp&gt;</em><em>#include &lt;exception&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="runtime__fwd_8hpp"></span><em>file</em> <code class="descname">runtime_fwd.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/exception_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/basename_registration_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/config_entry.hpp&gt;</em><em>#include &lt;hpx/runtime/find_localities.hpp&gt;</em><em>#include &lt;hpx/runtime/get_colocation_id.hpp&gt;</em><em>#include &lt;hpx/runtime/get_locality_id.hpp&gt;</em><em>#include &lt;hpx/runtime/get_locality_name.hpp&gt;</em><em>#include &lt;hpx/runtime/get_num_localities.hpp&gt;</em><em>#include &lt;hpx/runtime/get_os_thread_count.hpp&gt;</em><em>#include &lt;hpx/runtime/get_thread_name.hpp&gt;</em><em>#include &lt;hpx/runtime/get_worker_thread_num.hpp&gt;</em><em>#include &lt;hpx/runtime/naming_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/report_error.hpp&gt;</em><em>#include &lt;hpx/runtime/runtime_fwd.hpp&gt;</em><em>#include &lt;hpx/runtime/runtime_mode.hpp&gt;</em><em>#include &lt;hpx/runtime/set_parcel_write_handler.hpp&gt;</em><em>#include &lt;hpx/runtime/shutdown_function.hpp&gt;</em><em>#include &lt;hpx/runtime/startup_function.hpp&gt;</em><em>#include &lt;hpx/util/function.hpp&gt;</em><em>#include &lt;hpx/util_fwd.hpp&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;cstdint&gt;</em><em>#include &lt;string&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="throw__exception_8hpp"></span><em>file</em> <code class="descname">throw_exception.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/error.hpp&gt;</em><em>#include &lt;hpx/exception_fwd.hpp&gt;</em><em>#include &lt;hpx/util/detail/pp/cat.hpp&gt;</em><em>#include &lt;hpx/util/detail/pp/expand.hpp&gt;</em><em>#include &lt;hpx/util/detail/pp/nargs.hpp&gt;</em><em>#include &lt;boost/current_function.hpp&gt;</em><em>#include &lt;boost/system/error_code.hpp&gt;</em><em>#include &lt;exception&gt;</em><em>#include &lt;string&gt;</em><em>#include &lt;hpx/config/warnings_prefix.hpp&gt;</em><em>#include &lt;hpx/config/warnings_suffix.hpp&gt;</em><div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Defines</p>
<dl class="macro">
<dt id="c.HPX_THROW_EXCEPTION">
<span class="target" id="throw__exception_8hpp_1a3ada9b97bab2221332a6db245fe2067a"></span><code class="descname">HPX_THROW_EXCEPTION</code><span class="sig-paren">(</span>errcode, f, msg<span class="sig-paren">)</span><a class="headerlink" href="#c.HPX_THROW_EXCEPTION" title="Permalink to this definition">¶</a></dt>
<dd><p>Throw a <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a> initialized from the given parameters. </p>
<p>The macro <em>HPX_THROW_EXCEPTION</em> can be used to throw a <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a>. The purpose of this macro is to prepend the source file name and line number of the position where the exception is thrown to the error message. Moreover, this associates additional diagnostic information with the exception, such as file name and line number, locality id and thread id, and stack backtrace from the point where the exception was thrown.</p>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">errcode</span></code> holds the <a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663"><span class="std std-ref">hpx::error</span></a> code the new exception should encapsulate. The parameter <code class="docutils literal notranslate"><span class="pre">f</span></code> is expected to hold the name of the function exception is thrown from and the parameter <code class="docutils literal notranslate"><span class="pre">msg</span></code> holds the error message the new exception should encapsulate.</p>
<p><div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">raise_exception</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// Throw a hpx::exception initialized from the given parameters.</span>
    <span class="c1">// Additionally associate with this exception some detailed</span>
    <span class="c1">// diagnostic information about the throw-site.</span>
    <span class="n">HPX_THROW_EXCEPTION</span><span class="p">(</span><span class="n">hpx</span><span class="o">::</span><span class="n">no_success</span><span class="p">,</span> <span class="s">&quot;raise_exception&quot;</span><span class="p">,</span> <span class="s">&quot;simulated error&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
 <dl class="docutils">
<dt><strong>Example:</strong></dt>
<dd></dd>
</dl>
</p>
</dd></dl>

<dl class="macro">
<dt id="c.HPX_THROWS_IF">
<span class="target" id="throw__exception_8hpp_1a81b2aae0c2744fad9953f45a3c90683b"></span><code class="descname">HPX_THROWS_IF</code><span class="sig-paren">(</span>ec, errcode, f, msg<span class="sig-paren">)</span><a class="headerlink" href="#c.HPX_THROWS_IF" title="Permalink to this definition">¶</a></dt>
<dd><p>Either throw a <a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a> or initialize <em><a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">hpx::error_code</span></a></em> from the given parameters. </p>
<p>The macro <em>HPX_THROWS_IF</em> can be used to either throw a <em><a class="reference internal" href="#classhpx_1_1exception"><span class="std std-ref">hpx::exception</span></a></em> or to initialize a <em><a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">hpx::error_code</span></a></em> from the given parameters. If &amp;ec == &amp;<a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a>, the semantics of this macro are equivalent to <em>HPX_THROW_EXCEPTION</em>. If &amp;ec != &amp;<a class="reference internal" href="#namespacehpx_1a3c805fbcc4bc26b262633b5134b42014"><span class="std std-ref">hpx::throws</span></a>, the <em><a class="reference internal" href="#classhpx_1_1error__code"><span class="std std-ref">hpx::error_code</span></a></em> instance <code class="docutils literal notranslate"><span class="pre">ec</span></code> is initialized instead.</p>
<p>The parameter <code class="docutils literal notranslate"><span class="pre">errcode</span></code> holds the <a class="reference internal" href="#namespacehpx_1aac5bec895c3a4b279fb5d442a87a6663"><span class="std std-ref">hpx::error</span></a> code from which the new exception should be initialized. The parameter <code class="docutils literal notranslate"><span class="pre">f</span></code> is expected to hold the name of the function exception is thrown from and the parameter <code class="docutils literal notranslate"><span class="pre">msg</span></code> holds the error message the new exception should encapsulate. </p>
</dd></dl>

</div>
</dd></dl>

<dl class="file">
<dt>
<span class="target" id="is__execution__policy_8hpp"></span><em>file</em> <code class="descname">is_execution_policy.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/util/decay.hpp&gt;</em><em>#include &lt;type_traits&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="checkpoint_8hpp"></span><em>file</em> <code class="descname">checkpoint.hpp</code></dt>
<dd><em>#include &lt;hpx/dataflow.hpp&gt;</em><em>#include &lt;hpx/lcos/future.hpp&gt;</em><em>#include &lt;hpx/runtime/serialization/serialize.hpp&gt;</em><em>#include &lt;hpx/runtime/serialization/vector.hpp&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;fstream&gt;</em><em>#include &lt;iosfwd&gt;</em><em>#include &lt;sstream&gt;</em><em>#include &lt;string&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em><em>#include &lt;vector&gt;</em><p>This header defines the save_checkpoint and restore_checkpoint functions. These functions are designed to help HPX application developer’s checkpoint their applications. Save_checkpoint serializes one or more objects and saves them as a byte stream. Restore_checkpoint converts the byte stream back into instances of the objects. </p>
</dd></dl>

<dl class="file">
<dt>
<span class="target" id="debugging_8hpp"></span><em>file</em> <code class="descname">debugging.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="invoke_8hpp"></span><em>file</em> <code class="descname">invoke.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/util/result_of.hpp&gt;</em><em>#include &lt;hpx/util/void_guard.hpp&gt;</em><em>#include &lt;boost/ref.hpp&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="invoke__fused_8hpp"></span><em>file</em> <code class="descname">invoke_fused.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/util/detail/pack.hpp&gt;</em><em>#include &lt;hpx/util/invoke.hpp&gt;</em><em>#include &lt;hpx/util/result_of.hpp&gt;</em><em>#include &lt;hpx/util/tuple.hpp&gt;</em><em>#include &lt;hpx/util/void_guard.hpp&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="pack__traversal_8hpp"></span><em>file</em> <code class="descname">pack_traversal.hpp</code></dt>
<dd><em>#include &lt;hpx/util/detail/pack_traversal_impl.hpp&gt;</em><em>#include &lt;hpx/util/tuple.hpp&gt;</em><em>#include &lt;type_traits&gt;</em><em>#include &lt;utility&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="pack__traversal__async_8hpp"></span><em>file</em> <code class="descname">pack_traversal_async.hpp</code></dt>
<dd><em>#include &lt;hpx/util/detail/pack_traversal_async_impl.hpp&gt;</em><em>#include &lt;utility&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="unwrap_8hpp"></span><em>file</em> <code class="descname">unwrap.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em><em>#include &lt;hpx/util/detail/unwrap_impl.hpp&gt;</em><em>#include &lt;cstddef&gt;</em><em>#include &lt;utility&gt;</em></dd></dl>

<dl class="file">
<dt>
<span class="target" id="unwrapped_8hpp"></span><em>file</em> <code class="descname">unwrapped.hpp</code></dt>
<dd><em>#include &lt;hpx/config.hpp&gt;</em></dd></dl>

<dl class="dir">
<dt>
<span class="target" id="dir_430eb5665c98119d97b4f1ca4bcfd535"></span><em>dir</em> <code class="descname">/home/simbergm/src/hpx-worktrees/release/hpx/runtime/actions</code></dt>
<dd></dd></dl>

<dl class="dir">
<dt>
<span class="target" id="dir_c2c75812d4922b2ef95ca01dd66a4698"></span><em>dir</em> <code class="descname">/home/simbergm/src/hpx-worktrees/release/hpx/parallel/algorithms</code></dt>
<dd></dd></dl>

<dl class="dir">
<dt>
<span class="target" id="dir_08aef117f69a8940c124200002eaa290"></span><em>dir</em> <code class="descname">/home/simbergm/src/hpx-worktrees/release/hpx/components/component_storage</code></dt>
<dd></dd></dl>

<dl class="dir">
<dt>
<span class="target" id="dir_934d37c0134c02cb2116adbad08d9e5a"></span><em>dir</em> <code class="descname">/home/simbergm/src/hpx-worktrees/release/hpx/components</code></dt>
<dd></dd></dl>

<dl class="dir">
<dt>
<span class="target" id="dir_ee2282704f93e043b6e8c59aa6ff5ee7"></span><em>dir</em> <code class="descname">/home/simbergm/src/hpx-worktrees/release/hpx/runtime/components</code></dt>
<dd></dd></dl>

<dl class="dir">
<dt>
<span class="target" id="dir_c5fd2bf82f492308f51ed9a575f2cc40"></span><em>dir</em> <code class="descname">/home/simbergm/src/hpx-worktrees/release/hpx/parallel/container_algorithms</code></dt>
<dd></dd></dl>

<dl class="dir">
<dt>
<span class="target" id="dir_16b162e76f08041928c6dcd200a6f7e6"></span><em>dir</em> <code class="descname">/home/simbergm/src/hpx-worktrees/release/hpx/parallel/executors</code></dt>
<dd></dd></dl>

<dl class="dir">
<dt>
<span class="target" id="dir_b5ad4cf605f0b93c6881d0985b58cf53"></span><em>dir</em> <code class="descname">/home/simbergm/src/hpx-worktrees/release/hpx</code></dt>
<dd></dd></dl>

<dl class="dir">
<dt>
<span class="target" id="dir_6cf00c13a50a46fd2c3ba20cac54d158"></span><em>dir</em> <code class="descname">/home/simbergm/src/hpx-worktrees/release/hpx/lcos</code></dt>
<dd></dd></dl>

<dl class="dir">
<dt>
<span class="target" id="dir_54325bb0b341fb91b95f7185c5543fa5"></span><em>dir</em> <code class="descname">/home/simbergm/src/hpx-worktrees/release/hpx/runtime/naming</code></dt>
<dd></dd></dl>

<dl class="dir">
<dt>
<span class="target" id="dir_409512bbb8621b401c4a9f0290716192"></span><em>dir</em> <code class="descname">/home/simbergm/src/hpx-worktrees/release/hpx/parallel</code></dt>
<dd></dd></dl>

<dl class="dir">
<dt>
<span class="target" id="dir_0475946347b3c195ff077cf920704643"></span><em>dir</em> <code class="descname">/home/simbergm/src/hpx-worktrees/release/hpx/performance_counters</code></dt>
<dd></dd></dl>

<dl class="dir">
<dt>
<span class="target" id="dir_0f39a32b77ac74ae57400a66104121d3"></span><em>dir</em> <code class="descname">/home/simbergm/src/hpx-worktrees/release/hpx/runtime/threads/policies</code></dt>
<dd></dd></dl>

<dl class="dir">
<dt>
<span class="target" id="dir_b2633cbb6792bd947730ef64e1b47e1c"></span><em>dir</em> <code class="descname">/home/simbergm/src/hpx-worktrees/release/hpx/runtime/resource</code></dt>
<dd></dd></dl>

<dl class="dir">
<dt>
<span class="target" id="dir_ecd2e68f099a75fe1d00a3854c9f0270"></span><em>dir</em> <code class="descname">/home/simbergm/src/hpx-worktrees/release/hpx/runtime</code></dt>
<dd></dd></dl>

<dl class="dir">
<dt>
<span class="target" id="dir_663e42c929af33e131c433df1cee19d4"></span><em>dir</em> <code class="descname">/home/simbergm/src/hpx-worktrees/release/hpx/runtime/threads</code></dt>
<dd></dd></dl>

<dl class="dir">
<dt>
<span class="target" id="dir_18036ad8cd3197202f8b309ed9b788cf"></span><em>dir</em> <code class="descname">/home/simbergm/src/hpx-worktrees/release/hpx/traits</code></dt>
<dd></dd></dl>

<dl class="dir">
<dt>
<span class="target" id="dir_28047b3708f2b364e702c5f4b231edb1"></span><em>dir</em> <code class="descname">/home/simbergm/src/hpx-worktrees/release/hpx/util</code></dt>
<dd></dd></dl>

</div>


           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <!-- Copyright (c) 2018 Mikael Simberg

     Distributed under the Boost Software License, Version 1.0. (See accompanying
     file LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt) -->
<!-- Make HPX inspect tool happy: hpxinspect:nounlinked -->

<footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="contributing.html" class="btn btn-neutral float-right" title="Contributing to HPX" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="additional_material.html" class="btn btn-neutral" title="Additional material" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2008-2018, The Ste||ar Group.
      
        <span class="commit">
          Revision <code>f52dc95</code>.
        </span>
      

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
 

Distributed under the Boost Software License, Version 1.0. (See accompanying file
LICENSE_1_0.txt or copy at
<a href="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</a>)



</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.2.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>